<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>扁舟</title>
      <link href="/2024/05/02/54/"/>
      <url>/2024/05/02/54/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>想想从这段感情学到了什么。其实很欣慰的是我还是发现了我爱人的能力，从不仔细到无所畏惧——毕竟没什么能失去的了。这段不喜人的感情里，问题还是发生在了解和沟通阶段。对方并不能吸引我的表达，分享，思考。还是处于一个不契合的灵魂的阶段。我还是愿意相信后天可以补齐相遇相知的障碍，我相信我与她的习得能力，相信你我能自我成长，相信踏出樊笼的能力——相信爱的力量。</p><p>勉强还是太困难了，习得能力还是太勉强了。甚至于思维的碰撞，基因的相吸是不可奢望的。只能说还是愿意尝试坚守，愿意付出，并散发爱意。</p><p>他还是太沉重了，驾不了一叶扁舟。</p><p>这真的是爱吗？你喜欢的是身材高挑，长发飘飘，翩若惊鸿？no，你消费的是粉黛颜色，羡煞旁人，良辰美景。赏心乐事谁家院呐。物欲横流，爱情也被驯化成一种消费模式。在爱情的资本化中，不知我是走的太快还是太满慢？琳琅满目，佳肴美食，好一副欣欣向荣，好一个锣鼓喧天的天上宫阙。</p><p>最悲哀的是，当被一刀两断的推开后，才看见对方人性的缺点。乱花迷眼，这是不可接受的。而这样的路，我走了很多次。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 爱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低端主机 Ubuntu22.4 配置</title>
      <link href="/2024/03/18/51Ubuntu22.4%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/03/18/51Ubuntu22.4%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="低端主机-ubuntu22.4-配置">低端主机 Ubuntu22.4 配置</h1><h2 id="配置">配置</h2><p>AMD处理器a8 9600 华硕主板a320m 四代内存条ddr4 8g 2666独显4g显卡索泰gtx1050ti 影驰120固态硬盘 机箱电源</p><p>Ubuntu 22.04.4 LTS</p><h2 id="nvidia-驱动">Nvidia 驱动</h2><p>问题：没有安装显卡驱动，表现：<code>nvidia-smi</code>得不到输出</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvidia-smi</span></code></pre></div><h3 id="处理">处理</h3><p>卸载原有的nvidia的驱动：</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> autoremove --purge nvidia-*  # 这一个就行sudo apt-<span class="hljs-builtin-name">get</span> --purge <span class="hljs-builtin-name">remove</span> nvidia*sudo apt-<span class="hljs-builtin-name">get</span> --purge <span class="hljs-builtin-name">remove</span> <span class="hljs-string">&quot;*nvidia*&quot;</span>sudo apt-<span class="hljs-builtin-name">get</span> --purge <span class="hljs-builtin-name">remove</span> <span class="hljs-string">&quot;*cublas*&quot;</span> <span class="hljs-string">&quot;cuda*&quot;</span>sudo apt autoremove</code></pre></div><p>输入之后就能发现<code>nvidia-smi</code>命令不可以使用了，证明显卡驱动卸载成功！</p><p>查看显卡支持的驱动版本：</p><p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ubuntu-drivers devices</span></code></pre></div></p><p>因为内核比较新，直接选择最新的，安装nvidia535驱动：</p><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> nvidia-driver-<span class="hljs-number">535</span>sudo reboot <span class="hljs-comment"># 重启生效</span></code></pre></div><p>然后通过 <code>nvidia-smi</code>命令可以查看有没有应用在使用NAVIDIA显卡驱动。</p><p>参考：<ahref="https://blog.csdn.net/BingY_998/article/details/116943041">Linux（Ubuntu20.4）系统安装nvidia450驱动+pytorch1.8.1+cuda10.2+cudnn7.6.5教程详解</a></p><h2 id="其他">其他</h2><p>QQ；VScode；Anaconda：Anaconda3-2024.02-Linux-x86_64</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">bash</span> Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">2024</span>.<span class="hljs-number">02</span>-<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh # 不要sudo</code></pre></div><h2 id="pytorch">Pytorch</h2><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create -n py<span class="hljs-number">39</span>-torch python=<span class="hljs-number">3</span>.<span class="hljs-number">9</span></code></pre></div><p>https://pytorch.org/get-started/previous-versions/寻找合适的<code>nvidia-smi</code>显示的更低的CUDA版本以及对应的Pytorch等。</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> activate py<span class="hljs-number">39</span>-torch<span class="hljs-attribute">conda</span> install pytorch==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">16</span>.<span class="hljs-number">0</span> torchaudio==<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> pytorch-cuda=<span class="hljs-number">12</span>.<span class="hljs-number">1</span> -c pytorch -c nvidia</code></pre></div><p>测试：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<span class="hljs-comment"># 检查PyTorch版本</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PyTorch version:&quot;</span>, torch.__version__)<span class="hljs-comment"># 检查CUDA是否可用</span><span class="hljs-keyword">if</span> torch.cuda.is_available():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CUDA is available. 🚀&quot;</span>)    <span class="hljs-comment"># 获取当前CUDA设备的名称，通常是你的GPU的名称</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CUDA Device Name:&quot;</span>, torch.cuda.get_device_name(<span class="hljs-number">0</span>))    <span class="hljs-comment"># 创建一个简单的Tensor并移动到GPU上</span>    tensor = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>]).cuda()    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A tensor in CUDA:&quot;</span>, tensor)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CUDA is not available. Please check your installation.&quot;</span>)</code></pre></div><p>期望输出：</p><blockquote><p>PyTorch version: 2.1.0 CUDA is available. 🚀 CUDA Device Name: NVIDIAGeForce GTX 1050 Ti A tensor in CUDA: tensor([1., 2., 3.],device='cuda:0')</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web of Science爬虫 &amp; Python | Selenium</title>
      <link href="/2024/02/27/50Web%20of%20Science%E7%88%AC%E8%99%AB/"/>
      <url>/2024/02/27/50Web%20of%20Science%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="web-of-science爬虫-python-selenium">Web of Science爬虫 &amp;Python | Selenium</h1><p>这个爬虫的思路继承和脱胎自<ahref="https://zhuanlan.zhihu.com/p/670809708?">CNKI知网爬虫 &amp;Python</a>。</p><p>在此前知网爬虫中，只需要运行脚本，selenium就会全自动的输入关键词等信息而进行检索。这个流水线看起来很方便，但是也限制了检索方式。包括此后也有读者私信我问我怎么用其他方式检索或者能不能爬取其他数据。</p><p>综上所述，这个爬虫有了以下提升：</p><ul><li><strong>检索方式：</strong>能自己手动进行任意方式检索，只要最后能进入论文页面</li><li><strong>速度：</strong>使用BeautifulSoup对网页html处理为爬取数据，相比Selenium对每个数据抓取快得多</li><li><strong>稳定性：</strong>Web ofScience在国内访问不稳定，因为[方式]的改变，可以在网页出现问题后手动解决，也可以从自定义页面开始爬取</li></ul><h2 id="思路">思路</h2><p>新版Web of Science并不像知网一样不需要账号也能检索，而Web ofScience一般需要购买账号或者使用图书馆数据库转跳。因为多种多样的的进入方式只能通过手动处理，进而思考：我们是否可以中断程序手动控制浏览器，之后再把控制权交给程序进行？然后就有了这样的代码。</p><h2 id="实现">实现</h2><p>这个程序的主要逻辑是利用Selenium库自动化爬取Web ofScience（WOS）网站上的论文详情信息，并将抓取的数据存储到一个CSV文件中。</p><ol type="1"><li><p>定义<code>parse_html</code>函数，接收一个HTML字符串作为参数。该函数通过BeautifulSoup解析HTML内容，提取出论文的相关信息（如标题、引用次数、地址/国家、期刊名等），并将这些信息存入一个字典中。同时，它还尝试从HTML中获取当前论文所在的页码。</p></li><li><p>在主函数<code>__main__</code>部分：</p><ul><li>初始化Chrome浏览器驱动并打开指定的URL（Web ofScience的基础搜索页面）。</li><li>要求用户手动操作浏览器至论文详情页面。</li><li>切换到论文详情页面对应的浏览器窗口。</li><li>进入循环，每次循环处理一篇论文的详情页面：<ul><li>使用Selenium的WebDriverWait等待页面元素加载完成。</li><li>获取页面的HTML源代码并传给<code>parse_html</code>函数处理，得到论文信息字典以及当前页码。</li><li>将论文信息添加到一个pandasDataFrame中，如果索引已存在则更新数据，否则新增一行。</li><li>每处理完一篇论文后，就将其数据保存到CSV文件中。</li><li>尝试点击“下一页”按钮以滚动到下一篇文章的详情页面，若点击失败则提示用户手动解决可能的问题。</li><li>添加暂停时间以等待页面加载。</li></ul></li></ul></li><li><p>循环结束后，关闭浏览器驱动。</p></li></ol><p>整个程序实现了自动遍历Web ofScience论文详情页面，抽取关键信息，并将结果有序地保存在CSV文件中。</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">File: WOS_spider.py</span><span class="hljs-string">Author: Dramwig</span><span class="hljs-string">Email: dramwig@outlook.com</span><span class="hljs-string">Date: 2024-02-27</span><span class="hljs-string">Version: 1.2</span><span class="hljs-string"></span><span class="hljs-string">Description: This script uses Selenium and BeautifulSoup to scrape detailed paper information from Web of Science (WOS) website.</span><span class="hljs-string">It navigates through each paper&#x27;s detail page, extracts key information such as title, citation count, country, journal, etc., </span><span class="hljs-string">and saves the collected data into a CSV file.</span><span class="hljs-string"></span><span class="hljs-string">Please note that this script is intended for educational purposes only, and you should abide by the terms of service and usage policies </span><span class="hljs-string">of the Web of Science when using it or any derivative work.</span><span class="hljs-string"></span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> time<span class="hljs-comment"># 解析html</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_html</span>(<span class="hljs-params">html</span>):</span>    soup = BeautifulSoup(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)        <span class="hljs-comment"># 创建一个空的字典</span>    data_dict = &#123;&#125;        <span class="hljs-keyword">try</span>:        containers = soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;cdx-two-column-grid-container&#x27;</span>)        <span class="hljs-keyword">for</span> container <span class="hljs-keyword">in</span> containers:            <span class="hljs-comment"># 在这个容器内找到所有的标签和数据</span>            labels = container.find_all(class_=<span class="hljs-string">&#x27;cdx-grid-label&#x27;</span>)            datas = container.find_all(class_=<span class="hljs-string">&#x27;cdx-grid-data&#x27;</span>)            label = labels[<span class="hljs-number">0</span>].text.strip()            data_texts = [data.text.strip() <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> datas] <span class="hljs-comment"># 提取数据列表中的文本</span>            text = <span class="hljs-string">&#x27;\n&#x27;</span>.join(data_texts) <span class="hljs-comment"># 将文本连接成一个字符串，使用换行符分隔</span>                        <span class="hljs-comment"># 存储到字典中</span>            data_dict[label] = text    <span class="hljs-keyword">except</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解析容器失败&quot;</span>)        <span class="hljs-keyword">try</span>:        class_title = soup.find(class_=<span class="hljs-string">&quot;title text--large cdx-title&quot;</span>)        data_dict[<span class="hljs-string">&#x27;title&#x27;</span>] = class_title.text.strip()    <span class="hljs-keyword">except</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取标题失败&quot;</span>)    <span class="hljs-keyword">try</span>:        class_citation = soup.find(class_=<span class="hljs-string">&quot;mat-tooltip-trigger medium-link-number link ng-star-inserted&quot;</span>)        data_dict[<span class="hljs-string">&#x27;citation&#x27;</span>] = class_citation.text.strip()    <span class="hljs-keyword">except</span>:        data_dict[<span class="hljs-string">&#x27;citation&#x27;</span>] = <span class="hljs-string">&#x27;0&#x27;</span>    <span class="hljs-keyword">try</span>:        class_addresses = soup.find(<span class="hljs-string">&#x27;span&#x27;</span>, class_=<span class="hljs-string">&#x27;ng-star-inserted&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;FRAOrgTa-RepAddressFull-0&#x27;</span>)        <span class="hljs-built_in">print</span>(class_addresses.text.strip())        data_dict[<span class="hljs-string">&#x27;country&#x27;</span>] = class_addresses.text.split(<span class="hljs-string">&#x27;,&#x27;</span>)[-<span class="hljs-number">1</span>].strip()    <span class="hljs-keyword">except</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取国家失败&quot;</span>)        <span class="hljs-keyword">try</span>:        class_journal = soup.find(class_=<span class="hljs-string">&quot;mat-focus-indicator mat-tooltip-trigger font-size-14 summary-source-title-link remove-space no-left-padding mat-button mat-button-base mat-primary font-size-16 ng-star-inserted&quot;</span>)        data_dict[<span class="hljs-string">&#x27;journal&#x27;</span>] = class_journal.text.strip()    <span class="hljs-keyword">except</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取期刊失败&quot;</span>)        <span class="hljs-keyword">try</span>:        input_box = soup.find(class_=<span class="hljs-string">&#x27;wos-input-underline page-box&#x27;</span>)  <span class="hljs-comment"># 获取包含输入框的标签</span>        index = <span class="hljs-built_in">int</span>(input_box[<span class="hljs-string">&#x27;aria-label&#x27;</span>].split()[-<span class="hljs-number">1</span>])    <span class="hljs-keyword">except</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取页码失败&quot;</span>)            <span class="hljs-keyword">return</span> index, data_dict            <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:     <span class="hljs-comment"># 0000391627</span>    <span class="hljs-comment"># adolescent depression 1: https://webofscience-clarivate-cn-s.era.lib.swjtu.edu.cn/wos/alldb/full-record/WOS:000653016400005 </span>    url_root = <span class="hljs-string">&#x27;https://webofscience-clarivate-cn-s.era.lib.swjtu.edu.cn/wos/alldb/basic-search&#x27;</span>    papers_need = <span class="hljs-number">100000</span>    file_path = <span class="hljs-string">&#x27;result.csv&#x27;</span>        wait_time = <span class="hljs-number">30</span>    pause_time = <span class="hljs-number">4</span>        <span class="hljs-comment"># 变量</span>    xpath_nextpaper = <span class="hljs-string">&#x27;/html/body/app-wos/main/div/div/div[2]/div/div/div[2]/app-input-route/app-full-record-home/div[1]/app-page-controls/div/form/div/button[2]&#x27;</span>    df = pd.DataFrame()    index = <span class="hljs-number">0</span>        <span class="hljs-comment"># 读取df</span>    ifread = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;是否读取已有的CSV文件？(y/n)&quot;</span>)    <span class="hljs-keyword">if</span> ifread == <span class="hljs-string">&#x27;y&#x27;</span>:        df = pd.read_csv(file_path, index_col=<span class="hljs-number">0</span>)        index = <span class="hljs-built_in">int</span>(df.index[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;_&#x27;</span>)[-<span class="hljs-number">1</span>])        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;读取已有的CSV文件，当前行索引为<span class="hljs-subst">&#123;index&#125;</span>,即第<span class="hljs-subst">&#123;index+<span class="hljs-number">1</span>&#125;</span>篇论文&quot;</span>)        <span class="hljs-comment"># 打开的页面</span>    driver = webdriver.Chrome()    driver.get(url_root)        <span class="hljs-comment"># 手动操作，比如切换标签页等</span>    <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请手动操作至论文详情页面,完成后按Enter键继续...&quot;</span>)        <span class="hljs-comment"># 获取获取当前所有窗口的句柄</span>    window_handles = driver.window_handles        <span class="hljs-comment"># 假设新窗口是最后被打开的</span>    new_window_handle = window_handles[-<span class="hljs-number">1</span>]    <span class="hljs-comment"># 切换到新窗口</span>    driver.switch_to.window(new_window_handle)    <span class="hljs-comment"># 在新窗口上进行操作，例如获取新窗口的标题</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;新窗口的标题(请确保页面正确):&quot;</span>, driver.title)    <span class="hljs-keyword">while</span> index &lt;= papers_need:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在处理第&quot;</span>, index+<span class="hljs-number">1</span>, <span class="hljs-string">&quot;篇论文&quot;</span>)                <span class="hljs-comment"># 等待页面加载</span>        time.sleep(pause_time/<span class="hljs-number">2</span>)                <span class="hljs-keyword">try</span>:            <span class="hljs-comment"># 或者等待直到某个元素可见</span>            element = WebDriverWait(driver, wait_time).until(                EC.visibility_of_element_located((By.XPATH, <span class="hljs-string">&#x27;//*[@id=&quot;FRAOrgTa-RepAddressFull-0&quot;]&#x27;</span>))            )        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;An error occurred:&quot;</span>, e)            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;等待超时，可能是页面加载失败&quot;</span>)        time.sleep(pause_time/<span class="hljs-number">2</span>)                        <span class="hljs-comment"># 使用Selenium获取页面的HTML源码</span>        html = driver.page_source                <span class="hljs-comment"># 解析HTML</span>        <span class="hljs-keyword">try</span>:            index,data = parse_html(html)            row_index = <span class="hljs-string">f&#x27;Row_<span class="hljs-subst">&#123;index&#125;</span>&#x27;</span>            <span class="hljs-keyword">if</span> row_index <span class="hljs-keyword">in</span> df.index:                df.loc[row_index] = pd.Series(data, name=row_index) <span class="hljs-comment"># 如果行索引存在，则覆盖对应行的数据</span>            <span class="hljs-keyword">else</span>:                df = df._append(pd.Series(data, name=row_index)) <span class="hljs-comment"># 如果行索引不存在，则追加新的行</span>            df.to_csv(file_path, index=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将DataFrame保存为CSV文件,保留行索引作为第一列</span>            <span class="hljs-comment"># debug</span>            <span class="hljs-comment"># input(&quot;完成后按Enter键继续...&quot;)</span>                    <span class="hljs-comment"># 切换到下一页</span>            WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, xpath_nextpaper))).click()        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;An error occurred:&quot;</span>, e)            <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;网页出现问题等待手动解决...&quot;</span>)            <span class="hljs-comment"># 关闭浏览器</span>    driver.quit()</code></pre></div><h2 id="使用">使用</h2><h3 id="环境">环境</h3><p>运行方式：脚本运行</p><p>本地环境：Python 3.11.5，selenium 4.15.2，pandas2.0.3，beautifulsoup4 4.12.2</p><h3 id="可变参数">可变参数</h3><div class="hljs code-wrapper"><pre><code class="hljs python">url_root = <span class="hljs-string">&#x27;https://webofscience-clarivate-cn-s.era.lib.swjtu.edu.cn/wos/alldb/basic-search&#x27;</span>papers_need = <span class="hljs-number">100000</span>file_path = <span class="hljs-string">&#x27;result.csv&#x27;</span>    wait_time = <span class="hljs-number">30</span>pause_time = <span class="hljs-number">3</span></code></pre></div><ul><li><code>url_root</code>：是自动打开的网页（可以是任意网页，因为要手动操作）</li><li><code>papers_need</code>：自动停止爬取的页数</li><li><code>file_path</code>：爬取结果表格文件存储路径</li><li><code>wait_time</code>：等待网页某元素加载的时间（秒），可以缩短</li><li><code>pause_time</code>：每次翻页后的等待时间（秒），平衡速度和稳定性，可以缩短</li></ul><h3 id="使用步骤">使用步骤</h3><ol type="1"><li><p>运行程序。会自动打开谷歌浏览器，（确保安装了谷歌<strong>chromedriver</strong>，可以参考<ahref="https://blog.csdn.net/Z_Lisa/article/details/133307151">Selenium安装WebDriver最新Chrome驱动</a>）</p></li><li><p>手动操作。</p><ol type="1"><li>进入Web ofScience（新版界面），使用自己的方式进入（没有可以淘宝买账号）</li><li>通过自己想要的方式，选择想要的数据库，输入关键词，点击检索</li><li>点击第一篇文章，进入文章页面</li></ol></li><li><p>自动爬取。在程序终端输入任意键继续，程序会自动爬取页面信息，并存储在csv表格中。</p></li><li><p>*异常处理：网页访问异常，点击“后退”回到上个界面，再输入任意键继续，继续爬取。</p></li></ol><p>代码已经托管在Github，欢迎对该项目进行贡献！- <strong><ahref="https://github.com/Dramwig/WOS-spider/tree/main">Dramwig/WOS-spider:Python script to crawl Web of Science retrieved papers based on seleniumpackage. )</a></strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Selenium </tag>
            
            <tag> Web of Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年鉴</title>
      <link href="/2023/12/31/45%E5%B9%B4%E6%8A%A5/"/>
      <url>/2023/12/31/45%E5%B9%B4%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>        <div id="aplayer-BllOIiAF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"我爱你","author":"Ayasa绚沙","url":"http://music.163.com/song/media/outer/url?id=1829162380.mp3","pic":"http://p1.music.126.net/vsrq8MI6dWo_mVxY1Vzyow==/109951165806756872.jpg","lrc":""},{"title":"越过狂风暴雨奔向你","author":"Vicky宣宣","url":"http://music.163.com/song/media/outer/url?id=1914369550.mp3","pic":"http://p1.music.126.net/vQc-IrwU-AGl4INSYLZa7Q==/109951166970122350.jpg","lrc":""},{"title":"这条小鱼在乎","author":"司南","url":"http://music.163.com/song/media/outer/url?id=1991299225.mp3","pic":"http://p1.music.126.net/wUIoXRLys8KcZSUdSDnlqg==/109951167986741867.jpg","lrc":""},{"title":"光","author":"茶理理","url":"http://music.163.com/song/media/outer/url?id=1885205681.mp3","pic":"http://p2.music.126.net/v1qBRzgnfaAwdzU-UP14wA==/109951166502061116.jpg","lrc":""},{"title":"人类祈祷记录","author":"Akie秋绘","url":"http://music.163.com/song/media/outer/url?id=2060392604.mp3","pic":"http://p2.music.126.net/2vzlQF7Vfxl00CW5daKThA==/109951168710613535.jpg","lrc":""},{"title":"白色","author":"灰澈","url":"http://music.163.com/song/media/outer/url?id=494992638.mp3","pic":"http://p1.music.126.net/_EuX4aT0AB0f4Gi5fdMP8w==/109951162991584436.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-BllOIiAF");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><h2 id="app年度报告">APP年度报告</h2><h3 id="微信读书">微信读书</h3><ul><li>阅读了71小时24分钟，阅读108天，读完22本，笔记2291条<ul><li>《我想和你好好的：给年轻人的亲密关系成长课》年度最爱+思考最多+11月月度书，阅读9h45min</li><li>《房思琪的初恋乐园》第一本读完+3月月度书，阅读3h53min</li><li>《浮生六记》最小众，</li><li>《美丽新世界》最沉静阅读+8月月度书，阅读4h1min</li><li>《献给阿尔吉侬的花束》读到深夜+12月月度书，阅读6h20min</li><li>《自卑与超越》最爱分享，阅读5h2min</li><li>《不能承受的生命之重》最多好友共读+国庆节在读+9月月度书，阅读8h16min</li><li>《呼兰河传》劳动节在读+4月月度书，</li><li>《一个陌生女人的来信》5月月度书+6月月度书，阅读3h51min</li><li>《ZOO动物园》+7月月度书，阅读2h59min</li><li>《超新星纪元》，阅读3h53min</li></ul></li><li>偏好阅读时间：大部分时间都有读，在10:00\11:00\23:00阅读最多</li></ul><h3 id="不背单词">不背单词</h3><ul><li>连续学习30天、完成复习60天、连续签到60天、周末上线12周、每日刷词400个、打开不背60天、当日在线120分钟</li><li>来到不背235天、学习单词2570词、复习单词9550 次、一起相处2919分钟、共获得酷币3704个、学习习惯起床就学习、今年学完《六级真题核心词汇》</li><li>这一年，你学习49 小时 2570 词打败了 66% 的同学</li></ul><h3 id="网易云">网易云</h3><ul><li>二次元24%、轻音乐20%、国风19%、原声带19%、说唱18%</li><li>春天最爱《告白之夜（纯音乐）》、夏天最爱《雾里》、秋天最爱《Heaven》、冬天最爱《这条小鱼在乎》</li><li>你在云村听歌获得的多巴胺总量7268mg相当于谈了 25 场高质量的恋爱</li><li>你最爱深夜听歌深夜的22:00-05:00是你全年最活跃的时段</li><li>你在网易云音乐听到最多的歌词是：时光 365次</li><li>10月7日这天你睡得很晚03:56了你还在听 Austin Mahone,RichH...的《Sendlt (feat. Rich H...》</li><li>10月1日你把 沈以诚 的《形容》循环了 28次那一天是国庆假期你还记得在哪里度过的吗?</li><li>《这条小鱼在乎》累计播放了 72 次，累计放时长 268 分钟</li><li>你的2023年度歌单：这条小鱼在乎、光、飞鸟来信、雾里、形容、越过狂风暴雨奔向你、落-蓝心羽版、it's6pm but I miss u ...、遥相逢、虹</li><li>听歌总量2282首、听歌时长77084min</li></ul><p><img src="https://s2.loli.net/2023/12/31/iSsj7kXrlwgMC9T.png" alt="" style="zoom:25%;" /></p><h3 id="qq音乐">QQ音乐</h3><ul><li>你专注聆听2014首歌曲共计采样168h11min 美妙旋律</li><li>《三千曲》收听28次、收听1h15min</li><li>1.《三千曲》MeLo_绿萝组 2.《雾里》旺仔小乔 3.《我爱你》Ayasa绚沙4.《一起跳舞吧》丁程鑫 5.《告白の夜》Ayasa绚沙 6.《龙人二大家族》茶太7《扬6加...》KOKIA 8.《罗刹海市》刀郎 9《梦里花》张韶涵10.《开往早晨的·.. 》张碧晨</li><li>关键词“自己”820次</li><li>年度音乐人格INTJ、桀的[理性谋略者]、五月从INFP转变为INTJ</li><li>春季1081首 忧伤值24%、夏季932首 忧伤值20%、秋季112首 甜蜜度34%、冬季338首 忧伤值25%</li><li>听歌时长137DAYS、年度歌手：周深、偏好曲风：华语流行、年度歌曲：三千曲</li><li>主题解读：柔和易消化的旋律，慵懒放松的文艺氛围是你爱的曲调:徐缓的法兹、绵密的失载...在进入下一层新的梦前，摇晃一池浅蓝色沙滩</li></ul><h3 id="qq">QQ</h3><ul><li>今年共登录 344 天、多数在下午 上线</li><li>聊天最晚的时间是6月13日04:57[隐身] 状态常设</li><li>344天中共和223 好友聊过天，常用【大哭】表情当嘴替。i到甚至不敢看大部分聊天由对方发起</li><li>2023年共新增了 104位好友，目前共有 435 位好友</li><li>热聊 Top 3 的朋友：Hkra、宁梓静、钰lul</li><li>当前加入 207 个群聊主打万物皆可成群在 34个群中担任群主或管理员“数学建模国赛”是你聊天最多的群聊</li><li>在空间共发表965条说说，在2023年发表77条</li><li>2023年一共上传了379张照片互动最多的一张照片是这张（2023高教社杯全国大学生数学建模...获奖公示名单）</li></ul><h3 id="steam">Steam</h3><p><img src="https://s2.loli.net/2023/12/31/Rmdu7SbqIC82Be1.png" /></p><h3 id="bilibili">Bilibili</h3><ul><li>和B站共度的353天里，观看超844小时，领先90%的B站人</li><li>时间：29%知识之海、13%欣赏舞蹈、4%影视好瓜、21%游戏世界、10%生活之味</li><li>你把它们刻入DNA：财经、哗哩干杯、历史、舞蹈翻跳、马督工、bilibili、社会、睡前消息、投资、少年歌行风花雪月篇、手游直播、虚拟主播直播</li><li>《离散数学 东北大学》观看28次</li><li>1月 和 5406.3万 B友一起关注流浪地球2、8月 和2413.3万B友一起关注黑神话悟空、9月 和 49284万 B友一起关注华为Mate60、12月 和4097.5万 B友一起关注考研</li></ul><h3 id="知乎">知乎</h3><ul><li>你提出了 2 个问题、发表了 30 个回答、编织了 4 篇文章、进发出 24条想法、用 45931个字记录知识之旅</li><li>你在 科学工程 领域富有见解并发表了最多的创作、有 42017位都曾被你吸引浏览过你的优质内容、你最受欢迎的内容是关于为什么现在的孩子普遍都特别脆弱?收获了122 赞同</li><li>你用心的创作一共收获了995603 次浏览250 次转发623 次收藏618个赞和喜欢</li><li>今年有111个知友关注了特别的你给你最多赞许的人是@sunwuzhou03一共给你发出了 47个赞同</li><li>你常常在 深夜自娱时打开知乎</li><li>发现了 9788 个问题、探究了 42934 个回答、欣赏了 739篇专业文章、遇见了 5009 个优秀答主的回答、收获了 934 个高赞回答</li></ul><h3 id="tai">Tai</h3><p>*仅记录了7月到12月</p><figure><img src="https://s2.loli.net/2024/01/03/c8DNJzEGhS6bwFM.png"alt="image-20240103221253937" /><figcaption aria-hidden="true">image-20240103221253937</figcaption></figure><ul><li>2023应用使用时间排行：Edge 260h39m、QQ 123h2m、永劫 116h12m、Androidstudio 42h31m、Matlab 34h22m、VScode 32h57m、typora 28h44m、PPT13h36m、Word 12h29m &gt;10h</li><li>2023网站使用时间排行：Bilibili 72h39m、知乎23h31m（+专栏10h14m）、Poe 14h35m、Bing 12h46、Github 9h3m、CSDN6h50m</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 年报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络期末复习 - 期末复习</title>
      <link href="/2023/12/31/47/"/>
      <url>/2023/12/31/47/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络期末复习">计算机网络期末复习</h1><p>计网 选择 填空 判断 简答 分析 综合2个</p><h2 id="概论">概论</h2><h3 id="计算机网络定义">计算机网络定义:</h3><ul><li>按照<strong>网络协议</strong>，以<strong>共享资源</strong>为主要目的，将地理上<strong>分散</strong>且独立的计算机<strong>互相连接起来</strong>的<strong>集合体</strong>。</li><li>是<strong>互连</strong>，<strong>自治</strong>的计算机<strong>集合</strong>。</li></ul><h3 id="计算机网络的网络结构">计算机网络的网络结构：</h3><ul><li>网络 (Network) 由若干<strong>结点</strong> (Node)和连接这些结点的<strong>链路</strong> (Link) 组成。</li><li>计算机网络由<strong>通信子网</strong>和<strong>资源子网</strong>组成</li><li>从层次结构上来看，计算机网络的结构可以分为三层，分别是<strong>网络边界</strong>（端系统HOST），<strong>网络核心</strong>（骨干网）</li></ul><h3 id="计算机网络的诞生与演变">计算机网络的诞生与演变：</h3><ul><li>第一阶段：1969 第一个<strong>分组交换网</strong>ARPNET 1983TCP/IP成为ARPNET的标准协议（标志互联网诞生）</li><li>第二阶段：三级结构NSFNET(主干网、地区网和校园网)，覆盖美国机构大学等</li><li>第三阶段：1993年，NSFNET被商用因特网主干网替代；政府机构不再负责因特网运营，让各种因特网服务提供者ISP来运营。WWW出现。</li></ul><h3 id="三种交换方式">三种交换方式</h3><ul><li>电路交换、分组交换、报文交换</li></ul><h3 id="计算机网络分类">计算机网络分类：</h3><ul><li>按覆盖范围：个区网PAN、局域网LAN、（无线局域网WLAN、园区网CN）、城域网MAN、广域网 WAN</li><li>按数据交换方式：FDM (频分复用)、TDM (时分复用)</li><li>拓扑结构分：星型、环型、总线、网状型</li><li>互连网 internet：广域网 WAN、通信子网、资源子网</li></ul><h3 id="性能指标">性能指标</h3><ul><li>传输速率 1TB/s = <span class="math inline">\(10^3\)</span>Gb/s =<span class="math inline">\(10^6\)</span>Mb/s = <spanclass="math inline">\(10^9\)</span>Kb/s = <spanclass="math inline">\(10^{12}\)</span>b/s (bps)，数据量的KB，MB和数率M的是完全不一样的！</li><li>带宽（信号所包含的各种不同频率成分所占据的频率范围）Hz</li><li>时延 = <strong>发送时延+传播时延</strong>+处理时延（+排队时延）发送时延 = 分组长度(b)/发送速率(b/s) 传播时延 = 信道长度/传播时延</li><li>往返时间 RTT ； 利用率<spanclass="math inline">\(D=D_0/(1-U)\)</span></li></ul><p><img src="https://s2.loli.net/2023/12/30/9epoJOyBDGsXIVA.png" alt="image-20231230224824685" style="zoom:50%;" /></p><p>分组交换的传输时延 = n+m-1个分组发送时延 + m个传输时延</p><h3 id="计算机网络的体系结构">计算机网络的体系结构：</h3><ul><li>OSI参考模型：<strong>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</strong>。<ul><li><strong>物理层：</strong>如何在信道上可靠传输01</li><li><strong>数据链路层：</strong>实现相邻（Neighboring）网络实体间的数据传输，成帧</li><li><strong>网络层：</strong>将数据包跨越网络从源设备发送到目的设备（hostto host），分组（IP数据报）</li><li><strong>传输层：</strong>将数据从源端口发送到目的端口</li><li><strong>会话层：</strong>在应用程序之间建立和维持会话</li><li><strong>表示层：</strong>为上层用户提供数据或信息语法的表示变换。（数据编码（语言翻译）、<strong>压缩</strong>、加密、认证等）</li><li><strong>应用层：</strong>提供应用程序便捷的网络服务调用，规范化和标准化</li></ul></li><li>TCP/IP是四层的体系结构：应用层、运输层、<strong>网际</strong>层和<strong>网络接口层</strong>（ARPNET采用）</li><li>五层协议的体系结构：应用层 、运输层 、网络层、数据链路层、物理层</li></ul><figure><img src="https://s2.loli.net/2023/12/29/J9PtSW3zbnaYoHZ.png"alt="image-20231229231542386" /><figcaption aria-hidden="true">image-20231229231542386</figcaption></figure><h3id="计算机网络体系结构中的专用术语">计算机网络体系结构中的专用术语</h3><ul><li>网络设计中采用的<strong>结构化设计方法</strong>：计算机网络采用<strong>分层结构</strong>。每层完成一定的<strong>功能</strong>，每层都向它的上层提供一定的<strong>服务</strong>，而将如何实现服务的细节对上层<strong>屏蔽</strong>，即低层协议对高层而言是<strong>透明</strong>的。相邻两层之间为<strong>层间接口</strong>。对等层用户通话时所必须遵守的规则称为<strong>对等层协议</strong>。</li><li>实体：任何可发送或接收信息的硬件或软件进程，<strong>对等实体</strong>即收发双方相同层次的实体</li><li>协议：对等实体通信的规则、标准和约定，控制两个对等实体进行逻辑通信的规则的集合。</li><li>协议三要素：<strong>语义</strong>（讲什么）、<strong>语法</strong>（如何讲）和<strong>时序</strong>（讲的次序）</li><li>接口：定义下层向上层提供的服务原语</li><li>服务：服务是各层实体向其上层实体提供的一组原语操作</li><li>服务访问点：在同一系统中相邻两层的实体交换信息的<strong>逻辑接口</strong>，用于区分不同的服务类型</li><li>服务原语：上层使用下层所提供的服务必须通过与下层交换的一些<strong>命令</strong></li><li><strong>协议数据单元</strong>PDU(Protocol DataUnit)：<strong>对等层次之间</strong>传送的<strong>数据包</strong></li><li>服务数据单元SDU：同一系统内，<strong>层与层之间交换的数据包</strong>，可划分为多个PDU</li></ul><h3 id="杂七杂八的知识点">杂七杂八的知识点</h3><ul><li>世界上第一个计算机网络是：<strong>ARPANET</strong></li><li>计算机网络通信系统是<strong>数据通信系统</strong></li><li>通信子网的主要组成是<strong>网络节点</strong>和<strong>通信链路</strong></li><li><strong>广播式网络</strong>工作在<strong>数据链路层</strong></li><li><strong>主干网络</strong>一般是<strong>分布式</strong>的</li><li><strong>本地接入网</strong>一般是<strong>集中</strong>的</li><li><strong>分组交换网</strong>由<strong>通信子网</strong>和<strong>资源子网</strong>组成，以<strong>通信子网为中心</strong></li><li>ADSL<strong>（</strong>Asymmetric Digital Subscriber Line非对称数字用户线路<strong>）</strong>是一种宽带接入技术，该技术使用的传输介质是<strong>电话线</strong></li><li>互联网（internet）是<strong>网络的集合，是网络中的网络</strong>；因特网（Internet）是采用<strong>TCP/IP协议</strong>的世界范围的internet</li><li>基于<strong>TCP</strong>的应用层协议有:HTTP、FTP、SMTPQ、TELNET、SSH</li><li>基于<strong>UDP</strong>的应用层协议: DNS、TFTP(简单文件传输协议)、SNMP:简单网络管理协议、BOOTP、DHCP</li></ul><figure><img src="https://s2.loli.net/2023/12/22/s47ugXhD9eQrc2I.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="物理层">物理层</h2><h3 id="接口的特性">接口的特性：</h3><p>屏蔽掉不同传输媒体和通信手段的差异</p><ul><li>机械特性：指明接口所用接线器的<strong>形状和尺寸、引线数目和排列、固定和锁定</strong>装置等等。</li><li>电气特性：指明在接口电缆的各条线上出现的<strong>电压的范围</strong>。</li><li>功能特性：指明某条线上出现的某一电平的电压表示<strong>何种意义</strong>。</li><li>过程特性：指明对于不同功能的各种<strong>可能事件</strong>的出现<strong>顺序</strong>。</li></ul><h3 id="信号类型及信号变换">信号类型及信号变换</h3><p>调制方法：（基带传输）基带信号 to （频带传输） 带通信号</p><ul><li>调幅、调频、调相</li></ul><figure><img src="https://s2.loli.net/2023/12/22/Vv5TZSlsk2cPn4G.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="奈氏准则香农公式">奈氏准则、香农公式</h3><p>基带信号：始矩形脉冲电信号 ；带通信号：将基带信号调制到高频带</p><p>模拟信号经F频率采样成为离散信号：要求F≥2f，f是模拟信号的最高频率。</p><p>波特率B：每秒信号调制次数(次/秒) $B_{max} =2 H $ ，H -低通信道的带宽(Hz)</p><p>奈氏公式(理想信道)：$ C = 2H_2L$ , C -信道的<strong>最大数据传输率</strong> 信息传输速率(b/s)</p><p>Shannon定理（有噪声信道）：<spanclass="math inline">\(C=H\log_2(1+S/N)\)</span> <spanclass="math inline">\(分贝数=10\log_{10}s/n\)</span>。</p><h3 id="数字数据的数字信号编码">数字数据的数字信号编码：</h3><ul><li>归零RZ，不归零NRZ,NRZI(反向NRZ)</li><li><strong>曼彻斯特编码</strong>：一个周期T,分前后T/2。<strong>前高后低为1，前低后高为0</strong>。<ul><li>每位中间的跳变即可作为数据，又可作为时钟，能够自同步</li></ul></li><li><strong>差分曼彻斯特编码</strong>： 一个周期T,分前后T/2。<strong>无跳变为1，跳变为0</strong>。</li></ul><figure><img src="https://s2.loli.net/2023/12/21/LgOvkFoUtwP9VWX.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="复用技术">复用技术：</h3><p>将多路信号组合在一条物理信道上进行传输，到接收端再用专门的设备将各路信号分离出来，提高通信线路利用率</p><ul><li>频分复用(FDM)、时分复用(TDM)</li><li>统计时分复用(STDM)：指动态地按需分配共用信道的时隙，时隙中还必须要有用户的地址信息，因此造成开销</li><li>波分复用(WDM)：用多个激光器在单条光纤上同时发送多束不同波长激光的技术</li><li>码分复用(CDMA)：每一个比特时间划分为 m 个短的间隔，称为码片(chip)。每个站被指派一个唯一的 m bit 码片序列。相互正交：<spanclass="math inline">\(\mathbf{S}\bullet\mathbf{T}\equiv\frac{1}{m}\sum_{i=1}^{m}S_iT_i=\mathbf{0}\)</span>，<strong>发送可叠加</strong></li></ul><h3 id="交换技术">交换技术：</h3><ul><li><strong>线路交换：电路交换</strong></li><li><strong>存储转发交换：报文交换和分组交换</strong></li></ul><figure><img src="https://s2.loli.net/2023/12/22/I9bmuZYVxeUL8sr.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://s2.loli.net/2023/12/29/tCY8Pdiq3sfuhBI.png"alt="image-20231229140047749" /><figcaption aria-hidden="true">image-20231229140047749</figcaption></figure><h3 id="互连设备">互连设备</h3><ul><li>中继器(Repeater)：双向接收、放大并重发信号</li><li>HUB (共享式集线器) 同一个广播域 同一个冲突域</li></ul><h2 id="数据链路层">数据链路层</h2><p>逻辑链路控制LLC+介质访问控制MAC</p><h3 id="提供的服务">提供的服务</h3><ul><li>无确认无连接服务：以太网</li><li>有确认无连接服务 每一帧都得到单独的确认</li><li>有确认有连接服务</li></ul><h3 id="成帧---带字节填充的定界符法">成帧 - 带字节填充的定界符法</h3><ul><li>收到FLAG（0111-1110） − 则为帧的边界</li><li>收到ESC − 则后一字节无条件成为有效载荷</li><li>核心思想：选择的定界符不会在数据部分出现</li></ul><figure><img src="https://s2.loli.net/2023/12/21/3mghwUCclWOtZYs.png"alt="image-20231221232258683" /><figcaption aria-hidden="true">image-20231221232258683</figcaption></figure><h3 id="成帧---带比特填充的定界符法">成帧 - 带比特填充的定界符法</h3><ul><li>发送方：若在有效载荷中出现连续5个1比特，则直接插入1个0比特</li><li>接收方：若出现连续5个1比特<ul><li>若下一比特为0，则为有效载荷，直接丢弃0比特</li><li>若下一比特为1，则连同后一比特的0，构成定界符，一帧结束</li></ul></li></ul><figure><img src="https://s2.loli.net/2023/12/21/FOkwErnPl8coa6e.png"alt="image-20231221232511304" /><figcaption aria-hidden="true">image-20231221232511304</figcaption></figure><h3 id="差错检测和纠正">差错检测和纠正</h3><ul><li>纠错码<ul><li>码字：一个包含m个数据位和r个校验位的n位单元 n=m+r ；</li><li>码率：码字中不含冗余部分所占的比例m/n</li><li>码距（海明距离）：两个码字之间对应位置<strong>不同比特的数目</strong>。<ul><li>d-1为能检错位数，(d-1)/2为纠错能力</li></ul></li></ul></li></ul><h3 id="典型检错码">典型检错码</h3><ul><li><p>奇偶检验</p></li><li><p>校验和：主要用于TCP/IP体系中的网络层和传输层</p><figure><img src="https://s2.loli.net/2023/12/29/K3EJSlPa4iAe6pU.png"alt="image-20231229144327357" /><figcaption aria-hidden="true">image-20231229144327357</figcaption></figure></li><li><p><strong>循环冗余校验（CRC）</strong>：数据链路层广泛 使用</p><ul><li>事先选定一个n+1 位二进制位模式G（最高位为1），本质就是让n+r的二进制串能被G整除</li></ul></li></ul><p><img src="https://s2.loli.net/2023/12/22/r3CShvXQwejTH2z.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2023/12/21/5bTmNPz3wnuZCBK.png" alt="image-20231221233834305" style="zoom:67%;" /></p><h3 id="典型纠错码">典型纠错码：</h3><p><span class="math inline">\((m + r + 1) \le 2^r\)</span></p><figure><img src="https://s2.loli.net/2023/12/21/GXszDRyOSnY9HUi.png"alt="image-20231221235507251" /><figcaption aria-hidden="true">image-20231221235507251</figcaption></figure><h3 id="停止等待协议和时延">停止等待协议和时延：</h3><figure><img src="https://s2.loli.net/2023/12/22/3B8sa4LMSZlf7P2.png"alt="image-20231222112932783" /><figcaption aria-hidden="true">image-20231222112932783</figcaption></figure><figure><img src="https://s2.loli.net/2023/12/22/eBY4AdVhgiGOHuy.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="滑动窗口协议">滑动窗口协议：</h3><figure><img src="https://s2.loli.net/2023/12/22/PlaKbHLA7di6wXN.png"alt="image-20231222110603240" /><figcaption aria-hidden="true">image-20231222110603240</figcaption></figure><h3 id="回退n协议">回退N协议：</h3><p>对应接收窗口为1的情况</p><ul><li>当发送方发送了N个帧后，若发现该N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就重新发送出错帧及其后的N帧。</li></ul><figure><img src="https://s2.loli.net/2023/12/22/MglGkDW2mfi6FoR.png"alt="image-20231222110720456" /><figcaption aria-hidden="true">image-20231222110720456</figcaption></figure><h3 id="选择重传协议">选择重传协议：</h3><ul><li>在发送过程中，如果一个数据帧计时器超时，就认为该帧丢失或者被破坏；接收端只把出错的的帧丢弃，其后面的数据帧保存在缓存中，并向发送端回复NAK；发送端接收到NAK时，只重传出错的帧</li><li>如果落在窗口内的帧从未接受过，那么存储起来，等比它序列号小的所有帧都正确接收后，按次序交付给网络层</li><li>接收端收到的数据包的顺序可能和发送的数据包顺序不一样，因此在数据包里必须含有顺序号来帮助接收端进行排序。</li></ul><figure><img src="https://s2.loli.net/2023/12/22/pEtHTGKyoQ9MOUd.png"alt="image-20231222110857911" /><figcaption aria-hidden="true">image-20231222110857911</figcaption></figure><p><spanclass="math inline">\(\text{信道利用率}\quad=\mathrm{W}^*\mathrm{T}_f/\mathrm{~(T}_f+\mathrm{R)}\)</span></p><h3 id="hdlchigh-level-data-link-control">HDLC：（High-Level Data LinkControl）</h3><p>HDLC协议属于面向<u> 比特</u> 的同步控制协议；用<u> 01111110</u>来实现帧定界；它有三种 不同类型的帧，分别称为<u> 信息帧</u>、<u>监控帧</u>、<u> 无编号帧</u>，分别用于<u> 数据传输</u>、 <u>监督控制</u>、<u> 链路管理</u>。</p><figure><img src="https://s2.loli.net/2023/12/22/8vafZqIbXmYyKAl.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="slipserial-ip和-ppppoint-to-point-protocol">SLIP（Serial IP）和PPP（Point to Point Protocol）</h3><p>PPP用于<strong>点到点的链接</strong>，无须知道对方的数据链路层地，重要功能便是提供了<strong>身份验证</strong>功能</p><p><strong>Internet</strong>的两个<strong>数据链路层协议</strong>是 SLIP和 PPP 协议</p><p>SLIP协议属于面向_____字符_______协议。PPP协议属于面向_____比特_______协议，PPP主要包含_____3_______个方面内容，分别是_<em>帧格式定义<strong>、<em>LCP</em></strong></em>_<strong>、</strong>_<strong>NCP</strong>_____。</p><p><img src="https://s2.loli.net/2023/12/22/SJiGtRZBwxF8ed1.jpg" alt="img" style="zoom:67%;" /></p><figure><img src="https://s2.loli.net/2023/12/22/5wd6xQWKR9hOJtV.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li><strong>链路静止状态：不存在物理层的连接</strong></li><li><strong>链路建立状态： 建立链路层的连接</strong></li><li><strong>鉴别状态：身份验证</strong></li><li><strong>网络层协议状态 ：进行网络层配置</strong></li><li><strong>链路打开状态 ：打开链路连接</strong></li><li><strong>链路关闭状态：关闭链路连接</strong></li></ul><h3 id="pppoeppp-over-ethernet">PPPoE（PPP over Ethernet）:</h3><p>使用<strong>PPP协议自带认证功能</strong>，加上以太网链路上广播网络的属性得到，<strong>将PPP数据帧封装在以太网数据帧里边</strong>的PPPoE。即<strong>“在以太网上的PPP协议”</strong>。</p><figure><img src="https://s2.loli.net/2023/12/22/aATfVtz2e9DFrbH.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>（1）本站的 IP 地址；（2）主、辅域名服务器的 IP地址；（3）网关 的 IP 地址或 MAC 地址。PPPOE协议可以动态分配这些地址。请问如何获取这些地址？</strong></p><p>PPPoE 通过<strong>发现阶段</strong>的前两步获取<strong>网关的 MAC地址及其名称</strong>：客户端以广播方式发送 PADI 报文，网关响应 PADO报文，从其中的以太帧头的源 MAC 地址 即可获取<strong>网关的 MAC地址</strong>，从 PPPoE 报文的 TAG中可以获得<strong>网关的名称</strong>；</p><p>PPPoE 通过<strong>会话阶段</strong>的 <strong>IPCP</strong>来获取<strong>本站的 IP 地址和主、辅域名服务器的 IP地址</strong>：客户端向服务器发送 config-request报文，报文中指定需要协商本站 IP 地址、主、辅域名服务器 IP地址参数，服务器回答config-NAK，<strong>重新为这三个地址参数赋值</strong>，客户端利用服务器给定的这三个地址参数的新值，重新发送config-request，服务器回答 config-ACK，完成客户端 IP地址和主、辅域名服务器的 IP 地址的分配。</p><h2 id="信道共享技术">信道共享技术</h2><h3 id="两大通信共享技术">两大通信共享技术：</h3><ul><li>(物理层)物理信道划分复用</li><li>(链路层+物理层)多点接入(Multiple Access)共享</li></ul><h3 id="频分复用fdm">频分复用FDM：</h3><ul><li>信号被划分成若干通道(频道、波段)，每个通道互不重叠，独立进行数据传递。每个载波信号形成一个不重叠、相互隔离(不连续)的频带。接收端通过带通滤波器来分离信号。</li><li>例如：ADSL</li></ul><h3 id="时分复用tdm">时分复用TDM：</h3><ul><li>时分多路复用将用于传输的时间划分为若干个时间片段，每个用户分得一个时间片(时隙)。</li></ul><h3 id="波分复用wdmdwdm">波分复用WDM→DWDM：</h3><ul><li>多束不同频率的光通过棱柱或光栅，合成到一根共享的光纤，传到目的地后再将它们分解开来。</li></ul><h3 id="多址方式">多址方式：</h3><ul><li>以不同的移动信道分隔，防止相互干扰的技术方式称为多址方式。</li><li>频分多址(FDMA)、时分多址(TDMA) 、码分多址(CDMA)</li></ul><p><img src="https://s2.loli.net/2023/12/29/34ehtjqGf1idXBs.png" alt="image-20231229151247798" style="zoom:33%;" /></p><h3 id="纯aloha">纯ALOHA：</h3><ul><li>每个站自由的发送数据帧，若冲突，则等待一段随机时间后，重发。</li></ul><h3 id="时隙aloha">时隙ALOHA：</h3><ul><li>将时间划分为一段段时隙(Time Slot)，每个站只能在时隙开始时自由的发送数据帧，若冲突，则等待一段 随机时间后，重发。</li></ul><h3 id="随机接入csma与csmacd-和退避算法">随机接入CSMA与CSMA/CD和退避算法：</h3><ul><li>“先听后发”</li><li>①经侦听，如果介质空闲，开始发送</li><li>②如果介质忙，则等待一个随机分布的时间，然后重复步骤①</li><li>CSMA/CD：监听到信道空闲就发送数据，并继续监听下去，(电磁波在电缆中以有限速率传播)，如果听到发生冲突，立即放弃此数据帧的传送。同时发送Jam信号(通常采 用32 bit长的1和0交替的比特块) ，使网上所有用户知道发生了冲突。</li></ul><figure><img src="https://s2.loli.net/2023/12/29/kAh69sTY4lSr8Li.png"alt="image-20231222114703918" /><figcaption aria-hidden="true">image-20231222114703918</figcaption></figure><ul><li>CSMA/CD：带有冲突检测的CSMA协议 —— CDMA 码分多路复用</li><li>CSMA/CA，带有<strong>冲突避免的载波多路访问协议</strong></li></ul><h3 id="受控接入">受控接入：</h3><ul><li>轮叫轮询：主机按顺序从站1开始逐个询问，直到站N；一轮完成再从站1重新开始新一轮。被询问站若有数据发送即可发给主机；若无发一控制帧给主机，表示无数据可发；然后主机询问下一站。</li><li>传递轮询：主机向站N发出轮询帧。站N在发送完数据或告诉主机没有数据发送时，将相邻站N1的地址附上。站N-1检测到自己的地址，知道站N把发送权转移到本站；以此类推，直到站1。站1完成后将主机地址附上，把发送 权交回主机。</li><li>令牌环：得到令牌的站点获得在信道上发送的权利，如果该站点有报文待发，就将令牌置为“忙”，表示通道已被占用，然后发报，发完之后，就将令牌置为“空”，随即将令牌传递给下一站点；如果该站点无报文发送，则随即将刚收到的令牌转发给下一站点。</li></ul><h2 id="局域网技术">局域网技术</h2><h3 id="局域网的组成">局域网的组成：</h3><p>LAN 由<strong>硬件和软件</strong>两部分组成。</p><ul><li>硬件：计算机（包括服务器和工作站）、网卡、联网设备、电缆及其附属设备</li><li>软件：NOS、驱动程序、通信协议、其它网络系统软件</li></ul><h3 id="信道访问协议">信道访问协议</h3><p>总线网访问协议：ALOHA，CSMA，CSMA/CD</p><h3 id="aloha协议"><strong>ALOHA协议</strong></h3><figure><img src="https://s2.loli.net/2023/12/23/fjKgrDsAPSJFyxb.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="csma协议">CSMA协议</h3><p>载波监听多重访问协议 CSMA 可以分为_<em>1-坚持CSMA</em>、_<strong>非-坚持 CSMA </strong>、<strong>P-坚 持 CSMA</strong>。</p><ul><li><strong>1-坚持型CSMA</strong> =&gt;若信道忙，则<strong>继续(坚持)</strong>监听直至信道由忙变闲</li><li><strong>非坚持型CSMA</strong> =&gt;若信道忙，则<strong>不再坚持</strong>侦听，<strong>退避一段随机时间</strong>，然后重新开始发送过程</li><li><strong>P-坚持CSMA</strong> =&gt; 若发现信道空闲，则以<strong>概率 p发送数据</strong>，以<strong>概率(1-p)延迟至下一个时隙</strong>再重新开始侦听。</li></ul><figure><img src="https://s2.loli.net/2023/12/23/8jZvrEwoO9QXg1h.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="具有冲突检测功能的-csmacsmacd">具有冲突检测功能的CSMA(CSMA/CD)</h3><p>carrier sense multiple access/collision detection（顾名思义多了一个冲突检测的功能)</p><figure><img src="https://s2.loli.net/2023/12/23/8nILT1zfWcKtmCY.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="最小帧长">最小帧长:</h3><p>以太网规定最短有效帧长为 64 字节</p><p>最小帧长 = 碰撞窗口大小 <em>报文发送速率，碰撞窗口大小 = 2 </em>传播时延</p><p>传播时延=转发器（中继器）的时延 + 线路时延</p><figure><img src="https://s2.loli.net/2023/12/23/fvhg6TUSJAFX1bB.png"alt="image-20231223122941996" /><figcaption aria-hidden="true">image-20231223122941996</figcaption></figure><figure><img src="https://s2.loli.net/2023/12/23/PhXgD4Nt5qzwjyW.png"alt="image-20231223122958073" /><figcaption aria-hidden="true">image-20231223122958073</figcaption></figure><h3 id="ieee802标准">IEEE802标准</h3><p>在局域网标准中将<strong>数据链路层</strong>划分为<strong>两个子层</strong>，分别是___MAC__子层与___LLC_子层。其中，组帧属于___MAC<strong>子层的功能；共享信道分配属于</strong>_MAC<strong>子层的功能；向上提供服务访问点组帧属于</strong>_LLC__子层的功能。</p><ul><li>MAC（Media Access Control或者Medium AccessControl）地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置</li><li>信道访问协议也叫MAC (Multiple Access Control 多路访问控制 或 MediumAccess Control 介质访问控制 )协议</li><li>LLC =&gt; 逻辑链路控制(Logical Link Control)</li></ul><h2 id="网络层">网络层</h2><p>实现端系统间多跳传输可达</p><h3 id="无连接服务数据报服务">无连接服务（数据报服务）：</h3><ul><li>网络层向上只提供简单灵活无连接的、尽最大努力交付的数据报服务</li><li>时不需要先建立连接，数据报独立转发，相同源-目的的数据报可能经过不同的路径</li><li>网络层不提供服务质量的承诺，不提供端到端的可靠传输服务</li></ul><h3 id="面向连接服务虚电路服务">面向连接服务（虚电路服务）：</h3><ul><li>通信之间先建立逻辑连接</li><li>结合使用可靠传输的网络协议，保证所发送的分组<strong>无差错按序</strong>到达终点</li></ul><h3 id="虚电路网络">虚电路网络：</h3><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接（电路交换的电话通信是先建立了一条真正的连接）</li></ul><p>学习Internet网络层协议：IPv4/IPv6, ICMP, DHCP, NAT, ARP</p><figure><img src="https://s2.loli.net/2023/12/22/fIXr3B8H6zVRPbL.png"alt="image-20231222125640255" /><figcaption aria-hidden="true">image-20231222125640255</figcaption></figure><p><img src="https://s2.loli.net/2023/12/22/fIXr3B8H6zVRPbL.png" /></p><h3 id="数据报分片">数据报分片：</h3><ul><li>IPv4分组在传输途中可以多次分片</li><li>IPv4分片只在目的IP对应的目的端系统进行重组</li></ul><h3 id="分类的ip地址">分类的IP地址：</h3><figure><img src="https://s2.loli.net/2023/12/22/xDKTqapbEmwnP4U.png"alt="image-20231222125929107" /><figcaption aria-hidden="true">image-20231222125929107</figcaption></figure><h3 id="cidr和子网划分">CIDR和子网划分：</h3><ul><li>将32位的IP地址划分为前后两个部分，并采用斜线记法，即在IP地址后加上“/”，然后再写上网络前缀所占位数</li><li>一个 CIDR地址块可以表示很多地址，这种地址的聚合常称为<strong>路由聚合</strong>或者<strong>构成超网</strong></li><li>允许前缀重叠，数据包安<strong>最长匹配前缀</strong>发送</li></ul><h3 id="ip包转发">IP包转发：</h3><ul><li>直接交付：与目的主机在同一个IP子网内</li><li>间接交付：与目的主机不在同一个IP子网内（交换机）</li></ul><h3 id="dhcp动态主机配置协议">DHCP动态主机配置协议：</h3><ul><li>DHCP 客户从UDP端口68以广播形式向服务器发送发现报文（DHCPDISCOVER）</li><li>DHCP 服务器单播发出提供报文（DHCPOFFER）</li><li>DHCP 客户从多个DHCP服务器中选择一个，并向其以广播形式发送DHCP请求报文（DHCPREQUEST）</li><li>被选择的DHCP服务器单播发送确认报文（DHCPACK）</li></ul><figure><img src="https://s2.loli.net/2023/12/22/zjCSuhirVO6YwIn.png"alt="image-20231222130751536" /><figcaption aria-hidden="true">image-20231222130751536</figcaption></figure><h3 id="nat网络地址转换">NAT网络地址转换：</h3><ul><li>出数据报：外出数据报用 NAT IP地址(全局), 新port # 替代源IP地址(私有), port #</li><li>NAT转换表：每个 (源IP地址, port #)到(NAT IP地址, 新port #)映射项</li><li>入数据报：对每个入数据报的地址字段用存储在NAT表中的(源IP地址, port#)替代对 应的 (NAT IP地址, 新port #)</li></ul><h3 id="icmp协议-互联网控制报文协议">ICMP协议（互联网控制报文协议）：</h3><ul><li>终点不可达：无法转发该IP数据报（不知道怎么到因为路由表上没有）</li><li>源点抑制：过于拥塞了，某路由器丢弃该IP数据报并发送ICMP差错报文</li><li>时间超过：TTL归 0，丢弃该IP数据报并发送ICMP差错报文</li><li>参数问题：路由器收到IP数据报时发现存在误码，丢弃该IP数据报并发送ICMP差错报文</li><li>改变路由：知道下次应该把数据报发送给另外的路由（可通过更好的路由）改变差错</li></ul><p>PING是测试主机是否可达的一个常用命令。它属于 ICMP协议的一个子功能。</p><h3 id="路由算法">路由算法：</h3><ul><li>常用的 Internet 路由算法为： DV (Distance Vector) 和 LS(Link StateRouting Algorithm)</li><li>常用的 Internet 域内路由协议为： RIP， OSPF</li><li>其中，RIP 实现 DV 路由算法；</li><li>OSPF 实现 LS 路由算法</li></ul><p>掌握Internet路由协议：OSPF、RIP、BGP，了解MPLS</p><ul><li>RIP用UDP（RIP用到传输层），所以RIP是应用层的协议；</li><li>OSPF用IP（RIP用到网络层），所以OSPF是传输层协议；（有不同的说法）</li><li>BGP用TCP（RIP用到传输层），所以BGP是应用层协议；</li></ul><h3 id="网际互连">网际互连</h3><p><img src="https://s2.loli.net/2023/12/23/yzbCIRWD2lQxv6c.jpg" alt="img" style="zoom:50%;" /></p><figure><img src="https://s2.loli.net/2023/12/23/39g2HMzrtfndWBp.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="传输层">传输层</h2><p><strong>UDP（User DatagramProtocol）用户数据报协议</strong>，支持单播多播广播，线上提供无连接不可靠传输服务</p><p><strong>TCP（Transmission ControlProtocol）传输控制协议</strong>，只支持单播</p><figure><img src="https://s2.loli.net/2023/12/23/SCsjtu8apByXz7N.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><img src="https://s2.loli.net/2023/12/23/jq4SWnxIRLDhUVi.jpg" alt="img" style="zoom: 33%;" /></p><h3 id="tcp流量控制">TCP流量控制</h3><ul><li>所谓流量控制 (flowcontrol)就是让发送方的发送速率不要太快，要让接收方来得及接收</li><li>利用<strong>滑动窗口</strong>机制可以很方便地在TCP连接上实现对发送方的流量控制<ul><li>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小。</li><li>TCP发送方收到接收方的<strong>零窗口通知</strong>后，应启动<strong>持续计时器</strong>。持续计时器超时后，向接收方发送<strong>零窗口探测报文</strong>。</li></ul></li></ul><p>TCP发送方的发送窗口=min[自身拥塞窗口，TCP接收方的接收窗口]</p><h3 id="三次握手">三次握手</h3><figure><img src="https://s2.loli.net/2023/12/22/dwCRftnXkUFx5hL.png"alt="image-20231222160915538" /><figcaption aria-hidden="true">image-20231222160915538</figcaption></figure><figure><img src="https://s2.loli.net/2023/12/22/O1iP7cBQ48aL9gr.png"alt="image-20231222160948802" /><figcaption aria-hidden="true">image-20231222160948802</figcaption></figure><h3 id="tcp的拥塞控制">TCP的拥塞控制</h3><figure><img src="https://s2.loli.net/2023/12/22/DuGH9EBRWqnpwkC.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="应用层">应用层</h2><p><strong>每个应用层协议都是为了解决某一应用问题</strong>，通过位于不同主机中的多个应用进程之间的通信和协同工作来完成</p><ul><li>客户/服务器（C/S, Client/Server）方式</li><li>浏览器/服务器（B/S，Browser/Server） 方式</li><li>对等（P2P，Peer to Peer）方式</li></ul><h3 id="动态主机配置协议dhcp">动态主机配置协议DHCP</h3><figure><img src="https://s2.loli.net/2023/12/23/veAHIqGM6nbfo8P.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><img src="https://s2.loli.net/2023/12/23/veAHIqGM6nbfo8P.jpg" /></p><h3 id="域名解析dns">域名解析DNS</h3><p>域名服务器：</p><ul><li>根服务器<ul><li>每个根服务器都知道所有的顶级域名服务器的域名及其IP地址</li><li>根服务器并不直接把主机用户所查的域名转换成IP地址</li></ul></li></ul><figure><img src="https://s2.loli.net/2023/12/22/6tTRcVM5fNCL2pd.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://s2.loli.net/2023/12/23/XPuDdkKWbQOhIsJ.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="smtp-邮件-pop3-imap">SMTP 邮件 （POP3 IMAP）</h3><figure><img src="https://s2.loli.net/2023/12/22/hdmwPR7aeMNiqAL.png"alt="image-20231222164929686" /><figcaption aria-hidden="true">image-20231222164929686</figcaption></figure><p>为什么不能使用SMTP获取邮件？</p><ul><li>因为取邮件是 一个拉操作，而 SMTP是一个推协议，通过引入最终交付（邮件访问）协议来解决这个问题。</li></ul><figure><img src="https://s2.loli.net/2023/12/22/l61NKiLdDcBayJT.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="万维网">万维网</h3><p><img src="https://s2.loli.net/2023/12/23/Xd6SEDf3BiZL42o.png" alt="img" style="zoom:67%;" /></p><figure><img src="https://s2.loli.net/2023/12/23/4GJXlo5cx1yjLM3.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>Cookie是服务器为浏览器生成的，表面浏览器曾经访问过</li></ul><h3 id="p2p">P2P</h3><figure><img src="https://s2.loli.net/2023/12/22/ys9X1fTrmaEHYxI.png"alt="image-20231222165818587" /><figcaption aria-hidden="true">image-20231222165818587</figcaption></figure><h3 id="ftp">FTP</h3><figure><img src="https://s2.loli.net/2023/12/22/Qrjqs5GpmxS1RU3.png"alt="image-20231222170136224" /><figcaption aria-hidden="true">image-20231222170136224</figcaption></figure><figure><img src="https://s2.loli.net/2023/12/23/v2OPBZXzQqS47Gw.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://s2.loli.net/2023/12/23/S621ZRsTJmdMUfr.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="其他">其他</h1><p><ahref="https://blog.csdn.net/coutcodes/article/details/107180703">《计算机网络》谢希仁第七版课后习题答案</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学 - 期末复习</title>
      <link href="/2023/12/31/46/"/>
      <url>/2023/12/31/46/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="计算机图形学理论课复习大纲">计算机图形学理论课复习大纲</h2><p>考试题型：简答题，计算题，绘图题，分析与设计题，程序实现题。</p><p>分数分别为：20分，30分，10分，30分，10分。</p><h3 id="一-图形学基本概念">一、 图形学基本概念</h3><ol type="1"><li>什么是计算机图形学？</li><li>计算机图形学的主要研究内容包括哪些？</li><li>计算机图形学的主要应用领域。</li><li>图形和图像的主要区别是什么？</li><li>计算机图形处理系统的主要构成。</li><li>显卡的工作流程。</li><li>什么是显示存储器？</li><li>GPU的基本概念。</li><li>显卡分辨率的含义。</li><li>GPU堆包含哪几种主要的类型，具有什么样的特点？</li><li>GPU渲染流水线包含哪几个阶段，分别完成什么任务？</li><li>光照的基本原理</li><li>光照模型的分类</li><li>光源的分类</li><li>纹理的表现形式。</li><li>纹理的过滤方式及寻址方式</li><li>多级纹理的基本原理</li><li>模型的表示方法</li><li>Direct3D 12图形绘制的基本原理</li><li>三维模型顶点的数据结构表示</li></ol><h3 id="二-图形学基本算法">二、 图形学基本算法</h3><p>要求：算法的基本原理，算法描述，算法执行过程分析，过程计算，编程实现等。</p><ol type="1"><li>直线生成算法：DDA算法，中点画线法、Bresenham法。</li><li>圆和圆弧的生成算法：DDA算法，中点画线法，Bresenham法</li><li>线宽生成算法：刷子绘制法，实区域填充法</li><li>线型的处理</li><li>区域填充法：扫描线法，边填充法，种子填充法，扫描线种子填充法，</li><li>反走样技术：像素细分技术，Bresenham反走样技术</li><li>曲线生成：Bezier曲线和B样条曲线，包括二阶、三阶曲线等。</li><li>图形变化：平移、缩放、旋转</li><li>坐标系之间的变换：局部坐标、世界坐标、摄像机坐标、屏幕坐标</li><li>四边形裁剪算法：Cohen-Sutherland裁剪算法、中点分割裁剪算法、Liang-Barskey裁剪算法</li><li>多边形裁剪算法：Sutherland-Hodgman算法，Weiler-Atherton算法</li><li>三维线段裁剪算法：长方体裁剪算法，视椎体裁剪算法</li><li>图形消隐：背面剔除算法，画家算法，Weiler-Atherton算法，BSP树算法、深度缓冲区算法，Warnock算法</li><li>曲面的生成：Bezier曲面的生成，B样条曲面的生成，特别是二阶和三阶曲面</li><li>地形的生成算法</li><li>雨雪的模拟算法</li></ol><h2 id="第1章-绪论">第1章 绪论</h2><h3 id="什么是计算机图形学">什么是计算机图形学？</h3><p>计算机图形学是研究通过计算机将<strong>数据</strong>转化为<strong>图形</strong>，并在专门显示设备上显示的<strong>原理、方法和技术</strong>的学科。也就是如何<strong>用计算机生成、处理和显示图形</strong>的一门学科。</p><p>计算机图形学是研究怎样利用计算机来<strong>生成、处理和显示</strong>图形的<strong>原理、方法和技术</strong>的学科。</p><h3 id="计算机图形学的应用">计算机图形学的应用</h3><ol type="1"><li>图形用户接口 (2) 工业应用 (3) 商业领域 (4) 艺术领域 (5)科学计算可视化 (6) 虚拟现实 (7) 系统环境模拟</li></ol><h3 id="图形和图像的区别">图形和图像的区别</h3><ul><li><strong>表示方法</strong>不同：图形是由基本几何体（直线，点，圆、曲线、三角形等）构成的实体，同时具有几何属性和视觉属性。图像是由很多像素点构成的点阵信息。</li><li><strong>生成</strong>方法不同：图形是通过计算机算法生成的，而图像是通过照相机，摄像机等扫描设备或图像生成软件制作而成。</li><li><strong>研究侧重点</strong>不同：图形学主要研究如何使用计算机表示几何体，构建几何模型、如何通过建立数学模型或者算法把真实的或者想象的物体显示出来。图像处理主要研究如何将一种图像处理成另一种图像，包括图像增强、复原、解析和理解、编码、压缩、匹配，识别等。</li></ul><h2 id="第2章-计算机图像处理及显示的基本原理">第2章计算机图像处理及显示的基本原理</h2><h3 id="显卡工作流程">显卡工作流程</h3><ol type="1"><li>通过<strong>数据总线</strong>将要显示的图形或者图像数据送入GPU（图形处理器)。</li><li>GPU对送入的数据进行<strong>处理</strong>然后送入<strong>帧缓冲器</strong>（或称显存)。</li><li>送入<strong>帧缓冲器</strong>中的数据将被送入<strong>视频控制器</strong>。视频控制器将根据接口的类型确定处理方式，完成<strong>数模转换</strong>；</li><li>视频控制器的输出将送到<strong>显示屏</strong>。</li></ol><h3 id="概念">概念</h3><ul><li><p><strong>帧缓存/显存：</strong>显存用来<strong>存储屏幕上像素的颜色值</strong>。帧缓冲器中的单元数目与显示器上的像素数目相同，单元与像素一一对应，各单元的数值决定了其对应的像素的颜色。（比如一个像素24位）</p></li><li><p><strong>显卡分辨率：</strong>显卡分辨率是指显卡输出给显示器并能在显示器上描绘的像素点的数量。</p></li><li><p><strong>显卡颜色深度：</strong>每个像素包含三种颜色：R，G，B。像素的精细度由组成像素的颜色的位数和照射到像素的颜色的强度决定。显示透明度，往往还增加8bits来表示透明度。</p></li><li><p>规定以左手定则根据顶点的排列顺序来确定三角面的朝向。</p></li></ul><h3id="gpu处理输入的图形数据渲染流水线">GPU处理输入的图形数据（渲染流水线）</h3><ol type="1"><li>输入装配阶段。从内存中读入相关的顶点和索引，从而生成几何图形的基本要素（点，线以及三角面）。</li><li>顶点着色阶段。完成顶点转换（从局部坐标系转换到齐次裁剪坐标系中），光照（纹理）等各种形式的运算。</li><li>曲面细分阶段。将一个大的三角形分解成若干个小的三角形。</li><li>几何着色阶段。对输入的点进行筛选，然后输出相应的构成几何图形的基本要素。同时几何着色可以输出一系列的点到内存空间中。</li><li>裁剪。将区域之外的物体去除掉，只显示区域之内的物体。</li><li>光栅化阶段。将几何图元变为二维图像。第一部分工作：<strong>决定窗口坐标中的哪些整型栅格区域被基本图元占用</strong>；第二部分工作：分配一个颜色值和一个深度值到各个区域以便进行消隐操作。<strong>目的，是找出一个几何单元（比如线段或三角形）所覆盖的像素</strong>。</li><li>像素着色阶段。通过这些点及相应的属性可以在GPU中计算除相应像素的颜色，光照的影响，阴影等处理效果。</li><li>输出融合阶段。一些像素无法通过深度测试而被排除，而另一些像素送入，与此前已经写入到后台缓冲区中的像素进行相应的融合处理。</li></ol><h2 id="第3章-基本图形生成">第3章 基本图形生成 ★</h2><h3 id="画线算法">画线算法</h3><h4 id="数值微分画线法dda">数值微分画线法（DDA）</h4><ul><li>输入<span class="math inline">\(P_0(x_0,y_0),P_1(x_1,y_1)\)</span></li><li>计算增量 $ x=,y= \ ((y_1-y_0),(x_1-x_0))$</li><li>循环<span class="math inline">\(Length\)</span>次，<spanclass="math inline">\(x_{i+1} = x_i+\Delta x, y_{i+1} = y_i+\Deltay\)</span>，每步结果对不是整数那个四舍五入</li></ul><figure><img src="https://s2.loli.net/2023/12/30/hKX8oDS7I3m4tEN.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="中点画线法">中点画线法</h4><p>原理：<span class="math inline">\(d = 2F(x_k+1,y_k+0.5) =2a(x_k+1)+2b(y_k+0.5) + c, d_0 = 2a+b\)</span></p><ul><li><p>输入<span class="math inline">\(P_0(x_0,y_0),P_1(x_1,y_1)\)</span></p></li><li><p><span class="math inline">\(a=y_0-y_1,b=x_1-x_0\)</span></p></li><li><p><span class="math inline">\(d = 2a+b\)</span>， <spanclass="math inline">\(delta1 = 2a , delta2 = 2(a+b)\)</span></p></li><li><p>当<span class="math inline">\(d\ge 0\)</span>，取下点 y不变 <spanclass="math inline">\(y_{i+1} = y_i\)</span>, <spanclass="math inline">\(d+=delta1\)</span>；(<code>x++</code>一直自增)</p><p>当<span class="math inline">\(d&lt;0\)</span>，取上点 y加一 <spanclass="math inline">\(y_{i+1} = y_i+1\)</span>, <spanclass="math inline">\(d+=delta2\)</span>.</p></li></ul><figure><img src="https://s2.loli.net/2023/12/30/76vOlwcSKkImxGq.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="bresenham-画线算法">Bresenham 画线算法</h4><ul><li><p>输入<span class="math inline">\(P_0(x_0,y_0),P_1(x_1,y_1)\)</span></p></li><li><p><span class="math inline">\(e=2\Delta y-\Deltax\)</span></p></li><li><p>当<span class="math inline">\(e\ge 0\)</span>，取上点 <spanclass="math inline">\(y_{i+1} = y_i+1\)</span>, <spanclass="math inline">\(e&#39;=e+2\Delta y - 2\Delta x\)</span>；</p><p>当<span class="math inline">\(e&lt;0\)</span>，取下点 <spanclass="math inline">\(y_{i+1} = y_i\)</span>, <spanclass="math inline">\(e&#39;=e+2\Delta y\)</span>.</p></li></ul><figure><img src="https://s2.loli.net/2023/12/30/JmBR6XfWMtEOC1F.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://s2.loli.net/2023/12/30/9oOc6aq1bNjHnhL.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="圆形算法">圆形算法</h3><h4 id="中点画圆算法">中点画圆算法</h4><p>基本算法思想就是利用下一个点的绘制要么是右方的点，要么是右下侧的点。</p><ul><li><p>初始值 <span class="math inline">\(x=0,y=R\)</span>,<spanclass="math inline">\(d=1-R\)</span></p></li><li><p><span class="math inline">\(d&lt;0\)</span>，y不变，<spanclass="math inline">\(d=d+2x+3\)</span></p><p><span class="math inline">\(d\ge0\)</span>，y减一，<spanclass="math inline">\(d= d+2x_n-2y_n+5\)</span></p></li></ul><figure><img src="https://s2.loli.net/2023/12/30/MqsiKHj7dQc6nWr.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="bresenham画圆算法">Bresenham画圆算法</h4><p>利用下一个点的绘制要么是右方的点，要么是右下侧的点，要么是下方的点不断判定三个距离哪个最短则选择哪个。</p><ul><li>初始化 x=0, y=R, d=2(1-R)</li><li>d&lt;0, 2(d+y)-1&lt;=0: x=x+1, d=d+2x+3</li><li>d&lt;0, 2(d+y)-1&gt;0: x=x+1, y=y-1, d=d+2(x-y+3)</li><li>d=0: x=x+1, y=y-1, d=d+2(x-y+3)</li><li>d&gt;0, 2(d-x)-1&lt;=0: x=x+1, y=y-1, d=d+2(x-y+3)</li><li>d&gt;0, 2(d-x)-1&gt;0: y=y-1, d=d-2y+3</li></ul><figure><img src="https://s2.loli.net/2023/12/30/DIuh4QR5KZMarbU.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="线宽和线型的处理">线宽和线型的处理</h3><ul><li>线宽处理：刷子绘制法，方形刷子绘制法，实区域填充法产生线宽</li><li>线型处理：看成一个由布尔值对应的像素。每种线型对应一定的长度的像素，每个像素对应相应的布尔值。如果该像素对应的布尔值为1，则绘制该像素。如果对应的布尔值为0，则不绘制该像素。</li></ul><h3 id="区域填充">区域填充</h3><ul><li><p>检查某个像素是否在某个多边形区域内</p><ul><li>转角法：计算点与多边形各个顶点的连线所构成的夹角之和（带方向），为0标明是在区域外；如果为360°标明在区域内。</li><li>射线法：水平（右）或者垂直（下）方向做<strong>射线</strong>。判断该射线与多边形交点的个数。交点数为偶数在图形外；交点数奇数在图形内。</li></ul></li><li><p>扫描线法：</p><ul><li>求交、排序、两两配对、线段着色</li><li>注意<strong>顶点求交点</strong>规则：把所有极值顶点当成两个点</li><li>（活性边表法好像不考？）边表的结构为 <spanclass="math inline">\([x,y_{max},\frac1k]\)</span>。 $x:$当前扫描线与活性边的交点， $y_{max}: <spanclass="math inline">\(活性边较高端点的\)</span>y$ 坐标值， $1k:$活性边所在直线斜率的倒数。</li></ul><figure><img src="https://s2.loli.net/2024/01/06/15EK8hUg9einsdC.png"alt="image-20240106225101692" /><figcaption aria-hidden="true">image-20240106225101692</figcaption></figure></li><li><p>边填充法：该多边形每一条边右边区域像素的颜色全部取补</p></li><li><p>栅栏填充法：该多边形每一条边与栅栏之间像素的颜色全部取补</p></li><li><p>种子填充法：四连通/八联通，从某个像素点开始BFS/DFS整某个像素点开始个区域（缺点：堆栈大量使用）</p></li><li><p><strong>扫描线种子</strong>填充法：</p><ul><li>栈顶像素出栈。</li><li>沿扫描线对出栈像素的左右像素进行填充，直到遇到边界像素xl和xr为止</li><li>在区间[xl,xr]中检查与当前扫描线相邻的上下两条扫描线，则把<strong>每个</strong><em>非边界、未填充</em> 的<strong>像素区间</strong>的<strong>最右</strong>像素取为种子像素入栈。</li></ul></li></ul><h3 id="图形反走样技术">图形反走样技术</h3><p>问题：阶梯状边界；图形细节失真；狭小图形遗失：动画序列中时隐时现，产生闪烁。本质是用<strong>离散</strong>的像素去表示<strong>连续图形</strong>，从而引起失真。</p><p>Bresenham区域反走样技术：将多边形每条边与具有一定面积的像素相交的面积大小分为8个等级。相交面积0-1/8 1/8-2/8……</p><p><span class="math inline">\(S=(y_{i+1}+ y_i)/2=(y_i+ y_i+m)/2=y_i+m/2=e+m/2\)</span></p><p>### 曲线生成</p><p>要求：</p><ul><li>唯一性</li><li>几何不变性：用<strong>相同的方法</strong>去拟合平面空间中<strong>不同坐标</strong>系下<strong>相同</strong>的几个点，得到的<strong>拟合曲线不变</strong>。直角坐标系不具备几何不变性。</li><li>易于定界：矢量坐标系中<spanclass="math inline">\(p(t)=[x(t),y(t),z(t)]\)</span>，由于每一个变量都用统一的t标量来描述，非常容易确定其边界。</li><li>统一性:可以在不增加其他参数的情况下进行维数的扩充。P(t) = [x(t)y(t)] =&gt; P(t) = [x(t) y(t) z(t)]</li></ul><h4 id="参数样条曲线">参数样条曲线</h4><ul><li>零阶几何连续性：<spanclass="math inline">\(G^0\)</span>连续性，首尾相接</li><li>一阶几何连续性：<spanclass="math inline">\(G^1\)</span>连续性，首尾相接，且切矢量方向连续（一阶导数成比例）</li><li>一阶几何连续性：<spanclass="math inline">\(G^2\)</span>连续性，首尾相接，一二阶导数成比例，曲率连续。</li></ul><figure><imgsrc="/C:/Users/39366/AppData/Roaming/Typora/typora-user-images/image-20231230120756856.png"alt="image-20231230120756856" /><figcaption aria-hidden="true">image-20231230120756856</figcaption></figure><p>参数样条曲线数学表示：</p><p><span class="math display">\[P(t)=\begin{bmatrix}x(t)\\y(t)\\z(t)\end{bmatrix}=\begin{bmatrix}x_0&amp;x_1&amp;\cdots&amp;x_n\\y_0&amp;y_1&amp;\cdots&amp;y_n\\z_0&amp;z_1&amp;\cdots&amp;z_n\end{bmatrix}\begin{bmatrix}1\\ \vdots\\t^n\end{bmatrix}=C\cdot T\quad t\in[0,1]\]</span></p><p>Hermite插值样条：已知每个型值点的位置矢量及其切矢量，然后绘制出的样条曲线。</p><h4 id="bezier曲线的生成">Bezier曲线的生成</h4><p>Bezier曲线通过控制点来控制曲线的形状。把相邻的点连接起来形成一个特征多边形，并将其作为曲线的轮廓线，然后在每个特征多边形顶点配以伯恩斯坦（Bernstein)多项式作为权函数，对特征多边形的各顶点进行加权求和。<span class="math display">\[\begin{aligned}&amp;P(t)=\sum_{i=0}^nP_i\cdot BEZ_{i,n}(t)\quadt\in[0,1]\\\\&amp;BEZ_{i,n}(t)=C_n^it^i(1-t)^{n-i},\quadt\in[0,1]\end{aligned}\]</span> <strong>DeCasteljau算法</strong>：<strong>递归</strong>法绘制点</p><ol type="1"><li><p>用直线连接所有相邻的n个控制点，得到其特征多边形。</p></li><li><p>如果t∈[0,1]，则在特征多边形的每一条边上按照t:(1-t)的比例寻找一组新的点，构成新的多边形，该多边形的边比前面的多边形少一条边。</p></li><li><p>在新的多边形上，重复（2）的操作得到一组新的多边形。在n次这种操作之后，将得到一个点，该点即为曲线上的点。</p></li></ol><p><img src="https://s2.loli.net/2023/12/30/8cinNKfIslyD6ek.jpg" alt="img" style="zoom:33%;" /></p><h4 id="b样条曲线的生成">B样条曲线的生成</h4><p>B样条曲线由n+m+1个控制点构成，其中<span class="math inline">\(P_0~P_n\)</span>这个n+1个控制点控制其第一段曲线， <spanclass="math inline">\(P_1~P_{n+1}\)</span>这个n+1个控制点控制其第二段曲线,…,依次类推，总共m+1段曲线构成B样条曲线。<span class="math display">\[P(t)=\sum_{i=0}^nP_i\cdot B_{i,n}(t) t\in[0,1] \\B_{i,n}(t){=}\color{red}\frac1{n!}\sum_{j=0}^{n-i}(-1)^jC_{n+1}^j(t+n-k-j)^n\]</span></p><p>其第i段曲线可表示为：<spanclass="math inline">\(\begin{aligned}\mathsf{P}_{i,n}(t)&amp;=\sum_{\mathrm{k=0}}^nP_{i+\mathrm{k}}\cdotB_{k,n}(t)&amp;&amp;t\in[0,1]\end{aligned}\)</span></p><p><img src="https://s2.loli.net/2023/12/30/3FjEzHkNd2laMPO.png" alt="image-20231230132401533" style="zoom:33%;" /></p><h2 id="第4章-图形变换与裁剪">第4章 图形变换与裁剪 ★</h2><h3 id="图形矩阵变换">图形矩阵变换</h3>注：课程默认使用行向量表达，复合变换矩阵要写在行向量的右侧（从左向右结合）$$ T_{3D}=<spanclass="math display">\[\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\b_x&amp;b_y&amp;b_z&amp;1\end{bmatrix}\]</span>S_{3D}=<spanclass="math display">\[\begin{bmatrix}s_x&amp;0&amp;0&amp;0\\0&amp;s_y&amp;0&amp;0\\0&amp;0&amp;s_z&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\]</span><p>\</p><p><em>{}=</em>{}=_{}=$$<img src="https://s2.loli.net/2023/12/30/I8RODVgrYcBblxZ.png" alt="image-20231230135219739" style="zoom: 33%;" /></p><h4 id="平行投影">平行投影</h4><p><img src="https://s2.loli.net/2024/01/06/qrZhaFLtpNoWxRm.png" alt="image-20240106213205808" style="zoom:15%;" /></p><p>投影平面为<strong>xOz面</strong></p><p><strong>主视图</strong>：y拍扁 <span class="math display">\[T_\nu=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\]</span><strong>俯视图</strong>：z拍扁，绕X轴顺时针旋转90度，然后沿Z方向平移一段距离。<span class="math display">\[T_h=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;\cos(-90^\circ)&amp;\sin(-90^\circ)&amp;0\\0&amp;-\sin(-90^\circ)&amp;\cos(-90^\circ)&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;-z_p&amp;1\end{bmatrix}\]</span><strong>侧视图</strong>：x拍扁，绕Z轴逆时针旋转90度到xOz面，然后在X轴方向上移动一定距离。<br /><span class="math display">\[T_W=\begin{bmatrix}0&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}\cos90^\circ&amp;\sin90^\circ&amp;0&amp;0\\-\sin90^\circ&amp;\cos90^\circ&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\-x_L&amp;0&amp;0&amp;1\end{bmatrix}\]</span></p><p><strong>正轴测投影</strong>：将物体绕Z轴逆时针旋转某个角度（比如β角）,然后再绕X轴顺时针旋转α角，然后再向xOz面做正平行投影。<span class="math display">\[R_{zx}=R_zR_x=\begin{bmatrix}\cos \beta &amp; \sin \beta &amp; 0 &amp; 0\\-\sin \beta &amp; \cos \beta &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;\cos\alpha&amp;\sin\alpha&amp;0\\0&amp;-\sin\alpha&amp;\cos\alpha&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\]</span></p><h4 id="透视投影">透视投影</h4><ol type="1"><li>一点透视：也称为平行透视。即投影平面与投影对象所在坐标系的一个坐标平面平行。</li><li>两点透视：也称为成角透视。即投影平面与投影对象所在坐标系的一个坐标轴平行，而与另两个坐标轴成一定角度。</li><li>三点透视：也称为斜透视。即投影平面与投影对象所在的坐标系的坐标轴均不平行。</li></ol><figure><img src="https://s2.loli.net/2023/12/30/k1uw9eFMSd5OGv6.png"alt="image-20231230135755972" /><figcaption aria-hidden="true">image-20231230135755972</figcaption></figure><p>灭点：不平行于投影平面的平行线（如平行于 z轴的平行线）的投影的汇聚点，这个点称为灭点。（一定落在同一个面上）</p><p>主灭点：平行于三维坐标系坐标轴的平行线在投影平面上形成的灭点。</p><p><spanclass="math inline">\([x^{\prime},y^{\prime},z^{\prime},1]=[0,0,1/r,1]\)</span>其对应的投景约矩阵为：</p><p><span class="math display">\[\left[\begin{array}{llll}x^{\prime} &amp; y^{\prime} &amp; z^{\prime} &amp; H\end{array}\right]=\left[\begin{array}{llll}x &amp; y &amp; z &amp; 1\end{array}\right]\left[\begin{array}{llll}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; q \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]=\left[\begin{array}{llll}x &amp; y &amp; z &amp; q y+1\end{array}\right]\]</span> 如果灭点在X轴<spanclass="math inline">\([1/p,0,0,1]\)</span>和Y轴<spanclass="math inline">\([0,1/q,0,1]\)</span>上，则对应的投影矩阵分别为:<span class="math display">\[P_{x}=\left[\begin{array}{llll}1 &amp; 0 &amp; 0 &amp; p \\0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right], P_{y}=\left[\begin{array}{llll}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; q \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\]</span></p><h3 id="图形裁剪">图形裁剪</h3><h4id="cohen-sutherland裁剪算法编码裁剪算法">Cohen-Sutherland裁剪算法（编码裁剪算法）</h4><ol type="1"><li>对线段端点编码，定义为它所在区域的编码;</li><li>快速判断“完全可见”，若两端点编码均为0，则完全可见。<strong>RC0=0且RC1=0</strong></li><li>快速判断“完全不可见”，线段两端点编码的逻辑位“与”运算结果非零，则完全不可见。<strong>RC0&amp;RC1≠0</strong>说明直线段位于窗外的同一侧</li><li>若2)、3)不满足，逐个端点判断其编码 CtCbCrCl(C3C2C1C0)中位是否为“1”，若是，则需求交，交点的x坐标进行排序，从而将原始线段分割成最多五段线段（四个交点）。然后根据（1）（2）步判断这些线段是否在区域内。</li></ol><p><img src="https://s2.loli.net/2024/01/06/6DyukMBLPHzItlT.png" alt="image-20240106215840646" style="zoom:33%;" /></p><h4 id="中点分割裁剪算法">中点分割裁剪算法</h4><p>中点分割法的思想是通过不断求线段的中点，并<strong>采用Cohen-Sutherland算法可见性判断</strong>，然后确定可见区域内的线段。</p><ul><li>固定 P1，测试 P2是否在窗口内，若是，则 P2 是离 P1点最远的可见点。否则，将线段 P1P2 对分，求出中点 Pm，编码判断线段 PmP2是否全部在窗口外，若是，则舍弃PmP2，用 P1Pm代替P1P2；若不是，则用PmP2代替P1P2。</li></ul><p>本质就是固定一个端点求，用二分法求这个端点的最远的可见点。</p><h4id="liang梁友栋-barsky裁剪算法">Liang（<strong>梁友栋）</strong>-Barsky裁剪算法</h4><p>无论何种情况下，在裁剪区域之内的线段均为：AB ∩ RS ∩ TU</p><p><img src="https://s2.loli.net/2023/12/30/SE49AZKfWMmcTRj.png" alt="image-20231230144247813" style="zoom:33%;" /></p><p>记<span class="math inline">\(L=\max \left[x_{\min }, \min\left(x_{A}, x_{B}\right)\right], R=\min \left[x_{\max }, \max\left(x_{A},x_{B}\right)\right]\)</span>，不等式若有不成立，则不存在可见线段，不等式为：<span class="math display">\[\left\{\begin{array}{l}L \leqslant R \\L \leqslant \max \left(x_{T}, x_{U}\right) \\\min \left(x_{T}, x_{U}\right) \leqslant R\end{array}\right.;\quad\text{斜率&gt;0时}\left\{\begin{array}{l}L \leqslant R \\L \leqslant x_{U} \\x_{T} \leqslant R\end{array}\right.;\quad\text{斜率&lt;0时}\left\{\begin{array}{l}L \leqslant R \\L \leqslant x_{T} \\x_{U} \leqslant R\end{array}\right.\]</span> A B 斜率大于 0 时，可见线段的端点坐标：<spanclass="math inline">\(\begin{array}{l} x_{\alpha}=\max \left(L,x_{T}\right) \\ x_{\beta}=\min \left(R, x_{U}\right)\end{array}\)</span></p><p>A B 斜率小于 0 时，可见线段的端点坐标：<spanclass="math inline">\(\begin{array}{l} x_{\alpha}=\max \left(L,x_{U}\right) \\ x_{\beta}=\min \left(R, x_{T}\right)\end{array}\)</span></p><h3 id="多边形裁剪">多边形裁剪</h3><h4 id="sutherland-hodgman算法">Sutherland-Hodgman算法</h4><p>基本思想：用裁剪窗口的每一条边去裁剪某个多边形</p><ol type="1"><li>边 <span class="math inline">\(P_i P_{i+1}\)</span>可见一侧，输出<span class="math inline">\(P_{i+1}\)</span>。<br /></li><li>边<span class="math inline">\(P_iP_{i+1}\)</span>不可见一侧，此时没有新的顶点输出。</li><li>边<span class="math inline">\(P_iP_{i+1}\)</span>离开窗口，输出交点。</li><li>边<span class="math inline">\(P_iP_{i+1}\)</span>进入窗口，该交点和顶点<spanclass="math inline">\(P_{i+1}\)</span>都输出。</li></ol><p>问题：裁剪<strong>凹多边形</strong>可能会出现多余的边</p><h4 id="weiler-atherton算法">Weiler-Atherton算法</h4><p>可适用于任意类型的多边形，包括有空洞的。将裁剪多边形称为CP，被裁剪多边形称为SP。</p><ol type="1"><li>算法首先将CP和SP的顶点按照<strong>外部边界取顺时针</strong>，内部边界取逆时针的的方式将其构成环形链表。</li><li>求出SP与CP边线的所有交点，并将这些交点插入到SP和CP的环形链表中，并<strong>标明</strong>交点是出点还是进点。</li><li>算法从任意一个<strong>进点开始</strong>沿着SP的边线按照边线所标示的方向搜集顶点序列，当遇到<strong>出点</strong>时，则<strong>沿着CP的边线</strong>所标示的方向搜集顶点序列，当遇到<strong>进点</strong>时，则<strong>沿着SP的边线</strong>所标示的方向搜集顶点序列。</li></ol><p>搜索所有点。</p><h3 id="图形消隐">图形消隐</h3><h4 id="背面剔除算法">背面剔除算法</h4><p>在取景变换（将物体从世界坐标系转换到摄像机坐标系）之前，将那些背离视点方向而不可见的景物表面剔除。</p><ol type="1"><li>计算多边形的法向向量N和视线向量V。</li><li>计算法向向量N和视线向量V的夹角θ的余弦Cosθ=N.V。</li><li>cosθ＜0，即θ＞90°， 则该多边形表面为背面，是不可见的</li></ol><h4 id="画家算法">画家算法</h4><p>将多边形按照离视点的远近进行排序（P221判断遮挡，分割），然后先画出被遮挡的多边形，再画出不被遮挡的多边形，用后画的多边形覆盖先画的多边形，从而达到自动消隐的目的。</p><h4 id="weiler-atherton算法-1">Weiler-Atherton算法</h4><p>算法思想：采用裁剪算法的思想对隐藏面进行消隐。</p><p>算法步骤如下：</p><ol type="1"><li>先进行初步的深度预排序，即将变换到屏幕坐标系中的景物表面多边形按各顶点的z 最小值进行排序，形成景物多边形表。</li><li>以当前具有最大 z 值（即离视点最近）的景物表面作为裁剪多边形 CP。</li><li>用CP对景物多边形表中排在后面的景物表面进行裁剪，产生内部多边形 Pin和外部多边形 Pout 。</li><li>由于多边形顶点离视点最近的多边形表面不一定是真正排在最前面的可见面，因此，需比较CP与内部多边形Pin 的深度，检查 CP是否是真正离视点较近的多边形。如果是，则CP为可见表面，而位于裁剪多边形 CP之内的多边形 Pin为当前视点的隐藏面，可以消去该隐藏面；如果不是，则选择 Pin为新的裁剪多边形，重复步骤 3。</li><li>将位于裁剪多边形之外的景物表面 Pout组成外裁剪结果多边形表，取表中深度最大即排在最前面的表面为裁剪多边形，重复步骤3，继续对表中其他景物表面进行裁剪。</li><li>上述过程递归进行，直到外裁剪结果多边形表为空时为止</li></ol><h4 id="bsp树算法">BSP树算法</h4><p>算法思想：平面分割二叉树</p><p>先在场景中选取一剖分平面P1（与视点垂直的平面），将场景空间分割成两个半空间。它相应地把场景中的景物分成两组，相对于视点而言，一组景物多边形位于P1的前面，作为BSP树的左孩子（front)，另一组景物多边形位于P1的后面,作为BSP树的右孩子（Back)，如果有物体与P1相交，就将它分割为两个物体分别标识为A和B，再用平面 P2对所生成的两个子空间继续进行分割，并对每一子空间所含景物进行分类。上述空间剖分和景物分类过程递归进行，直至每一子空间中所含景物少于给定的阈值为止。</p><p>优先绘制标识为“back”的子空间中所含的景物，这样可使得前面的物体覆盖后面的物体，从而实现物体的消隐。</p><h4 id="深度缓冲区算法">深度缓冲区算法</h4><p>目前大多数的硬件实现方法</p><p>算法思想：对投影到显示屏上的每一个像素所对应的多边形表面的深度进行比较，然后取最近表面的属性值作为该像素的属性值。<strong>Z缓冲器（Z-buffer，深度缓冲区）</strong>，深度缓冲器只是帧缓冲器的扩充。</p><ol type="1"><li>将场景中的所有多边形通过取景变换、透视变换变换到屏幕坐标系中，物体的深度比较可通过它们z值的比较来实现。</li><li>初始化深度缓冲存储器和帧缓冲器。深度缓冲器应初始化为离视点最远的最大z值，帧缓冲器应初始化为背景的属性值。</li><li>扫描待显示的每一个多边形，比较当前多边形所覆盖的每一个像素点的深度值，如果其深度值比深度缓冲区中当前像素的深度值小，则取代原来的深度值，并将对应像素的属性值保存到帧缓冲区对应的位置中。反之，则不做任何处理。循环该步骤，直到处理完所有的多边形。</li></ol><h4 id="warnock算法">Warnock算法</h4><p>该算法将整个观察范围细分成越来越小的矩形单元，直至每个单元仅包含单个可见面片的投影或不包含任何面片。</p><p>单纯窗口：景物已经足够简单，比如没有任何可见物体，或者窗口已被一个可见面片完全充满</p><p>算法思想：将非单纯的窗口四等分为4个子窗口（四叉树），对每个子窗口再进一步判别是否是单纯的，直到窗口单纯或窗口边长已缩减至一个像素点为止。</p><ol type="1"><li>对每个窗口进行判断，若画面中所有多边形均与此窗口分离，即此窗口为空，则按背景光强或颜色直接显示而无需继续分割。</li><li>若窗口中仅包含一个多边形，则窗口内多边形外的区域按背景光强或颜色填充，多边形内按多边形相应的光强或颜色填充。</li><li>若窗口与一个多边形相交，则窗口内多边形外的区域按背景光强或颜色填充，相交多边形内位于窗口内的部分按多边形相应的光强或颜色填充。</li><li>若窗口被一个多边形包围且窗口内无其他的多边形，则窗口按此包围多边形相应的光强或颜色填充。</li><li>若窗口至少被一个多边形包围且此多边形距离视点最近，则窗口按此离视点最近的包围多边形的相应光强或颜色填充。</li><li>若以上条件都不满足，则继续细分窗口，并重复以上测试。</li></ol><p>四元素，看不懂…</p><h2 id="第5章-模型生成方法">第5章 模型生成方法</h2><h3 id="模型的表示方法">模型的表示方法</h3><p>三角面：顶点+索引</p><h3 id="参数多项式曲面">参数多项式曲面</h3><p><span class="math display">\[\begin{cases}x=x(u,v)\\y=y(u,v)\\z=z(u,v)&amp;\end{cases}\quad(u,v)\in[0,1]\times[0,1]\]</span></p><p><span class="math display">\[P(u,v)=\sum_{i=0}^m\sum_{j=0}^na_{ij}u^i\nu^j=U^\mathrm{T}AV\quad(u,v)\in[0,1]\times[0,1]\]</span></p><h4 id="bezier曲面">Bezier曲面</h4><p><span class="math display">\[P(u,v)=\sum_{i=0}^m\sum_{j=0}^nP_{ij}BEZ_{i,m}(u)BEZ_{j,n}(v)\quadu\in[0,1],v\in[0,1]\]</span> $$</p><h4 id="b-样条曲面">B 样条曲面</h4><p><span class="math display">\[P(u,v)=\sum_{i=0}^m\sum_{j=0}^nP_{ij}B_{i,k}(u)B_{j,h}(\nu)\quadu\in[0,1],\nu\in[0,1]\]</span></p><figure><img src="https://s2.loli.net/2024/01/09/gVWfeZhpoMTq4Ja.png"alt="image-20240109100103615" /><figcaption aria-hidden="true">image-20240109100103615</figcaption></figure><h3 id="d地形模拟">3D地形模拟</h3><h4 id="diamond-square算法">Diamond-Square算法</h4><ol type="1"><li>给定一个四边形,四个顶点的坐标(包含高度)，定义一初始高度因子h和一缩放倍数b。</li><li>迭代，先求出四边形的中心点高度为顶点平均高度+h*r的随机数，再分别求出4个边的中点，高度为两端点高度的平均值+h*r</li><li>修正高度因子 h=h/b，用(2)的方法分别对这 4个小正方形进行处理。直到达到所期望的山形细腻程度。</li></ol><h3 id="植物形态模拟">植物形态模拟</h3><h4 id="l系统的植物形态模拟">L系统的植物形态模拟</h4><ul><li>F：从当前位置向前走h的长度，同时画线</li><li>G：从当前位置向前走h的长度，但不画线</li><li>+：从当前方向向左转δ角度</li><li>−：从当前方向向右转δ角度</li><li>｜：原地转向180°</li></ul><p>定义一个产生式，通过产生式生成新的符号串。如果进行多次迭代，可生成更长的新的符号串，然后根据所产生的符号串来生成对应的树。</p><figure><img src="https://s2.loli.net/2023/12/31/NOakHouzQ9ECB8D.png"alt="image-20231231094949109" /><figcaption aria-hidden="true">image-20231231094949109</figcaption></figure><h4 id="迭代函数算法iterated-function-systemifs">迭代函数算法（IteratedFunction System，IFS）</h4><p>IFS系统由一个压缩仿射变换集<spanclass="math inline">\(X=\{w_1,w_2,…,w_N\}\)</span>和对应概率集<spanclass="math inline">\(P=\{p_1,p_2,…,p_N\}\)</span>组成 <spanclass="math display">\[\begin{gathered}\sum_{j=1}^Np_j=1,p_j&gt;0,j=1,2,\cdots,N\\\boldsymbol{w}_j\begin{pmatrix}x\\y\end{pmatrix}=\begin{pmatrix}\boldsymbol{a}_j&amp;\boldsymbol{b}_j\\\boldsymbol{c}_j&amp;\boldsymbol{d}_j\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}+\begin{pmatrix}\boldsymbol{e}_j\\\boldsymbol{f}_j\end{pmatrix},\boldsymbol{j}=1,2,\cdots,N\end{gathered}\]</span> 输入：初始点的坐标x,y; 输出：屏幕上显示的树</p><ol type="1"><li>输入N或者设定N为某个固定值, 输入或设置迭代次数M。</li><li>随机生成N个W概率值，并保存到w[N]。</li><li>随机生成N个概率值，并保存到P[N]。</li><li>随机生成概率值p。</li><li>轮盘选择法。如果P&lt;P[0],则w= w[0]; 反之，如果P&lt;p[0]+P[1],则w=w[0]+w[1];….</li><li>根据前面的公式更新x,y。</li><li>在屏幕上(x,y)的位置以一定的亮度或者颜色显示该像素。</li><li>循环执行步骤（4）~（7）M次。</li></ol><figure><img src="https://s2.loli.net/2023/12/31/sywN25MZjOcraDW.png"alt="image-20231231100959845" /><figcaption aria-hidden="true">image-20231231100959845</figcaption></figure><h3id="粒子系统雨雪现象模拟液态流体模拟">粒子系统：雨雪现象模拟、液态流体模拟</h3><ol type="1"><li>生成一定数量的初始粒子，对其各个属性进行赋值。</li><li>更新粒子的运动参数，比如速度，加速度，位置，生命周期等。<br /></li><li>针对每一个粒子，在粒子对应的位置上绘制位图，并进行位移的映射，背景融合等。</li><li>删除已经消亡的粒子，释放其占用的资源。</li></ol><p>在模拟时都是在每一帧对其属性进行更新。</p><ul><li>基于粒子系统的喷泉模拟</li><li>基于粒子系统的瀑布模拟</li></ul><h3 id="气态流体模拟">气态流体模拟</h3><p>细胞自动机：又称为元胞自动机（CellularAutomata），是一种在空间和时间上都离散的演化动力系统。每个元胞之上都有若干种离散或者连续的状态，这些状态在每一个时间步都会按照相同的规则发生变化，于是形成了整个元胞自动机的演化过程。</p><p>例子：火焰的模拟，<spanclass="math inline">\(s_{i,j}^t\)</span>局部温度<spanclass="math inline">\(u_{i,j}^t\)</span>燃料供应……</p><h2 id="第6章-图形显示技术">第6章 图形显示技术</h2><h3 id="光照模型">光照模型</h3><ul><li>光照模型分类：几何光照模型（局部光照模型和整体光照模型）、物理光照模型</li><li>光源的分类：点光源、线光源、面光源、体光源</li></ul><h4 id="光照基本模型">光照基本模型</h4><p><strong>漫反射光</strong>(diffuseReflection)：当光线照射到物体表面，有一部分光线将进入物体内部，部分会被吸收，而另一部分会从内部向各个方向散射并返回表面，这就形成漫反射光。<spanclass="math inline">\(\begin{aligned}c_d&amp;=\max(\texttt{L.n, 0})\cdotB_L\otimes m_d\end{aligned}\)</span></p><p><strong>环境光照</strong>（AmbientLight）：从其他物体发射过来的光线照射到物体所形成的间接光照。<spanclass="math inline">\(c_a=A_L\otimes\boldsymbol{m}_d\mid\)</span></p><p><strong>镜面光照</strong>（Specularreflection)：一部分光将被反射，另一部分光被折，被反射的部分称为镜面反射光，只有观察者在特定的角度才能看到。<spanclass="math inline">\(\mathbf{c}_s=\max\left(\mathbf{L}\cdot\mathbf{n},0\right)\cdot\mathbf{B}_L\otimes\mathbf{R}_F(\alpha_h)\frac{m+8}8{\left(\mathbf{n}\cdot\mathbf{h}\right)}^m\)</span></p><p><strong>光照整体模型</strong>： <span class="math display">\[\begin{aligned}\text{LitColor}&amp; =\mathbf{c}_a+\mathbf{c}_d+\mathbf{c}_s  \\&amp;=\mathbf{A}_L\otimes\mathbf{m}_d+\max\left(\mathbf{L}\cdot\mathbf{n},0\right)\cdot\mathbf{B}_L\otimes\left(\mathbf{m}_d+\mathbf{R}_F(\alpha_h)\frac{m+8}8{\left(\mathbf{n}\cdot\mathbf{h}\right)}^m\right)\end{aligned}\]</span></p><ul><li>L:光源的光向量 n: 表面法向 h: 光向量与观察向量之间的中间向量 $A_L:$入射的环境光量。 <spanclass="math inline">\(m_d:\)</span>根据表面漫反射率而反射的入射光量。L.n: 光线与法向量之间夹角的余弦。 <spanclass="math inline">\(a_h{:}\)</span> 中间向量h与光向量之间的夹角。<span class="math inline">\(R_F(a_h):\)</span> 中间向量h(由表面点指向观察点的单位向量) 所反射到观察者眼中的光量。 m:控制表面的粗糙度。<spanclass="math inline">\((\mathbf{n}\cdot\mathbf{h})^m\)</span>线h与宏观表面法向n之间夹角为<spanclass="math inline">\(\Theta h\)</span>的所有为平面片段。 <spanclass="math inline">\(\frac{m+8}{s}:\)</span>在镜面发射过程中，为模拟能量守恒所采用的归一化因子。</li></ul><p>环境光照</p><ul><li>环境光模型（物体表面对环境光反射的强度）</li><li>漫反射模型（观察者从不同角度观察到的反射光具有同样的亮度，这样的反射光成为漫反射光）</li><li>镜面反射（反射光 =&gt; 对入射光的直接反射）</li><li>Phong模型（环境光 + 漫反射光 + 镜面反射光）</li></ul><p><strong>整体光照模型：</strong>光线追踪</p><h3 id="明暗处理">明暗处理</h3><h4 id="gouraud明暗处理">Gouraud明暗处理</h4><p>基本思想：对离散的<strong>顶点颜色</strong>采样进行双线性插值得到内部点颜色。</p><ol type="1"><li>计算每个多边形顶点的平均单位法矢量</li><li>对每个顶点根据简单光照模型计算光强</li><li>在多边形表面上对顶点颜色进行线性插值</li></ol><p>特点：（1）只适用于简单的漫反射模型（2）线性光强度插值会引起马赫带效应</p><h4 id="phong明暗处理">Phong明暗处理</h4><ol type="1"><li>计算多边形顶点处曲面法向矢量的平均值。</li><li>对离散的多边形顶点<strong>法向量</strong>进行<strong>双线性插值</strong>，得到面上每个点的法向矢量。</li><li>按光照模型确定多边形内部各点的光强</li></ol><h3 id="纹理细节模拟">纹理细节模拟</h3><p><strong>颜色纹理</strong>：将图片映射到物体表面的方式来实现。将图片的四个角点的坐标分别定义为(0,0)(0,1) (1,1) (1,0)。三角形每一个顶点均对应图片的一个(u,v)坐标。</p><p><strong>几何纹理</strong>：物体表面的微观几何形状（粗燥程度）。物体表面法向量矢量的修改可通过在各采样点的位置上增加一个扰动函数，对其做微小的扰动，从而改变表面的微观几何现状来实现。</p><p><strong>过程纹理</strong>：通过过程迭代函数生成纹理。目的是用简单的参数来逼真的描述复杂的自然纹理细节。例如：噪声函数，湍流函数等来动态的生成天空，水流等。</p><h2 id="复习大纲总结">复习大纲总结</h2><h3 id="图形学基本概念">图形学基本概念</h3><h4 id="什么是计算机图形学-1">1. 什么是计算机图形学？</h4><p>研究通过计算机，将<strong>数据</strong>转化为<strong>图形</strong>，并在专门显示设备上<strong>显示</strong>的<strong>原理、方法和技术</strong>的学科。也就是如何<strong>用计算机生成、处理和显示图形</strong>的一门学科。</p><h4 id="计算机图形学的主要研究内容包括哪些">2.计算机图形学的主要研究内容包括哪些？</h4><p>硬件部分：包括各种<strong>输入/输出</strong>、<strong>图形处理设备</strong>或器件的研究</p><p>软件部分：</p><ul><li>图形<strong>生成</strong>算法的研究，包括基本图形的生成，比如直线，圆/圆弧，多边形，曲线/曲面，多面体，自然现象/自然景物等。</li><li>图形<strong>变换</strong>算法的研究，包括图形在平面或者空间中的变换，各种视窗之间的转换，平面和空间裁剪，消隐等。</li><li>图形<strong>显示技术</strong>研究，包括光照、材质、纹理、阴影、透明、光线追踪等技术的研究。</li></ul><h4 id="计算机图形学的主要应用领域">3. 计算机图形学的主要应用领域。</h4><ol type="1"><li>图形用户接口 (2) 工业应用 (3) 商业领域 (4) 艺术领域 (5)科学计算可视化 (6) 虚拟现实 (7) 系统环境模拟</li></ol><h4 id="图形和图像的主要区别是什么">4. 图形和图像的主要区别是什么？</h4><ul><li><strong>表示方法</strong>不同：图形是由基本几何体（直线，点，圆、曲线、三角形等）构成的实体，同时具有几何属性和视觉属性。图像是由很多像素点构成的点阵信息。</li><li><strong>生成方法</strong>不同：图形是通过计算机算法生成的，而图像是通过照相机，摄像机等扫描设备或图像生成软件制作而成。</li><li><strong>研究侧重点</strong>不同：图形学主要研究如何使用计算机<strong>表示几何体</strong>，构建几何模型、如何通过建立数学模型或者算法把真实的或者想象的物体显示出来。图像处理主要研究如何将一种图像<strong>处理成另一种图像</strong>，包括图像增强、复原、解析和理解、编码、压缩、匹配，识别等。</li></ul><h4 id="计算机图形处理系统的主要构成">5.计算机图形处理系统的主要构成。</h4><p>典型的计算机图形系统包括<strong>处理、存储、交互、输入、输出</strong> 5个基本功能</p><p><img src="https://s2.loli.net/2024/01/06/OTQDkLhuVjGW1Np.png" alt="计算机图形学学习笔记（一）：图形学概论 - 知乎" style="zoom: 33%;" /></p><h4 id="显卡的工作流程">6. 显卡的工作流程。</h4><p>图像或者图形数据在CPU处理后，通过下面四个步骤到达显示器：</p><ol type="1"><li>通过数据<strong>总线</strong>将要显示的图形或者图像数据送入<strong>GPU</strong>（图形处理器)。</li><li>GPU对送入的数据进行<strong>处理</strong>然后送入<strong>帧缓冲器</strong>（或称显存)。</li><li>送入帧缓冲器中的数据将被送入<strong>视频控制器</strong>。视频控制器将根据接口的类型确定处理方式，完成数模转换；</li><li>视频控制器的输出将送到<strong>显示屏</strong>。</li></ol><h4 id="什么是显示存储器">7. 什么是显示存储器？</h4><p>显存用来<strong>存储屏幕上像素的颜色值</strong>，简称<strong>帧缓冲器</strong>，俗称显存。帧缓冲器中的单元数目与显示器上的像素数目相同，单元与像素一一对应，各单元的数值决定了其对应的像素的颜色。</p><h4 id="gpu的基本概念">8. GPU的基本概念。</h4><p>GPU是专为执行复杂的<strong>数学和几何计算</strong>而设计的<strong>微处理器</strong>，能够将复杂的图形<strong>转换</strong>成显示器能够显示的图像。GPU可通过编程完成所需要的图形变换和计算。</p><p>GPU可以完成大量的并行计算。由很多的流处理单元（SM，streamingmultiprocessor)构成，每一个流处理单元由多个核（计算单元），任务调度器，寄存器组，指令缓冲器，纹理缓冲区，纹理映射单元等构成。</p><h4 id="显卡分辨率的含义">9. 显卡分辨率的含义。</h4><p>显卡分辨率是指显卡输出给显示器并能在显示器上描绘的像素点的数量。分辨率越大，所能显示的图像的像素点就越多，并且能显示更多的细节，当然也就越清晰。</p><p>显卡分辨率跟显存的大小以及视频控制器上RAMDAC的速率有关。如果显存足够大，则RAM DAC决定了分辨率的最大值。</p><h4 id="gpu堆包含哪几种主要的类型具有什么样的特点">10.GPU堆包含哪几种主要的类型，具有什么样的特点？</h4><ul><li>上传堆：CPU只能将数据传送给上传堆，上传堆不能向CPU传数据。</li><li>默认堆：默认堆需要通过上传堆传送数据，CPU不能直接访问。</li><li>回读堆：GPU可通过回读堆将数据传送给CPU。</li></ul><h4 id="gpu渲染流水线包含哪几个阶段分别完成什么任务">11.GPU渲染流水线包含哪几个阶段，分别完成什么任务？</h4><ol type="1"><li><strong>输入装配</strong>阶段。从内存中读入相关的顶点和索引，从而生成几何图形的<strong>基本要素</strong>（点，线以及三角面）。</li><li><strong>顶点着色</strong>阶段。完成顶点转换（从局部坐标系转换到齐次裁剪坐标系中），光照（纹理）等各种形式的运算。</li><li><strong>曲面细分</strong>阶段。将一个大的三角形分解成若干个小的三角形。</li><li><strong>几何着色</strong>阶段。对输入的点进行筛选，然后输出相应的构成几何图形的基本要素。</li><li><strong>裁剪</strong>。将区域之外的物体去除掉，只显示区域之内的物体。</li><li><strong>光栅化</strong>阶段。将几何图元变为二维图像。</li><li><strong>像素着色</strong>阶段。通过这些点及相应的属性可以在GPU中计算除相应像素的颜色，光照的影响，阴影等处理效果。</li><li><strong>输出融合</strong>阶段。一些像素无法通过深度测试而被排除，而另一些像素送入，与此前已经写入到后台缓冲区中的像素进行相应的融合处理。</li></ol><h4 id="光照的基本原理">12. 光照的基本原理</h4><p>当光照射到物体表面时，物体将<strong>吸收</strong>一部分光，同时也会<strong>反射或透射</strong>一部分光。<strong>反射或透射</strong>出的光进入人的眼睛所显示出的颜色就是物体的颜色。</p><h4 id="光照模型的分类">13. 光照模型的分类</h4><ul><li>几何光照模型：以几何学原理为基础，形式简单，精度低，主要用于图像渲染。<ul><li><strong>局部光照模型</strong>：局部光照模型假设物体表面不透明，反射均匀，光源直射物体表面，可模拟漫反射，镜面反射，阴影等。</li><li><strong>整体光照模型</strong>：在模拟局部光照模型的基础上，还须考虑周围环境对景物表面的影响。可以模拟镜面映像，透明，折射，相邻景物之间的色彩辉映等较为精致的光照效果。<br /></li></ul></li><li>物理光照模型：以<strong>电池波反射理论</strong>为基础，精度高，形式比较复杂，用于光谱分析等物理领域。</li></ul><h4 id="光源的分类">14. 光源的分类</h4><ul><li><strong>点</strong>光源：光线由中心点均匀向四周散射。在光源比场景中的物体小得多或者距离物体足够远时，可将该光源视为点光源。</li><li><strong>线</strong>光源：发光的光源呈一条直线则称为线光源。线光源可看成由无数个点光源构成。比如日光灯，穿过单缝的光等。<br /></li><li><strong>面</strong>光源：面光源是一种通过将光源均匀分布在一个平面上实现整体均匀照明效果的照明装置。</li><li><strong>体</strong>光源：体光源在所有方向上发射光线，产生全方位的光照效果。</li></ul><h4 id="纹理的表现形式">15. 纹理的表现形式。</h4><ul><li><strong>颜色纹理</strong>：将图片映射到物体表面的方式来实现。</li><li><strong>几何纹理</strong>：物体表面的微观几何形状（粗燥程度）。</li><li><strong>过程纹理</strong>：过程纹理用于表现各种规则或不规则的<strong>动态变化</strong>的自然景象。</li></ul><h4 id="纹理的过滤方式及寻址方式">16. 纹理的过滤方式及寻址方式</h4><ul><li><strong>纹理过滤</strong>：纹理图与实际待显示的图形大小不一致的情况，需要通过纹理过滤来解决。<ul><li><strong>点</strong>过滤：在纹理贴图时，选择与待投影到屏幕上的几何体分辨率最为匹配的Mipmap层级，并根据具体需求选用常数插值或线性插值。</li><li><strong>线性</strong>过滤：在纹理贴图时，选区与待投影到屏幕上的几何体分辨率最为匹配的两个临近的Mipmap层级（一个稍大于屏幕上几何体的分辨率，一个稍小于屏幕上几何体的分辨率），然后对这两种MipMap层级的图分别进行常量过滤或线性过滤，生成他们各自相应的纹理颜色。最后再在这两种插值纹理之间进行颜色的插值计算。</li><li><strong>各向异性</strong>过滤：需要对映射点周围8个(正方体）或更多的像素进行取样，获得平均值后映射到像素点上。</li></ul></li><li><strong>寻址模式</strong>：当设定的纹理坐标值大于（1.0.1.0）时，则通过寻址模式来解决。<ul><li><strong>重复寻址</strong>模式（Wrap）：通过在坐标的每个整数点处重复绘制图像来托充纹理函数。</li><li><strong>边框颜色寻址</strong>模式：通过将每个不在 [0,1]范围内的坐标（u,v）都映射为<strong>指定的颜色</strong>（边框颜色）而拓充纹理函数</li><li><strong>钳位寻址</strong>模式：通过将范围[0,1]外的颜色使用<strong>边缘的纹理</strong>坐标内容进行延伸</li><li><strong>镜像寻址</strong>模式：通过在坐标的每个整数点处绘制图像的<strong>镜像来扩充</strong>纹理函数。</li></ul></li></ul><h4 id="多级纹理的基本原理">17. 多级纹理的基本原理</h4><p>多级纹理是指使用<strong>多个不同大小</strong>的纹理图片作为贴图来提高画面质量的方法。针对物体处于<strong>不同的距离</strong>，<strong>采用不同分辨率</strong>大小的纹理贴图，可以提高图像显示质量，降低图像渲染的复杂度。</p><h4 id="模型的表示方法-1">18. 模型的表示方法</h4><ul><li>通过<strong>三角形、四边形、曲面方程</strong>等来<strong>模拟</strong>物体的表面，最后形成三维模型；</li><li>是通过无数个细小的四面体、球体等<strong>基本几何体</strong>来构成整个物体。</li></ul><h4 id="direct3d-12图形绘制的基本原理">19. Direct3D12图形绘制的基本原理</h4><p>CPU的数据传递给GPU之后，GPU将把它保存到到GPU的<strong>存储空间</strong>中。Direct12版本将其分成<strong>上传堆</strong>、<strong>默认堆</strong>和<strong>回读堆</strong>，并用于存储不同类型的图形数据，同时通过不同的API对其进行操作。Direct3D提供的<strong>图形接口</strong>，通过与GPU卡的<strong>通信</strong>及<strong>编程</strong>实现对图形的<strong>计算和显示</strong>。其原来由CPU进行的计算则转移到GPU中，由GPU计算出对应的像素位置，然后再进行显示。</p><h4 id="三维模型顶点的数据结构表示">20. 三维模型顶点的数据结构表示</h4><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span>&#123;</span>XMFLOAT3 Pos;      <span class="hljs-comment">//顶点的坐标</span>XMFLOAT4 Color;    <span class="hljs-comment">//顶点的颜色，第四个位置表示alpha通道，用于控制颜色的透明度</span>&#125;;std::vector&lt;Vertex&gt; Vertices;   <span class="hljs-comment">//存储所有的顶点 </span>std::vector&lt;<span class="hljs-keyword">int</span>&gt; Indices32;  <span class="hljs-comment">//存储所有三角面对应顶点的索引</span><span class="hljs-comment">// 一个正方体</span>Vertices[<span class="hljs-number">0</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>);Vertices[<span class="hljs-number">1</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-number">-1.0f</span>, +<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>);Vertices[<span class="hljs-number">2</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(+<span class="hljs-number">1.0f</span>, +<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>);Vertices[<span class="hljs-number">3</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(+<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>);Vertices[<span class="hljs-number">4</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>, +<span class="hljs-number">1.0f</span>);Vertices[<span class="hljs-number">5</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-number">-1.0f</span>, +<span class="hljs-number">1.0f</span>, +<span class="hljs-number">1.0f</span>);Vertices[<span class="hljs-number">6</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(+<span class="hljs-number">1.0f</span>, +<span class="hljs-number">1.0f</span>, +<span class="hljs-number">1.0f</span>);Vertices[<span class="hljs-number">7</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(+<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>, +<span class="hljs-number">1.0f</span>);Indices[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;Indices[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;Indices[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>; <span class="hljs-comment">//左手定则来确定其法向</span>Indices[<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;Indices[<span class="hljs-number">4</span>]=<span class="hljs-number">2</span>;Indices[<span class="hljs-number">5</span>]=<span class="hljs-number">3</span>; <span class="hljs-comment">// 左手定则来确定其法向</span>……</code></pre></div><h3 id="图形学基本算法">图形学基本算法</h3><p>要求：算法的基本原理，算法描述，算法执行过程分析，过程计算，编程实现等。</p><h4 id="直线生成算法dda算法中点画线法bresenham法">1.直线生成算法：DDA算法，中点画线法、Bresenham法。</h4><ul><li><p>DDA略</p></li><li><p>中点画线法</p><ul><li><p>检验 0 ≤ k ≤ 1</p></li><li><p>a = <strong>y0 - y1</strong>, b = x1 - x0</p></li><li><p>d0 = <strong>2a+b</strong></p></li><li><p>当<span class="math inline">\(d\ge 0\)</span>，取下点 y不变 <spanclass="math inline">\(y_{i+1} = y_i\)</span>, <spanclass="math inline">\(d&#39;=d+2a\)</span>；</p><p>当<span class="math inline">\(d&lt;0\)</span>，取上点 y加一 <spanclass="math inline">\(y_{i+1} = y_i+1\)</span>, <spanclass="math inline">\(d&#39;=d+2a+2b\)</span>.</p></li></ul></li><li><p>Bresenham法</p><ul><li><p>检验 0 ≤ k ≤ 1</p></li><li><p><span class="math inline">\(\Delta y\)</span> = y1 - y0, <spanclass="math inline">\(\Delta x\)</span> = x1 - x0</p></li><li><p>e = <span class="math inline">\(2\Delta y-\Deltax\)</span>,</p></li><li><p>当<span class="math inline">\(e\ge 0\)</span>，取上点 <spanclass="math inline">\(y_{i+1} = y_i+1\)</span>, <spanclass="math inline">\(e&#39;=e+2\Delta y - 2\Delta x\)</span>；</p><p>当<span class="math inline">\(e&lt;0\)</span>，取下点 <spanclass="math inline">\(y_{i+1} = y_i\)</span>, <spanclass="math inline">\(e&#39;=e+2\Delta y\)</span>.</p></li></ul></li></ul><h4 id="圆和圆弧的生成算法dda算法中点画线法bresenham法">2.圆和圆弧的生成算法：DDA算法，中点画线法，Bresenham法</h4><ul><li><p>DDA算法</p><ul><li><p><span class="math inline">\(y_{n+1}= y_n-εx_n\)</span></p><p><span class="math inline">\(x_{n+1}= x_n+εy_n\)</span></p></li></ul></li><li><p>中点画线法</p><ul><li><p>初始值 <span class="math inline">\(x=0,y=R\)</span>, <spanclass="math inline">\(d=1-R\)</span></p></li><li><p><span class="math inline">\(d&lt;0\)</span>，y不变，<spanclass="math inline">\(d=d+2x+3\)</span></p><p><span class="math inline">\(d\ge0\)</span>，y减一，<spanclass="math inline">\(d= d+2x-2y+5\)</span></p></li></ul></li><li><p>Bresenham法</p><ul><li>初始化 <span class="math inline">\(x=0, y=R, d=2(1-R)\)</span></li><li>d&lt;0, <strong>2(d+y)-1</strong>&lt;=0: <spanclass="math inline">\(x=x+1, d=d+2x+3\)</span></li><li>d&lt;0, 2(d+y)-1&gt;0: <span class="math inline">\(x=x+1, y=y-1,d=d+2x-2y+6\)</span></li><li>d=0: 同上</li><li>d&gt;0, 2(d-x)-1&lt;=0: 同上</li><li>d&gt;0, 2(d-x)-1&gt;0: <span class="math inline">\(y=y-1,d=d-2y+3\)</span></li></ul></li></ul><h4 id="线宽生成算法刷子绘制法实区域填充法">3.线宽生成算法：刷子绘制法，实区域填充法</h4><ul><li><p>刷子绘制法</p><ul><li><p>如果直线斜率小于等于1，则将刷子置成垂直方向。使垂直方向有w个像素。每次在中心点上下绘制w/2个像素。</p></li><li><p>如果直线斜率大于1，则将刷子支撑水平方向。使水平方向上有w个像素。如右图所示。</p></li><li><p>缺点： (1) 线宽较大时，不自然 (2)折线处有缺口 (3)宽度不符合要求(4)对称问题：奇偶数像素，效果不同</p></li></ul></li><li><p>方形刷子绘制法：将正方形的中心对准单线条像素，然后沿单线条对应方向移动。</p></li></ul><h4 id="线型的处理">4. 线型的处理</h4><p>线型可以看成一个由布尔值对应的像素。每种线型对应一定的长度的像素，每个像素对应相应的布尔值。如果该像素对应的布尔值为1，则绘制该像素。如果对应的布尔值为0，则不绘制该像素。</p><h4 id="区域填充法扫描线法边填充法种子填充法扫描线种子填充法">5.区域填充法：扫描线法，边填充法，种子填充法，扫描线种子填充法，</h4><ul><li><p>扫描线法：</p><ul><li>求交、排序、两两配对、线段着色，</li><li>注意<strong>顶点求交点</strong>规则：把所有极值顶点当成两个点</li><li>（活性边表法好像不考？）边表的结构为 <spanclass="math inline">\([x,y_{max},\frac1k]\)</span>。 $x:$当前扫描线与活性边的交点， $y_{max}: <spanclass="math inline">\(活性边较高端点的\)</span>y$ 坐标值， $1k:$活性边所在直线斜率的倒数。</li></ul><figure><img src="https://s2.loli.net/2024/01/06/15EK8hUg9einsdC.png"alt="image-20240106225101692" /><figcaption aria-hidden="true">image-20240106225101692</figcaption></figure></li><li><p>边填充法：该多边形每一条边右边区域像素的颜色全部取补</p></li><li><p>栅栏填充法：该多边形每一条边与栅栏之间像素的颜色全部取补</p></li><li><p>种子填充法：四连通/八联通，从某个像素点开始BFS/DFS整某个像素点开始个区域（缺点：堆栈大量使用）</p></li><li><p><strong>扫描线种子</strong>填充法：</p><ul><li>栈顶像素出栈。</li><li>沿扫描线对出栈像素的左右像素进行填充，直到遇到边界像素xl和xr为止</li><li>在区间[xl,xr]中检查与当前扫描线相邻的上下两条扫描线，则把<strong>每个</strong><em>非边界、未填充</em> 的<strong>像素区间</strong>的<strong>最右</strong>像素取为种子像素入栈。</li></ul></li></ul><h4 id="反走样技术像素细分技术bresenham反走样技术">6.反走样技术：像素细分技术，Bresenham反走样技术</h4><ul><li><p>像素细分技术</p><p>(1)将每个显示像素划分为若干个子像素。</p><p>(2)按照常规的计算方法计算出每个像素的颜色和亮度。</p><p>(3)采用算数平均或者加权平均等方法求解对应像素的亮度和颜色。</p><p>(4)显示出对应的像素。</p></li><li><p>Bresenham反走样技术：当待填充的多边形与具有一定面积的像素相交时，求出二者相交的面积，然后以此面积值来决定该像素应该显示的亮度和颜色。</p><p>Bresenham区域反走样算法首先将多边形每条边与具有一定面积的像素相交的面积大小分为8个等级，如果相交的面积小于1/8，则其灰度等级为0，介于1/8到2/8之间，则为1，依次类推。</p><p><span class="math inline">\(S=(y_{i+1}+ y_i)/2=(y_i+ y_i+m)/2=y_i+m/2=e+m/2\)</span>，用e来确定像素的灰度值，注意将其映射到正的区间。</p></li></ul><h4 id="曲线生成bezier曲线和b样条曲线包括二阶三阶曲线等">7.曲线生成：Bezier曲线和B样条曲线，包括二阶、三阶曲线等。</h4><p>二次Bezier曲线： 当控制点的个数为3时，可以得到Bezier曲线方程 <spanclass="math inline">\(P(t)=(1-t)^2P_0+2t(1-t)P_1+t^2P_2\quadt\in[0,1]\)</span></p><p><span class="math display">\[\begin{aligned}&amp;\text{用矩阵形式表示为}:\\&amp;P(t)=[P_0,P_1,P_2]\begin{bmatrix}1&amp;-2&amp;1\\0&amp;2&amp;-2\\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1\\t\\t^2\end{bmatrix}\quadt\in[0,1]\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}\text{性质}:\\&amp;\text{P}(0){=}P_0,\quadP(1){=}P_2,\quad\text{P}^{\prime}(0){=}2(\text{P}_1-\text{P}_0),\quad\text{P}^{\prime}(1){=}2(\text{P}_2-\text{P}_1)\\&amp;\text{P}(0.5){=}\frac12(\text{P}_1+\frac12(P_0+\text{P}_2))=\frac12(\text{P}_1+\text{P}_m),\text{P}^{\prime}(0.5){=}\text{P}_2{-}\text{P}_0\end{aligned}\]</span></p><p><img src="https://s2.loli.net/2024/01/06/ziYFIPXnT4CAN6U.png" alt="image-20240106232012983" style="zoom:25%;" /></p><p>三次Bezier曲线： 当控制点的个数为4时，可以得到三次Bezier曲线方程：<spanclass="math inline">\(P(t)=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3=B_{0,3}(t)P_0+B_{1,3}(t)P_1+B_{2,3}(t)P_2+B_{3,3}(t)P_3\quadt\in[0,1]\)</span> <span class="math display">\[\begin{aligned}&amp;\text{用矩阵形式表示为}:\\&amp;P(t)=[P_0,P_1,P_2,P_3]\begin{bmatrix}1&amp;-3&amp;3&amp;-1\\0&amp;3&amp;-6&amp;3\\0&amp;0&amp;3&amp;3\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1\\t\\t^2\\t^3\end{bmatrix}\quadt\in[0,1]\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}\text{性质:}\\&amp;\mathsf P(0)=P_0,\quadP(1)=P_3,\quad\mathsf P&#39;(0)=3(\mathsf P_1-\mathsf P_0),\quad\mathsfP&#39;(1)=3(\mathsf P_3-\mathsf P_2)\\&amp;\mathsfP&#39;&#39;(0)=6(\mathsf P_0-\mathsf2\mathsf P_1+\mathsfP_2),\quad\mathsf P&#39;&#39;(1)=6(\mathsf P_1-\mathsf2\mathsfP_2+\mathsf P_3)\end{aligned}\]</span></p><p><img src="https://s2.loli.net/2024/01/07/6kh4qRsAJVboWuN.png" alt="image-20240107103212717" style="zoom:25%;" /></p><p>二次B样条曲线：在n=2控制点为3个时，可得到二次B样条曲线的定义为：<span class="math display">\[P(t)=\sum_{i=0}^2P_i\cdotB_{i,2}(t)=\frac12(t-1)^2P_0+\frac12(-2t^2+2t+1)P_1+\frac12t^2P_2\]</span></p><p><span class="math display">\[\begin{aligned}\text{性质:} \\&amp;\begin{aligned}\mathsf P(0)=\frac12(P_0+P_1)\quad\mathsfP(1)=\frac12(P_1+P_2)\quad\mathsf P&#39;(0)=P_1-P_0\quad\mathsfP&#39;(1)=P_2-P_1\end{aligned} \\&amp;\mathsf{P}(0.5)=\frac12(\frac12\left(\mathsf{P}(0)+\mathsf{P}(1)\right)+P_1)=\frac12(P_m+P_1)\quadP^{\prime}(0.5)=\mathsf{P}(1)-\mathsf{P}(0)\end{aligned}\]</span></p><p><img src="https://s2.loli.net/2024/01/06/xPSw9HnlGL4toUJ.png" alt="image-20240106231929596" style="zoom:25%;" /></p><p>三次B样条曲线：在n=3控制点为4个时，可得到三次B样条曲线的定义为：<span class="math display">\[P(t)=\sum_{i=0}^3P_i\cdotB_{i,3}(t)=\frac16(-t^3+3t^2-3t+1)P_0+\frac16(3t^3-6t^2+4)P_1+\frac16\left(-3t^3+3t^2+3t+1\right)P_2+\frac16t^3P_3\]</span> 三次B样条曲线的起点在三角形<span class="math inline">\(\DeltaP_0P_1P_2\)</span>的中线<spanclass="math inline">\(P_1P_m\)</span>上，且<strong>距离P1点的1/3</strong>处（<strong>不是中点！</strong>）。其切线方向与<spanclass="math inline">\(P_0P_2\)</span>平行，且为底边长度的1/2。同样终点位于<spanclass="math inline">\(\Delta P_1P_2P_3\)</span>的纵向<spanclass="math inline">\(P_2P_n\)</span>上，且在距离P2点1/3处。其切线方向与<spanclass="math inline">\(P_1P_3\)</span> ”平行，且为底边长度的1/2。 <spanclass="math display">\[\begin{aligned}\text{性质:}\\&amp;P_{0,3}(0)=\frac{1}{6}(P_{0}+4P_{1}+P_{2})=\frac{1}{3}(\frac{P_{0}+P_{2}}{2})+\frac{2}{3}P_{1}\\&amp;P_{0,3}(1)=\frac{1}{6}\bigl(P_{1}+4P_{2}+P_{3}\bigr)=\frac{1}{3}\bigl(\frac{P_{1}+P_{3}}{2}\bigr)+\frac{2}{3}P_{2}\\&amp;P_{0,3}^{\prime}(0)=\frac{1}{2}(P_{2}-P_{0}),P_{0,3}^{\prime}(1)=\frac{1}{2}(P_{3}-P_{1})\end{aligned}\]</span><img src="https://s2.loli.net/2024/01/06/LAqHEJijUQ4oGzY.png" alt="image-20240106231856996" style="zoom: 50%;" /></p><h4 id="图形变化平移缩放旋转">8. 图形变化：平移、缩放、旋转</h4><p><span class="math display">\[T_{3D}=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\b_x&amp;b_y&amp;b_z&amp;1\end{bmatrix}S_{3D}=\begin{bmatrix}s_x&amp;0&amp;0&amp;0\\0&amp;s_y&amp;0&amp;0\\0&amp;0&amp;s_z&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\\\mathbf{R}_{\mathbf{x}}=\left[\begin{array}{cccc}1 &amp; 0 &amp; 0&amp; 0 \\0 &amp; \cos \theta &amp; \sin \theta &amp; 0 \\0 &amp; -\sin\theta &amp; \cos \theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp;1\end{array}\right]\mathbf{R}_{\mathbf{y}}=\left[\begin{array}{cccc}\cos\theta &amp; 0 &amp; -\sin \theta &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0\\\sin \theta &amp; 0 &amp; \cos \theta &amp; 0 \\0 &amp; 0 &amp; 0&amp;1\end{array}\right]\mathbf{R}_{\mathbf{z}}=\left[\begin{array}{cccc}\cos\theta &amp; \sin \theta &amp; 0 &amp; 0 \\-\sin \theta &amp; \cos\theta &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0&amp; 1\end{array}\right]\]</span></p><p>坐标行向量表达，变换矩阵×在右侧，逆时针为正方向</p><h4 id="坐标系之间的变换局部坐标世界坐标摄像机坐标屏幕坐标">9.坐标系之间的变换：局部坐标、世界坐标、摄像机坐标、屏幕坐标</h4><p><strong>摄像机坐标</strong>（PPT） <span class="math display">\[\begin{align}\left[x, y, z,1\right]\begin{bmatrix}\dfrac{1}{r\tan\left(\alpha/2\right)}&amp;0&amp;0&amp;0\\0&amp;\dfrac{1}{\tan\left(\alpha/2\right)}&amp;0&amp;0\\0&amp;0&amp;\dfrac{f}{f-n}&amp;1\\0&amp;0&amp;\dfrac{-nf}{f-n}&amp;0\end{bmatrix}\quad&amp;=\left[\dfrac{x}{r\tan\left(\alpha/2\right)},\dfrac{y}{\tan\left(\alpha/2\right)},\dfrac{zf-nf}{f-n},z\right]\\\text{规格化}&amp;=\left[\frac{x}{rz\tan\left(\alpha/2\right)},\frac{y}{z\tan\left(\alpha/2\right)},A+\frac{B}{z},1\right]\end{align}\]</span> <imgsrc="https://s2.loli.net/2024/01/07/9gKkVnEGQdm1iN2.png" /></p><p><strong>世界坐标 - 摄像机坐标</strong></p><p>注意：坐标轴顺时针旋转，也就是场景逆时针选择。坐标轴变换对应的变换矩阵都是反向的。</p><ul><li>步骤1：场景坐标系的原点从场景坐标系平移到视点位置 E(Cx,Cy,Cz)</li><li>步骤2：经过平移后的坐标系绕<spanclass="math inline">\(x_e\)</span>轴逆时针旋转90°，</li><li>步骤3：坐标系绕<spanclass="math inline">\(y_e\)</span>轴顺时针旋转角<spanclass="math inline">\(\varphi\)</span>，使新坐的z轴垂直指向原景物坐标系的Z轴，</li><li>步骤4：坐标系绕<spanclass="math inline">\(x_e\)</span>轴顺时针旋转角<spanclass="math inline">\(\theta\)</span>，使新坐的z轴垂直指向原景物坐标系的原点，</li><li>步骤5：右手坐标系调整为左手坐标系，x轴反向</li></ul><p><span class="math display">\[\boldsymbol{T}_1=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\-C_x&amp;-C_y&amp;-C_z&amp;1\end{bmatrix}\boldsymbol{T}_2=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;\cos(-90^\circ)&amp;\sin(-90^\circ)&amp;0\\0&amp;-\sin(-90^\circ)&amp;\cos(-90^\circ)&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\left.\boldsymbol{T}_{3}=\left[\begin{matrix}{\cos\varphi}&amp;{0}&amp;{-\sin\varphi}&amp;{0}\\{0}&amp;{1}&amp;{0}&amp;{0}\\{\sin\varphi}&amp;{0}&amp;{\cos\varphi}&amp;{0}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{matrix}\right.\right]\boldsymbol{T}_{4}=\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \cos \theta &amp; -\sin \theta &amp; 0 \\0 &amp; \sin \theta &amp; \cos \theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\boldsymbol{T}_5=\begin{bmatrix}-1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\]</span></p><figure><img src="https://s2.loli.net/2024/01/07/SHa59nx1TuBDwI7.png"alt="image-20240107161501549" /><figcaption aria-hidden="true">image-20240107161501549</figcaption></figure><h4id="四边形裁剪算法cohen-sutherland裁剪算法中点分割裁剪算法liang-barskey裁剪算法">10.四边形裁剪算法：Cohen-Sutherland裁剪算法、中点分割裁剪算法、Liang-Barskey裁剪算法</h4><ul><li>Cohen-Sutherland裁剪算法（编码裁剪算法）<ol type="1"><li>对线段端点编码，定义为它所在区域的编码;</li><li>快速判断“完全可见”，若两端点编码均为0，则完全可见。<strong>RC0=0且RC1=0</strong></li><li>快速判断“完全不可见”，线段两端点编码的逻辑位“与”运算结果非零，则完全不可见。<strong>RC0&amp;RC1≠0</strong>说明直线段位于窗外的同一侧</li><li>若2)、3)不满足，逐个端点判断其编码 CtCbCrCl(C3C2C1C0)中位是否为“1”，若是，则需求交，交点的x坐标进行排序，从而将原始线段分割成最多五段线段（四个交点）。然后根据（1）（2）步判断这些线段是否在区域内。</li></ol></li></ul><p><img src="https://s2.loli.net/2024/01/06/uleTRDy7MwWmnGI.png" alt="image-20240106215840646" style="zoom: 25%;" /></p><ul><li><p>中点分割裁剪算法</p><ul><li><p>采用Cohen-Sutherland算法判断可见性</p></li><li><p>固定 P1，测试 P2是否在窗口内，若是，则 P2 是离 P1点最远的可见点。否则，将线段 P1P2 对分，求出中点 Pm，编码判断线段 PmP2是否全部在窗口外，若是，则舍弃PmP2，用 P1Pm代替P1P2；若不是，则用PmP2代替P1P2。求得离P1最远的可见点Pm。</p></li><li><p>固定P2，再测 P1，</p></li></ul></li><li><p>Liang（<strong>梁友栋）</strong>-Barsky裁剪算法</p><ul><li>无论何种情况下，在裁剪区域之内的线段均为：AB ∩ RS ∩ TU</li></ul></li></ul><p><img src="https://s2.loli.net/2023/12/30/SE49AZKfWMmcTRj.png" alt="image-20231230144247813" style="zoom: 25%;" /></p><p>记<span class="math inline">\(L=\max \left[x_{\min }, \min\left(x_{A}, x_{B}\right)\right], R=\min \left[x_{\max }, \max\left(x_{A},x_{B}\right)\right]\)</span>，不等式若有不成立，则不存在可见线段，不等式为：<span class="math display">\[\left\{\begin{array}{l}L \leqslant R \\L \leqslant \max \left(x_{T}, x_{U}\right) \\\min \left(x_{T}, x_{U}\right) \leqslant R\end{array}\right.;\quad\text{斜率&gt;0时}\left\{\begin{array}{l}L \leqslant R \\L \leqslant x_{U} \\x_{T} \leqslant R\end{array}\right.;\quad\text{斜率&lt;0时}\left\{\begin{array}{l}L \leqslant R \\L \leqslant x_{T} \\x_{U} \leqslant R\end{array}\right.\]</span> A B 斜率大于 0 时，可见线段的端点坐标：<spanclass="math inline">\(\begin{array}{l} x_{\alpha}=\max \left(L,x_{T}\right) \\ x_{\beta}=\min \left(R, x_{U}\right)\end{array}\)</span></p><p>A B 斜率小于 0 时，可见线段的端点坐标：<spanclass="math inline">\(\begin{array}{l} x_{\alpha}=\max \left(L,x_{U}\right) \\ x_{\beta}=\min \left(R, x_{T}\right)\end{array}\)</span></p><h4 id="多边形裁剪算法sutherland-hodgman算法weiler-atherton算法">11.多边形裁剪算法：Sutherland-Hodgman算法，Weiler-Atherton算法</h4><ul><li>Sutherland-Hodgman算法<ul><li>裁剪<strong>凹多边形</strong>可能会出现多余的边</li></ul></li></ul><p><img src="https://s2.loli.net/2024/01/06/rwSGV3WHFTcxy1z.png" alt="image-20240106233155378" style="zoom: 33%;" /></p><ul><li><p>Weiler-Atherton算法</p><ul><li>将裁剪多边形称为CP，被裁剪多边形称为SP。</li><li>算法首先将CP和SP的顶点按照<strong>外部边界取顺时针</strong>，内部边界取逆时针的的方式将其构成环形链表。</li><li>求SP与CP的所有交点，并将这些交点插入到SP和CP的环形链表中，并<strong>标明</strong>交点是出点还是进点（进入CP）。</li><li>算法从任意一个<strong>进点开始</strong>沿着SP的边线按照边线所标示的方向搜集顶点序列，当遇到<strong>出点</strong>时，则<strong>沿着CP的边线</strong>所标示的方向搜集顶点序列，当遇到<strong>进点</strong>时，则<strong>沿着SP的边线</strong>所标示的方向搜集顶点序列。</li><li>搜索所有点。</li></ul><p><img src="https://s2.loli.net/2024/01/07/UXE7l39SjkPzV4y.png" alt="image-20240107175129445" style="zoom: 33%;" /></p></li></ul><h4 id="三维线段裁剪算法长方体裁剪算法视椎体裁剪算法">12.三维线段裁剪算法：长方体裁剪算法，视椎体裁剪算法</h4><ul><li><p>长方体裁剪算法（编码裁剪算法）</p><ul><li>采用6位二进制对不同区域进行<strong>编码</strong>，[前，后，上，下，右，左]</li><li>如果线段的两个端点的编码全部为0，则完全在长方体内部</li><li>同时位于长方体的一侧，则两端点编码对应位相与的结果必不为0，因此该线段完全不可见。</li><li>穿越立方体，则需要求交，然后将线段分割成几个部分，分别判断每一段线段是否可见。</li></ul><p><img src="https://s2.loli.net/2024/01/07/jNULnzQf29BxgHP.png" alt="image-20240107175302050" style="zoom: 50%;" /></p></li><li><p>视椎体裁剪</p><ul><li>计算每个平面方程。如果对应的方程的值&gt;0，表明在该平面之上……其他同长方体</li></ul></li></ul><h4id="图形消隐背面剔除算法画家算法weiler-atherton算法bsp树算法深度缓冲区算法warnock算法">13.图形消隐：背面剔除算法，画家算法，Weiler-Atherton算法，BSP树算法、深度缓冲区算法，Warnock算法</h4><ul><li><strong>背面剔除算法</strong><ol type="1"><li><p>计算多边形的法向向量N和视线向量V。</p></li><li><p>计算法向向量N和视线向量V的夹角θ的余弦Cosθ=N.V。</p></li><li><p>cosθ＜0，即θ＞90°， 则该多边形表面为背面，是不可见的</p></li></ol></li><li><strong>画家算法</strong><ul><li>将多边形按照离视点的远近进行排序（P221判断遮挡，分割），然后先画出被遮挡的多边形，再画出不被遮挡的多边形，用后画的多边形覆盖先画的多边形，从而达到自动消隐的目的。</li></ul></li><li><strong>Weiler-Atherton算法</strong>：采用裁剪算法的思想对隐藏面进行消隐。<ol type="1"><li>先进行初步的深度预排序，即将变换到屏幕坐标系中的景物表面多边形按各顶点的z 最小值进行排序，形成景物多边形表。</li><li>以当前具有最大 z 值（即离视点最近）的景物表面作为裁剪多边形 CP。</li><li>用CP对景物多边形表中排在后面的景物表面进行裁剪，产生内部多边形 Pin和外部多边形 Pout 。</li><li>由于多边形顶点离视点最近的多边形表面不一定是真正排在最前面的可见面，因此，需比较CP与内部多边形Pin 的深度，检查 CP是否是真正离视点较近的多边形。如果是，则CP为可见表面，而位于裁剪多边形 CP之内的多边形 Pin为当前视点的隐藏面，可以消去该隐藏面；如果不是，则选择 Pin为新的裁剪多边形，重复步骤 3。</li><li>将位于裁剪多边形之外的景物表面 Pout组成外裁剪结果多边形表，取表中深度最大即排在最前面的表面为裁剪多边形，重复步骤3，继续对表中其他景物表面进行裁剪。</li><li>上述过程递归进行，直到外裁剪结果多边形表为空时为止</li></ol></li><li><strong>BSP树算法</strong>：平面分割二叉树<ul><li>先在场景中选取一剖分平面P1（与视点垂直的平面），将场景空间分割成两个半空间。它相应地把场景中的景物分成两组，相对于视点而言，一组景物多边形位于P1的前面，作为BSP树的左孩子（front)，另一组景物多边形位于P1的后面,作为BSP树的右孩子（Back)，如果有物体与P1相交，就将它分割为两个物体分别标识为A和B，再用平面 P2对所生成的两个子空间继续进行分割，并对每一子空间所含景物进行分类。上述空间剖分和景物分类过程递归进行，直至每一子空间中所含景物少于给定的阈值为止。</li><li>优先绘制标识为“back”的子空间中所含的景物，这样可使得前面的物体覆盖后面的物体，从而实现物体的消隐。</li></ul></li><li><strong>深度缓冲区算法</strong>：对投影到显示屏上的每一个像素所对应的多边形表面的深度进行比较，然后取最近表面的属性值作为该像素的属性值。深度缓冲器只是帧缓冲器的扩充。<ol type="1"><li>将场景中的所有多边形通过取景变换、透视变换变换到屏幕坐标系中，物体的深度比较可通过它们z值的比较来实现。</li><li>初始化深度缓冲存储器和帧缓冲器。深度缓冲器应初始化为离视点最远的最大z值，帧缓冲器应初始化为背景的属性值。</li><li>扫描待显示的每一个多边形，比较当前多边形所覆盖的每一个像素点的深度值，如果其深度值比深度缓冲区中当前像素的深度值小，则取代原来的深度值，并将对应像素的属性值保存到帧缓冲区对应的位置中。反之，则不做任何处理。循环该步骤，直到处理完所有的多边形。</li></ol></li><li><strong>Warnock算法</strong>：将非单纯的窗口四等分为4个子窗口（四叉树），对每个子窗口再进一步判别是否是单纯的，直到窗口单纯或窗口边长已缩减至一个像素点为止。<ol type="1"><li>对每个窗口进行判断，若画面中所有多边形均与此窗口分离，即此窗口为空，则按背景光强或颜色直接显示而无需继续分割。</li><li>若窗口中仅包含一个多边形，则窗口内多边形外的区域按背景光强或颜色填充，多边形内按多边形相应的光强或颜色填充。</li><li>若窗口与一个多边形相交，则窗口内多边形外的区域按背景光强或颜色填充，相交多边形内位于窗口内的部分按多边形相应的光强或颜色填充。</li><li>若窗口被一个多边形包围且窗口内无其他的多边形，则窗口按此包围多边形相应的光强或颜色填充。</li><li>若窗口至少被一个多边形包围且此多边形距离视点最近，则窗口按此离视点最近的包围多边形的相应光强或颜色填充。</li><li>若以上条件都不满足，则继续细分窗口，并重复以上测试。</li></ol></li></ul><h4id="曲面的生成bezier曲面的生成b样条曲面的生成特别是二阶和三阶曲面">14.曲面的生成：Bezier曲面的生成，B样条曲面的生成，特别是二阶和三阶曲面</h4><p>二阶Bezier曲面 <span class="math display">\[P(u,v)=\sum_{i=0}^2\sum_{j=0}^2P_{ij}BEZ_{i,2}(u)BEZ_{j,2}(v)\quadu\in[0,1],v\in[0,1]\]</span> 三阶Bezier曲面 <span class="math display">\[P(u,v)=\sum_{i=0}^3\sum_{j=0}^3P_{ij}BEZ_{i,3}(u)BEZ_{j,3}(v)\quadu\in[0,1],v\in[0,1]\\=\begin{bmatrix}BEZ_{0,3}(u)&amp;BEZ_{1,3}(u)&amp;BEZ_{2,3}(u)&amp;BEZ_{3,3}(u)\end{bmatrix}\begin{bmatrix}P_{00}&amp;P_{01}&amp;P_{02}&amp;P_{03}\\P_{10}&amp;P_{11}&amp;P_{12}&amp;P_{13}\\P_{20}&amp;P_{21}&amp;P_{22}&amp;P_{23}\\P_{30}&amp;P_{31}&amp;P_{32}&amp;P_{33}\end{bmatrix}\begin{bmatrix}BEZ_{0,3}(v)\\BEZ_{1,3}(v)\\BEZ_{2,3}(v)\\BEZ_{3,3}(v)\end{bmatrix}\\=[(1-u)^3\quad3u(1-u)^2\quad3u^2(1-u)\quadu^3]\begin{bmatrix}P_{00}&amp;P_{01}&amp;P_{02}&amp;P_{03}\\P_{10}&amp;P_{11}&amp;P_{12}&amp;P_{13}\\P_{20}&amp;P_{21}&amp;P_{22}&amp;P_{23}\\P_{30}&amp;P_{31}&amp;P_{32}&amp;P_{33}\end{bmatrix}\begin{bmatrix}(1-\nu)^3\\3\nu(1-\nu)^2\\3\nu^2(1-\nu)\\\nu^3\end{bmatrix}\\\begin{aligned}=[1\quad u\quad u^2\quadu^3]\boldsymbol{N}\begin{bmatrix}\boldsymbol{P}_{00}&amp;\boldsymbol{P}_{01}&amp;\boldsymbol{P}_{02}&amp;\boldsymbol{P}_{03}\\\boldsymbol{P}_{10}&amp;\boldsymbol{P}_{11}&amp;\boldsymbol{P}_{12}&amp;\boldsymbol{P}_{13}\\\boldsymbol{P}_{20}&amp;\boldsymbol{P}_{21}&amp;\boldsymbol{P}_{22}&amp;\boldsymbol{P}_{23}\\\boldsymbol{P}_{30}&amp;\boldsymbol{P}_{31}&amp;\boldsymbol{P}_{32}&amp;\boldsymbol{P}_{33}\end{bmatrix}\boldsymbol{N}^\intercal\begin{bmatrix}1\\v\\v^2\\v^3\end{bmatrix}\quad\text{其中:}\quad\boldsymbol{N}=\begin{bmatrix}1&amp;-3&amp;3&amp;-1\\0&amp;3&amp;-6&amp;3\\0&amp;0&amp;3&amp;-3\\0&amp;0&amp;0&amp;1\end{bmatrix},\end{aligned}\]</span> 二阶B样条曲面 <span class="math display">\[P(u,\nu)=\sum_{i=0}^m\sum_{j=0}^nP_{ij}B_{i,k}(u)B_{j,h}(\nu)\quadu\in[0,1],\nu\in[0,1]\]</span> 三阶B样条曲面 <span class="math display">\[\begin{aligned}P(u,\nu)&amp;=\begin{bmatrix}B_{0,3}(u)&amp;B_{1,3}(u)&amp;B_{2,3}(u)&amp;B_{3,3}(u)\end{bmatrix}\begin{bmatrix}P_{00}&amp;P_{01}&amp;P_{02}&amp;P_{03}\\P_{10}&amp;P_{11}&amp;P_{12}&amp;P_{13}\\P_{20}&amp;P_{21}&amp;P_{22}&amp;P_{23}\\P_{30}&amp;P_{31}&amp;P_{32}&amp;P_{31}\end{bmatrix}\begin{bmatrix}B_{0,3}(v)\\B_{1,3}(v)\\B_{2,3}(v)\\B_{3,3}(v)\end{bmatrix}\\&amp;=\begin{bmatrix}1&amp;u&amp;u^2&amp;u^3\end{bmatrix}N\begin{bmatrix}P_{00}&amp;P_{01}&amp;P_{02}&amp;P_{03}\\P_{10}&amp;P_{11}&amp;P_{12}&amp;P_{13}\\P_{20}&amp;P_{21}&amp;P_{22}&amp;P_{23}\\P_{30}&amp;P_{11}&amp;P_{32}&amp;P_{33}\end{bmatrix}N^{\intercal}\begin{bmatrix}1\\v\\v\\v^2\\v^3\end{bmatrix},N=\frac16\begin{bmatrix}1&amp;4&amp;1&amp;0\\-3&amp;0&amp;3&amp;0\\3&amp;-6&amp;3&amp;0\\-1&amp;3&amp;-3&amp;1\end{bmatrix}\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}&amp;B_{0,3}(u)=\frac16(-u^3+3u^2-3u+1), &amp;B_{0,3}(\nu) &amp;=\frac16(-\nu^3+3\nu^2-3\nu+1)  \\&amp;B_{1,3}(u)=\frac16(3u^3-6u^2+4)\text{,}  &amp;B_{1,3}(\nu)&amp;=  \frac16(3\nu^3-6\nu^2+4)  \\&amp;B_{2,3}(u)=\frac16(-3u^3+3u^2+3u+1),&amp;B_{2,3}(\nu)&amp;=\frac16(-3\nu^3+3\nu^2+3\nu+1)  \\&amp;B_{3,3}(u)= \frac16\boldsymbol{u}^3,  &amp;B_{3,3}(\nu)&amp;=\begin{aligned}\frac{1}{6}\nu^3\end{aligned}\end{aligned}\]</span></p><h4 id="地形的生成算法">15. 地形的生成算法</h4><ul><li>Diamond-Square算法<ol type="1"><li>给定一个四边形,四个顶点的坐标(包含高度)，定义一初始高度因子h和一缩放倍数b。</li><li>迭代，先求出四边形的中心点高度为顶点平均高度+h*r的随机数，再分别求出4个边的中点，高度为两端点高度的平均值+h*r</li><li>修正高度因子 h=h/b，用(2)的方法分别对这 4个小正方形进行处理。直到达到所期望的山形细腻程度。</li></ol></li></ul><h4 id="雨雪的模拟算法">16. 雨雪的模拟算法</h4><ul><li>生成一定数量的初始粒子，对其各个属性进行赋值。</li><li>更新粒子的运动参数，比如速度，加速度，位置，生命周期等。<br /></li><li>针对每一个粒子，在粒子对应的位置上绘制位图，并进行位移的映射，背景融合等。</li><li>删除已经消亡的粒子，释放其占用的资源。</li></ul><p><span class="math display">\[\begin{cases}\nu_x=\nu_x+\Delta t\cdot f/m\\\nu_y=\nu_y+\Deltat\cdot\left(g+f/m\right)\\\nu_z=\nu_z+\Delta t\cdot f/m&amp;\end{cases},\begin{cases}P_x=P_x+\nu_x\cdot\Delta t\\P_y=P_y+\nu_y\cdot\Deltat\\P_z=P_z+\nu_z\cdot\Delta t&amp;\end{cases}\]</span></p><h2 id="代码">代码</h2><h3 id="dda画直线">DDA画直线</h3><figure><img src="https://s2.loli.net/2024/01/07/lHerkjFw8hKLfJD.png"alt="CG--10-06_02-42-53" /><figcaption aria-hidden="true">CG--10-06_02-42-53</figcaption></figure><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Line_DDA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color color)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 计算delta_x, delta_y, 确定steps，并计算dx, dy</span>    <span class="hljs-keyword">int</span> delta_x = x1 - x0, delta_y = y1 - y0,        steps = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(delta_x), <span class="hljs-built_in">abs</span>(delta_y));    <span class="hljs-keyword">double</span> x = x0, y = y0,           dx = (<span class="hljs-keyword">double</span>)delta_x / steps, dy = (<span class="hljs-keyword">double</span>)delta_y / steps;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= steps + <span class="hljs-number">1</span>; i++)    &#123;        <span class="hljs-built_in">putpixel</span>((<span class="hljs-keyword">int</span>)(x + <span class="hljs-number">0.5</span>), (<span class="hljs-keyword">int</span>)(y + <span class="hljs-number">0.5</span>), color); <span class="hljs-comment">// 四舍五入生成像素点</span>        x += dx, y += dy;    &#125;&#125;</code></pre></div><h3 id="中点画线法-1">中点画线法</h3><figure><img src="https://s2.loli.net/2024/01/07/O9P2JCvAeByUmKj.png"alt="CG--10-06_02-43-03" /><figcaption aria-hidden="true">CG--10-06_02-43-03</figcaption></figure><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Line_Midpoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color color)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (x0 &gt; x1) <span class="hljs-comment">// 保证x0 &lt;= x1</span>        <span class="hljs-built_in">swap</span>(x0, x1), <span class="hljs-built_in">swap</span>(y0, y1);    <span class="hljs-keyword">int</span> a = y0 - y1, b = x1 - x0,   <span class="hljs-comment">// 直线L的参数（c因为没有用到不用计算）</span>        d,                          <span class="hljs-comment">// 决策变量d</span>        dd_L, dd_G,                 <span class="hljs-comment">// 决策变量d的增量(L代表小于0的情况，G代表大于0的情况)</span>        x = x0, y = y0,             <span class="hljs-comment">// 初始P坐标</span>        dPx_L, dPy_L, dPx_G, dPy_G; <span class="hljs-comment">// P坐标的增量(L代表小于0的情况，G代表大于0的情况)</span>    <span class="hljs-comment">// 根据k值分情况生成决策变量和增量</span>    <span class="hljs-keyword">if</span> (-b &lt;= a &amp;&amp; a &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// k ∈ [0, 1]</span>    &#123;        d = <span class="hljs-number">2</span> * a + b;                            <span class="hljs-comment">// d0 = 2a + b</span>        dPx_L = <span class="hljs-number">1</span>, dPy_L = <span class="hljs-number">1</span>, dd_L = <span class="hljs-number">2</span> * (a + b); <span class="hljs-comment">// d &lt; 0情况</span>        dPx_G = <span class="hljs-number">1</span>, dPy_G = <span class="hljs-number">0</span>, dd_G = <span class="hljs-number">2</span> * a;       <span class="hljs-comment">// d &gt;= 0 情况</span>    &#125;    <span class="hljs-comment">// 其他斜率情况略</span>    <span class="hljs-comment">// 迭代生成直线</span>    <span class="hljs-keyword">while</span> (x != x1 || y != y1)    &#123;        <span class="hljs-built_in">putpixel</span>(x, y, color);        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>)            x += dPx_L, y += dPy_L, d += dd_L;        <span class="hljs-keyword">else</span>            x += dPx_G, y += dPy_G, d += dd_G;    &#125;    <span class="hljs-built_in">putpixel</span>(x, y, color);&#125;</code></pre></div><h3 id="bresenham-画线法">Bresenham 画线法</h3><figure><img src="https://s2.loli.net/2024/01/07/b8odh1OEkGt3wZX.png"alt="CG--10-06_02-43-08" /><figcaption aria-hidden="true">CG--10-06_02-43-08</figcaption></figure><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Line_Bresenham</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color color)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (x0 &gt; x1) <span class="hljs-comment">// 保证x0 &lt;= x1</span>        <span class="hljs-built_in">swap</span>(x0, x1), <span class="hljs-built_in">swap</span>(y0, y1);    <span class="hljs-keyword">int</span> Delta_x = x1 - x0, Delta_y = y1 - y0,        d,                          <span class="hljs-comment">// 决策变量d</span>        dd_L, dd_G,                 <span class="hljs-comment">// 决策变量d的增量(L代表小于0的情况，G代表大于0的情况)</span>        x = x0, y = y0,             <span class="hljs-comment">// 初始P坐标</span>        dPx_L, dPy_L, dPx_G, dPy_G; <span class="hljs-comment">// P坐标的增量(L代表小于0的情况，G代表大于0的情况)</span>    <span class="hljs-comment">// 根据k值分情况生成决策变量和增量</span>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt;= Delta_y &amp;&amp; Delta_y &lt;= Delta_x) <span class="hljs-comment">// k ∈ [0, 1]</span>    &#123;        d = <span class="hljs-number">2</span> * Delta_y - Delta_x;                            <span class="hljs-comment">// d0 = 2Δy - Δx</span>        dPx_L = <span class="hljs-number">1</span>, dPy_L = <span class="hljs-number">0</span>, dd_L = <span class="hljs-number">2</span> * Delta_y;             <span class="hljs-comment">// d &lt; 0情况</span>        dPx_G = <span class="hljs-number">1</span>, dPy_G = <span class="hljs-number">1</span>, dd_G = <span class="hljs-number">2</span> * (Delta_y - Delta_x); <span class="hljs-comment">// d &gt;= 0 情况</span>    &#125;    <span class="hljs-comment">// 其他斜率情况略</span>    <span class="hljs-comment">// 迭代生成直线</span>    <span class="hljs-keyword">while</span> (x != x1 || y != y1)    &#123;        <span class="hljs-built_in">putpixel</span>(x, y, color);        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>)            x += dPx_L, y += dPy_L, d += dd_L;        <span class="hljs-keyword">else</span>            x += dPx_G, y += dPy_G, d += dd_G;    &#125;    <span class="hljs-built_in">putpixel</span>(x, y, color);&#125;</code></pre></div><h3 id="中点画圆法">中点画圆法</h3><figure><img src="https://s2.loli.net/2024/01/07/iLHvQzCr4nsbJDk.png"alt="CG--10-06_02-43-19" /><figcaption aria-hidden="true">CG--10-06_02-43-19</figcaption></figure><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawCirclePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xc, <span class="hljs-keyword">int</span> yc, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, Color color)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">putpixel</span>(xc + x, yc + y, color);    <span class="hljs-built_in">putpixel</span>(xc + y, yc + x, color);    <span class="hljs-built_in">putpixel</span>(xc - x, yc + y, color);    <span class="hljs-built_in">putpixel</span>(xc + y, yc - x, color);    <span class="hljs-built_in">putpixel</span>(xc + x, yc - y, color);    <span class="hljs-built_in">putpixel</span>(xc - y, yc + x, color);    <span class="hljs-built_in">putpixel</span>(xc - x, yc - y, color);    <span class="hljs-built_in">putpixel</span>(xc - y, yc - x, color);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Circle_Midpoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xc, <span class="hljs-keyword">int</span> yc, <span class="hljs-keyword">int</span> R, Color color)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = R, <span class="hljs-comment">// 初始P坐标</span>        d = <span class="hljs-number">1</span> - R;    <span class="hljs-comment">// 决策变量d</span>    <span class="hljs-keyword">while</span> (x &lt; y)    &#123;        <span class="hljs-built_in">DrawCirclePoints</span>(xc, yc, x, y, color);        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>)            d += <span class="hljs-number">2</span> * x + <span class="hljs-number">3</span>, x++;        <span class="hljs-keyword">else</span>            d += <span class="hljs-number">2</span> * (x - y) + <span class="hljs-number">5</span>, x++, y--;    &#125;    <span class="hljs-built_in">DrawCirclePoints</span>(xc, yc, x, y, color);&#125;</code></pre></div><h3 id="bresenham-画圆法">Bresenham 画圆法</h3><figure><img src="https://s2.loli.net/2024/01/07/nPpvQtHSJVwU2Tk.png"alt="CG--10-06_02-43-28" /><figcaption aria-hidden="true">CG--10-06_02-43-28</figcaption></figure><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// DrawCirclePoints()函数已在中点画圆法给出，这里不再给出</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Circle_Bresenham</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xc, <span class="hljs-keyword">int</span> yc, <span class="hljs-keyword">int</span> R, COLORREF color)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = R,  <span class="hljs-comment">// 初始P坐标</span>        d = <span class="hljs-number">2</span> - <span class="hljs-number">2</span> * R; <span class="hljs-comment">// 决策变量d</span>    <span class="hljs-keyword">while</span> (x &lt; y)    &#123;        <span class="hljs-built_in">DrawCirclePoints</span>(xc, yc, x, y, color);        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">2</span> * (d + y) - <span class="hljs-number">1</span> &lt;= <span class="hljs-number">0</span>)            d += <span class="hljs-number">2</span> * x + <span class="hljs-number">3</span>, x++;        <span class="hljs-keyword">else</span>            d += <span class="hljs-number">2</span> * (x - y + <span class="hljs-number">3</span>), x++, y--;    &#125;    <span class="hljs-built_in">DrawCirclePoints</span>(xc, yc, x, y, color);&#125;</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发技术 - 期末复习</title>
      <link href="/2023/12/28/49/"/>
      <url>/2023/12/28/49/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="java开发技术复习">Java开发技术复习</h1><h2 id="java语言基础-1-2">Java语言基础 1-2</h2><ul><li><p>标识符以字母、下划线(_)或者**美元符号(<spanclass="math inline">\()**开头，字母、数字、下划线(_)以及美元符号(\)</span>)组成</p></li><li><p>长整型是<code>long</code>(64位)、<code>char</code>是16位、<code>boolean</code>是1位</p></li><li><p>整型常量的后缀字母：l(L)，表示<code>long</code>型,64bits</p></li><li><p>实型常量的后缀字母：f(F), d(D)</p></li><li><p>字符串连接运算时，如果一个操作数为字符串，一个操作数为数值型，则会自动将数值型转换为字符串(塑型)</p></li><li><p><code>String substring(int k)</code>从位置k处提取子串到串结束</p><p><code>String substring(int start, int end)</code>从位置start到end提取子串</p><p><code>int compareTo(String t)</code> 本串&lt;串t,返回负数；本串&gt;串t, 返回正数；本串=串t, 返回0</p><p><code>char charAt(int k)</code>返回<code>String</code>串第<em>k</em>个字符(<em>k</em>从0开始)</p></li><li><p><code>int</code> - <code>Integer</code>, <code>char</code> -<code>Character</code></p></li><li><p><code>valueOf()</code><strong>静态方法</strong>，用于返回给定参数的原生 Number对象值，参数可以是基本数据类型, String等。</p></li><li><p>用<strong><code>Scanner</code></strong>类实现数据输入</p><figure><img src="https://s2.loli.net/2023/12/24/mMRItxWVFleHa6N.png"alt="image-20231224222156195" /><figcaption aria-hidden="true">image-20231224222156195</figcaption></figure></li><li><p><code>System.out.print(字符串)</code> 输出串不换行</p><p><code>System.out.println(字符串)</code> 输出串并换行,<code>println</code>的ln是line的意思</p><p><code>System.out.printf(格式串,表达式列表)</code></p><figure><img src="https://s2.loli.net/2023/12/24/jKT4ZypieSOu5fN.png"alt="image-20231224222639445" /><figcaption aria-hidden="true">image-20231224222639445</figcaption></figure></li><li><p>Java数组作函数参数时为引用型参数传递；其它参数传递情况都是传值。</p></li><li><p><code>int[] a 和</code>int a[]都是合法的，可以作为声明数组或函数的形参。</p></li></ul><h2 id="面向对象编程-1-3">面向对象编程 1-3</h2><ul><li><p>Java会给成员变量一个初始值；Java不会给局部变量赋予初始值，如果在类声明中没有给实例变量赋初值，则对象的属性值为零或空</p></li><li><p>Java不支持默认的参数值</p></li><li><p>类的访问控制只有public（公共类）及无修饰符（缺省类）两种</p><table><thead><tr class="header"><th>类型</th><th>无修饰</th><th>public</th></tr></thead><tbody><tr class="odd"><td><strong>同一包中的类</strong></td><td><strong>yes</strong></td><td><strong>yes</strong></td></tr><tr class="even"><td><strong>不同包中的类</strong></td><td><strong>no</strong></td><td><strong>yes</strong></td></tr></tbody></table><table><thead><tr class="header"><th>类型</th><th>private</th><th>无修饰</th><th>protected</th><th>public</th></tr></thead><tbody><tr class="odd"><td>同一类</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr class="even"><td>同一包中的 子类</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr><tr class="odd"><td>同一包中的 非子类</td><td>no</td><td>yes</td><td><strong>yes</strong></td><td>yes</td></tr><tr class="even"><td>不同包中的 子类</td><td>no</td><td>no</td><td>yes</td><td>yes</td></tr><tr class="odd"><td>不同包中的 非子类</td><td>no</td><td>no</td><td>no</td><td>yes</td></tr></tbody></table></li><li><p>如果在一个类中不存在无参的构造方法，则要求其子类声明时必须声明构造方法，否则在子类对象的初始化时会出错</p></li><li><p>[public] [abstract|final] class 类名[<strong>extends</strong>父类名] | [<strong>implements </strong>接口名]</p></li><li><p>只支持类的单继承，每个子类只能有一个直接父类</p></li><li><p>在 Java 中，如果子类的构造函数中没有显式调用<code>super(...)</code> 或者调用另一个构造函数（使用<code>this(...)</code>），那么会隐式调用父类的默认（无参）构造函数（如果父类有默认构造函数）</p></li><li><p><code>super()</code> 或 <code>this()</code>必须作为构造函数的第一条语句，这是由于对象的初始化顺序，确保在子类构造过程中首先完成父类的初始化或本类其他构造方法的调用。</p></li><li><p><code>this()</code>关键字用于在构造函数中调用同一类的其他构造函数（重载）</p></li><li><p>抽象方法定义：<code>abstract double getArea();</code></p></li><li><p>继承改写已有的属性和方法方法：隐藏，<code>super.value</code>访问父类被隐藏的的变量和方法</p></li><li><p>父类不能直接访问子类的变量和方法，因为继承是单向的。但是父类并不知道它的子类的存在。当子类执行继承自父类的操作时，处理的是继承自父类的变量，而当子类执行它自己声明的方法时，所操作的就是它自己声明的变量。</p></li><li><p><code>static</code>静态方法是与类本身相关联的，而不是与类的实例相关联的。因此，它们不涉及多态性和动态绑定，所以不能被覆盖。</p></li><li><p><code>final</code> 修饰的变量表示该变量的值不能被修改。</p></li><li><p>类本身并不能被声明为<code>static</code>，可以创建静态内部类。</p></li><li><p>接口的数据成员一定要赋初值，且此值将不能再更改，允许省略final关键字；接口中的字段默认是 <code>public</code>、<code>static</code> 和<code>final</code> 的；接口中的方法必须是“抽象方法”，不能有方法体，允许省略public及abstract关键字。</p></li><li><p><code>abstract</code> 和 <code>static</code>两个修饰符是互斥的</p></li><li><p>接口可通过扩展<code>extends</code>的技术派生出新的接口</p></li><li><p>塑型(类型转换):当一个类对象被塑型为其父类后，它提供的方法会减少</p></li><li><p><strong>多态</strong>：所有的对象都可被塑型为相同的类型，响应相同的消息。</p><ul><li>向上塑型技术：一个父类的引用变量可以指向不同的子类对象</li><li>动态绑定技术：运行时根据父类引用变量所指对</li><li>象的实际类型执行相应的子类方法，从而实现多态性</li></ul></li></ul><h2 id="异常">异常</h2><ul><li><p>try-catch-finally（无论是否发生异常，代码总执行）throws-声明异常throw-抛出异常</p></li><li><p>用户自定义处理信息：<code>System.err.println("出现错误”)</code></p></li><li><p>调用方法输出异常信息：<strong><code>e.printStackTrace();</code></strong></p></li><li><table><colgroup><col style="width: 44%" /><col style="width: 55%" /></colgroup><thead><tr class="header"><th>异 常 类 型</th><th>说 明</th></tr></thead><tbody><tr class="odd"><td>Exception</td><td>异常层次结构的父类</td></tr><tr class="even"><td>ArithmeticException</td><td>算术错误情形，如以零作除数</td></tr><tr class="odd"><td>ArrayIndexOutOfBoundsException</td><td>数组下标越界</td></tr><tr class="even"><td>NullPointerException</td><td>尝试访问 null 对象成员</td></tr><tr class="odd"><td>ClassNotFoundException</td><td>不能加载所需的类</td></tr><tr class="even"><td>IllegalArgumentException</td><td>方法接收到非法参数</td></tr><tr class="odd"><td>ClassCastException</td><td>对象强制类型转换出错</td></tr><tr class="even"><td>NumberFormatException</td><td>数字格式转换异常，如把"abc"转换成数字</td></tr></tbody></table></li><li><p>try块或catch块有return，返回前也会执行finally块，唯一不执行finally块是System.exit()退出</p></li><li><p>多catch：只执行第一个与异常类型匹配的catch语句</p></li><li><p>使用 <code>throws</code>关键字对外声明该方法有可能发生异常，如果没处理会报错“未处理异常类型异常”。<code>void myMethod() throws SomeException &#123; /*方法体*/ &#125;</code></p></li><li><p>手动抛出异常 throw new Exception(“说明");</p></li><li><p>使用log4j记录日志</p></li></ul><h2 id="字符串">字符串</h2><ul><li>字符串是常量final类，值不可改。replace等函数将引用s指向了一个新的String对象</li><li>String的长度是不可变，StringBuffer长度可变，所以当进行大量的字符串连接操作时用StringBuffer</li><li>public String(charl] value, int offset, int count) , value -作为字符源的数组 offset -初始偏移量 count - 长度</li></ul><p><img src="https://s2.loli.net/2023/12/25/9NkHdIcfWqTjxv8.png" alt="image-20231225120535157" style="zoom:50%;" /></p><ul><li><p>使用 <code>==</code> 运算符比较两个 <code>String</code>对象时，它会比较两个对象的引用是否指向相同的内存地址，而不是比较字符串的内容。要用str1.equals(str2)</p></li><li><p>equalsIgnoreCase()，toLowerCase()， toUpperCase( )</p></li><li><p>index0f(String str, int fromIndex), lastIndex0f(String str, intfromindex) , 注意lastIndex0f是反向搜索</p></li><li><p>substring(int index)提取从位置索引开始的字符串部分， ingsubstring(int beginindex, int endindex)</p></li><li><p>trim()方法，用于去除字符串两端的空白字符（空格、制表符、换行符等），返回一个新的字符串</p></li><li><p>split(strings)方法，将一个字符串分割为子字符串，结果作为字符串数组返回</p></li><li><p>StringBuffer的使用：sb.append("c"); 追加字符串sb.insert(index,"c"); //插入字符串</p></li><li><p>String类提供了大量的操作字符串的方法</p><ul><li>获得字符串的长度：length()</li><li>比较字符串：equals()</li><li>连接字符串：concat()</li><li>提取字符串：substring()</li><li>搜索字符串：indexOf()</li><li>拆分字符串：split()</li></ul></li><li><p>常用的StringBuffer类提供的方法</p><ul><li><p>转换成String类型：toString()</p></li><li><p>连接字符串：append()</p></li><li><p>插入字符串：insert()</p></li></ul></li></ul><h2 id="applet">Applet</h2><ul><li><p>init()方法是Applet首先执行的方法</p></li><li><p>小应用程序都继承自<strong>java.applet.Applet</strong>类，必须是public类</p></li><li><p>生命周期</p><p>1.打开浏览器时，创建(<strong>init</strong>)方法运行；整个生命周期只被执行一次</p><p>2.显示Applet时，启动(<strong>start</strong>)方法运行；运行或从其它页面返回时调用</p><ul><li>public void paint(Graphics g)<strong>输出文本，绘制图像，输出图像，声音等</strong>，start()后被执行</li></ul><p>3.不显示Applet时，停止(<strong>stop</strong>)方法运行；离开Applet所在页面时</p><p>4.关闭浏览器时，撤销(<strong>destroy</strong>)方法运行；关闭浏览器，运行时浏览器被关闭，系统将先执行stop()方法，再执行destroy()方法</p></li><li><p>任何与绘图有关的操作第一个要用的是java.awt.Graphics类，Graphics类的对象不是由new产生的,而是由系统或其他方式直接将生成好的</p></li><li><p>坐标原点在左上角，X轴向右，Y轴向下</p></li><li><p>public abstract void <strong>drawString</strong>(String) str, intx, int y)</p><p>使用此图形上下文的当前字体和颜色绘制由指定 string给定的文本。最左侧字符的基线位于此图形上下文坐标系的 (<em>x</em>,<em>y</em>) 位置处。</p></li><li><p>public abstract void <strong>fillRect</strong>(int x, int y, intwidth, int height)</p><p>填充指定的矩形。该矩形左边缘和右边缘分别位于 x 和 x + width -1。上边缘和下边缘分别位于 y 和 y + height - 1。得到的矩形覆盖 width像素宽乘以 height 像素高的区域</p></li><li><p>Color c = new Color(0,255,0) //Color(int r，int g，int b);Color(int rgb);</p><p>g.setColor(c); g.setColor(Color.red);</p></li><li><p>0-正常-PLAIN； 1-粗体-BOLD；2-斜体-ITALIC</p></li><li><p>g.setFont(new Font("隶书", Font.BOLD, 28));</p></li><li><p><strong>Graphics</strong>拥有的绘图方法</p><p>drawLine(int,int,int,int) 画直线。起点坐标，终点坐标</p><p>drawRect(int,int,int,int) 画矩形。左角坐标，宽，高</p><p>fillRect(int,int,int,int) 用前景颜色填充矩形。</p><p>drawRoundRect(int,int,int,int,int,int)画圆角矩形。左角坐标，X宽，Y高，深度X，深度Y</p><p>draw3DRect(int,int,int,int,boolean)画3D矩形。左角坐标，宽X，高Y，true</p><p>drawOval(int,int,int,int) 画椭圆。中心坐标，长轴，短轴</p><p>drawArc(int,int,int,int,int,int)画弧。左角坐标，宽，高，起始角，终止角</p><p>drawPolyline(int[],int[],int) 画折线。各点的X坐标，Y坐标，折线数</p><p>drawPolygon(int[],int[],int) 画多角形。各点的X坐标，Y坐标，边数</p><p>drawPolygon(Polygon) 画多角形。定义好的多角形对象</p></li><li><p>返回Applet类文件所在网页的网络路径:<code>public URL getDocumentBase()</code></p></li><li><p>载入图片:<code>public Image getImage(URL url, String name) name</code>可以为路径下的图片</p><p>testImage = getImage(getDocumentBase(),"flag.gif");</p><p>g.drawImage(testImage,0,0,this);</p></li><li><p>载入声音:</p><p>public AudioClip getAudioClip(URL url, String name)</p><p>getAudioClip(getDocumentBase(),"tiger.au").play();</p></li><li><p>Applet被设计为从远程站点下载然后在本地执行,游览器中启用了Java，那么浏览器就会自动下载网页中的Applet代码并执行。</p></li><li><p>Applet的限制执行环境常常称作<strong>sandbox</strong>。<strong>不能读写</strong>本地计算机的文件，<strong>不能运行</strong>任何本地可执行程序；除与下载处它的服务器Applet<strong>不能同的其他任何主机通信</strong>；只能获取Java版本操作系统的名字和版本、用来分离文件、路径以及行的字符，不能获取任何其它关于本地计算机的信息。</p></li></ul><h2 id="gui-1-2">GUI 1-2</h2><h3 id="了解awt和swing">了解AWT和Swing</h3><ul><li><p>AWT（Abstract WindowToolkit）是在Swing出现之前用来设计界面的工具包</p><p>用awt包中的类创建的用户界面在不同的操作平台上有不同的表现。使用不灵活</p><p>import java.awt.*;</p></li><li><p>Swing是对AWT的扩展，它是Java 2中的一个标准包</p><p>组件都以J开头，例如：JFrame、JButton等。swing界面在不同的平台上外观完全一样，真正做到平台独立</p><p>import javax.swing.*;</p></li></ul><h3id="熟悉4个顶层容器和常用的中间容器">熟悉4个顶层容器和常用的中间容器</h3><ul><li><p>顶层容器</p><ul><li><p><strong>JFrame</strong>用来创建application，最常用的</p><p>JApplet用来创建applet</p><p>JDialog用来创建对话框，常用</p><p>JWindow不常用</p></li></ul></li><li><p>中间容器</p><ul><li><p><strong>JPanel</strong>提供一个面板</p><p><strong>JScrollPane</strong>是具有滚动条的窗格</p><p><strong>JSplitPane</strong>是具有拆分功能的窗格</p><p>JTabbedPane是带有若干标签的分类窗格</p><p>JInternalFrame用于创建内嵌于JFrame中的内部框架</p><p><strong>Box </strong>提供创建横向/纵向盒子容器的功能</p></li></ul></li><li><p>基本组件</p></li></ul><h3 id="掌握jframe">掌握JFrame</h3><ul><li>构造方法<ul><li>JFrame() 创建无标题窗口。</li><li>JFrame(String s) 创建标题名字是字符串s的窗口。</li></ul></li><li>常用方法<ul><li>getContentPane() JFrame不是一个容器而是一个框架，可以通过getContentPane()方法得到JFrame的contentpane</li><li>setTitle(String title) 设置JFrame标题文本</li><li>get/setSize()：获取/设置JFrame的大小。</li><li>add(Object a)：将组件添加到JFrame中。</li><li>dispose()关闭JFrame并回收用于创建窗口的任何资源。</li><li>setVisible(boolean b)设置JFrame的可见性。</li><li>setLocation(x,y) 设置JFrame在屏幕的位置</li><li>void setExtendedState(int); 设置扩展的状态</li><li>void setDefaultCloseOperation(int); 设置默认的关闭时的操作</li><li>setIconImage(image); 设置JFrame的图标</li></ul></li></ul><h3 id="基本组件">基本组件</h3><ul><li><p>标签（JLabel）是最简单的组件，用于显示单行静态文本。</p><ul><li><p>构造</p><p>JLabel label1 = new JLabel(“姓名”); ImageIcon ii = newImageIcon(“java.gif”); JLabel label2 = new JLabel(ii); JLabel label3 =new JLabel(“姓名”,ii,JLabel.CENTER);</p></li><li><p>方法</p><p>setText、setIcon</p></li></ul></li><li><p>按钮（JButton）</p><ul><li><p>构造</p><p>JButton button1 = new JButton(“姓名”); ImageIcon ii = newImageIcon(“java.gif”); JButton button2 = new JButton(ii); JButtonbutton3 = new JButton(“姓名”，ii);</p></li><li><p>方法</p><p>void setActionCommand(String); voidaddActionListener(ActionListener);</p></li></ul></li><li><p>文本框（<strong>JTextField</strong>）</p><ul><li><p>构造</p><p>JTextField tf1 = new JTextField(10);</p><p>JTextField tf2 = new TextField(“aa”);</p><p>JTextField tf3 = new JTextField(“aa”，8);</p></li><li><p>方法</p><p>public String getText()</p><p>public String getSelectedText()</p><p>public void setText(String s)</p><p>public void setEchoChar(char c)</p><p>public void setEditable(boolean b)</p></li></ul></li><li><p>文本区（JTextArea）</p><ul><li>JTextArea ta = new JTextArea(10,10);</li><li>JScrollPane sp = new JScrollPane(ta);//将文本区对象放入一个滚动窗格中</li></ul></li><li><p>单选按钮（ JRadioButton ）</p><ul><li><p>方法</p></li><li><p>void addActionListener(ActionListener);</p><p>void addItemListener(ItemListener);</p><p>boolean isSelected();</p><p>void setSelected(boolean);</p></li><li><p>按钮组（ButtonGroup）维持只有一个单选按钮处于选择状态</p></li></ul></li><li><p>复选框（JCheckbox）</p></li><li><p>列表框（JList）</p></li><li><p>下拉列表（ JComboBox ）</p></li><li><p>密码域（ JPasswordField ）</p></li><li><p>滑动条（JSlider ）</p></li></ul><h3 id="会对组件进行布局">会对组件进行布局</h3><ul><li>FlowLayout流式布局：该布局以行为单位依次排列各组件，一行排不下时，另起一行<ul><li><strong>JPanel</strong>的默认布局</li></ul></li><li>BorderLayout边界布局：<strong>按照东、西、南、北、中</strong>5个方位排列各组件<ul><li>顶层容器JFrame、JApplet、JDialog、JWindow的默认布局</li></ul></li><li>GridLayout 网格布局</li><li>GridBagLayout 网格包布局</li><li>CardLayout 卡片布局：该布局以一叠卡片的形式依次排列各组件</li><li>BoxLayout 盒式布局：以一行或一列的方式依次排列各组件</li><li>null 空布局（不使用布局）</li></ul><h3 id="熟悉常用基本组件的创建和操作">熟悉常用基本组件的创建和操作</h3><h3 id="会设置组件的颜色和字体">会设置组件的颜色和字体</h3><h3 id="awt组件及其事件处理机制">AWT组件及其事件处理机制</h3><ul><li>事件处理<ul><li>事件源——发生事件的对象，如：按钮 单击按钮会触发ActionEvent事件</li><li>监听器——对事件源实施监视的对象，如：包含按钮的窗口<br /></li><li>处理事件的接口——监听器对象自动调用一个方法，负责处理事件源发生的事件。该事件由ActionListener接口来监听</li></ul></li></ul><h2 id="其他">其他</h2><h3 id="流stream文件file和io">流(Stream)、文件(File)和IO</h3><p>#### 字节流方法</p><p>字节输入流<code>InputStream</code>主要方法：</p><ul><li><code>read()</code> ：从此输入流中读取一个数据字节。</li><li><code>read(byte[] b)</code> ：从此输入流中将最多 b.length个字节的数据读入一个 byte 数组中。</li><li><code>read(byte[] b, int off, int len)</code> ：从此输入流中将最多len 个字节的数据读入一个 byte 数组中。</li><li><code>close()</code>：关闭此输入流并释放与该流关联的所有系统资源。</li></ul><p>字节输出流<code>OutputStream</code>主要方法：</p><ul><li><code>write(byte[] b)</code> ：将 b.length 个字节从指定 byte数组写入此文件输出流中。</li><li><code>write(byte[] b, int off, int len)</code> ：将指定 byte数组中从偏移量 off 开始的 len 个字节写入此文件输出流。</li><li><code>write(int b)</code> ：将指定字节写入此文件输出流。</li><li><code>close()</code>：关闭此输入流并释放与该流关联的所有系统资源。</li></ul><h4 id="字符流方法">字符流方法</h4><p>字符输入流<code>Reader</code>主要方法：</p><ul><li><code>read()</code>：读取单个字符。</li><li><code>read(char[] cbuf)</code> ：将字符读入数组。</li><li><code>read(char[] cbuf, int off, int len)</code> ：将字符读入数组的某一部分。</li><li><code>read(CharBuffer target)</code>：试图将字符读入指定的字符缓冲区。</li><li><code>flush()</code> ：刷新该流的缓冲。</li><li><code>close()</code> ：关闭此流，但要先刷新它。</li></ul><p>字符输出流<code>Writer</code>主要方法：</p><ul><li><code>write(char[] cbuf)</code> ：写入字符数组。</li><li><code>write(char[] cbuf, int off, int len)</code>：写入字符数组的某一部分。</li><li><code>write(int c)</code> ：写入单个字符。</li><li><code>write(String str)</code> ：写入字符串。</li><li><code>write(String str, int off, int len)</code>：写入字符串的某一部分。</li><li><code>flush()</code> ：刷新该流的缓冲。</li><li><code>close()</code> ：关闭此流，但要先刷新它。</li></ul><p>另外，字符缓冲流还有两个独特的方法：</p><ul><li><code>BufferedWriter</code>类<code>newLine()</code>：<strong>写入一个行分隔符。这个方法会自动适配所在系统的行分隔符。</strong></li><li><code>BufferedReader</code>类<code>readLine()</code>：读取一个文本行。</li></ul><figure><img src="https://s2.loli.net/2023/12/26/hBzpenVt9jCMy6U.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="java内存">Java内存</h3><ul><li><strong>方法区</strong>（静态区，method）：<ul><li><strong>类的元数据信息</strong>：每个被加载的类都有对应的元数据，包括类的名称、访问修饰符、字段信息、方法信息等。这些信息在方法区中被存储。</li><li><strong>运行时常量池</strong>：每个类都有自己的常量池，其中包含类中使用的常量、字面量和符号引用。这些在编译时生成，运行时存储在方法区的运行时常量池中。</li><li><strong>静态变量</strong>：类的静态变量被存储在方法区中，它们是类级别的变量，而不是实例级别的。</li><li><strong>类的字节码</strong>：类经过编译后产生的字节码也会被存储在方法区中。这些字节码被JVM加载后转换成运行时的机器码。</li><li><strong>类和方法的其他相关信息</strong>：方法区还包括其他与类和方法相关的信息，如方法的字节码、方法的访问修饰符、方法的异常表等。</li></ul></li><li><strong>堆(heap)</strong>：<ul><li><strong>对象实例</strong>: 所有通过 <code>new</code>关键字创建的对象实例都存储在堆中。这包括类的实例、数组以及任何动态分配的对象。</li><li><strong>实例变量</strong>:对象的实例变量也存储在堆中。这些变量定义了对象的状态和特征，并在对象创建时分配内存。</li><li><strong>数组</strong>:Java中的数组也是对象，因此它们的数据存储在堆中。无论是基本数据类型的数组还是对象类型的数组，它们都被存储在堆内存中。</li><li><strong>垃圾回收信息</strong>:Java的堆还包含垃圾回收器所需的信息，用于管理对象的生命周期和内存的回收。</li></ul></li><li><strong>栈</strong>（Stack）：小、快<ul><li><p><strong>局部变量</strong>：方法中定义的局部变量，包括基本数据类型（如int、boolean等）和对象的引用。这些变量的生命周期与方法的执行周期相关联，在方法执行期间分配，在方法执行结束时释放。</p></li><li><p><strong>方法调用和执行信息</strong>：每次方法调用时，栈会存储调用的方法所需的信息，包括方法的参数、返回地址、方法的执行状态等。当方法调用结束时，栈会弹出该方法的信息，恢复上一个方法的执行状态。</p></li><li><p><strong>操作数栈</strong>：栈中还包括一个操作数栈（OperandStack），用于存放方法执行过程中的临时数据和运算结果。例如，在方法中进行算术运算或者对象引用的操作时，临时结果会被压入操作数栈，进行计算后再弹出。</p></li></ul></li><li>例题：<ul><li>类方法的定义只会在类加载时存储在方法区中，并且被所有实例共享；而实例方法的引用会存在于对象的内存空间中，但实际方法的定义并不会复制到每个对象中。</li></ul></li></ul><h3 id="修饰符分类">修饰符分类</h3><ul><li>访问修饰符<ul><li><strong>default</strong> (即默认，什么也不写）:在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。<strong>注意：不能修饰类（外部类）</strong></li><li><strong>public</strong> :对所有类可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> :对同一包内的类和所有子类可见。使用对象：变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li></ul></li><li>非访问修饰符<ul><li><strong>static</strong> 修饰符，用来修饰类方法和类变量。</li><li><strong>final</strong> 修饰符，用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li><strong>abstract </strong>修饰符，用来创建抽象类和抽象方法。</li><li><strong>synchronized </strong>和 <strong>volatile</strong>修饰符，主要用于线程的编程。</li></ul></li></ul><h1 id="复习ppt">复习PPT</h1><h2 id="jdbcjava数据库连接">JDBC（Java数据库连接）</h2><p><img src="https://s2.loli.net/2023/12/26/tSbIMTWqeArzaUg.png" alt="image-20231226144610571" style="zoom:50%;" /></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.DriverManager;<span class="hljs-keyword">import</span> java.sql.Statement;<span class="hljs-comment">//1、导入驱动jar包</span><span class="hljs-comment">//2、注册驱动</span>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="hljs-comment">//3、获取数据库的连接对象</span>Connection con = DriverManager.getConnection(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456789&quot;</span>);<span class="hljs-comment">//4、获取执行sql语句的对象</span>Statement stat = con.createStatement();<span class="hljs-comment">//5.1、执行sql查询并接收返回结果</span>ResultSet resultSet = statement.executeQuery(<span class="hljs-string">&quot;SELECT * FROM tableName&quot;</span>);<span class="hljs-comment">//5.2、执行sql并接收返回结果</span><span class="hljs-keyword">int</span> rowsAffected = statement.executeUpdate(<span class="hljs-string">&quot;UPDATE tableName SET column = value WHERE condition&quot;</span>);<span class="hljs-comment">//6、处理结果</span><span class="hljs-keyword">while</span> (resultSet.next()) &#123; <span class="hljs-comment">//指针移动下一行</span>    <span class="hljs-keyword">int</span> id = resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 通过列名或列索引获取整数</span>    String name = resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>); <span class="hljs-comment">// 通过列名或列索引获取字符串</span>    <span class="hljs-keyword">double</span> price = resultSet.getDouble(<span class="hljs-string">&quot;price&quot;</span>); <span class="hljs-comment">// 通过列名或列索引获取双精度数值</span>&#125;<span class="hljs-comment">//7、释放资源</span>stat.close();con.close();resultSet.close()</code></pre></div><h2 id="applet-1">Applet</h2><p><img src="https://s2.loli.net/2023/12/26/GztHKeYBqrmvaQW.png" alt="image-20231226153307577" style="zoom:50%;" /></p><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">applet</span> <span class="hljs-attr">code</span>=<span class="hljs-string">&quot;HelloWorldApplet.class&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;120&quot;</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.applet.*;   <span class="hljs-keyword">import</span> java.awt.*;   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaApplet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Applet</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span></span><span class="hljs-function">    </span>&#123;        g.setColor(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 设置颜色为红色</span>        g.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">&quot;宋体&quot;</span>, Font.BOLD, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 0-正常-PLAIN； 1-粗体-BOLD；2-斜体-ITALIC</span>        g.drawString(<span class="hljs-string">&quot;Hello, Java Applet!&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>); <span class="hljs-comment">// 在 (50, 50) 处绘制字符串</span>        g.drawLine(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">200</span>, <span class="hljs-number">50</span>); <span class="hljs-comment">// 起点 (50, 50)，终点 (200, 50)</span>        g.drawRect(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">150</span>, <span class="hljs-number">80</span>); <span class="hljs-comment">// 左上角坐标 (50, 100)，宽 150，高 80</span>        g.fillRect(<span class="hljs-number">250</span>, <span class="hljs-number">100</span>, <span class="hljs-number">150</span>, <span class="hljs-number">80</span>); <span class="hljs-comment">// 左上角坐标 (250, 100)，宽 150，高 80</span>    &#125;&#125;</code></pre></div><h2 id="异常处理">异常处理</h2><p><img src="https://s2.loli.net/2023/12/26/r7HoV9j2UuEt3MS.png" alt="image-20231226153445381" style="zoom:50%;" /></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 抛出异常的函数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exampleFunction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 在这个例子中，我们手动抛出一个异常</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;这是一个示例异常&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 调用可能抛出异常的函数</span>            exampleFunction();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// 捕获并处理异常</span>            System.err.println(<span class="hljs-string">&quot;捕获到异常: &quot;</span> + e.getMessage());            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 无论异常是否被捕获，finally 块中的代码都会执行</span>            System.out.println(<span class="hljs-string">&quot;无论如何都会执行的代码块&quot;</span>);        &#125;    &#125;</code></pre></div><h2 id="字符串操作">字符串操作</h2><figure><img src="https://s2.loli.net/2023/12/26/crBT7xOAX6ymewz.png"alt="image-20231226154030401" /><figcaption aria-hidden="true">image-20231226154030401</figcaption></figure><h2 id="字节流字符流缓冲流">字节流、字符流、缓冲流</h2><p><img src="https://s2.loli.net/2023/12/26/Hp6yk4Aa7BGXSDl.png" alt="image-20231226153930902" style="zoom: 25%;" /></p><p>File - FileOutputStream - BufferedOutputStream</p><p>File - FileOutputStream - OutputStreamWriter - BufferedWriter</p><p>File - FileWriter - BufferedWriter</p><p>主要方法：（<strong>字节流就是byte，字符流就是char</strong>）</p><ul><li><code>read()</code>：读取单个字符。</li><li><code>read(byte[] cbuf)</code> ：将字符读入数组。</li><li><code>write(byte[] b)</code> ：将 b.length 个字节从指定 byte数组写入此文件输出流中。返回一个长度，到达<strong>流的末尾</strong>返回<strong>-1</strong>。</li><li><code>close()</code> ：关闭此流</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// BufferedInputStream、BufferedOutputStream（缓冲字节流）</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-comment">// 缓冲字节流，提高了效率</span>BufferedOutputStream bis = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(file, <span class="hljs-keyword">true</span>));<span class="hljs-comment">// 要写入的字符串</span>String string = <span class="hljs-string">&quot;松下问童子，言师采药去。只在此山中，云深不知处。&quot;</span>;<span class="hljs-comment">// 写入文件</span>bis.write(string.getBytes());<span class="hljs-comment">// 关闭流</span>bis.close();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">read</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;BufferedInputStream fis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));<span class="hljs-comment">// 一次性取多少个字节</span><span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-comment">// 用来接收读取的字节数组</span>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-comment">// 读取到的字节数组长度，为-1时表示没有数据</span><span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<span class="hljs-comment">// 循环取数据</span><span class="hljs-keyword">while</span> ((length = fis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 将读取的内容转换成字符串</span>sb.append(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, length));&#125;<span class="hljs-comment">// 关闭流</span>fis.close();<span class="hljs-keyword">return</span> sb.toString();&#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// InputStreamReader、OutputStreamWriter（字符流）</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-comment">// OutputStreamWriter可以显示指定字符集，否则使用默认字符集</span>OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(file, <span class="hljs-keyword">true</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);        <span class="hljs-comment">//FileWriter fw = new FileWriter(file, true);</span><span class="hljs-comment">// 要写入的字符串</span>String string = <span class="hljs-string">&quot;松下问童子，言师采药去。只在此山中，云深不知处。&quot;</span>;osw.write(string);osw.close();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">read</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(file), <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">// 字符数组：一次读取多少个字符</span><span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<span class="hljs-comment">// 每次读取的字符数组先append到StringBuilder中</span>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-comment">// 读取到的字符数组长度，为-1时表示没有数据</span><span class="hljs-keyword">int</span> length;<span class="hljs-comment">// 循环取数据</span><span class="hljs-keyword">while</span> ((length = isr.read(chars)) != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 将读取的内容转换成字符串</span>sb.append(chars, <span class="hljs-number">0</span>, length);&#125;<span class="hljs-comment">// 关闭流</span>isr.close();<span class="hljs-keyword">return</span> sb.toString()&#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// BufferedReader、BufferedWriter（字符缓冲流）</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-comment">// BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file, true), &quot;UTF-8&quot;));</span><span class="hljs-comment">// FileWriter可以大幅度简化代码</span>BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(file, <span class="hljs-keyword">true</span>));<span class="hljs-comment">// 要写入的字符串</span>String string = <span class="hljs-string">&quot;松下问童子，言师采药去。只在此山中，云深不知处。&quot;</span>;bw.write(string);bw.close();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">read</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(file));<span class="hljs-comment">// 用来接收读取的字节数组</span>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-comment">// 按行读数据</span>String line;<span class="hljs-comment">// 循环取数据</span><span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 将读取的内容转换成字符串</span>sb.append(line);&#125;<span class="hljs-comment">// 关闭流</span>br.close();<span class="hljs-keyword">return</span> sb.toString();&#125;&#125;</code></pre></div><h2 id="file">File</h2><p>file.exists()</p><p>file.createNewFile();</p><p>file.delete();</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\Download\\test.txt&quot;</span>);<span class="hljs-comment">// 判断文件是否存在</span><span class="hljs-keyword">if</span> (!file.exists()) &#123;<span class="hljs-comment">// 不存在则创建</span>file.createNewFile();&#125;System.out.println(<span class="hljs-string">&quot;文件的绝对路径：&quot;</span> + file.getAbsolutePath());System.out.println(<span class="hljs-string">&quot;文件的大小：&quot;</span> + file.length());<span class="hljs-comment">// 刪除文件</span>file.delete();&#125;&#125;</code></pre></div><h2 id="html-jsp---web开发">HTML &amp; JSP - WEB开发</h2><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@page</span> language=<span class="hljs-string">&quot;java&quot;</span>  pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span>%&gt;&lt;%<span class="hljs-meta">@page</span> <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.*&quot;</span>%&gt;&lt;%<span class="hljs-meta">@page</span> <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;cn.edu.swjtu.news.entity.*&quot;</span>%&gt;&lt;%<span class="hljs-meta">@page</span> <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;cn.edu.swjtu.news.dao.NewsDao&quot;</span>%&gt;&lt;%<span class="hljs-meta">@page</span> <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;cn.edu.swjtu.news.dao.impl.NewsDaoImpl&quot;</span>%&gt;&lt;!DOCTYPE html PUBLIC <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Type&quot;</span> content=<span class="hljs-string">&quot;text/html; charset=ISO-8859-1&quot;</span>&gt;&lt;title&gt;新闻列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table align=<span class="hljs-string">&quot;center&quot;</span> border=<span class="hljs-string">&quot;1&quot;</span>&gt;  &lt;tr&gt;    &lt;th&gt;主题&lt;/th&gt;       &lt;th&gt;标题&lt;/th&gt;       &lt;th&gt;作者&lt;/th&gt;      &lt;/tr&gt;&lt;% NewsDao newsDao=<span class="hljs-keyword">new</span> NewsDaoImpl();List&lt;News&gt; list=newsDao.getAllnews();<span class="hljs-keyword">for</span>(News tempNew:list)&#123;%&gt;     &lt;tr&gt;    &lt;td&gt;&lt;%=tempNew.getNtname() %&gt;&lt;/td&gt;       &lt;td&gt;&lt;%=tempNew.getNtitle() %&gt;&lt;/td&gt;       &lt;td&gt;作者：&lt;%=tempNew.getNauthor() %&gt;&lt;/td&gt;      &lt;/tr&gt; &lt;%    &#125;%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> 二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span> 三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>主题<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>作者<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> 1 <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> 1 <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> 1 <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="gui---swing---基本组件">GUI - Swing - 基本组件</h2><figure><img src="https://s2.loli.net/2023/12/26/iU7patLI2lMPmB6.png"alt="image-20231226153357844" /><figcaption aria-hidden="true">image-20231226153357844</figcaption></figure><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.swing.*;<span class="hljs-keyword">import</span> java.awt.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">J</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建窗口</span>JFrame jf = <span class="hljs-keyword">new</span> JFrame();jf.setTitle(<span class="hljs-string">&quot;这是一个窗口&quot;</span>);    <span class="hljs-comment">//设置窗口标题</span>jf.setSize(<span class="hljs-number">800</span>,<span class="hljs-number">600</span>);<span class="hljs-comment">//jf.setExtendedState(JFrame.MAXIMIZED_BOTH); //设置窗口最大化</span>jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); <span class="hljs-comment">//设置窗口关闭方式</span>Container con=jf.getContentPane();JPanel pan=<span class="hljs-keyword">new</span> JPanel();JLabel l_ma=<span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;密码&quot;</span>);pan.add(l_ma);JPasswordField password=<span class="hljs-keyword">new</span> JPasswordField(<span class="hljs-number">20</span>);password.setEchoChar(<span class="hljs-string">&#x27;*&#x27;</span>);pan.add(password);JLabel l_xm=<span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;姓名&quot;</span>);pan.add(l_xm);JTextField tf_name=<span class="hljs-keyword">new</span> JTextField(<span class="hljs-number">20</span>);pan.add(tf_name);JLabel l_xb=<span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;性别&quot;</span>);pan.add(l_xb);JRadioButton  male = <span class="hljs-keyword">new</span> JRadioButton(<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-keyword">true</span>);JRadioButton  female = <span class="hljs-keyword">new</span> JRadioButton(<span class="hljs-string">&quot;女&quot;</span>);ButtonGroup  group=<span class="hljs-keyword">new</span> ButtonGroup();group.add(male);group.add(female);pan.add(male);pan.add(female); JLabel l_ah=<span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;爱好&quot;</span>);JCheckBox[] hobby=&#123;<span class="hljs-keyword">new</span> JCheckBox(<span class="hljs-string">&quot;音乐&quot;</span>),<span class="hljs-keyword">new</span> JCheckBox(<span class="hljs-string">&quot;足球&quot;</span>),<span class="hljs-keyword">new</span> JCheckBox(<span class="hljs-string">&quot;绘画&quot;</span>)&#125;;pan.add(l_ah);pan.add(hobby[<span class="hljs-number">0</span>]);pan.add(hobby[<span class="hljs-number">1</span>]);pan.add(hobby[<span class="hljs-number">2</span>]); JLabel  l_yx=<span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;院系&quot;</span>);pan.add(l_yx);String[] departmentNames = &#123;<span class="hljs-string">&quot;计算机科学与技术系&quot;</span>,<span class="hljs-string">&quot;电子信息与技术系&quot;</span>,<span class="hljs-string">&quot;计算机工程系&quot;</span>&#125;;JComboBox  department = <span class="hljs-keyword">new</span> JComboBox(departmentNames);department.setEditable(<span class="hljs-keyword">false</span>);pan.add(department);JLabel   l_xk=<span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;选课&quot;</span>);String[] coursesNames = &#123;<span class="hljs-string">&quot;数据结构&quot;</span>,<span class="hljs-string">&quot;操作系统&quot;</span>,<span class="hljs-string">&quot;网络原理&quot;</span>,<span class="hljs-string">&quot;Java程序设计&quot;</span>,<span class="hljs-string">&quot;分布式系统开发技术&quot;</span>,<span class="hljs-string">&quot;计算机导论&quot;</span>,<span class="hljs-string">&quot;密码学&quot;</span>,<span class="hljs-string">&quot;计算机组成原理&quot;</span>,<span class="hljs-string">&quot;编译原理&quot;</span>,<span class="hljs-string">&quot;图形学&quot;</span>&#125;;JList course = <span class="hljs-keyword">new</span> JList(coursesNames);pan.add(l_xk);pan.add(course);JLabel l_jf=<span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;加分&quot;</span>);    pan.add(l_jf);JSlider addition = <span class="hljs-keyword">new</span> JSlider(JSlider.HORIZONTAL, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);addition.setMajorTickSpacing(<span class="hljs-number">10</span>);addition.setMinorTickSpacing(<span class="hljs-number">5</span>);addition.setPaintTicks(<span class="hljs-keyword">true</span>);addition.setPaintLabels(<span class="hljs-keyword">true</span>);addition.setSnapToTicks(<span class="hljs-keyword">true</span>);pan.add(addition); JButton b_sub=<span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;确认&quot;</span>);pan.add(b_sub);JButton b_save=<span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;保存&quot;</span>);pan.add(b_save); JProgressBar progbar = <span class="hljs-keyword">new</span> JProgressBar(JProgressBar.HORIZONTAL,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);progbar.setStringPainted(<span class="hljs-keyword">true</span>);pan.add(progbar);JLabel l_jg=<span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;录入结果&quot;</span>);JTextArea result=<span class="hljs-keyword">new</span> JTextArea(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>);JScrollPane sp=<span class="hljs-keyword">new</span> JScrollPane(result);pan.add(l_jg); pan.add(sp); con.add(pan);jf.setVisible(<span class="hljs-keyword">true</span>);&#125;&#125;</code></pre></div><figure><img src="https://s2.loli.net/2023/12/28/LnPcwXpEDv45duM.png"alt="image-20231228110640861" /><figcaption aria-hidden="true">image-20231228110640861</figcaption></figure><p>ActionListener接口的actionPerformed(ActionEvente)方法，e.getSource()==btn 判断</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<span class="hljs-keyword">import</span> java.awt.event.*;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">guessFrame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Frame</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ActionListener</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;    Button btnGetNum=<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;get&quot;</span>);    Button btnEnter=<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;yes&quot;</span>);    Label lblInfo=<span class="hljs-keyword">new</span> Label(<span class="hljs-string">&quot;guess&quot;</span>,Label.CENTER);    TextField txtInput=<span class="hljs-keyword">new</span> TextField(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-number">10</span>);        guessFrame(String s)     &#123;    <span class="hljs-keyword">super</span>(s);       setSize(<span class="hljs-number">300</span>,<span class="hljs-number">200</span>);setResizable(<span class="hljs-keyword">false</span>);setVisible(<span class="hljs-keyword">true</span>);setLayout(<span class="hljs-keyword">new</span> FlowLayout());<span class="hljs-comment">//lblInfo.setBounds(50,50,120,20);</span>add(lblInfo);<span class="hljs-comment">//txtInput.setBounds(50,80,120,20);</span>add(txtInput);<span class="hljs-comment">//btnGetNum.setBounds(50,120,80,20);</span>add(btnGetNum);<span class="hljs-comment">//btnEnter.setBounds(150,120,50,20);</span>add(btnEnter);btnGetNum.addActionListener(<span class="hljs-keyword">this</span>);btnEnter.addActionListener(<span class="hljs-keyword">this</span>);&#125;    <span class="hljs-comment">//实现ActionListener接口中的actionPerformed方法（见下一页）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">if</span>(e.getSource()==btnGetNum)<span class="hljs-comment">//单击 “得到随机数”接钮</span>       &#123;            number=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">100</span>)+<span class="hljs-number">1</span>;       &#125;       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.getSource()==btnEnter)<span class="hljs-comment">//单击 “确定”接钮</span>       &#123;            <span class="hljs-keyword">int</span> guess=<span class="hljs-number">0</span>;            <span class="hljs-keyword">try</span>            &#123;           guess=Integer.parseInt(txtInput.getText());<span class="hljs-comment">//获取文本框中的数值</span>           <span class="hljs-keyword">if</span> (guess==number)           &#123;          lblInfo.setText(<span class="hljs-string">&quot;yes!&quot;</span>);           &#125;           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(guess&gt;number)           &#123;          lblInfo.setText(<span class="hljs-string">&quot;high!&quot;</span>);          txtInput.setText(<span class="hljs-keyword">null</span>);           &#125;           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(guess&lt;number)           &#123;          lblInfo.setText(<span class="hljs-string">&quot;low!&quot;</span>);          txtInput.setText(<span class="hljs-keyword">null</span>);           &#125;            &#125; <span class="hljs-keyword">catch</span>(NumberFormatException event)            &#123;            lblInfo.setText(<span class="hljs-string">&quot;re&quot;</span>);  &#125;       &#125;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">guessNumber</span></span><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span><span class="hljs-function"></span>&#123;        guessFrame guessfrm=<span class="hljs-keyword">new</span> guessFrame(<span class="hljs-string">&quot;猜数游戏&quot;</span>);&#125;  &#125;</code></pre></div><h2 id="题目">题目</h2><ul><li>单项选择题(30分，每小题2分)</li><li>程序填空题（20分，每空2分）</li><li>程序阅读题（20分，每小题5分）</li><li>程序设计题1（15分）：html+jsp（<strong>WEB开发</strong>文件夹内容）</li><li>程序设计题2（15分）：Gui 组件</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java开发技术 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人机交互 - 期末复习</title>
      <link href="/2023/12/24/48/"/>
      <url>/2023/12/24/48/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="人机交互">人机交互</h1><h2 id="绪论">1 绪论</h2><p>定义：研究如何设计人类活动和计算系统间的交互，以及如何构建人机界面来支持交互的学科。</p><p>相关学科：认知心理学、人机工程学、多媒体技术和虚拟现实技术</p><h3 id="研究内容">研究内容：</h3><ul><li>人机交互界面表示模型与设计方法</li><li>可用性分析与评估</li><li>多通道智能交互技术——研究视觉、听觉、触觉和力觉等多通道信息与计算机系统进行通信。</li><li>认知与智能用户界面</li><li>群件及社会化交互——个人或群组间的信息传递、群组中的信息共享、业务过程自动化与协调，以及人和过程之间的交互活动</li><li>Web交互设计</li><li>移动界面设计——向移动应用的界面设计</li></ul><h3 id="主要发展阶段">主要发展阶段</h3><ul><li>批处理阶段</li><li>联机终端阶段</li><li>图形用户界面阶段</li><li>自然交互阶段</li></ul><h2 id="人机交互要素-人设备交互">2 人机交互要素： 人、设备、交互</h2><h3 id="感知">感知：</h3><p>通过人体感觉器官和组织进行人与外部世界的信息的交流和传递。主要有<strong>视觉、听觉和触觉感知</strong></p><h3 id="知觉">知觉：</h3><ul><li><strong>选择性，</strong>分化对象和背景的选择性是知觉最基本的特性，背景往往衬托着、弥漫着、扩展着，对象往往轮廓分明、结构完整。</li><li><strong>整体性，</strong>当一个残缺不全的部分呈现到眼前时，人脑会把知觉对象补充完整，当对知觉对象不熟悉时，知觉会将它组织为具有一定结构的整体，即知觉的组织化。</li><li><strong>理解性，</strong>旧经验与新刺激建立多维度、多层次的联系，以保证理解的全面和深刻。</li><li><strong>恒常性，</strong>当客观条件在一定范围内改变时,人的知觉映象在相当程度上却保持着它的稳定性。</li></ul><h3 id="格式塔心理学完形心理学">格式塔心理学（完形心理学）：</h3><p>用户在感知事物的时候总是尽可能将其视为一个“好” 的型式</p><ul><li><strong>接近法则</strong>：空间距离较短或互相接近的物体容易被视为整体</li><li><strong>相似法则</strong>：将看上去相似的物体看成一个整体</li><li><strong>连续法则</strong>：共线或具有相同方向的物体会被组合在一起</li><li><strong>闭合法则</strong>：忽视轮廓的间隙而将其视作一个完整的整体</li><li>对称性原则：相互对称且能够组合为有意义单元的物体会被组合在一起</li><li>区域性原则：将具有很小区域的对象视为图形而不是区域（最小化原则）</li><li>前景与背景：前景和背景在某些情况下可以互换</li><li><strong>*简单法则</strong>：是设计的目标，为了达到该目标，通常的做法是删除、重组、放弃、隐藏。对于原本内容就很少的设计，是较容易做到的，但对于内容非常复杂的问题，要做到简单，必须一步一步的简化。简单更像是追求的目标，而接近、相似、关闭和连续则是实现这一目标的方法。</li></ul><h3 id="认知">认知：</h3><p>认知是人们在进行日常活动时发生于头脑中的事情，它涉及认知处理，如思维、记忆、学习、幻想、决策、看、读、写和交谈等。</p><ul><li>注意：意通常是指选择性注意，即注意是有选择的加工某些刺激而忽视其他刺激的倾向。</li><li>记忆：记忆就是回忆各种知识以便采取适当的行动。<ul><li>分三种类型：感觉记忆（瞬时记忆）、短时记忆和长时记忆</li><li>7±2理论：减少对用户记忆的需求，信息单元的数量最多为7个</li></ul></li></ul><h3 id="认知过程">认知过程：</h3><ul><li>问题解决：按照一定的 目标，应用各种认知活动、技能等，经过一系列的思维操作，使问题得以解决的过程。</li><li>语言处理：阅读、说话和聆听</li><li>思维：对新输入信息与脑内储存知识经验进行一系列复杂的心智操作过程，主要的思维活动有分析与综合，比较与分类及抽象和概括。</li><li>想象：对已储存的表象进行加工改造形成新形象的心理过程，<strong>无意想象</strong>是指事先没有预定目的的想象，<strong>有意想象</strong>是指事先有预定目的的想象</li></ul><h3 id="交互设备给出系统-设计方案-选用交互设备">交互设备（给出系统设计方案 选用交互设备）：</h3><ul><li><strong>输入设备（</strong>键盘 手写板 手写笔<strong>二三维扫描仪</strong> 摄像头 <strong>动作捕捉设备</strong>（机械光学 电磁式）鼠标 触控板 控制杆 触摸屏 手写液晶屏 <strong>眼动跟踪系统）</strong><ul><li>文本输入设备：键盘、手写输入、语音输入、学字符识别</li><li>定位设备（WIMP系统）：鼠标、触摸板、指点杆、触摸屏、眼球跟踪器、尖笔/光笔、输入笔</li><li>图像输入设备：扫描仪、数码相机、传真机</li></ul></li><li><strong>输出设备（</strong>显示器，数字纸 电子阅读器 打印机 耳机麦克风 声卡(声音合成)<ul><li>显示设备：光栅扫描阴极射线管、液晶显示器、等离子体显示器、触摸屏、发光二极管、电子墨水、点字显示器</li></ul></li></ul><h3 id="执行评估活动的周期">执行/评估活动的周期：</h3><ul><li>形成目标、形成意图、明确动作、执行动作、感知系统状态、解释感知的状态、评估感知的解释</li><li>执行的隔阂(用户为达目标而制定的动作与系统允许的动作之间的差别)</li><li>评估的隔阂(系统状态的实际表现与用户预期之间的差别)</li><li><strong>执行隔阂的产生原因</strong>是，用户根据以往的软件使用经验，认为当前系统或软件应该设计完成了某项功能，然而实际上该功能在该系统中并没有实现。</li><li><strong>评估隔阂产生的原因</strong>是，用户根据以往的经验认为界面上某选项或按钮具有某项特定功能，但实际系统在该位置实现的功能与用户所想不一致。</li></ul><h3id="产品或系统中的-认知模型系统模型设计模型及之间的关系">产品或系统中的认知模型、系统模型、设计模型及之间的关系。</h3><ul><li><strong>设计模型</strong>：设计师设想的模型，说明系统如何运作。</li><li><strong>系统模型</strong>：系统实际上如何运作。</li><li><strong>认知模型</strong>（用户模型）：用户如何理解系统的运作。用户心理模型，用户对系统的认知。</li><li><strong>关系：</strong>根据<strong>设计模型</strong>设计系统的<strong>具体实现</strong>，形成<strong>系统模型</strong>。用户根据已有的认知模型使用系统，系统模型根据使用方式给出对应的反馈，用户又通过这种反馈积累经验，不断地更新认知模型。</li></ul><h3 id="w2h方法">5W+2H方法</h3><p>虚拟现实技术（以其在医学领域的应用为例）</p><ul><li><strong>What：</strong>就是利用虚拟环境建立虚拟的人体模型，学生借助跟踪球、HMD、感觉手套，可以在虚拟实验室中，进行“尸体”解剖和各种手术练习。</li><li><strong>Why：</strong>目的为：进行人体构造的学习，手术的练习以及最佳手术方案的寻找。</li><li><strong>Where：</strong> 虚拟医学实验室。</li><li><strong>When：</strong>模拟或练习手术时以及模拟“尸体”解剖时。</li><li><strong>Who：</strong> 有一定医学知识的学生/医生。</li><li><strong>How：</strong> 借助输入输出的设备，采用自然方式进行交互。具体到医学领域，就是医生借助跟踪球、HMD、感觉手套与虚拟的人体模型之间进行交互。</li><li>How much</li></ul><h3 id="隐喻">隐喻：</h3><p>图形用户界面GUI与现实世界中对象的视觉抽象进行关联</p><h2 id="交互设计目标">3 交互设计目标</h2><h3 id="可用性目标">可用性目标</h3><ul><li>易学性：指使用系统的难易，即系统应当容易学习，从而用户可以在较短时间内应用系统来完成某些 任务</li><li>高效率：当用户学会使用产品之后，用户应该具有更高的生产力水平（效率），效率指熟练用户到达学习曲线上平坦阶段时的稳定绩效水平</li><li>易记性：用户在学会使用软件后应当容易记忆，学会某个系统后，应能够迅速回想起它的使用方法</li><li>少出错：尽可能降低出错率，保证导致灾难性后果错误的发生频率降到最低，保证错误发生后迅速恢复到正常状态</li><li>主观满意度：用户对系统的主观喜爱程度</li></ul><h3 id="用户体验目标">用户体验目标</h3><h2 id="用户研究">3 用户研究</h2><h3 id="需求">需求</h3><p>定义：关于目标产品的一种陈述，它指定了产品应做什么，或者应如何工作，应该是具体、明确和无歧义的</p><p>需求活动：搜集数据，解释数据，提取需求</p><h3 id="用户特性">用户特性</h3><p>心理学原理部分，假设每个人都有相似的能力和局限性，交互产品设计人员应该意识到个性的差异</p><ul><li>体验水平差异：新手、专家、中间用户</li><li>年龄差异：老年人、儿童</li><li>文化差异：符号理解、姿势理解、颜色含义</li><li>健康差异：视觉损伤、听觉损伤、残疾</li></ul><h3 id="用户研究-1">用户研究</h3><p>定义：用户研究是对用户目标、需求和能力的系统研究，用于指导设计、产品结构或者工具的优化，提升交互式产品的用户体验。</p><figure><img src="https://s2.loli.net/2023/12/24/rheTsIDMbG29KJ1.png"alt="image-20231224190658771" /><figcaption aria-hidden="true">image-20231224190658771</figcaption></figure><h3 id="用户建模">用户建模</h3><p>用户模型用于描述用户交互行为过程、认知过程以及所需要的系统条件。心理认知包括感知、思维、动机、态度等方面，每一个因素都可能影响到用户任务的完成过程。</p><p>人物角色法是根据用户的目标及特征建立的描述模型，涵盖了目标用户的外观、行为特点、使用动机、期望、体验目标等内容。一般情况下建立4～6个用户角色甚至更多，并根据需求的优先级分为首要人物角色、次要人物角色、 补充任务角色等。</p><h4 id="七步人物角色法">七步人物角色法：</h4><p>头像、 基本信息、与产品相关的 计算机背景或生活方式、与产品相关的行为习惯、用户目标、困难。</p><h4 id="需求定义的5个步骤">需求定义的5个步骤：</h4><ul><li>创建问题和前景综述：设计问题综述应该简明地反映需要改变的情况，来服务人物角色和提供产品给人物 角色的商业组织</li><li>头脑风暴：尽可能地去除成见，允许设计师以开放和灵活的方式想象来构建场景剧本，使用他们的思维 从场景剧本中得到需求</li><li>确定人物角色的期望：<ul><li>影响人物角色愿望的态度、经历、渴望，以及其他社会、文化、环境和认知因素</li><li>人物角色在使用产品体验方面可能的一般期待和愿望</li><li>人物角色认为什么是数据的基本单元或者元素</li></ul></li><li>构建情境场景剧本：关注人物角色的活动，及其心理模型和动机，将注意力集中在设计的产品中怎样能够最好地帮助你的人物角色达到目标</li><li>确立需求<ul><li>数据需求：必须在系统中被描绘的对象和信息，可以被看作是与对象相关的宾语或形容词，如账号、人、文档、邮件、歌曲、图片以及它们的属性比如状态、日期等</li><li>功能需求：系统对象必须进行的操作，最终会转化为界面控件</li></ul></li></ul><h4 id="建立用户档案的五个过程">建立用户档案的五个过程：</h4><ul><li>定义目标用户群、归纳用户特征、归纳使用环境特征、归纳用户任务、塑造人物角色</li></ul><h2 id="交互任务分析">4 交互任务分析</h2><p>任务分解：是一个过程的线性描述，能获得过程所包含的元素以及主要的环境因素。5W/2H</p><h3 id="层次化任务分析hta">层次化任务分析（HTA）：</h3><p>包含各步骤的分层流程图</p><ul><li>一个框在其他框之上，表示想做什么（子目标）</li><li>该框在其他框之下，表示它如何完成</li></ul><p><img src="https://s2.loli.net/2023/12/24/MBHRQgkhVp6IuL7.png" alt="image-20231224191154977" style="zoom: 67%;" /></p><h3 id="用例">用例</h3><p>每个参与者有特定的用例，包括参与者的一个任务或目标。</p><figure><img src="https://s2.loli.net/2023/12/24/ZfNRUr5bQBJinth.png"alt="image-20231224191313392" /><figcaption aria-hidden="true">image-20231224191313392</figcaption></figure><h3 id="原型">原型</h3><p>在某一方面和真正产品比较接近、以便人们能对这一方面的各种技术方案进行不断评估和改进的一种接近于实际产品的模型，借助于原型，当事人就能与未来的产品交互，从中获得一些实际的使用体验，并发掘新思路</p><h2 id="交互设计过程与原则">5-1 交互设计过程与原则</h2><h3 id="设计目标">设计目标</h3><h4 id="可用性度量">可用性度量</h4><ul><li><strong>易学性的度量：</strong>找一些从未使用过系统的用户，能够代表系统的目标用户，区分没有任何计算机使用经验的新手用户和具有一般计算机使用经验的用户，统计他们学习使用系统直至达到某种熟练程度的时间。</li><li><strong>使用效率的度量：</strong>由于用户自身的原因、少量系统的操作十分复杂的原因，并不是所有用户都能够迅速达到最终的绩效水平。因此我们要要区分不同的用户群体，对于有经验的用户来说较为正规的衡量方式是通过使用系统的小时数来定义的。先让其使用产品，然后度量其绩效水平或为用户绘制学习曲线当发现用户的绩效水平在一段时间内不再提高时，就认为已经达到了该用户的稳定绩效水平。</li><li><strong>易记性的度量：</strong>首要将用户分类为新手用户，熟练用户，非频繁使用用户。其中对非频繁使用用户进行测试最能体现系统的易记性。我们可以对在特定长时间内没有使用系统的用户进行标准用户测试：记录下这些用户执行特定任务所用的时间。也可以对用户进行记忆测试，如在用户完成一个应用系统的特定任务后，让用户解释各种命令的作用。</li><li><strong>错误率的度量：</strong>错误，通常指不能实现预定目标的操作。我们可以在用户执行特定任务时统计这种操作的次数，可以在度量其他可用性属性的同时来度量错误率的情况。统计完错误的情况以后，对错误进行分类，（1）错误发生后能够被用户立刻纠正，不会对系统带来灾难性的影响，往往会被包含在使用效率的统计当中（2）不易于被用户发现，从而可能造成最终结果存在问题。因此设计人员在设计时也应该将其发生的频率降到最低。</li><li><strong>满意度的度量：</strong>满意度度量评价都是主观的，因此以询问用户的方式进行度量更合适。为减少单个用户评价的主观性，把多个用户的结果综合起来取其平均值。度量通常在用户测试完成后进行，要求用户通过简单的调查问卷对系统打分，可以1-5或1-7的Likert度量尺度或语义差异尺度作为打分标准，一定要在用户使用系统执行真实的任务之后再来询问他们的看法。</li></ul><h4 id="用户体验目标-1">用户体验目标</h4><ul><li>用户体验：用户在与系统交互时的感觉，<strong>用户体验目标</strong>让用户喜欢产品。<strong>实施:</strong>早期通过焦点小组、访谈等<strong>获取用户体验目标</strong>,开发中应用可用性方法，<strong>后期用户测试</strong></li></ul><h3 id="简易可用性工程">简易可用性工程</h3><h4 id="可用性属性的度量">可用性属性的度量</h4><ul><li>易学习性</li><li>效率测试</li><li>主观满意度</li></ul><h4 id="完整的可用性工程过程">完整的可用性工程过程</h4><p>（1）了解用户 （2）竞争性分析 （3） 设定可用性目标（4）用户参与的设计 （5） 迭代设计 （6）产品发布后的工作</p><h4 id="简化四种主要技术">简化（四种主要技术)</h4><ul><li>（1）用户和任务观察 （2）场景 （3）简化的边做边说（4）启发式评估</li></ul><h3 id="设计原则">设计原则</h3><h4 id="交互设计过程的四项基本活动">交互设计过程的四项基本活动：</h4><ul><li>发现并标识用户需要并建立需求：必须了解谁是目标用户；交互式产品应提供哪些支持 ； 最基本的需要、需求</li><li>开发满足需求的候选设计方案： 设计的核心活动 ；两个子活动：概念设计和物理设计（具体设计）</li><li>构建设计的交互式版本 ： 评价设计的最佳方法就是让用户与产品交互 ；不一定是可运行的软件版本</li><li>（在整个过程中）评估设计 ：评估它的可用性和可接受性；制定各种评估标准</li></ul><h4 id="交互设计规则">交互设计规则：</h4><ul><li><strong>可学习性：</strong>新用户能用它开始有效的交互并能获得最大的性能</li><li><strong>灵活性：</strong>用户和系统能以多种方式交换信息</li><li><strong>健壮性：</strong>在决定成就和目标评估方面对用户提供的支持程度</li></ul><h4 id="shneiderman黄金规则">Shneiderman黄金规则：</h4><ol type="1"><li>尽可能保证一致</li><li>符合普遍可用性：充分考虑用户操作的熟练程度、年龄范围、身体状况（如是否有残疾）等多方面的不同需求</li><li>提供信息丰富的反馈</li><li>设计说明对话框以生成结束信息</li><li>预防并处理错误</li><li>让操作容易撤销</li><li>支持内部控制点</li><li>减轻短时记忆负担</li></ol><h4 id="norman的七项原理">Norman的七项原理：</h4><ul><li>应用现实世界和头脑中的知识</li><li>简化任务结构：为用户提供帮助；提供更多反馈信息；任务自动化</li><li>使事情变得明显</li><li>获得正确的映射</li><li>利用自然和人为的限制力量</li><li>容错设计</li><li>映射标准化</li></ul><h4 id="nielsen十项启发式规则">Nielsen十项启发式规则：</h4><ul><li>系统状态的可见度</li><li>系统和现实世界的吻合</li><li>用户享有控制权和自主权</li><li>一致性和标准化</li><li>避免出错</li><li>依赖识别而非记忆</li><li>使用的灵活性和高效性</li><li>审美感和最小化设计</li><li>帮助用户识别、诊断和恢复错误</li><li>帮助和文档</li></ul><h2 id="交互式系统设计">5-2 交互式系统设计</h2><h3 id="设计框架">设计框架</h3><p>先站在一个高层次上关注用户界面和相关行为的整体结构</p><h4 id="alan-cooper的设计框架">Alan Cooper的设计框架</h4><ol type="1"><li>定义外形因素和输入方法</li><li>定义功能和数据元素</li><li>决定功能组合层次</li><li>勾画大致的设计框架</li><li>构建关键情景场景剧本：描述了人物角色如何同产品交互</li><li>通过验证性的场景剧本来检查设计</li></ol><h3 id="简化设计">简化设计</h3><p>简化设计的四策略：</p><ul><li>删除：删除不必要的</li><li>组织：组织要提供的</li><li>隐藏：隐藏非核心的</li><li>转移</li></ul><h3 id="折衷设计">折衷设计</h3><p>个性化和配置、本地化和国际化、审美学与实用性</p><h3 id="细节设计">细节设计</h3><ul><li>加快系统的响应时间</li><li>减轻用户的记忆负担</li><li>减少用户的等待感</li><li>设计好的出错信息</li></ul><h3 id="交互设计模式">交互设计模式</h3><p>定位模式、结构模式、行为模式</p><p>切分内容：对象列表、动作或任务列表、类别列表、工具列表</p><p>物理结构：多窗口、单一窗口分页、平铺窗口</p><h2 id="以用户为中心的交互产品设计">6 以用户为中心的交互产品设计</h2><h3 id="用户体验的层次模型">用户体验的层次模型：</h3><ul><li>表现层：界面：图片、文字……+可点击的 ——感知设计</li><li>框架层：按钮、表格、图片或文本区域的位置——界面设计、导航设计和信息设计</li><li>结构层：结构则设计用户如何到达某页面，能去何处，导航——交互设计与信息架构</li><li>范围层：结构层确定网站各种特性和功能最合适的组合方式——功能规格和内容需求</li><li>战略层：经营目标、用户目标——产品目标和用户需求</li></ul><h2 id="可视化设计">7 可视化设计</h2><h3 id="屏幕复杂度计算">屏幕复杂度计算</h3><p>ans = 屏幕中元素的个数 + 水平对齐点的个数 + 垂直对齐点的个数</p><h3 id="用户界面设计原理">用户界面设计原理</h3><ul><li>结构原理：好的用户界面设计对用户界面的组织方式应符合所支持工作的结构，符合用户对工作的认识</li><li>简单性原理</li><li>可见性原理：设计目标是让所有需要和相关的选项可见和明确，不应让用户被不必要的信息所迷惑</li><li>反馈原理：成功的反馈就是以能被对方注意到、读到和正确理解的方式来提供信息</li><li>宽容原理：高可用性的系统帮助用户少犯错误</li><li>重用原理：用户界面内在外观、位置以及行为上的一致性使得软件容易学习和记忆如何使用</li></ul><h2 id="交互设计模型与理论">8 交互设计模型与理论</h2><h3 id="cmn-goms分析">CMN-GOMS分析</h3><ul><li>目标Goals：任务分解为一组目标和子目标。目标就是用户执行任务最终想要得到的结果,它可以在不同的层次中进行定义。</li><li>操作Operators：操作是任务分析到最低层时的行为，是用户为了完成任务所必须执行的基本动作。（如单击、按键）</li><li>方法Methods：方法是描述如何完成目标的过程。一个方法本质上来说是内部的算法，用来确定子目标序列及完成目标所需要的操作。如：最小化窗口</li><li>选择Selection：选择是用户要遵守的判定规则，以确定在特定环境下所要使用的方法。当有多个方法可供选择时，GOMS尽量来预测会使用哪个方法,这需要根据特定用户、系统的状态、目标的细节来预测要选择哪种方法。</li></ul><h3 id="lotos模型">LOTOS模型：</h3><ul><li>T1 |||T2（交替Interleaving）：T1和T2两个任务相互独立执行，可按任意顺序执行，但永远不会同步。</li><li>T1 []T2（选择Choice）：需要在T1，T2中选择一个执行，一旦选择某一个后，必须执行它直到结束，在这中间另一个再无执行机会。</li><li>T1 | [a1,...,an] | T2（同步Synchronization）：任务T1，T2必须在动作（a1,……，an）处保持同步</li><li>T1 [&gt;T2（禁止Deactivation）：一旦T2任务被执行，T1便无效（不活动）</li><li>T1 &gt;&gt; T2（允许Enabling）：当T1成功结束后才允许T2执行</li></ul><h3 id="uan模型">UAN模型：</h3><ul><li>动作标识符<ul><li>move_mouse(x,y) 移动鼠标至(x,y)</li><li>release_button(x,y) 在(x,y)位置释放鼠标按钮；</li><li>highlight(icon)使icon高亮显示；</li><li>de_highlight(icon) 取消icon的高亮显示。</li></ul></li><li>条件选择标识符<ul><li>while(condition)TASK：当条件condition为真时，循环执行任务TASK；</li><li>if(condition) then TASK：如果条件condition满足，则执行任务TASK；</li><li>iteration A* or A+ ：表示迭代操作；（遍历）</li><li>waiting ：表示等待，可以等待一个条件满足，也可以等待任务中的一个操作执行。</li></ul></li></ul><h3 id="g-u-l模型">G-U-L模型：</h3><ul><li>G-U-L运用GOMS原理为基础进行任务分解，建立基本的行为模型，原子操作由UAN模型描述，在此基础上，运用LOTOS算符来表示 任务目标之间的时序关系。</li></ul><h3 id="人类处理器模型mhp">人类处理器模型MHP</h3><ul><li>是一种预测模型，提供一种描述人类信息处理的方法，能对人的行为做出一般性预测，使用一组按照原则（操作原则）运行的存储器和处理器来表现人类的处理系统<ul><li>感知系统——处理来自外部世界的感官刺激</li><li>认知系统——作必要的处理来连接另两个子系统</li><li>运动神经系统——控制人的动作</li></ul></li></ul><h3 id="击键模型klm">击键模型（KLM）</h3><ul><li>操作符<ul><li>K 按键盘键或点击鼠标。</li><li>P 将鼠标移动到屏幕上的一个目标</li><li>H 手放置到键盘或其他设备上</li><li>D 绘制一条线段 M 心理准备</li><li>R 系统响应</li></ul></li><li>编码方法<ul><li>列出操作次序，累加每一项操作的预计时间<spanclass="math inline">\(T_{execute}=T_{k}+T_{P}+T_{h}+T_{d}+T_{m}+T_{r}\)</span></li><li>例：H[鼠标]MP[网络连接图标]K[右键]P[修复]K[左键]，时间:0.4+1.35+2P+2K=4.35秒</li></ul></li></ul><h3id="hick定律席克定律又称希克法则">Hick定律，席克定律（又称希克法则）</h3><ul><li>做决定的时间会随着选择数量的增加而增加, <spanclass="math inline">\(T=a + b\log_2(n + 1)\)</span></li><li>a表示的是与做决定无关的时 间（前期认识和观察的时间），</li><li>b表示根据对选项认识的处理时间（从经验衍生出的常量，对人来说约为0.155s）</li></ul><h3 id="状态转移网络stn">状态转移网络（STN）</h3><ul><li>系统定义为一个具有一定数量状态的转换机， 称之为有限状态机-FiniteState Machine(FSM)</li><li>FSM从外部世界中接收到事件，并能使FSM从一个状态转换到另一个状态。</li></ul><figure><img src="https://s2.loli.net/2023/12/24/YOdtvKEXnBM8xsW.png"alt="image-20231224163502700" /><figcaption aria-hidden="true">image-20231224163502700</figcaption></figure><h3 id="三态模型tsm">三态模型（TSM）</h3><ul><li>跟踪运动 S1</li><li>拖动运动 S2</li><li>无反馈运动 S0</li></ul><figure><img src="https://s2.loli.net/2023/12/24/uTvJbtnE1GhyIN5.png"alt="image-20231224163924733" /><figcaption aria-hidden="true">image-20231224163924733</figcaption></figure><h3 id="fitts定律">Fitts定律</h3><p>点中一个目标的时间是目标大小和目标距离的函数</p><ul><li>困难指数 (Index of Difficulty) <span class="math inline">\(ID=\log_2(A/W+1) (bits)\)</span><ul><li>A运动距离或振幅；W目标的宽度</li></ul></li><li>运动时间 (Movement Time)<span class="math inline">\(MT = a + b*ID(secs)\)</span><ul><li>一般性计算，可使用a=50,b=150(单位是毫秒)</li></ul></li><li>性能指数(Index of Performance)<span class="math inline">\(IP = ID/MT(bits/sec)\)</span></li></ul><p>应用：</p><ul><li>缩短当前位置到目标区域的距离<ul><li>出现在用户正在操作的对象旁边的控制菜单（右键菜单）比下拉菜单或工具栏可以被打开得更快，因为不需要移动到屏幕的其他位置。</li></ul></li><li>增大目标大小以缩短定位时间<strong>评估技术：（1）观察用户（2）询问用户意见（3）询问专家意见（4）用户测试：测试用户的执行情况（5）基于模型和理论：预测界面的有效性（GOMS模型）</strong><ul><li>屏幕的边和角很适合放置像菜单栏和按钮这样的元素，因为边角是巨大的目标，它们无限高或无限宽，鼠标无法越过他们。</li></ul></li></ul><h2 id="评估与测试">9 评估与测试</h2><ul><li><strong>评估的定义：（1）</strong>系统化的数据搜集过程<strong>（2）</strong>目的是了解用户或用户组在特定环境中，使用产品执行特定任务的情况。保证整个产品开发过程都能考虑用户的需要。</li><li><strong>评估的目标：（1）</strong>评估系统功能的范围和可达性（有用、效率)<strong>（2）</strong>评估交互中用户的体验（交互的所有方面)<strong>（3）</strong>确定系统的某些特定问</li></ul><h3 id="评估范型">评估范型：</h3><ul><li><strong>（1）快速评估：</strong>设计人员非正式地向用户或顾问了解反馈信息，以证实设计构思是否符合用户需要，可在任何阶段进行，强调“快速了解”，而非仔细记录研究发现，得到的数据通常是非正式、叙述性的，是设计网站时常用的方法</li><li><strong>（2）可用性测试：</strong>在评估人员的密切控制之下实行的，评测典型用户执行典型任务（用户出错次数、完成任务的时间）时，量化表示用户的执行情况的方法。其缺点是：测试用户的数量通常较少，不适合进行细致的统计分析</li><li><strong>（3）实地研究：基本特征：</strong>在自然工作环境中进行<strong>目的：</strong>理解用户实际工作情形以及技术对他们的影响<strong>作用：</strong>探索新技术的应用契机，确定产品的需求，促进技术的引入，评估技术的应用<strong>分类：</strong>评测人员也可作为“局外人”、“局内人”或测试用户</li><li><strong>（4）预测性评估：</strong>专家们根据自己对典型用户的了解（通常使用启发式过程）预测可用性问题，其基本特征是，用户可以不在场，使得整个过程快速、成本较低。</li><li><strong>评估技术</strong>：（1）观察用户（2）询问用户意见（3）询问专家意见（4）用户测试：测试用户的执行情况（5）基于模型和理论：预测界面的有效性（GOMS模型）</li><li><strong>DECIDE评估框架：</strong>（1）<strong>确定</strong>评估需要完成的总体目标（Determine)（2）<strong>发掘</strong>需要回答的具体问题(Explorer）（3）<strong>选择</strong>用于回答具体问题的评估范型和技术(Choose)（4）<strong>标识</strong>必须解决的实际问题，如测试用户的选择(ldentity)（5）<strong>决定</strong>如何处理有关道德的问题（Decide）（6）<strong>评估</strong>解释并表示数据（Evaluate）</li></ul><h3 id="可用性问题分级">可用性问题分级：</h3><ul><li><p>基于量化数据的分级</p></li><li><p>问题严重性的主观打分，取平均值</p></li><li><p>可用性分级的两个因素：多少用户会遇到这个问题、用户受该问题影响的程度</p></li><li><p>该问题只在第一次使用时出现，还是会 永远出现</p></li><li><p>评估技术-询问用户和专家：访谈、问卷调查、认知走查、启发式评估</p></li></ul><h3 id="nielsen的十条启发式规则">Nielsen的十条启发式规则：</h3><ol type="1"><li><strong>系统状态可见</strong></li><li><strong>系统与现实世界的匹配</strong></li><li><strong>用户可控性/用户自由</strong></li><li><strong>统一和标准</strong></li><li><strong>防错性</strong></li><li><strong>识别胜于回忆</strong></li><li><strong>使用起来灵活高效</strong></li><li><strong>美观简洁</strong></li><li><strong>帮助用户识别、诊断和从错误中恢复</strong></li><li><strong>帮助和文档</strong></li></ol><h3id="适用于评估商务网站的启发式评估">适用于评估商务网站的启发式评估：</h3><ol type="1"><li>高质量内容（High-quality content）</li><li>时时更新（Often Updated）</li><li>最小下载时间（Minimal download time）</li><li>易用（Ease of use）</li><li>符合用户需要（Relevant to users’ needs）</li><li>在线媒体的唯一性（Unique to the online medium）</li><li>网络化的企业文化（Netcentric corporate culture）</li></ol><h3 id="评估技术-用户观察">评估技术-用户观察：</h3><ul><li>直接观察：实验室观察、现场观察</li><li>间接观察：日志和交互记录</li><li>数据记录：纸笔、音视频、日志和交互记录</li><li>数据分析：定性分析、定量分析</li></ul><h3 id="评估技术-用户测试"><strong>评估技术-用户测试：</strong></h3><ul><li>以MEDLINEplus为例，在对MEDLINEplus网站进行启发式评价后，发现了可用性问题，对网站做了修改，现计划对网站进行用户测试</li><li><strong>（1）定义目标和问题：</strong>信息分类方法是否有效，用户能否进退自如并且找到需要的信息</li><li><strong>（2）选择参与者：</strong>通过问卷了解年龄、使用互联网的经验、查找医药信息的频度，挑选每个月使用互联网超过两次的人员</li><li><strong>（3）设计测试任务：</strong>问题选自网站用户最经常提出的一些问题，设计了5项任务，任务1:查找信息，了解肩膀上的黑痣有没有可能是皮肤癌，任务2:查找信息，了解是否有丙肝疫苗，进行了小规模试验以确定任务的有效性</li><li><strong>（4）明确测试步骤：</strong>准备统一的说明稿，分为五个部分，以保证每个参与者都得到相同的信息和相同的对待，测试在实验室环境中进行。</li><li><strong>（5）数据收集：</strong>评估小组事先设定了成功完成每项任务的标准，记录用户执行任务的全过程，<strong>数据来源：</strong>根据录像和交互记录计算用户执行任务的时间问卷调查和询问阶段搜集到的数据<strong>数据列表：</strong>开始时间及完成时间，搜索时访问的网页及数量，搜索时访问的医药文献，用户的搜索路径，用户的负面评论和特殊的操作习惯，用户满意度问卷调查数据。</li><li><strong>（6）数据分析：网站的结构</strong>，如专栏的安排、菜单的深度和链接的组织等，<strong>浏览的有效性</strong>，如菜单的使用、文字密度。<strong>搜索特征</strong>，如搜索界面、提示、术语的使用是否满足一致性要求。</li><li><strong>（7）总结、报告测试结果：主要问题是：</strong>访问外部网站较为困难。<strong>分析搜索过程：</strong>有几位参与者在“健康话题”中查找不同类型的癌症时遇到了困难。<strong>问卷调查结果：</strong>参与者对MEDLINEplus的评价是中性的非常易学，但不易于使用，在返回前一个屏幕时会遇到问题。</li></ul><h1 id="扫描">扫描</h1><figure><img src="%E6%89%AB%E6%8F%8F1.png" alt="扫描1" /><figcaption aria-hidden="true">扫描1</figcaption></figure><figure><img src="%E6%89%AB%E6%8F%8F2.png" alt="扫描2" /><figcaption aria-hidden="true">扫描2</figcaption></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人机交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建果蔬识别系统</title>
      <link href="/2023/12/17/44/"/>
      <url>/2023/12/17/44/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="构建果蔬识别系统">构建果蔬识别系统</h1><p>这是软件研讨课的个人项目作业。</p><h2 id="简介">简介</h2><p>这个项目旨在使用深度学习技术构建一个果蔬识别系统，能够识别各种不同类型的水果和蔬菜。系统通过图像数据集进行训练，使用卷积神经网络（CNN）进行图像分类，最终能够准确识别并区分不同种类的水果和蔬菜。</p><h2 id="开发环境与技术">开发环境与技术</h2><h3 id="开发环境">开发环境</h3><ol type="1"><li>Python编程语言</li><li>TensorFlow和Keras深度学习框架</li><li>相关Python库（如NumPy、Matplotlib等）</li></ol><h3 id="技术">技术</h3><ol type="1"><li><p>卷积神经网络（CNN）</p></li><li><p>图像数据预处理与增强</p></li><li><p>数据集拆分与训练验证集划分</p></li><li><p>模型训练与评估</p></li><li><p>数据增强</p></li></ol><p><img src="image-20231217171013668.png" alt="image-20231217171013668" style="zoom:50%;" /></p><h2 id="功能介绍">功能介绍</h2><p>图像识别：能够识别并分类不同种类的水果和蔬菜。训练与评估：使用数据集进行模型训练，并评估模型在测试集上的准确性。预测展示：能够展示模型对测试图像的识别结果，并显示识别的置信度。</p><h2 id="构建模型">构建模型</h2><h3 id="model-summary">Model Summary</h3><table><thead><tr class="header"><th>Layer (type)</th><th>Output Shape</th><th>Param #</th></tr></thead><tbody><tr class="odd"><td>Sequential</td><td>(None, 180, 180, 3)</td><td>0</td></tr><tr class="even"><td>Rescaling</td><td>(None, 180, 180, 3)</td><td>0</td></tr><tr class="odd"><td>Conv2D</td><td>(None, 180, 180, 8)</td><td>224</td></tr><tr class="even"><td>AveragePooling2D</td><td>(None, 90, 90, 8)</td><td>0</td></tr><tr class="odd"><td>Conv2D</td><td>(None, 90, 90, 16)</td><td>1168</td></tr><tr class="even"><td>AveragePooling2D</td><td>(None, 45, 45, 16)</td><td>0</td></tr><tr class="odd"><td>Conv2D</td><td>(None, 45, 45, 32)</td><td>4640</td></tr><tr class="even"><td>AveragePooling2D</td><td>(None, 22, 22, 32)</td><td>0</td></tr><tr class="odd"><td>Conv2D</td><td>(None, 11, 11, 64)</td><td>18496</td></tr><tr class="even"><td>AveragePooling2D</td><td>(None, 5, 5, 64)</td><td>0</td></tr><tr class="odd"><td>Dropout</td><td>(None, 5, 5, 64)</td><td>0</td></tr><tr class="even"><td>Flatten</td><td>(None, 1600)</td><td>0</td></tr><tr class="odd"><td>Dense</td><td>(None, 64)</td><td>102464</td></tr><tr class="even"><td>Dense (outputs)</td><td>(None, 12)</td><td>780</td></tr></tbody></table><p>Total params: 127,772 (499.11 KB) Trainable params: 127,772 (499.11KB) Non-trainable params: 0 (0.00 Byte)</p><p><img src="image-20231217170902275.png" alt="image-20231217170902275" style="zoom:50%;" /></p><h2 id="训练过程">训练过程</h2><p><img src="image-20231217170829815.png" style="zoom:50%;" /></p><p>再训练下去就会过拟合了……</p><h2 id="结果">结果</h2><p><img src="image-20231217171053274.png" alt="image-20231217171053274" style="zoom: 50%;" /></p><p><img src="image-20231217171116333.png" alt="image-20231217171116333" style="zoom:50%;" /></p><p><img src="image-20231217171134529.png" alt="image-20231217171134529" style="zoom:50%;" /></p><p><img src="image-20231217171154662.png" alt="image-20231217171154662" style="zoom:50%;" /></p><p><img src="image-20231217171212600.png" alt="image-20231217171212600" style="zoom:50%;" /></p><p><img src="image-20231217171220286.png" alt="image-20231217171220286" style="zoom:50%;" /></p><p>最后在测试集验证正确率最高也就60%，尝试了调整参数或者增加模型层次，但是只有负优化，不是很理解怎么改进……</p><h2 id="代码">代码</h2><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> PIL<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras<span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers<span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Sequential<span class="hljs-keyword">import</span> pathlib<span class="hljs-keyword">import</span> os<span class="hljs-comment"># %% 导入数据</span>data_dir = <span class="hljs-string">u&#x27;data/image_data&#x27;</span>data_dir = pathlib.Path(data_dir).with_suffix(<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(data_dir))<span class="hljs-comment"># %% 参数</span>batch_size = <span class="hljs-number">32</span>img_height = <span class="hljs-number">180</span>img_width = <span class="hljs-number">180</span>train_ds = tf.keras.utils.image_dataset_from_directory(    data_dir,    validation_split=<span class="hljs-number">0.2</span>,    subset=<span class="hljs-string">&quot;training&quot;</span>,    seed=<span class="hljs-number">123</span>,    image_size=(img_height, img_width),    batch_size=batch_size)val_ds = tf.keras.utils.image_dataset_from_directory(    data_dir,    validation_split=<span class="hljs-number">0.2</span>,    subset=<span class="hljs-string">&quot;validation&quot;</span>,    seed=<span class="hljs-number">123</span>,    image_size=(img_height, img_width),    batch_size=batch_size)class_names = train_ds.class_names<span class="hljs-built_in">print</span>(class_names)<span class="hljs-comment"># %% 可视化</span><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pltplt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> train_ds.take(<span class="hljs-number">1</span>):    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):        ax = plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)        plt.imshow(images[i].numpy().astype(<span class="hljs-string">&quot;uint8&quot;</span>))        plt.title(class_names[labels[i]])        plt.axis(<span class="hljs-string">&quot;off&quot;</span>)plt.show()<span class="hljs-keyword">for</span> image_batch, labels_batch <span class="hljs-keyword">in</span> train_ds:    <span class="hljs-built_in">print</span>(image_batch.shape)    <span class="hljs-built_in">print</span>(labels_batch.shape)    <span class="hljs-keyword">break</span><span class="hljs-comment"># %%</span>AUTOTUNE = tf.data.AUTOTUNEtrain_ds = train_ds.cache().shuffle(<span class="hljs-number">1000</span>).prefetch(buffer_size=AUTOTUNE)val_ds = val_ds.cache().prefetch(buffer_size=AUTOTUNE)normalization_layer = layers.Rescaling(<span class="hljs-number">1.</span> / <span class="hljs-number">255</span>)normalized_ds = train_ds.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: (normalization_layer(x), y))image_batch, labels_batch = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(normalized_ds))first_image = image_batch[<span class="hljs-number">0</span>]<span class="hljs-comment"># Notice the pixel values are now in `[0,1]`.</span><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">min</span>(first_image), np.<span class="hljs-built_in">max</span>(first_image))<span class="hljs-comment"># %% 数据增强</span>num_classes = <span class="hljs-built_in">len</span>(class_names)data_augmentation = keras.Sequential(    [        layers.RandomFlip(<span class="hljs-string">&quot;horizontal&quot;</span>,                          input_shape=(img_height,                                       img_width,                                       <span class="hljs-number">3</span>)),        layers.RandomRotation(<span class="hljs-number">0.1</span>),        layers.RandomZoom(<span class="hljs-number">0.1</span>),    ])plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<span class="hljs-keyword">for</span> images, _ <span class="hljs-keyword">in</span> train_ds.take(<span class="hljs-number">1</span>):    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):        augmented_images = data_augmentation(images)        ax = plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)        plt.imshow(augmented_images[<span class="hljs-number">0</span>].numpy().astype(<span class="hljs-string">&quot;uint8&quot;</span>))        plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<span class="hljs-comment"># %% 新神经网络</span>model = Sequential([    data_augmentation,    layers.Rescaling(<span class="hljs-number">1.</span> / <span class="hljs-number">255</span>),    layers.Conv2D(<span class="hljs-number">8</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>, strides=<span class="hljs-number">1</span>),    layers.AveragePooling2D(),    layers.Conv2D(<span class="hljs-number">16</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>, strides=<span class="hljs-number">1</span>),    layers.AveragePooling2D(),    layers.Conv2D(<span class="hljs-number">32</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>, strides=<span class="hljs-number">1</span>),    layers.AveragePooling2D(),    layers.Conv2D(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>, strides=<span class="hljs-number">2</span>),    layers.AveragePooling2D(),    layers.Dropout(<span class="hljs-number">0.5</span>),    layers.Flatten(),    layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>),    layers.Dense(num_classes, name=<span class="hljs-string">&quot;outputs&quot;</span>)])model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">True</span>),              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])model.summary()tf.keras.utils.plot_model(model, show_shapes=<span class="hljs-literal">True</span>)<span class="hljs-comment">#%% 训练</span>epochs = <span class="hljs-number">15</span>history = model.fit(    train_ds,    validation_data=val_ds,    epochs=epochs)<span class="hljs-comment"># 可视化</span>acc = history.history[<span class="hljs-string">&#x27;accuracy&#x27;</span>]val_acc = history.history[<span class="hljs-string">&#x27;val_accuracy&#x27;</span>]loss = history.history[<span class="hljs-string">&#x27;loss&#x27;</span>]val_loss = history.history[<span class="hljs-string">&#x27;val_loss&#x27;</span>]epochs_range = <span class="hljs-built_in">range</span>(epochs)plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)plt.plot(epochs_range, acc, label=<span class="hljs-string">&#x27;Training Accuracy&#x27;</span>)plt.plot(epochs_range, val_acc, label=<span class="hljs-string">&#x27;Validation Accuracy&#x27;</span>)plt.legend(loc=<span class="hljs-string">&#x27;lower right&#x27;</span>)plt.title(<span class="hljs-string">&#x27;Training and Validation Accuracy&#x27;</span>)plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)plt.plot(epochs_range, loss, label=<span class="hljs-string">&#x27;Training Loss&#x27;</span>)plt.plot(epochs_range, val_loss, label=<span class="hljs-string">&#x27;Validation Loss&#x27;</span>)plt.legend(loc=<span class="hljs-string">&#x27;upper right&#x27;</span>)plt.title(<span class="hljs-string">&#x27;Training and Validation Loss&#x27;</span>)plt.show()<span class="hljs-comment">#%% 预测测试</span>test_path = <span class="hljs-string">&#x27;data/test_image_data&#x27;</span>batch_size = <span class="hljs-number">32</span>img_height = <span class="hljs-number">180</span>img_width = <span class="hljs-number">180</span>test_ds = tf.keras.utils.image_dataset_from_directory(    test_path,    validation_split=<span class="hljs-number">0.2</span>,    subset=<span class="hljs-string">&quot;training&quot;</span>,    seed=<span class="hljs-number">123</span>,    image_size=(img_height, img_width),    batch_size=batch_size)class_names = test_ds.class_names<span class="hljs-built_in">print</span>(class_names)<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npcorrect_predictions = <span class="hljs-number">0</span>total_predictions = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> test_ds:    predictions = model.predict(images)    predicted_labels = np.argmax(predictions, axis=<span class="hljs-number">1</span>)    correct_predictions += np.<span class="hljs-built_in">sum</span>(predicted_labels == labels)    total_predictions += <span class="hljs-built_in">len</span>(labels)    <span class="hljs-comment"># print(np.sum(predicted_labels == labels)/len(labels))</span>accuracy = correct_predictions / total_predictions<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy on test set: &#123;:.2%&#125;&quot;</span>.<span class="hljs-built_in">format</span>(accuracy))<span class="hljs-comment">#%% 预测绘制img</span><span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> test_ds.take(<span class="hljs-number">1</span>):    predictions = model.predict(images)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(images)):        img = images[i]        prediction = predictions[i]        score = tf.nn.softmax(prediction)        plt.figure()        plt.imshow(img.numpy().astype(<span class="hljs-string">&quot;uint8&quot;</span>))        plt.axis(<span class="hljs-string">&quot;off&quot;</span>)        plt.title(<span class="hljs-string">&quot;Predicted: &#123;&#125; Truth: &#123;&#125; (Confidence: &#123;:.2f&#125;%)&quot;</span>.<span class="hljs-built_in">format</span>(class_names[np.argmax(score)], class_names[labels[i]], <span class="hljs-number">100</span> * np.<span class="hljs-built_in">max</span>(score)))        plt.show()    <span class="hljs-comment"># %%</span></code></pre></div><h2 id="参考文献">参考文献</h2><p>TensorFlow官方文档: <ahref="https://www.tensorflow.org/api_docs">TensorFlowDocumentation</a></p><p>Keras官方文档: <a href="https://keras.io/api/">KerasDocumentation</a></p><p>NumPy官方文档: <a href="https://numpy.org/doc/">NumPyDocumentation</a></p><p>Matplotlib官方文档: <ahref="https://matplotlib.org/stable/contents.html">MatplotlibDocumentation</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CNN </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> tensorflow </tag>
            
            <tag> 数据增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNKI知网爬虫 &amp; Python</title>
      <link href="/2023/12/06/43/"/>
      <url>/2023/12/06/43/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="cnki知网爬虫-python">CNKI知网爬虫 &amp; Python</h1><p>当涉及从CNKI（中国知网）获取数据时，编写一个网络爬虫以收集信息可能是个不错的选择。这篇博客将指导您如何使用Python和Selenium库编写一个简单的爬虫，从CNKI网站上检索关于特定主题的论文信息。</p><h2 id="特点">特点</h2><ul><li>根据指定关键词在 CNKI 进行论文搜索。</li><li>提取信息包括标题、作者、摘要、出版详情等。</li><li>支持多线程以提高检索速度。</li><li>将提取的信息保存到指定文件中（在这种情况下是一个 TSV 文件）。</li><li><strong>若存在指定文件将最后一行编号开始查询（可以随时关闭程序，下次接着爬取）。</strong></li><li>异常处理以确保稳健性。</li></ul><h2 id="利用python编写cnki知网爬虫">利用Python编写CNKI知网爬虫</h2><p>中国知网（CNKI）是一个知名的学术资源库，它提供了丰富的学术文献、期刊和论文。为了从CNKI获取数据，我们将使用Python编写一个简单但功能强大的网络爬虫。</p><p>因为知网的频繁的更新，以及目录是动态加载的，<del>而我不会找包</del>，还有听说知网有严厉的反爬机制。用传统的<code>response = requests.get(url)</code>爬取论文信息是不太可能的。</p><p>我查找了一些资料，先尝试查了GitHub上有没有现成的</p><p><ahref="https://github.com/qiuqingyu/CNKICrawler">qiuqingyu/CNKICrawler:中国知网爬虫</a>、<ahref="https://github.com/yanzhou/CnkiSpider">yanzhou/CnkiSpider:中国知网爬虫</a>，两个排名比较高的项目因为年久失修不能使用了……</p><p><ahref="https://github.com/aFlyBird0/CnkiSpider">aFlyBird0/CnkiSpider:知网爬虫，专利、论文项目</a>这个是2021年的，新一些，但是我没有尝试。</p><p>以及我只想要一个能运行的轻量级一点的爬虫，我几乎想要放弃了，但之后Bing，发现了CSDN和知乎有一些不算长的脚本就能爬。然后就认识了Selenium的强大。</p><p><ahref="https://zhuanlan.zhihu.com/p/599579339">这篇知乎文章</a>代码我只能跑通一部分，但是已经看到了能实现的眉目。<ahref="https://zhuanlan.zhihu.com/p/663793038">作者的另一篇介绍</a>让我了解了selenium的Xpath怎么用怎么获取。</p><p>缺点就是比较慢，而且加载网页会置顶浏览器，导致跑代码的时候干其他事情不太方便。</p><h3 id="准备工作">准备工作</h3><p>首先，确保您已经安装了Python并安装了必要的库。我们将使用Selenium来模拟浏览器行为，从而检索和提取我们感兴趣的信息。</p><h3 id="代码实现">代码实现</h3><p>以下是一个简化的示例代码，展示了如何使用Python和Selenium进行基本的CNKI知网爬取：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_info</span>(<span class="hljs-params">driver, xpath</span>):</span>    <span class="hljs-keyword">try</span>:        element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, xpath)))        <span class="hljs-keyword">return</span> element.text    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span><span class="hljs-comment"># 以上是一个简要的函数，展示了如何使用Python和Selenium进行基本的CNKI知网爬取。</span></code></pre></div><p>selenium其实就是操控（Driver）一个浏览器，点击、填写、获取文本等。这其实就是一个自动化脚本而已。</p><h3 id="实现步骤">实现步骤</h3><ol type="1"><li><strong>设置环境</strong>：确保您已经安装了Python和Selenium库，并配置了WebDriver（例如ChromeWebDriver或Edge WebDriver）。</li><li><strong>编写代码</strong>：使用Python编写爬虫代码，包括模拟浏览器行为（例如页面导航、关键字搜索等）和信息提取（例如论文标题、作者、摘要等）。</li><li><strong>测试和调试</strong>：运行您的代码并测试其功能。确保它可以成功地检索到您感兴趣的信息。</li><li><strong>优化和扩展</strong>：根据需要优化代码，处理异常情况并扩展其功能。您可以添加多线程支持以加快爬取速度，或者保存数据到文件或数据库中。</li></ol><h3 id="接下来的步骤">接下来的步骤</h3><p>这只是一个入门级的示例，您可以根据需要扩展它。您可能想要添加更多功能，例如多线程支持、数据持久化、自动化登录等。同时，还请确保您的爬虫行为是合法的，遵守网站的使用条款和规定。</p><p>我修改了<ahref="https://zhuanlan.zhihu.com/p/599579339">这篇知乎文章</a>的代码，重新更改了一些Xpath，并加上自己的逻辑。</p><blockquote><p>代码不再维护，含有一些问题，最新代码见下文</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> concurrent.futures<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="hljs-keyword">import</span> DesiredCapabilities<span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<span class="hljs-keyword">import</span> os<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">webserver</span>():</span>    <span class="hljs-comment"># get直接返回，不再等待界面加载完成</span>    desired_capabilities = DesiredCapabilities.EDGE    desired_capabilities[<span class="hljs-string">&quot;pageLoadStrategy&quot;</span>] = <span class="hljs-string">&quot;none&quot;</span>    <span class="hljs-comment"># 设置微软驱动器的环境</span>    options = webdriver.EdgeOptions()    <span class="hljs-comment"># 设置浏览器不加载图片，提高速度</span>    options.add_experimental_option(<span class="hljs-string">&quot;prefs&quot;</span>, &#123;<span class="hljs-string">&quot;profile.managed_default_content_settings.images&quot;</span>: <span class="hljs-number">2</span>&#125;)    <span class="hljs-comment"># 创建一个微软驱动器</span>    driver = webdriver.Edge(options=options)    <span class="hljs-keyword">return</span> driver<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_page</span>(<span class="hljs-params">driver, keyword</span>):</span>    <span class="hljs-comment"># 打开页面，等待两秒</span>    driver.get(<span class="hljs-string">&quot;https://kns.cnki.net/kns8/AdvSearch&quot;</span>)    time.sleep(<span class="hljs-number">2</span>)    <span class="hljs-comment"># 修改属性，使下拉框显示</span>    opt = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;div.sort-list&#x27;</span>)  <span class="hljs-comment"># 定位元素</span>    driver.execute_script(<span class="hljs-string">&quot;arguments[0].setAttribute(&#x27;style&#x27;, &#x27;display: block;&#x27;)&quot;</span>, opt)  <span class="hljs-comment"># 执行 js 脚本进行属性的修改；arguments[0]代表第一个属性</span>    <span class="hljs-comment"># 鼠标移动到下拉框中的[通讯作者]</span>    ActionChains(driver).move_to_element(driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;li[data-val=&quot;RP&quot;]&#x27;</span>)).perform()    <span class="hljs-comment"># # 找到[关键词]选项并点击</span>    <span class="hljs-comment"># WebDriverWait(driver, 100).until(</span>    <span class="hljs-comment">#     EC.visibility_of_element_located((By.CSS_SELECTOR, &#x27;li[data-val=&quot;KY&quot;]&#x27;))).click()</span>    <span class="hljs-comment"># 传入关键字</span>    WebDriverWait(driver, <span class="hljs-number">100</span>).until(        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;gradetxt&quot;]/dd[1]/div[2]/input&#x27;&#x27;&#x27;</span>))    ).send_keys(keyword)    <span class="hljs-comment"># 点击搜索</span>    WebDriverWait(driver, <span class="hljs-number">100</span>).until(        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;ModuleSearch&quot;]/div[1]/div/div[2]/div/div[1]/div[1]/div[2]/div[3]/input&#x27;&#x27;&#x27;</span>))    ).click()    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在搜索，请稍后...&quot;</span>)    <span class="hljs-comment"># # 点击切换中文文献</span>    <span class="hljs-comment"># WebDriverWait(driver, 100).until(</span>    <span class="hljs-comment">#     EC.presence_of_element_located((By.XPATH, &quot;/html/body/div[3]/div[1]/div/div/div/a[1]&quot;))</span>    <span class="hljs-comment"># ).click()</span>    <span class="hljs-comment"># 获取总文献数和页数</span>    res_unm = WebDriverWait(driver, <span class="hljs-number">100</span>).until(EC.presence_of_element_located(        (By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;countPageDiv&quot;]/span[1]/em&#x27;&#x27;&#x27;</span>))    ).text    <span class="hljs-comment"># 去除千分位里的逗号</span>    res_unm = <span class="hljs-built_in">int</span>(res_unm.replace(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>))    page_unm = <span class="hljs-built_in">int</span>(res_unm / <span class="hljs-number">20</span>) + <span class="hljs-number">1</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;共找到 <span class="hljs-subst">&#123;res_unm&#125;</span> 条结果, <span class="hljs-subst">&#123;page_unm&#125;</span> 页。&quot;</span>)    <span class="hljs-keyword">return</span> res_unm<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_info</span>(<span class="hljs-params">driver, xpath</span>):</span>    <span class="hljs-keyword">try</span>:        element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, xpath)))        <span class="hljs-keyword">return</span> element.text    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_choose_info</span>(<span class="hljs-params">driver, xpath1, xpath2, <span class="hljs-built_in">str</span></span>):</span>    <span class="hljs-keyword">try</span>:         <span class="hljs-keyword">if</span> WebDriverWait(driver, <span class="hljs-number">1</span>).until(EC.presence_of_element_located((By.XPATH, xpath1))).text==<span class="hljs-built_in">str</span>:            <span class="hljs-keyword">return</span> WebDriverWait(driver, <span class="hljs-number">1</span>).until(EC.presence_of_element_located((By.XPATH, xpath2))).text        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span>    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl</span>(<span class="hljs-params">driver, papers_need, theme</span>):</span>    count = <span class="hljs-number">1</span>    file_path = <span class="hljs-string">f&quot;CNKI_<span class="hljs-subst">&#123;theme&#125;</span>.tsv&quot;</span>    <span class="hljs-keyword">if</span> os.path.exists(file_path) <span class="hljs-keyword">and</span> os.path.getsize(file_path) &gt; <span class="hljs-number">0</span>:        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> file:            lines = file.readlines()            last_line = lines[-<span class="hljs-number">1</span>].strip()            count = <span class="hljs-built_in">int</span>(last_line.split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((count-<span class="hljs-number">1</span>) // <span class="hljs-number">20</span>):        <span class="hljs-comment"># 切换到下一页</span>        time.sleep(<span class="hljs-number">3</span>)        WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;//*[@id=&#x27;PageNext&#x27;]&quot;</span>))).click()    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;从第 <span class="hljs-subst">&#123;count&#125;</span> 条开始爬取\n&quot;</span>)    <span class="hljs-comment"># 当爬取数量小于需求时，循环网页页码</span>    <span class="hljs-keyword">while</span> count &lt;= papers_need:        <span class="hljs-comment"># 等待加载完全，休眠3S</span>        time.sleep(<span class="hljs-number">3</span>)        title_list = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_all_elements_located((By.CLASS_NAME, <span class="hljs-string">&quot;fz14&quot;</span>)))        <span class="hljs-comment"># 循环网页一页中的条目</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((count-<span class="hljs-number">1</span>) % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>, <span class="hljs-number">21</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n###正在爬取第 <span class="hljs-subst">&#123;count&#125;</span> 条(本页第<span class="hljs-subst">&#123;i&#125;</span>条)#######################################\n&quot;</span>)            <span class="hljs-keyword">try</span>:                term = (count-<span class="hljs-number">1</span>) % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>  <span class="hljs-comment"># 本页的第几个条目</span>                                <span class="hljs-comment"># 获取基础信息</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取基础信息...&#x27;</span>)                title_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[2]&#x27;&#x27;&#x27;</span>                author_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[3]&#x27;&#x27;&#x27;</span>                source_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[4]&#x27;&#x27;&#x27;</span>                date_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[5]&#x27;&#x27;&#x27;</span>                database_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[6]&#x27;&#x27;&#x27;</span>                quote_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[7]&#x27;&#x27;&#x27;</span>                download_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[8]&#x27;&#x27;&#x27;</span>                xpaths = [title_xpath, author_xpath, source_xpath, date_xpath, database_xpath, quote_xpath, download_xpath]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    future_elements = [executor.submit(get_info, driver, xpath) <span class="hljs-keyword">for</span> xpath <span class="hljs-keyword">in</span> xpaths]                title, authors, source, date, database, quote, download = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> future_elements]                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> quote.isdigit():                    quote = <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> download.isdigit():                    download = <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;title&#125;</span> <span class="hljs-subst">&#123;authors&#125;</span> <span class="hljs-subst">&#123;source&#125;</span> <span class="hljs-subst">&#123;date&#125;</span> <span class="hljs-subst">&#123;database&#125;</span> <span class="hljs-subst">&#123;quote&#125;</span> <span class="hljs-subst">&#123;download&#125;</span>\n&quot;</span>)                               <span class="hljs-comment"># 点击条目</span>                title_list[i-<span class="hljs-number">1</span>].click()                                <span class="hljs-comment"># 获取driver的句柄</span>                n = driver.window_handles                                <span class="hljs-comment"># driver切换至最新生产的页面</span>                driver.switch_to.window(n[-<span class="hljs-number">1</span>])                time.sleep(<span class="hljs-number">3</span>)                                <span class="hljs-comment"># 开始获取页面信息</span>                <span class="hljs-comment"># 点击展开</span>                <span class="hljs-keyword">try</span>:                    WebDriverWait(driver, <span class="hljs-number">10</span>).until(                        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;ChDivSummaryMore&quot;]&#x27;&#x27;&#x27;</span>))                    ).click()                <span class="hljs-keyword">except</span>:                    <span class="hljs-keyword">pass</span>                                <span class="hljs-comment"># 获取作者单位</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取institute...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    institute = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[3]/div/h3[2]&quot;</span>))).text                <span class="hljs-keyword">except</span>:                    institute = <span class="hljs-string">&#x27;无&#x27;</span>                <span class="hljs-built_in">print</span>(institute+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取摘要、关键词、专辑、专题</span>                <span class="hljs-comment"># 获取摘要</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取abstract...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    abstract = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.CLASS_NAME, <span class="hljs-string">&quot;abstract-text&quot;</span>))).text                <span class="hljs-keyword">except</span>:                    abstract = <span class="hljs-string">&#x27;无&#x27;</span>                <span class="hljs-built_in">print</span>(abstract+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取关键词</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取keywords...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    keywords = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.CLASS_NAME, <span class="hljs-string">&quot;keywords&quot;</span>))).text[:-<span class="hljs-number">1</span>]                <span class="hljs-keyword">except</span>:                    keywords = <span class="hljs-string">&#x27;无&#x27;</span>                      <span class="hljs-built_in">print</span>(keywords+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取专辑</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取publication...&#x27;</span>)                xpaths = [                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[1]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[1]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[1]/p&quot;</span>)                ]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    futures = [executor.submit(get_choose_info, driver, xpath1, xpath2, <span class="hljs-string">&#x27;专辑：&#x27;</span>) <span class="hljs-keyword">for</span> xpath1, xpath2 <span class="hljs-keyword">in</span> xpaths]                    results = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures)]                publication = <span class="hljs-built_in">next</span>((result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results <span class="hljs-keyword">if</span> result != <span class="hljs-string">&#x27;无&#x27;</span>), <span class="hljs-string">&#x27;无&#x27;</span>)                <span class="hljs-built_in">print</span>(publication+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取专题</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取topic...&#x27;</span>)                xpaths = [                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[3]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[3]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[3]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[3]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[2]/p&quot;</span>)                ]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    futures = [executor.submit(get_choose_info, driver, xpath1, xpath2, <span class="hljs-string">&#x27;专题：&#x27;</span>) <span class="hljs-keyword">for</span> xpath1, xpath2 <span class="hljs-keyword">in</span> xpaths]                    results = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures)]                topic = <span class="hljs-built_in">next</span>((result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results <span class="hljs-keyword">if</span> result != <span class="hljs-string">&#x27;无&#x27;</span>), <span class="hljs-string">&#x27;无&#x27;</span>)                <span class="hljs-built_in">print</span>(topic+<span class="hljs-string">&#x27;\n&#x27;</span>)                                url = driver.current_url                                <span class="hljs-comment"># 获取下载链接</span>                <span class="hljs-comment"># link = WebDriverWait( driver, 10 ).until( EC.presence_of_all_elements_located((By.CLASS_NAME  ,&quot;btn-dlcaj&quot;) ) )[0].get_attribute(&#x27;href&#x27;)</span>                <span class="hljs-comment"># link = urljoin(driver.current_url, link)</span>                <span class="hljs-comment"># 写入文件</span>                res = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;count&#125;</span>\t<span class="hljs-subst">&#123;title&#125;</span>\t<span class="hljs-subst">&#123;authors&#125;</span>\t<span class="hljs-subst">&#123;institute&#125;</span>\t<span class="hljs-subst">&#123;date&#125;</span>\t<span class="hljs-subst">&#123;source&#125;</span>\t<span class="hljs-subst">&#123;publication&#125;</span>\t<span class="hljs-subst">&#123;topic&#125;</span>\t<span class="hljs-subst">&#123;database&#125;</span>\t<span class="hljs-subst">&#123;quote&#125;</span>\t<span class="hljs-subst">&#123;download&#125;</span>\t<span class="hljs-subst">&#123;keywords&#125;</span>\t<span class="hljs-subst">&#123;abstract&#125;</span>\t<span class="hljs-subst">&#123;url&#125;</span>&quot;</span>.replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>                <span class="hljs-keyword">try</span>:                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>) <span class="hljs-keyword">as</span> f:                        f.write(res)                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;写入失败:&#x27;</span>, <span class="hljs-built_in">str</span>(e))                    <span class="hljs-keyword">raise</span> e            <span class="hljs-keyword">except</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; 第<span class="hljs-subst">&#123;count&#125;</span> 条爬取失败\n&quot;</span>)                <span class="hljs-comment"># 跳过本条，接着下一个</span>                <span class="hljs-keyword">continue</span>                        <span class="hljs-keyword">finally</span>:                <span class="hljs-comment"># 如果有多个窗口，关闭第二个窗口， 切换回主页</span>                n2 = driver.window_handles                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n2) &gt; <span class="hljs-number">1</span>:                    driver.close()                    driver.switch_to.window(n2[<span class="hljs-number">0</span>])                <span class="hljs-comment"># 计数,判断需求是否足够</span>                count += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> count == papers_need: <span class="hljs-keyword">break</span>        <span class="hljs-comment"># 切换到下一页</span>        WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;//a[@id=&#x27;PageNext&#x27;]&quot;</span>))).click()            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取完毕！&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:        keyword = <span class="hljs-string">&quot;青少年抑郁&quot;</span>    driver = webserver()        <span class="hljs-comment"># 设置所需篇数</span>    papers_need = <span class="hljs-number">500</span>    res_unm = open_page(driver, keyword)        <span class="hljs-comment"># 判断所需是否大于总篇数</span>    papers_need = papers_need <span class="hljs-keyword">if</span> (papers_need &lt;= res_unm) <span class="hljs-keyword">else</span> res_unm        os.system(<span class="hljs-string">&quot;pause&quot;</span>)        <span class="hljs-comment"># 开始爬取</span>    crawl(driver, papers_need, keyword)    <span class="hljs-comment"># 关闭浏览器</span>    driver.close()</code></pre></div><p>总算能成功运行了，因为太慢了之后增加了并行处理，尽量加速。得到了下面这个代码，封装的多一些。</p><blockquote><p>2023/12/07 更新，修复了一些逻辑BUG、专辑专题覆盖更全。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> concurrent.futures<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="hljs-keyword">import</span> DesiredCapabilities<span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<span class="hljs-keyword">import</span> os<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">webserver</span>():</span>    <span class="hljs-comment"># get直接返回，不再等待界面加载完成</span>    desired_capabilities = DesiredCapabilities.EDGE    desired_capabilities[<span class="hljs-string">&quot;pageLoadStrategy&quot;</span>] = <span class="hljs-string">&quot;none&quot;</span>    <span class="hljs-comment"># 设置微软驱动器的环境</span>    options = webdriver.EdgeOptions()    <span class="hljs-comment"># 设置浏览器不加载图片，提高速度</span>    options.add_experimental_option(<span class="hljs-string">&quot;prefs&quot;</span>, &#123;<span class="hljs-string">&quot;profile.managed_default_content_settings.images&quot;</span>: <span class="hljs-number">2</span>&#125;)    <span class="hljs-comment"># 创建一个微软驱动器</span>    driver = webdriver.Edge(options=options)    <span class="hljs-keyword">return</span> driver<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_page</span>(<span class="hljs-params">driver, keyword</span>):</span>    <span class="hljs-comment"># 打开页面，等待两秒</span>    driver.get(<span class="hljs-string">&quot;https://kns.cnki.net/kns8/AdvSearch&quot;</span>)    time.sleep(<span class="hljs-number">2</span>)    <span class="hljs-comment"># 修改属性，使下拉框显示</span>    opt = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;div.sort-list&#x27;</span>)  <span class="hljs-comment"># 定位元素</span>    driver.execute_script(<span class="hljs-string">&quot;arguments[0].setAttribute(&#x27;style&#x27;, &#x27;display: block;&#x27;)&quot;</span>, opt)  <span class="hljs-comment"># 执行 js 脚本进行属性的修改；arguments[0]代表第一个属性</span>    <span class="hljs-comment"># 鼠标移动到下拉框中的[通讯作者]</span>    ActionChains(driver).move_to_element(driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;li[data-val=&quot;RP&quot;]&#x27;</span>)).perform()    <span class="hljs-comment"># # 找到[关键词]选项并点击</span>    <span class="hljs-comment"># WebDriverWait(driver, 100).until(</span>    <span class="hljs-comment">#     EC.visibility_of_element_located((By.CSS_SELECTOR, &#x27;li[data-val=&quot;KY&quot;]&#x27;))).click()</span>    <span class="hljs-comment"># 传入关键字</span>    WebDriverWait(driver, <span class="hljs-number">100</span>).until(        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;gradetxt&quot;]/dd[1]/div[2]/input&#x27;&#x27;&#x27;</span>))    ).send_keys(keyword)    <span class="hljs-comment"># 点击搜索</span>    WebDriverWait(driver, <span class="hljs-number">100</span>).until(        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;ModuleSearch&quot;]/div[1]/div/div[2]/div/div[1]/div[1]/div[2]/div[3]/input&#x27;&#x27;&#x27;</span>))    ).click()    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在搜索，请稍后...&quot;</span>)    <span class="hljs-comment"># # 点击切换中文文献</span>    <span class="hljs-comment"># WebDriverWait(driver, 100).until(</span>    <span class="hljs-comment">#     EC.presence_of_element_located((By.XPATH, &quot;/html/body/div[3]/div[1]/div/div/div/a[1]&quot;))</span>    <span class="hljs-comment"># ).click()</span>    <span class="hljs-comment"># 获取总文献数和页数</span>    res_unm = WebDriverWait(driver, <span class="hljs-number">100</span>).until(EC.presence_of_element_located(        (By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;countPageDiv&quot;]/span[1]/em&#x27;&#x27;&#x27;</span>))    ).text    <span class="hljs-comment"># 去除千分位里的逗号</span>    res_unm = <span class="hljs-built_in">int</span>(res_unm.replace(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>))    page_unm = <span class="hljs-built_in">int</span>(res_unm / <span class="hljs-number">20</span>) + <span class="hljs-number">1</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;共找到 <span class="hljs-subst">&#123;res_unm&#125;</span> 条结果, <span class="hljs-subst">&#123;page_unm&#125;</span> 页。&quot;</span>)    <span class="hljs-keyword">return</span> res_unm<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_info</span>(<span class="hljs-params">driver, xpath</span>):</span>    <span class="hljs-keyword">try</span>:        element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, xpath)))        <span class="hljs-keyword">return</span> element.text    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_choose_info</span>(<span class="hljs-params">driver, xpath1, xpath2, <span class="hljs-built_in">str</span></span>):</span>    <span class="hljs-keyword">try</span>:         <span class="hljs-keyword">if</span> WebDriverWait(driver, <span class="hljs-number">1</span>).until(EC.presence_of_element_located((By.XPATH, xpath1))).text==<span class="hljs-built_in">str</span>:            <span class="hljs-keyword">return</span> WebDriverWait(driver, <span class="hljs-number">1</span>).until(EC.presence_of_element_located((By.XPATH, xpath2))).text        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span>    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl</span>(<span class="hljs-params">driver, papers_need, theme</span>):</span>    count = <span class="hljs-number">1</span>    file_path = <span class="hljs-string">f&quot;CNKI_<span class="hljs-subst">&#123;theme&#125;</span>.tsv&quot;</span>    <span class="hljs-keyword">if</span> os.path.exists(file_path) <span class="hljs-keyword">and</span> os.path.getsize(file_path) &gt; <span class="hljs-number">0</span>:        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> file:            lines = file.readlines()            last_line = lines[-<span class="hljs-number">1</span>].strip()            count = <span class="hljs-built_in">int</span>(last_line.split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count // <span class="hljs-number">20</span>):        <span class="hljs-comment"># 切换到下一页</span>        time.sleep(<span class="hljs-number">3</span>)        WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;//*[@id=&#x27;PageNext&#x27;]&quot;</span>))).click()    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;从第 <span class="hljs-subst">&#123;count&#125;</span> 条开始爬取\n&quot;</span>)    <span class="hljs-comment"># 当爬取数量小于需求时，循环网页页码</span>    <span class="hljs-keyword">while</span> count &lt;= papers_need:        <span class="hljs-comment"># 等待加载完全，休眠3S</span>        time.sleep(<span class="hljs-number">3</span>)        title_list = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_all_elements_located((By.CLASS_NAME, <span class="hljs-string">&quot;fz14&quot;</span>)))        <span class="hljs-comment"># 循环网页一页中的条目</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((count-<span class="hljs-number">1</span>) % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>, <span class="hljs-number">21</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n###正在爬取第 <span class="hljs-subst">&#123;count&#125;</span> 条(本页第<span class="hljs-subst">&#123;i&#125;</span>条)#######################################\n&quot;</span>)            <span class="hljs-keyword">try</span>:                term = (count-<span class="hljs-number">1</span>) % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>  <span class="hljs-comment"># 本页的第几个条目</span>                                <span class="hljs-comment"># 获取基础信息</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取基础信息...&#x27;</span>)                title_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[2]&#x27;&#x27;&#x27;</span>                author_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[3]&#x27;&#x27;&#x27;</span>                source_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[4]&#x27;&#x27;&#x27;</span>                date_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[5]&#x27;&#x27;&#x27;</span>                database_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[6]&#x27;&#x27;&#x27;</span>                quote_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[7]&#x27;&#x27;&#x27;</span>                download_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[8]&#x27;&#x27;&#x27;</span>                xpaths = [title_xpath, author_xpath, source_xpath, date_xpath, database_xpath, quote_xpath, download_xpath]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    future_elements = [executor.submit(get_info, driver, xpath) <span class="hljs-keyword">for</span> xpath <span class="hljs-keyword">in</span> xpaths]                title, authors, source, date, database, quote, download = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> future_elements]                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> quote.isdigit():                    quote = <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> download.isdigit():                    download = <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;title&#125;</span> <span class="hljs-subst">&#123;authors&#125;</span> <span class="hljs-subst">&#123;source&#125;</span> <span class="hljs-subst">&#123;date&#125;</span> <span class="hljs-subst">&#123;database&#125;</span> <span class="hljs-subst">&#123;quote&#125;</span> <span class="hljs-subst">&#123;download&#125;</span>\n&quot;</span>)                               <span class="hljs-comment"># 点击条目</span>                title_list[i-<span class="hljs-number">1</span>].click()                                <span class="hljs-comment"># 获取driver的句柄</span>                n = driver.window_handles                                <span class="hljs-comment"># driver切换至最新生产的页面</span>                driver.switch_to.window(n[-<span class="hljs-number">1</span>])                time.sleep(<span class="hljs-number">3</span>)                                <span class="hljs-comment"># 开始获取页面信息</span>                <span class="hljs-comment"># 点击展开</span>                <span class="hljs-keyword">try</span>:                    WebDriverWait(driver, <span class="hljs-number">10</span>).until(                        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;ChDivSummaryMore&quot;]&#x27;&#x27;&#x27;</span>))                    ).click()                <span class="hljs-keyword">except</span>:                    <span class="hljs-keyword">pass</span>                                <span class="hljs-comment"># 获取作者单位</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取institute...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    institute = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[3]/div/h3[2]&quot;</span>))).text                <span class="hljs-keyword">except</span>:                    institute = <span class="hljs-string">&#x27;无&#x27;</span>                <span class="hljs-built_in">print</span>(institute+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取摘要、关键词、专辑、专题</span>                <span class="hljs-comment"># 获取摘要</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取abstract...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    abstract = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.CLASS_NAME, <span class="hljs-string">&quot;abstract-text&quot;</span>))).text                <span class="hljs-keyword">except</span>:                    abstract = <span class="hljs-string">&#x27;无&#x27;</span>                <span class="hljs-built_in">print</span>(abstract+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取关键词</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取keywords...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    keywords = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.CLASS_NAME, <span class="hljs-string">&quot;keywords&quot;</span>))).text[:-<span class="hljs-number">1</span>]                <span class="hljs-keyword">except</span>:                    keywords = <span class="hljs-string">&#x27;无&#x27;</span>                      <span class="hljs-built_in">print</span>(keywords+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取专辑</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取publication...&#x27;</span>)                xpaths = [                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[1]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[1]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[1]/p&quot;</span>)                ]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    futures = [executor.submit(get_choose_info, driver, xpath1, xpath2, <span class="hljs-string">&#x27;专辑：&#x27;</span>) <span class="hljs-keyword">for</span> xpath1, xpath2 <span class="hljs-keyword">in</span> xpaths]                    results = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures)]                publication = <span class="hljs-built_in">next</span>((result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results <span class="hljs-keyword">if</span> result != <span class="hljs-string">&#x27;无&#x27;</span>), <span class="hljs-string">&#x27;无&#x27;</span>)                <span class="hljs-built_in">print</span>(publication+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取专题</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取topic...&#x27;</span>)                xpaths = [                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[3]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[3]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[3]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[3]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[2]/p&quot;</span>)                ]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    futures = [executor.submit(get_choose_info, driver, xpath1, xpath2, <span class="hljs-string">&#x27;专题：&#x27;</span>) <span class="hljs-keyword">for</span> xpath1, xpath2 <span class="hljs-keyword">in</span> xpaths]                    results = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures)]                topic = <span class="hljs-built_in">next</span>((result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results <span class="hljs-keyword">if</span> result != <span class="hljs-string">&#x27;无&#x27;</span>), <span class="hljs-string">&#x27;无&#x27;</span>)                <span class="hljs-built_in">print</span>(topic+<span class="hljs-string">&#x27;\n&#x27;</span>)                                url = driver.current_url                                <span class="hljs-comment"># 获取下载链接</span>                <span class="hljs-comment"># link = WebDriverWait( driver, 10 ).until( EC.presence_of_all_elements_located((By.CLASS_NAME  ,&quot;btn-dlcaj&quot;) ) )[0].get_attribute(&#x27;href&#x27;)</span>                <span class="hljs-comment"># link = urljoin(driver.current_url, link)</span>                <span class="hljs-comment"># 写入文件</span>                res = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;count&#125;</span>\t<span class="hljs-subst">&#123;title&#125;</span>\t<span class="hljs-subst">&#123;authors&#125;</span>\t<span class="hljs-subst">&#123;institute&#125;</span>\t<span class="hljs-subst">&#123;date&#125;</span>\t<span class="hljs-subst">&#123;source&#125;</span>\t<span class="hljs-subst">&#123;publication&#125;</span>\t<span class="hljs-subst">&#123;topic&#125;</span>\t<span class="hljs-subst">&#123;database&#125;</span>\t<span class="hljs-subst">&#123;quote&#125;</span>\t<span class="hljs-subst">&#123;download&#125;</span>\t<span class="hljs-subst">&#123;keywords&#125;</span>\t<span class="hljs-subst">&#123;abstract&#125;</span>\t<span class="hljs-subst">&#123;url&#125;</span>&quot;</span>.replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>                <span class="hljs-keyword">try</span>:                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>) <span class="hljs-keyword">as</span> f:                        f.write(res)                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;写入失败:&#x27;</span>, <span class="hljs-built_in">str</span>(e))                    <span class="hljs-keyword">raise</span> e            <span class="hljs-keyword">except</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; 第<span class="hljs-subst">&#123;count&#125;</span> 条爬取失败\n&quot;</span>)                <span class="hljs-comment"># 跳过本条，接着下一个</span>                <span class="hljs-keyword">continue</span>                        <span class="hljs-keyword">finally</span>:                <span class="hljs-comment"># 如果有多个窗口，关闭第二个窗口， 切换回主页</span>                n2 = driver.window_handles                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n2) &gt; <span class="hljs-number">1</span>:                    driver.close()                    driver.switch_to.window(n2[<span class="hljs-number">0</span>])                <span class="hljs-comment"># 计数,判断需求是否足够</span>                count += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> count == papers_need: <span class="hljs-keyword">break</span>        <span class="hljs-comment"># 切换到下一页</span>        WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;//a[@id=&#x27;PageNext&#x27;]&quot;</span>))).click()            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取完毕！&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:        keyword = <span class="hljs-string">&quot;青少年抑郁&quot;</span>    driver = webserver()        <span class="hljs-comment"># 设置所需篇数</span>    papers_need = <span class="hljs-number">500</span>    res_unm = open_page(driver, keyword)        <span class="hljs-comment"># 判断所需是否大于总篇数</span>    papers_need = papers_need <span class="hljs-keyword">if</span> (papers_need &lt;= res_unm) <span class="hljs-keyword">else</span> res_unm        <span class="hljs-comment"># os.system(&quot;pause&quot;)</span>        <span class="hljs-comment"># 开始爬取</span>    crawl(driver, papers_need, keyword)    <span class="hljs-comment"># 关闭浏览器</span>    driver.close()</code></pre></div><p>获取专辑和获取专题是最慢的，而且因为知网摆放的问题而且没有特殊命名，用了很蠢的方法查询了四个位置，应该有其他优化方法。</p><h3 id="展示">展示</h3><p><imgsrc="https://pic.imgdb.cn/item/65708984c458853aef8c5262.jpg" /></p><h2 id="结语">结语</h2><p>这篇博客希望能为您提供一个简单但实用的起点，让您开始使用Python编写CNKI知网爬虫。祝您编写爬虫的过程愉快，同时请注意遵守相关法律法规和网站规定。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 知网 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>眠</title>
      <link href="/2023/11/09/42/"/>
      <url>/2023/11/09/42/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="眠">眠</h1><p>从前的果实已然硕黄，在一碧万顷的水天之间，充满了丰收的喜悦。一截枯木在湖面横亘，细数近日糜烂的生活。</p><p>身后应是一片连边的森林，阳光透过树梢照射在林间的小屋上，坐在树下思绪渺渺。</p><p>故事道：树后应有一道传送门，穿过这扇门，你能到达记忆深处。于是看到了昏黄天空，纱窗，变色的玻璃，破碎的镜子，磨破皮的老式黑色沙发，用茶几盖上布做的课桌，黄色的门廊……记忆里，日头向晚，家人当归了。门上的数字显示为12。</p><p>梦到，与予站在讲台上，手捧奖状，台下是同学的喝彩，这一年是18；梦到，在报告厅前售卖文创，报告厅里是活动的结束声，那是我的生日：梦到，独自行走在昔园，似乎下着雨，心里是难言与痛苦，那是关于熹的；梦到我在班主任办公室里，解释手机的情况，只求不告诉家长，这也是关于她的，因为我不能失去唯一的联系方式。</p><p>望到，阳光蓝天下的白裙黑衣，看气球与鲜花，看形形色色的人举杯或交谈。那声音带我成为了他，见到了她，她眼里是我，我亦望着她，是暖阳，金黄了发梢，白衣，朦胧。我不认识我，看不清，但见到她心里便照了温暖，入了欣喜，浸满温情。满眼欣赏溢着温柔。但是并不是她？我不认识她！</p><p>那声音述说着，过去的事情都过去了，现在也不会再感受到那悲伤又为什么苦苦舔舐？那身影告诉我，既然祂不是她，那又为什么痛苦？要记得那美满，在每一次呼吸都会感受到，都要更加的圆满。</p><p>你还想在看看吗？湖面的层层波涛由远及近，自然的能量从远处汇聚而来。躺坐在沙滩上，闭上眼，眼中也有阳光的温情吧。</p><p>内心暖流涌起，在一碧万顷的水天之间，充满了喜悦。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 散文 </tag>
            
            <tag> 催眠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列车上的梦</title>
      <link href="/2023/10/10/37%E5%88%97%E8%BD%A6%E4%B8%8A%E7%9A%84%E6%A2%A6/"/>
      <url>/2023/10/10/37%E5%88%97%E8%BD%A6%E4%B8%8A%E7%9A%84%E6%A2%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>列车上没有梦。 <span id="more"></span></p></blockquote><h2 id="列车上的梦">列车上的梦</h2><p>你睡了，静静的躺在我身边。车窗外的灯光拂过你的黑发，你的身体小小的，很独立很可爱，我很喜欢。</p><p>我们之间只有浅浅的栏杆与短短的间隙阻拦，我一伸手就能触碰到你。我不忍心，怕打扰了你的睡梦，你侧过身去，呼吸变得很细…</p><p>还记得，你坐在我的身后，我坐在你的身前，风拂过我的脸颊，吹动你的长发。你举起相机，记录了这一刻，在这五六十公里的旅途上，我的心似那万顷的金灿灿的稻谷。在金灿灿之间，你背着我张开手臂，这幅画卷随着远山村庄携刻在一起，阳光拂面，你很美。我驾着车，你放着歌曲，你的温度通过肌肤传递到我的身上，暖洋洋的，蒸发了清晨的小雨。</p><p>在古城中走街串巷，你捧起了一本书，嗯，在梦中我忘记了是什么书，我只记得，在扎染玫瑰与工艺品间，你穿上了裙子，你笑了，裙子上带着花，和你笑的一样好看。</p><p>早在列车人员的叫喊前，你早便醒了，你趴在枕头上，打开床帘。不远处，天边泛白，然后变黄，黑色褪去变成深蓝色。</p><p>在海边，在输送海水的码头，你蹲坐在桥洞里，让我留下了你的照片，身后是汹涌的海浪，远处是远山与蓝天白云。你流落在了这样的世界里，这样的世界汹涌澎湃，你像一直小猫一样，安安静静的蜷缩在世界一角，不畏外物，我很欣赏你。落日余晖，天边看不见斜阳，唯见山边黄澄澄的云。你坐在海边，粉紫色的天空，倒影着我的内心。</p><p>夜深了，你累了，但你走出了门去买了裙子。我留在了屋子里，酣睡而去。</p><p>我在车上悠悠转醒，我依靠在座椅上向左倾倒，你的发丝就在我眼前，很黑、很细、很温柔，像你。你也睡着了，而我轻轻依靠便能枕在你的肩膀。但是我们的目的地到了，我拍了拍腿把你叫醒，你朦胧着双眼述说着动听的音律。理想邦美术馆里，明信片上的绘画很好看，你拿在手里更好看。在一望无际的深蓝色的天空里，你站在我相机的中心，你拿着自拍杆拍下了自己，而我拍下了你。</p><p>“你为什么总是拍我”</p><p>“因为你就是我的风景”</p><p>这并不是“mouthsweet”，这仅仅是我百转千回的内心话语，说予你听。在公园的山顶，fufu很可爱，你抱着fufu留下与这个梦中城市的合照，你也fufu的，我留下了你和fufu和这个城市的照片，我也fufu的。兴盛大桥很雄伟很精致，像发卡一样别在你发间的发梢。我觉得很有趣，说的是你。</p><p>列车向前奔走着，你睡在我的床下，我看不见你。但是我看见你在玩手机，手机里面不是照片、不是歌曲、也不是你。</p><p>在苍山雾蒙蒙的云间，我们穿着单薄的衣衫走在厚厚衣服的人之间。氧气也不用，在几度的山涧间，迎客松很挺拔，我也想要这样挺拔。能罩住风雪，能遮挡阳光，为了那个手拂过许愿牌的旅客。人来人往间，我双眼极目所至，无不是你。而你左手fufu右手自拍杆拍着视频，视频中有时有我的身影。你偏着头敬礼，不是给我，是摄像机。</p><p>苍翠的山峰，风景很美，我等不了了，走在了前面，我不敢回头，怕看见你，怕看不见你，几公里的山路寥寥。我回头找你，在山石嶙峋中，你比着yes，眼睛里亮晶晶的，看着摄像机。我总是落后你半步，前路交给你，我只是跟着你，跟着你……</p><p>没能给你买裙子，没能在照片中找到你。在列车隆隆中，我翻来覆去。我很痛苦，痛苦旅程的结束，痛苦求而不得，痛苦不被关心。</p><p>在有一天夜里，你告诉我，会关心我，会为我难过。在更远的梦里，你告诉我你不看外貌而看能力。我告诉你，两个完整的圆才能在一起，因为我不完美，所以言尽于此。我告诉你，我能交予的都已给你，我许下承诺，Iwill try my best to be better，你告诉我metoo。你告诉我，可以在你那打卡，我告诉你我会做个2048给你。数独很好玩，但是你不会玩，于是我就把我所会的交给你。</p><p>I want to be better。于是我背单词，看书，学习安卓开发。Youtoo，所以你开始投身于作业；搞机器人，然后做作业。</p><p>我开始看《我要和你好好的》和《不能承受的生命之轻》，我做了很多笔记，我想读给你听：</p><blockquote><p>“是的，我很多时候会不安，而且看到你平凡的在我身边同另一个男生微信聊天…是我自私吗？也许我们关系没到那步，你并不需要对我表现的特别和“忠诚”但是他到火车站接你，而你让我自己回家我又能怎么想呢？更何况你逃避了这个问题，和我设想的一样，在这个设想里我也会疏远你但是我还是反悔了，你旅途中带给我的美好和深入聊天建立的情感纽带让我贪心的想和你做朋友下去…以上，这也是我不够好的表现 I need to become better”</p></blockquote><blockquote><p>我感觉超出了界限，但是你似乎并不觉得，于是我回退了一步，以试图看清我的喜欢，看清我喜欢的女孩，看清这段关系。我没有勇气表白，因为表白很有可能会推远我们，虽然我已然喜欢上了你。</p></blockquote><blockquote><p>我爱你，但是我还没做到最好，所以我在变好——尽最大的能力，我要值得被你爱，也要有爱你的能力。你在未来是否接受我，那是你的事，我在变好，是为了我自己！</p></blockquote><p>有好多好多，我要学习我的英语，学会爱和被爱，这样我才能尽我所能的用我的完整靠近你。</p><p>在列车到站后，我帮你取下箱子，自然的帮你推着箱子，你有些不自在的夺走了自己的箱子。我尊重你，于是就有了一个人夺走了我身边的你。这是你决定的，我也尊重你！</p><p>在每个早上的七点，或者更早，我起来开始一天，你也起来上课或者写作业。我把我的打卡发给了你，你有时鼓励我，我的心暖暖的；你有事不理我，我只能当做你很忙。我和你一起听音乐，带着耳机度过了一天……</p><p>于是你告诉了我一个笑话，笑话不好笑，因为我是那个笑话。</p><p>但是我早早的就有感知啊！所谓男人也有第六感吗？在我痛苦的时候你应该很快乐吧，就像我常看到的一样，对着手机笑，很可爱，很漂亮，想来很有趣，很幸福。</p><p>置身与夜雨中，雨湿透了我的心。然后破碎开来变得更加坚硬。</p><p>夜晚的风乎乎的吹着，你睡在我的身侧，我坐在冰冷的地板上看你，你在梦中笑的很美。</p><p>我很感激你。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 岁月录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 光点 </tag>
            
            <tag> 散文 </tag>
            
            <tag> 爱情 </tag>
            
            <tag> 玥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 791 (Div. 2) 过题</title>
      <link href="/2023/10/05/41/"/>
      <url>/2023/10/05/41/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="codeforces-round-791-div.-2-过题">Codeforces Round 791 (Div. 2)过题</h1><p>https://codeforces.com/contest/1679</p><h2 id="a.-avtobus">A. AvtoBus</h2><h3 id="题意">题意</h3><p>汽车的轮胎可能有4个或者6个，对于给定的每个n（n表示轮胎数量），给出汽车的数量的极小值和极大值，不可能就输出-1### 题解</p><p>纯纯的签到题 平板上写了个 // Created on iPad.</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    cin &gt;&gt; t;    <span class="hljs-keyword">while</span> (t--)    &#123;        <span class="hljs-keyword">int</span> n;        cin &gt;&gt; n;        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)        &#123;            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        n /= <span class="hljs-number">2</span>; <span class="hljs-comment">// n = 2a+3b</span>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)            n -= <span class="hljs-number">3</span>, ans++;        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)        &#123;            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        cout &lt;&lt; ans + n / <span class="hljs-number">6</span> * <span class="hljs-number">2</span> + n % <span class="hljs-number">6</span> / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;        cout &lt;&lt; ans + n / <span class="hljs-number">2</span> &lt;&lt; endl;    &#125;&#125;</code></pre></div><p><ahref="https://codeforces.com/contest/1679/submission/226810092">AC</a>了。</p><h2 id="b.-stone-age-problem">B. Stone Age Problem</h2><h3 id="题意-1">题意</h3><p>题意大概是：给定一个 长度为 n 的 数组 a 和 q次操作。每次操作可能为</p><ol type="1"><li>把 数组a 中的一个元素的值 变成 x 。</li><li>把 数组 a 的所有元素变成 x 。</li><li>询问 数组 a 的所有元素和 sum(a[1∼n]) 。</li></ol><h3 id="题解">题解</h3><p>我们用 布尔变量 all 和 数值 变量 v 来表示 "数组 a 是否全部被变成 数值v "。如果 数组 全部被 变为 v 了，我们再用 一个映射 d[i] 来表示， 在 all为真的情况下，a[i] 的 数值被 操作 1 变为了多少。之后就是模拟写代码了。</p><h2 id="c.-rooks-defenders">C. Rooks Defenders</h2><h3 id="题意-2">题意</h3><p>问题被转化为: 给定一个元素全为 0 的二维数组 a[][] ，和 q次操作，每次操作可能为:</p><ol type="1"><li>给定 x, y ，将 a[x][y] 变成 1 (题目保证在操作之前 a[x][y] 是 0).</li><li>给定 x, y ，将 a[x][y] 变成 0 （题目保证在操作之前 a[x][y] 是 1）.</li><li>给定 x_{1}, y_{1}, x_{2}, y_{2} ，询问是否有 " a 的 x_{1} x_{2} 行每行都至少存在一个 1 " 或 " a 的 y_{1} y_{2} 列 每列都至少存在一个 1 "。 这题本质上是 "单点值修改，区间和查询"，可以用树状数组。</li></ol><h3 id="题解-1">题解</h3><p>单点修改区间查询的问题。可以用树状数组/线段树维护某一段区间内多少行/列上有多少个车。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span>    <span class="hljs-keyword">int</span> l, r, v, sum;&#125;tr1[maxn * <span class="hljs-number">4</span>], tr2[maxn * <span class="hljs-number">4</span>];<span class="hljs-keyword">int</span> n, q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(Node tr[], <span class="hljs-keyword">int</span> u)</span></span>&#123;    tr[u].sum = tr[u &lt;&lt; <span class="hljs-number">1</span>].sum + tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(Node tr[], <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;    tr[u] = &#123;l, r&#125;;    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(tr, u &lt;&lt; <span class="hljs-number">1</span>, l, mid);    <span class="hljs-built_in">build</span>(tr, u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node tr[], <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="hljs-keyword">return</span> tr[u].sum;    <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (l &lt;= mid) sum += <span class="hljs-built_in">query</span>(tr, u &lt;&lt; <span class="hljs-number">1</span>, l, r);    <span class="hljs-keyword">if</span> (r &gt; mid) sum += <span class="hljs-built_in">query</span>(tr, u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(Node tr[], <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span></span>&#123;    <span class="hljs-keyword">if</span> (tr[u].l == tr[u].r)&#123;        tr[u].v += v;        tr[u].sum = (tr[u].v &gt; <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">modify</span>(tr, u &lt;&lt; <span class="hljs-number">1</span>, x, v);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(tr, u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);    <span class="hljs-built_in">pushup</span>(tr, u);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-built_in">build</span>(tr1, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n), <span class="hljs-built_in">build</span>(tr2, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">while</span>(q--)&#123;        <span class="hljs-keyword">int</span> op;        cin &gt;&gt; op;        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">int</span> x, y;            cin &gt;&gt; x &gt;&gt; y;            <span class="hljs-built_in">modify</span>(tr1, <span class="hljs-number">1</span>, x, <span class="hljs-number">1</span>);            <span class="hljs-built_in">modify</span>(tr2, <span class="hljs-number">1</span>, y, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">int</span> x, y;            cin &gt;&gt; x &gt;&gt; y;            <span class="hljs-built_in">modify</span>(tr1, <span class="hljs-number">1</span>, x, <span class="hljs-number">-1</span>);            <span class="hljs-built_in">modify</span>(tr2, <span class="hljs-number">1</span>, y, <span class="hljs-number">-1</span>);                    &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">int</span> x0, y0, x1, y1;            cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; x1 &gt;&gt; y1;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(tr1, <span class="hljs-number">1</span>, x0, x1) == x1 - x0 + <span class="hljs-number">1</span> || <span class="hljs-built_in">query</span>(tr2, <span class="hljs-number">1</span>, y0, y1) == y1 - y0 + <span class="hljs-number">1</span>)                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;    &#125;&#125;</code></pre></div><h2 id="d.-toss-a-coin-to-your-graph...">D. Toss a Coin to YourGraph...</h2><h3 id="题意-3">题意</h3><p>给出一个有向图，求图中所有长度为k的路径经过的点中最大的点权最小是多少。</p><h3 id="题解-2">题解</h3><p>二分答案,每次都只用小于等于<code>mid</code>的边建图,然后判断图中是否有长度为k的路径或有环即可,可以用拓扑排序判环和<code>DP</code></p><h2 id="e.-typical-party-in-dorm">E. Typical Party in Dorm</h2><h3 id="题意-4">题意</h3><p>给出一个字符串,其中有些位置是<code>?</code>，每次询问给出一个集合,每个<code>?</code>的位置可以用集合中任意的字母代替产生很多不同的字符串,所有产生的串中回文串总数是多少?</p><h3 id="题解-3"><ahref="https://zhuanlan.zhihu.com/p/514519244">题解</a></h3><p>首先我们用类似马拉车算法的初始化方法给在字符之间插入一下<code>#</code>,以便我们直接枚举回文中心.</p><p>我们处理每个回文中心对于询问状态的贡献.</p><p>用状态压缩的方法表示询问中的字符集,我们枚举回文中心,然后处理对于每个回文中心每个回文半径至少需要哪些字母(状压表示)才能使当前的回文中心和回文半径合法(当然也可能怎样都不合法).这部分处理是O(n^2)的,然后用<code>子集和DP</code>处理一下就可以得到某个当前串对每个询问集合会产生多少贡献.</p><p>然后我们发现最后的结果不仅和集合中包含哪些字母有关,还和集合的大小有关,所以我们可以分别处理每个状态在不同集合大小情况下对答案的贡献,这样处理询问的时候就可以O(1)查询了.总复杂度应该是O(17n^2)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静静的</title>
      <link href="/2023/10/05/40/"/>
      <url>/2023/10/05/40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>你静静的坐在身边，静静的合眼 静静的睡</p><p>静静的，离开大理，离开云南，离开牧笛</p><p>我也静静的，</p><p>因为我知道，静静的，是最后的时光</p><p>静静的，故事就暂停了</p><p>静静的，故事就远去了</p><p>留不住的，都在静静的消逝了</p><p>静静的，还能见吗</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大理 </tag>
            
            <tag> 喜欢 </tag>
            
            <tag> 玥 </tag>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心论</title>
      <link href="/2023/10/04/35/"/>
      <url>/2023/10/04/35/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>        <div id="aplayer-FGGoyFPE" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"落","author":"蓝心羽","url":"http://music.163.com/song/media/outer/url?id=1865012590.mp3","pic":"/2023/10/04/35/03D879F2836B9E2C792186AC78FE5F39.png","lrc":""},{"title":"ハナタバ （花束）","author":"MIMI/可不","url":"http://music.163.com/song/media/outer/url?id=1999253939.mp3","pic":"http://p1.music.126.net/rGRfS1wSBcQcrN2F7bY4tw==/109951168067420441.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-FGGoyFPE");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><p>毫无疑问，我喜欢上了她。</p><p>在美好的时间，美好的地点，美好的旅途中，不合时宜的贴近了心。</p><p>如何判断这就喜欢上了？</p><p>是看见她就会开心，会情不自禁的关心，会胡思乱想，会嫉妒、会好奇、会贪恋，会忍不住的贴近(贴贴！)，会变得敏感，会有危机感，会心情被牵动(吃醋的换一种表述)。</p><p>yes，that's right.yes，that's right.</p><p>所以合适吗？</p><p>时间上，在短短两天喜欢上一个人，这样的爱未免过于浅薄，未知她全面，就喜欢上，只是滥情，是不负责任！行为上，贴贴与拉扯，主动甚至迫切的帮忙打伞，提东西，拍照，关心，这是极不负责任的，在不知道对方态度便走入安全距离，过于靠近，这是大不只廉耻！</p><p>请容许我在狡辩一下</p><p>第一次与一人单独旅游，第一次为旅游出省，第一次连续的关心一个人，第一次送鲜花……</p><p>把如此多的第一次献给一个人，这样喜欢上不是很正常吗？</p><p>对方能把原计划自己的旅行加入一个人，这不也是表达了好感吗？</p><p>非也！好感也许只是好感，朋友的好感不也是可以的吗？在知道对方大概率仅是好感的情况下，把自己置于不合适的位置，表现了超出友情的照顾，真是下头！更合理，她想带去大理的可能最开始就不是你！你只不过是搭上了顺风车而已，不表谢意就罢了，还想入非非，实乃不可说。</p><p>我哪里没表现出感谢了，我发自内心的感谢她。我感谢她的陪伴感谢她的提携，感谢她让我有了这次非同一般的经历，就像我昨天所写的</p><p>“</p><p>我不知道她怎么想，但是在此时此刻，在这三四天里，大理唯属于我和她，就足够了。</p><p>弥足珍贵的经历，又再次一去不返了。索性，我还在大理，还在她身边，享受这时光，并尽量的留住时间记忆与记录……</p><p>我消极的认为没有下次了</p><p>”</p><p>这段时光我已经很满足了，体验了两三天的“亲密关系”我已经很……</p><p>打住打住，怎么在这自我感动上了，你别忘了“嗯，她下次会抓别人去，还有一个以为不会去的人……”，这也是你写的吧，你就搁那自我感动，自我怀疑然后再自我逃避吧！我已经预测到了未来。毕竟总是这样，还是这样。</p><p>你别忘了她所讨厌的正是很痛苦的爱情，那种吵架，那种吃醋，那种自我内耗，这都是她讨厌你不可能与你同行的理由！</p><p>那我应该怎么办……吃醋就别谈了，正是因为还没在一起然后又有学弟和她聊的欢才有占有欲吗……</p><p>呸，你那不是占有欲，你只会自我怀疑，然后退缩，你不自信，不，你甚至不相信你喜欢的人！这就是你的命门。</p><p>要我说啊，你就应该进攻或者抛弃你那幻想。</p><p>不，表白不是进攻的号角，我错误的理解了她，她应当确实是不喜欢我的，所以不平等的关注才会产生内耗，那我又如何放弃幻想呢，以前的经验告诉我，很难。我可以尝试压抑住，可以尝试疏远，可以吗？</p><p>你觉得呢？你忘记高中的感情花了两年，你现在说的那个不是做过的或者更狠。只能说，这个结只能从你那不自信不相信解决了。你总会被动的等别人，你这人啊，活该啊。</p><p>都说不主动是得不到的，现在主动了反而更不好了？</p><p>你那不是主动，是自我感动！别人需要的是你那些关怀吗你把自己的位置放的越低，就预得不到你想要的。她想要的可是强者，慕强知道吧，和你那高中那个一样，你这样强吗？说来也是，原来这才是你们半个分手的原因，我总算是知道了。</p><p>fine</p><p>fine</p><p>不必多说，我要做的就是回退感情是吧回到友情的层面，这方面还是有一点点经验了……</p><p>“</p><p>当我把墨镜摘下来，林间亮堂了起来，阳光透过针叶林投影下来，一切都是美好的样子。</p><p>”</p><p>你关注到了一切都美好，证明了你本身的不美好，特别是带上墨镜的眼睛所看到的。听我一声劝，这种子种下了，不是那么好脱身的，你还是把时间放在需要准备的大事上，这些事时时品味下，也能作为美好的烦恼了。</p><p>“</p><p>与学弟，聊天中发自拍与视频</p><p>还有与闺蜜提到的那个以为不会陪她去大理的男生</p><p>嗯……</p><p>也是的，最后一天了，</p><p>谢谢你，但是假期快结束了</p><p>我越界了，所以我该走了</p><p>向前去</p><p>向前去</p><p>”</p><p>嗯，不错，走一步看一步也行，更何况还没爱的那么深，相比之前，迷途知返吧……</p><p>但你也知道，那么多年了，心动的有机会？这样消极的等待，有意义吗？</p><p>那你抓得住吗？你抓不住眼前的机会，也抓不住她。你旅途所带走的只有记忆，却带不走她。</p><p>So， the question is coming back again.</p><p>what should I do?</p><p>Do your best if she needs you, do your best if you stayaloneness.</p><p>说了，但什么都没说。</p><p>说了，但是都说了。</p><p>别忘了，你说的“you are my sightseen”，“i will follow you”。能不能做life的和forever的就看你了。</p><p>你这是属于还在暗恋都把后事想了，你这样才是下偷男吧。</p><p>sightseen可不是你嘴甜突发奇想的，你大脑在胡思乱想什么，谁又知道呢(笑)。好了好了，我困了，明天再告诉我你的判断吧。</p><p>我可以接受是判断题，但不能接受成为选项！</p><p>傻子——</p><p><img src="image-20231005235046690.png" /></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 大理 </tag>
            
            <tag> 喜欢 </tag>
            
            <tag> 玥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桂月</title>
      <link href="/2023/10/01/33/"/>
      <url>/2023/10/01/33/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="桂月">桂月</h1><p>桂枝挂月，夜阑无眠。</p><p>是什么时候开始想起了那轮月，圆月常挂天边，却难时时相见。常有雨疏风骤，尝有楼高林立。上天难见，又何现月？</p><p>我曾欣赏满碧池的荷花而忽视了看见水中的游鱼，盯着那桂枝看，当然也就忘记了那高璇的天边月，也是情有可原了。要怪，就怪那荷花惹眼，桂花怡人了。人啊，总是先看见眼前物，眼中景色聚焦聚焦虚化虚化，也就仅剩的那摸嫣红了罢！要为何总怪繁华迷人眼，薄雾遮人面哉？</p><p>所谓小人得志，无怪乎此，但岂能仅怪那外物而忽视自己的错误呢。说那君子，却似那浮生六记的沈复一般，问尽风雅之事又言行不一难当重任。所谓世人，亦无外乎此。</p><p>如今那月盘时隐时现，时暖时清，却似那人一般时近时远。猜不透的心情，看不清的身影。倘若一直看着其随春秋岁去的变化倒也能读懂他的习性，但偶尔看上几眼又如何看的透。如今怕是年与日去，悔之晚矣…</p><p>然世人，总望着不能得之物，若望清月，则忘眼前海棠，若观荷塘又让那月倒影的越来越远了。故而失而复得，得而复失，不能两全。更何况，失而不能复得的海棠，得而依然会掩去的玉珏。</p><p>夜不能寐，珏终缺乎？</p><p>注1，文中圆月代指人</p><p>注2，玉珏，亦是月</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 散文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX2023 安装食用指南</title>
      <link href="/2023/09/19/32/"/>
      <url>/2023/09/19/32/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="latex2023-安装食用指南">LaTeX2023 安装食用指南</h1><h2 id="环境texlive2023安装">【环境】texlive2023安装</h2><ul><li>通过<ahref="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">清华大学开源软件镜像站</a>下载texlive2023.iso</li></ul><p><img src="v2-ddb77505e4396c3e2ce5b10a9317b3a8_b.jpg" alt="下载位置" style="zoom: 67%;" /></p><ul><li>右键点击iso文件，解压到你想安装的位置<ul><li>注：不带中文，不带空格</li></ul></li><li>双击install-tl-windows.bat进入安装程序<ul><li>然后等待安装完成，时间很长</li></ul></li></ul><p><img src="image-20230919092411345.png" alt="image-20230919092411345" style="zoom: 33%;" /></p><p><img src="image-20230919092516807.png" alt="image-20230919092516807" style="zoom: 50%;" /></p><p><img src="image-20230919092642594.png" alt="修改安装路径" style="zoom: 50%;" /></p><ul><li>环境变量会自动添加，不用再手动配置，至此环境安装完毕，可以<ahref="#验证">验证</a></li></ul><h2 id="编译器安装texstudio">【编译器】安装texstudio</h2><ul><li>在<ahref="https://mirrors.tuna.tsinghua.edu.cn/github-release/texstudio-org/texstudio/LatestRelease/">清华大学开源软件镜像站</a>下载</li></ul><p><img src="v2-17e5ff5f67819d6c2afd3bc15f989f6c_b.jpg" alt="img" style="zoom:67%;" /></p><ul><li>双击exe安装即可</li></ul><h2 id="验证">验证</h2><p>打开cmd，输入以下代码，能看到版本信息则表示texlive安装完成</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">tex -v</span><span class="hljs-attribute">latex -v</span><span class="hljs-attribute">xelatex -v</span><span class="hljs-attribute">pdflatex -v</span></code></pre></div><p>打开TeXstudio即可开始使用……</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX在数学建模比赛中的起手式</title>
      <link href="/2023/09/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/LaTeX%E5%9C%A8%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E8%B5%B7%E6%89%8B%E5%BC%8F/"/>
      <url>/2023/09/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/LaTeX%E5%9C%A8%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E8%B5%B7%E6%89%8B%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="latex-在数学建模比赛中的起手式">LaTeX在数学建模比赛中的起手式</h1><h2 id="算法设计起手式">算法设计起手式</h2><h3 id="step形式">STEP形式</h3><p>类似于在三线表中用自然语言表示的方法</p><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;algorithm&#125;[H]  \renewcommand&#123;\algorithmcfname&#125;&#123;算法&#125;  \LinesNumberedHidden % 隐藏行号  \SetAlgoNoEnd % 取消结构块末尾END  \SetAlgoNoLine % 取消每行代码末尾竖线  \SetKwInOut&#123;Input&#125;&#123;输入&#125;  \SetKwInOut&#123;Output&#125;&#123;输出&#125;  \Input&#123;输入$in$&#125;  \Output&#123;输出$out$&#125;  \textbf&#123;\textit&#123;Step&#125;1&#125;: 语句1\;  \textbf&#123;\textit&#123;Step&#125;2&#125;: 语句2\;  \textbf&#123;\textit&#123;Step&#125;3&#125;: 语句3\;  \caption&#123;Step表示&#125;\end&#123;algorithm&#125;</code></pre></div><figure><img src="image-20230907104527593.png" alt="image-20230907104527593" /><figcaption aria-hidden="true">image-20230907104527593</figcaption></figure><h3 id="伪代码">伪代码</h3><p>使用伪代码的方法</p><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;algorithm&#125;[H]  \renewcommand&#123;\algorithmcfname&#125;&#123;算法&#125;  \SetAlgoLined  \SetKwInOut&#123;Input&#125;&#123;输入&#125;  \SetKwInOut&#123;Output&#125;&#123;结果&#125;  %\Input&#123;输入$in$&#125;  \Output&#123;输出$out$&#125;  \BlankLine % 插入一个空行  initialization\;  \While&#123;While condition&#125;&#123;    instructions\;    \eIf&#123;condition&#125;&#123;      instructions1      $$\text&#123;公式&#125;\ ;$$      instructions2\;    &#125;&#123;      instructions3\;    &#125;  &#125;  \caption&#123;伪代码表示&#125;\end&#123;algorithm&#125;</code></pre></div><figure><img src="image-20230907104545224.png" alt="image-20230907104545224" /><figcaption aria-hidden="true">image-20230907104545224</figcaption></figure><h2 id="配置">配置</h2><h3 id="lstlisting-代码框">lstlisting 代码框</h3><div class="hljs code-wrapper"><pre><code class="hljs latex">%代码框设置\lstset&#123;     language=matlab, % 设置语言basicstyle=\ttfamily, % 设置字体族     %basicstyle=\small, breaklines=true, % 自动换行keywordstyle = \color&#123;blue&#125;, % 设置关键字为粗体，颜色为 NavyBluemorekeywords=&#123;&#125;, % 设置更多的关键字，用逗号分隔emph=&#123;&#125;, % 指定强调词，如果有多个，用逗号隔开    emphstyle=\bfseries\color&#123;Rhodamine&#125;, % 强调词样式设置    commentstyle = \it\fontspec&#123;Times New Roman&#125;\color[RGB]&#123;60,118,61&#125;, % 设置注释样式    stringstyle = \it\fontspec&#123;Times New Roman&#125;\color&#123;red!100&#125;, % 设置字符串样式    columns=fixed,     numbers=left, % 显示行号在左边    numbersep=2em, % 设置行号的具体位置    numberstyle=\footnotesize, % 缩小行号    frame=single, % 边框    framesep=1em, % 设置代码与边框的距离    rulecolor=\color&#123;gray&#125;, %框架颜色设置&#125;</code></pre></div><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;lstlisting&#125;[language=matlab]clc;clear;see = 0;% 加载数据data = readtable(&#x27;路径全天候数据表.xlsx&#x27;);\end&#123;lstlisting&#125;</code></pre></div><figure><img src="image-20230907105407542.png" alt="image-20230907105407542" /><figcaption aria-hidden="true">image-20230907105407542</figcaption></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> 数学建模 </tag>
            
            <tag> 排版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>婚恋与爱</title>
      <link href="/2023/09/06/52/"/>
      <url>/2023/09/06/52/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="婚恋与爱">婚恋与爱</h1><h2 id="一些笔记">一些笔记</h2><p><ahref="https://www.bilibili.com/video/BV1r54y1A7L9/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=8ab096c23a71e7accfe2fadc4d4db0c0">给未来孩子的信：去谈恋爱吧，别怕爱情虚幻，生活比爱情更虚幻| 爱的哲学</a></p><p>资产阶级符号：美甲、高跟鞋、化妆……抢夺性的符号，消费性、享乐性的符号。男性享受的是凌驾于生产、穿着这些符号的人之上的感觉，是一种带有资本主义色彩的欲望陷阱——男权主义资本家，是资本的欲望，资本将这些符号富集到女性身上。比如“黑长直”的女性让男生产生的欲望，男性身上也富集了这样的符号。这样的符号学景观的生产流水线，就是为了激发资产阶、小资产阶级男性的拼搏欲。性关系与婚姻关系在这种情况下成为了资本增值的环节。</p><p>面对当下的社会环境，面对社会赤裸裸的每一个环节的现实的物质力量和他符号学的权力关系的再生产环节。若你能在与异性交往的过程中帮她疏解这种痛苦，在精神枷锁深层次的痛苦，那你就能找到伴侣。你要有能力承载她们自然的一面、丑陋的一面，释放取消次要的环节。</p><p>首先要把自己从这种“女体富集审美符号等级制度的符号”的等级制枷锁中挣脱出来。</p><p>资产阶级投射在女性身上的幻想，呈现出一个个审美环节审美单元。</p><p>催婚的本质：父母想要让子女实现小资产阶级家庭的再生产。把家庭作为资本主义单元。这个单元里面没有爱情，只有浪漫主义暴力。尝试寻找不追求资产阶级幻想的女性。</p><p><ahref="https://www.bilibili.com/video/BV1r54y1A7L9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8ab096c23a71e7accfe2fadc4d4db0c0">给未来孩子的信：去谈恋爱吧，别怕爱情虚幻，生活比爱情更虚幻| 爱的哲学</a></p><p>定义爱：对他人<strong>强烈</strong>的<strong>情感寄托</strong></p><p>举例：吊桥效应<br />问题：爱情是一种归因错误，错误标记的心理幻想吗？<br />依恋理论：依恋需求是情绪的发源地。对“吊桥效应”的解释：危险的环境激发出了更多的依恋需要。成人之爱是依恋情结的延续。<br />结论：爱如依恋，关系中的双方对彼此深层次的应答性是爱最重要的特征。<br />局限：依恋只解释了心理层面的爱，而没有解释成人之爱在精神和身体层面上的炽热。<br />成人之爱：第一次完整地接触另一个人的身体。<br />自我认同感：一种逐渐累积的信心一-相信个体维持内在一致性、连续性的能力能够与个体对他人意义的一致性、连续性相匹配。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 与 Matlab、C++ 的交互使用</title>
      <link href="/2023/08/29/31/"/>
      <url>/2023/08/29/31/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="python-与-matlabc-的交互使用">Python 与 Matlab、C++的交互使用</h1><h2 id="python-与-matlab">Python 与 Matlab</h2><p>方法：借助于 matlab 自带的引擎 API</p><p><ahref="%5BPython版本与MATLAB产品兼容版本%20-%20MATLAB%20&amp;%20Simulink%20(mathworks.com)%5D(https://www.mathworks.com/support/requirements/python-compatibility.html)">与MATLAB 产品兼容的 Python 版本（按版本）</a></p><h3 id="配置">配置</h3><p>在MATLAB的命令栏输入 <code>matlabroot</code> 可以得到MATLAB的安装路径，我的安装路径是<code>'D:\Program Files\MATLAB\R2022a'</code>。</p><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">cd matlab路径<span class="hljs-symbol">\e</span>xtern<span class="hljs-symbol">\e</span>ngines<span class="hljs-symbol">\p</span>ython # 即 D:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ATLAB<span class="hljs-symbol">\R</span>2022a<span class="hljs-symbol">\e</span>xtern<span class="hljs-symbol">\e</span>ngines<span class="hljs-symbol">\p</span>ythonpython setup.py install</code></pre></div><h3 id="测试-python-调用-matlab-函数">测试 python 调用 matlab 函数</h3><ol type="1"><li>multiplication_matlab.m 文件：一个乘法函数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> = <span class="hljs-title">multiplication_matlab</span><span class="hljs-params">(b,c)</span></span>a = b * c<span class="hljs-keyword">end</span></code></pre></div><ol start="2" type="1"><li>python 主程序：调用上述 matlab 函数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">import</span> matlab.engine               <span class="hljs-comment"># import matlab引擎</span><span class="hljs-comment"># 启动一个新的MATLAB进程，并返回Python的一个变量，它是一个MatlabEngine对象，用于与MATLAB过程进行通信。</span>eng = matlab.engine.start_matlab() <span class="hljs-comment"># 可以调用matlab的内置函数。                                  </span>d = eng.multiplication_matlab(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 可以调用matlab写的脚本函数</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;d&#x27;</span>, d, <span class="hljs-built_in">type</span>(d))</code></pre></div><ol start="3" type="1"><li>运行 python 结果：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs angelscript">a =  <span class="hljs-built_in">int</span>64   <span class="hljs-number">6</span>d <span class="hljs-number">6</span> &lt;<span class="hljs-keyword">class</span> &#x27;<span class="hljs-symbol">int</span>&#x27;&gt;</code></pre></div><h3 id="注意">注意</h3><ul><li>调用 MATLAB 的函数相对于相同的计算操作可能会慢一些，这是因为在调用MATLAB函数时涉及到了更多的处理步骤和资源开销。所以对于简单的函数不建议调用matlab实现。</li><li>启动引擎 <code>eng = matlab.engine.start_matlab()</code>的时间开销很大，也存在一些随机性，所以不要每次调用都重新启动引擎 。</li></ul><h2 id="python-与-c">python 与 C++</h2><p>测试</p><h3 id="python-调用-c-函数">Python 调用 C 函数</h3><ol type="1"><li>called_c.c：C语言函数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//编译命令 gcc -o libpycall.so -shared -fPIC called_c.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:%d, b:%d.&quot;</span>, a, b);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><ol start="2" type="1"><li>在命令行或者终端输入：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs angelscript">gcc -o libpycall.so -<span class="hljs-keyword">shared</span> -fPIC called_c.c</code></pre></div><p>生成libpycall.so动态库文件，之后就可以在Python中调用foo函数。Python文件：py_call_c.py</p><ol start="3" type="1"><li>运行py_call_c.py输出：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>:<span class="hljs-number">1</span>, b:<span class="hljs-number">3</span></code></pre></div><h3 id="python-调用-c-类">Python 调用 C++ 类</h3><ol type="1"><li>cpp_called.cpp：C++源文件</li></ol><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//Python调用c++(类）动态链接库</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLib</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestLib::display</span><span class="hljs-params">()</span> </span>&#123;    cout&lt;&lt;<span class="hljs-string">&quot;First display&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestLib::display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;    cout&lt;&lt;<span class="hljs-string">&quot;Second display:&quot;</span>&lt;&lt;a&lt;&lt;endl;&#125;<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;    TestLib obj;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;        obj.<span class="hljs-built_in">display</span>();      &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;        obj.<span class="hljs-built_in">display</span>(a);      &#125;&#125;</code></pre></div><ol start="2" type="1"><li>在命令行或者终端输入编译命令：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs angelscript">g++ -o libpycallcpp.so -<span class="hljs-keyword">shared</span> -fPIC cpp_called.cpp</code></pre></div><p>说明：</p><ul><li><p>fPIC：生成位置无关目标代码，适用于动态连接；</p></li><li><p>Lpath：表示在path目录中搜索库文件，如-L.表示在当前目录；</p></li><li><p>I path：表示在path目录中搜索头文件；</p></li><li><p>o file：制定输出文件为file；</p></li><li><p>shared：生成一个共享库文件。</p></li></ul><ol start="3" type="1"><li>py_call_c.py：Python文件：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ctypesdll = ctypes.cdll.LoadLibrarylib = dll(<span class="hljs-string">&#x27;./libpycallcpp.so&#x27;</span>) <span class="hljs-comment"># 刚刚生成的库文件的路径</span>lib.display()lib.display_int(<span class="hljs-number">0</span>)</code></pre></div><ol start="4" type="1"><li>运行输出：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">First</span> display<span class="hljs-built_in">Second</span> display:<span class="hljs-number">0</span></code></pre></div><h1 id="参考">参考</h1><ul><li><ahref="https://zhuanlan.zhihu.com/p/514259625">Python调用matlab及其配置方法- 知乎 (zhihu.com)</a></li><li><ahref="https://zhuanlan.zhihu.com/p/604451198">几行Python代码调用C++程序- 知乎 (zhihu.com)</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matlab </tag>
            
            <tag> 语言交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022a半年鉴 - 雾中花</title>
      <link href="/2023/07/14/30%E5%B9%B4%E6%8A%A5/"/>
      <url>/2023/07/14/30%E5%B9%B4%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>        <div id="aplayer-qiMQdFCk" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"雾里","author":"朵芊/双怡","url":"http://music.163.com/song/media/outer/url?id=1985847535.mp3","pic":"http://p1.music.126.net/VL11pZBCvTiKXouXobDIzg==/109951167922641293.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-qiMQdFCk");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><h1 id="小结">小结</h1><p>半夜，一点，没有睡意，从床上翻下，想写点东西。</p><p>已经连续三天睡眠时长超过十个小时了，最近也多是在虚度光阴，也是日常的考试后的松懈和假期综合征了。</p><p>回想这忙碌的一学期又干了什么呢？这一学期里我总共修了十六门课，有八门期末考试，课程中有四个是实验课，总共30.5学时，占据了我一周的大部分时间。这确实是我入校以来课程最多的学期了，但是其中包括了两课是转专业补休的。下一个繁忙的学期是大三下……</p><p>两天考四门，四天考六门，这样的考试安排加上我并不良好的应试状态，我考试成绩并不亮眼似乎也是正常发挥了……</p><p>给这一学期或者小半年做一个小小的总结吧！</p><ul><li>在竞赛上：我仍然参加了（大量的）竞赛，并终于获得了国一（但是签字还没跑）</li><li>在学习上：度过了困难的大二下，并基本补齐了所有转专业要补的课</li><li>在社团上：我忽视了惟悦，继续在数模和ACM协会中混了下去（换届），还加了新成立的HSD</li><li>在生活上：和寝室的矛盾更加尖锐，在社团关系中度过了“党争”，并抵达了似乎是最好的结局</li><li>在科研上：我尝试加入了老师（袁）带领的组，但是因为其他事情挤压没放太多时间以及没有主动和老师沟通被踢除了组（因为提出的人不少所以也不至于很尴尬）</li><li>在亲密关系上：割舍愤怒痛苦放下了更多的她，能够对下一段感情抱有消极的期望</li><li>生活习惯上：因为课程的不规律和繁多更无法做到规律的睡眠习惯，倒是在前期养成了上床用ipad看微信阅读看书的习惯</li></ul><p>综上，总体上还算如意，细节上仍有很多失意。</p><p>买不到归乡的车票，看来铁路部门也不想让我明天回家吧（摊手</p><h1 id="碑---碎碎念">碑 - 碎碎念</h1><p>第二学期已经结束了呢……大学生活过去一大半了呢……听说大三一年过的很快，大四或在已经科研或者考研或者找工作或者去远方旅行，这么算下来大学已经时日无多了呢……而我却感觉什么也没学到啊……</p><p>如何？何如？时间不多了，想学的东西很多，大学不自学不争取真是什么都学不到呢。</p><p>而且，而且，找不到时间和空间陪自己和散自己了，不过下学期课程压力少，或许可以尝试</p><p>但是，但是，人还是迷茫的，但这和大一入学的迷茫不一样</p><p>可惜，可惜的是，这大半年来，也没什么精彩的日子也没什么难忘的记忆，没有故事也没有记录故事的人</p><p>也许，也许这就是悲剧本身吧</p><div style="text-align: center;"><p><img src="https://pic.imgdb.cn/item/64b040e51ddac507cc114a7e.jpg" style="zoom: 50%; display: inline-block;"></p></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>释怀</title>
      <link href="/2023/06/23/29/"/>
      <url>/2023/06/23/29/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>又一年有由春转夏，这一年，你释怀了吗</p><p>月亮残了又缺，这一月，她释怀了吗</p><p>天色熹微，这一天，我释怀了吗</p><p>我听见，很多人，都说释怀了。他们有的重游故地，有的擦除过往，有的去了他们曾经想去的地方。</p><p>我听说过有的人造访了我所在的学校，然后配图新修的校门，是为释怀。我想到我曾数次踏步的校园，大片的绿草地与银杏大道，我可曾释怀？我也想到无数次路过的校园，关于它的舆论我没有足够的位置评价，无力始终伴随——有曾经或讨厌或身边的人，靠着冲刺与民族加分步入了那里，也是讽刺和遗憾。曾无数次埋怨过自己的学校，批判他的体系，批评他的地位，可是他也是收留了我的地方——没了他，还不知道流落何方。</p><p>这就是可悲的人吧，生来仰望星空，长大只会看见跑不完的阶梯在天穹扶摇直上，低下了头便更没勇气抬起来。</p><p>逝去的魂灵曾经传语道，生活的痛苦永远比快乐多，贫穷、饥饿、疾病，有人仓皇奔波于痛苦本身，也有人为求知本身而感到痛苦。我们都希望是后者。但是面对人的有限性与人界的无限性，个人奔波的痛苦究竟是为了提升还是为了求生？是为了过的更体面还是为了自己的家庭？我不理解世上的大部分人，亦看不清自己。</p><p>那些释怀与不释怀的混杂在一起，飘散到脑海中。我释怀了吗？释怀了是什么？如果我释怀了为什么还记得这一切？如果我没有释怀为什么却又淡忘了？同时间赛跑人总是落后的那一方，就像我现在躺在床上消磨的时间，都是花费掉的筹码。</p><p>我面对不了这样或那样的自己，就像我还面对不了几天后的考试。我忘不掉的那些，无非是fb的赞美诗罢了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪山</title>
      <link href="/2023/05/18/28/"/>
      <url>/2023/05/18/28/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从故事里遥遥窥见雪山那刻起，我的心就落在了那里。</p><p>那雪山好远好远的，藏在书斐薄雾与云烟里，一阵风便没了影。似乎要一生追寻它。</p><p>日以继日的奔向那个方向，那个认定的方向路荆棘密布，杂草丛生，还有一座一座的跨月不完的山涧与溪流，无数的层峦叠嶂。一不小心就会迷失了方向。</p><p>但是，在一次雨过天晴的清晨，你总是能远眺它——在那头，白雪皑皑的雪山在阳光的照耀下闪闪发光，雪山高耸，没入云端，仿佛世界尽头。凝视它，自己的心灵也能得到洗涤，灵魂在茫茫山峦中悄然升腾。</p><p>渐渐走出崇山峻岭，那天地间寒冷彻骨的风吹得你发丝凌乱，肩头沾染冰霜。你走入了客栈，为阶段性的胜利欣喜，你想睡一觉，然后再继续前行。</p><p>你醒了，雪山没有露面，空气中凝结的水露告诉你，此刻不能前行。</p><p>你决定等待，等待雨停，等待天晴，等待雪山再次出现。你在客栈里安心等待，享受着温暖的火炉和美味的食物，和来自各地的旅人们分享彼此的冒险故事。在这里，你也能发现许多新的目标和方向，等待着你去探索和挑战。你认定当雪山再次出现，你会在新的起点继续前行，越过那平野草地，到达那片未知的领域，追逐自己的梦想。在客栈里您能度过漫长的等待时间。</p><p>习惯了火炉，习惯了旅人陪伴，习惯了美食。在踏上前路变得困难时，你不得不做上了马车，来到了山脚下最大的城市，从此你爱上了康庄大道，再也跨不过泥泞的沟壑。</p><p>城市里灯火通明，人群熙攘，与之前的旅途大不相同。你沉浸在城市的喧嚣之中，开始迷失雪山的方向。在声色犬马中，努力地渴望着前进，但是却越走越远，再也看不见雪山的身影。你在城市中徘徊，渐渐变得茫然失措。</p><p>雪山的方向已经不再清晰，但你知道你还有无数的雪山——在鸡鸣狗吠声中你还是知道的——在不远处的金峰山或者最近处的玄岳山，无数的人渴望取道。</p><p>你在金峰山和玄岳山之间徘徊，试图攀登它们的高峰，但却发现这些“雪山”并不是你真正想要的。在往复的追求中，你跌倒在积雪之中……</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 散文 </tag>
            
            <tag> 雪山 </tag>
            
            <tag> 故事 </tag>
            
            <tag> 童话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理实验 - 实验六：运算器设计</title>
      <link href="/2023/05/17/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/17/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实验内容">实验内容</h1><p>将算术逻辑单元与寄存器组集成，设计简单的运算器。</p><p><strong>Sin,Sout:</strong></p><table><thead><tr class="header"><th>Sin</th><th>Sout</th><th>寄存器输入信号</th><th>寄存器输出信号</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>键盘输入</td><td>PC</td></tr><tr class="even"><td>0</td><td>1</td><td>键盘输入</td><td>res，即R[RA]</td></tr><tr class="odd"><td>1</td><td>0</td><td>ALU计算结果输入</td><td>PC</td></tr><tr class="even"><td>1</td><td>1</td><td>ALU计算结果输入</td><td>res，即R[RA]</td></tr></tbody></table><p><strong>R0-R3:</strong></p><table><thead><tr class="header"><th>寄存器</th><th style="text-align: center;">控制信号 RA1 RA0 Wr Rd</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>R0</td><td style="text-align: center;">0 0 0 1</td><td>写入</td></tr><tr class="even"><td>R0</td><td style="text-align: center;">0 0 1 0</td><td>读出</td></tr><tr class="odd"><td>R1</td><td style="text-align: center;">0 1 0 1</td><td>写入</td></tr><tr class="even"><td>R1</td><td style="text-align: center;">0 1 1 0</td><td>读出</td></tr><tr class="odd"><td>R2</td><td style="text-align: center;">1 0 0 1</td><td>写入</td></tr><tr class="even"><td>R2</td><td style="text-align: center;">1 0 1 0</td><td>读出</td></tr><tr class="odd"><td>R3</td><td style="text-align: center;">1 1 0 1</td><td>写入</td></tr><tr class="even"><td>R3</td><td style="text-align: center;">11 1 0</td><td>读出</td></tr></tbody></table><p>RA控制R0~R3的选择，Wr和Rd控制输入和输出。</p><p><strong>PC：</strong></p><table><thead><tr class="header"><th>寄存器</th><th style="text-align: center;">控制信号 M1 M0</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>PC</td><td style="text-align: center;">0 0</td><td>置数</td></tr><tr class="even"><td>PC</td><td style="text-align: center;">0 1</td><td>加一计数</td></tr><tr class="odd"><td>PC</td><td style="text-align: center;">1 0</td><td>减一计数</td></tr><tr class="even"><td>PC</td><td style="text-align: center;">1 1</td><td>保持</td></tr></tbody></table><p>reset为低电平有效的PC清零信号。</p><p><strong>ALU：</strong></p><table><thead><tr class="header"><th>控制信号 s2 s1 s0</th><th>实现功能</th></tr></thead><tbody><tr class="odd"><td>000</td><td>F清零</td></tr><tr class="even"><td>001</td><td>A与B逻辑乘(&amp;)</td></tr><tr class="odd"><td>010</td><td>A与B逻辑加(|)</td></tr><tr class="even"><td>011</td><td>A与B逻辑异或(^)</td></tr><tr class="odd"><td>100</td><td>A与B算数加</td></tr><tr class="even"><td>101</td><td>A逻辑左移一位</td></tr><tr class="odd"><td>110</td><td>A逻辑右移一位</td></tr><tr class="even"><td>111</td><td>A算数右移一位</td></tr></tbody></table><h1 id="实验代码">实验代码</h1><h2 id="顶层设计">顶层设计</h2><p>注：实验和仿真时要对应的修改bdf中的Parameter的值！</p><figure><img src="https://pic2.imgdb.cn/item/646434ac0d2dde577715cc42.png"alt="bdf" /><figcaption aria-hidden="true">bdf</figcaption></figure><h2 id="cpu寄存器-cpu_register_group">CPU寄存器 CPU_register_group</h2><p>注：l用于分频，clk_alt是分频时钟信号。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> CPU_register_group(<span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] M,RA,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] D,<span class="hljs-keyword">input</span> wr,rd,reset,<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] PC,res,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] R0,R1,R2,R3);<span class="hljs-keyword">reg</span> clk_alt;<span class="hljs-keyword">reg</span> [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>] l;<span class="hljs-keyword">parameter</span> wei = <span class="hljs-number">9</span>;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-comment">//分频</span><span class="hljs-keyword">begin</span>l&lt;=l+<span class="hljs-number">1</span>;clk_alt&lt;=l[wei];<span class="hljs-keyword">end</span><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk_alt <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset) <span class="hljs-comment">//处理PC的值</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(!reset)PC = <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(M)<span class="hljs-number">0</span>:PC = D;<span class="hljs-number">1</span>:PC = PC+<span class="hljs-number">1</span>;<span class="hljs-number">2</span>:PC = PC-<span class="hljs-number">1</span>;<span class="hljs-keyword">default</span>:PC = PC;<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-comment">//处理寄存器的值</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(RA)<span class="hljs-number">0</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R0=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R0;<span class="hljs-keyword">end</span><span class="hljs-number">1</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R1=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R1;<span class="hljs-keyword">end</span><span class="hljs-number">2</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R2=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R2;<span class="hljs-keyword">end</span><span class="hljs-number">3</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R3=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R3;<span class="hljs-keyword">end</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="矩阵键盘-keymodule">矩阵键盘 keymodule</h2><p>注：COUNT_MAX用于防抖，当其小于10左右会出现抬起抖动读取，建议在实验时设置为100或1000；在仿真时设置为1。</p><p>注：因为clr绑定在按钮上，而按键按下为低电平，所以清理信号低电平有效，改为!clr。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> keymodule(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> clr,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] out);<span class="hljs-keyword">parameter</span> COUNT_MAX = <span class="hljs-number">32&#x27;d1000</span>; <span class="hljs-comment">//没有按键按下的延迟时间</span><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] cnt = <span class="hljs-number">2&#x27;d0</span>;<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] num =<span class="hljs-number">5&#x27;d16</span>;<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] count_num=COUNT_MAX;<span class="hljs-keyword">initial</span>KEY_R = <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-comment">//根据按钮的列扫描信号和行输入信号判断按钮是否被按下</span><span class="hljs-keyword">always</span>  @(<span class="hljs-keyword">posedge</span> clk,<span class="hljs-keyword">negedge</span> clr)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(!clr)<span class="hljs-keyword">begin</span>cnt&lt;=<span class="hljs-number">2&#x27;b0</span>;out&lt;=<span class="hljs-number">16&#x27;h0000</span>;count_num&lt;=COUNT_MAX; <span class="hljs-comment">//让下一次就能读取</span><span class="hljs-keyword">end</span><span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(KEY_C==<span class="hljs-number">4&#x27;b1111</span>)<span class="hljs-keyword">begin</span><span class="hljs-comment">//num = 5&#x27;d16;</span>cnt = cnt + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">case</span> (cnt)<span class="hljs-number">2&#x27;b00</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-number">2&#x27;b01</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1101</span>;<span class="hljs-number">2&#x27;b10</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1011</span>;<span class="hljs-number">2&#x27;b11</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b0111</span>;         <span class="hljs-keyword">endcase</span><span class="hljs-comment">//计数分频防止位移过快</span><span class="hljs-keyword">if</span>(count_num &lt; COUNT_MAX)count_num = count_num + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>   <span class="hljs-keyword">case</span> (&#123;KEY_C, KEY_R&#125;) <span class="hljs-number">8&#x27;b_1110_1011</span>: num = <span class="hljs-number">5&#x27;d0</span>; <span class="hljs-number">8&#x27;b_0111_0111</span>: num = <span class="hljs-number">5&#x27;d1</span>; <span class="hljs-number">8&#x27;b_0111_1011</span>: num = <span class="hljs-number">5&#x27;d2</span>; <span class="hljs-number">8&#x27;b_0111_1101</span>: num = <span class="hljs-number">5&#x27;d3</span>;  <span class="hljs-number">8&#x27;b_1011_0111</span>: num = <span class="hljs-number">5&#x27;d4</span>; <span class="hljs-number">8&#x27;b_1011_1011</span>: num = <span class="hljs-number">5&#x27;d5</span>; <span class="hljs-number">8&#x27;b_1011_1101</span>: num = <span class="hljs-number">5&#x27;d6</span>; <span class="hljs-number">8&#x27;b_1101_0111</span>: num = <span class="hljs-number">5&#x27;d7</span>;    <span class="hljs-number">8&#x27;b_1101_1011</span>: num = <span class="hljs-number">5&#x27;d8</span>; <span class="hljs-number">8&#x27;b_1101_1101</span>: num = <span class="hljs-number">5&#x27;d9</span>; <span class="hljs-number">8&#x27;b_0111_1110</span>: num = <span class="hljs-number">5&#x27;d10</span>; <span class="hljs-number">8&#x27;b_1011_1110</span>: num = <span class="hljs-number">5&#x27;d11</span>;    <span class="hljs-number">8&#x27;b_1101_1110</span>: num = <span class="hljs-number">5&#x27;d12</span>; <span class="hljs-number">8&#x27;b_1110_1110</span>: num = <span class="hljs-number">5&#x27;d13</span>; <span class="hljs-number">8&#x27;b_1110_0111</span>: num = <span class="hljs-number">5&#x27;d14</span>; <span class="hljs-number">8&#x27;b_1110_1101</span>: num = <span class="hljs-number">5&#x27;d15</span>;    <span class="hljs-keyword">endcase</span>  <span class="hljs-keyword">if</span>(count_num &gt;= COUNT_MAX) <span class="hljs-comment">//没有按键按下的空闲时间够长（防抖）</span><span class="hljs-keyword">begin</span>count_num = <span class="hljs-number">32&#x27;b0</span>;<span class="hljs-comment">//移位</span>out=out&lt;&lt;<span class="hljs-number">4</span>;out[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = num[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end KER_R!=4&#x27;b1111</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end if(clr) else</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end always</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="数码管输出-segment_displays">数码管输出 segment_displays</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> segment_displays(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] N,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] seg,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel);<span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span>sel=sel+<span class="hljs-number">1</span>;<span class="hljs-keyword">case</span>(sel)<span class="hljs-number">3&#x27;b000</span>:num=N[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>];<span class="hljs-number">3&#x27;b001</span>:num=N[<span class="hljs-number">27</span>:<span class="hljs-number">24</span>];<span class="hljs-number">3&#x27;b010</span>:num=N[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<span class="hljs-number">3&#x27;b011</span>:num=N[<span class="hljs-number">19</span>:<span class="hljs-number">16</span>];<span class="hljs-number">3&#x27;b100</span>:num=N[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>];<span class="hljs-number">3&#x27;b101</span>:num=N[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>];<span class="hljs-number">3&#x27;b110</span>:num=N[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>];<span class="hljs-number">3&#x27;b111</span>:num=N[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span>@(num)<span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(num)<span class="hljs-number">4&#x27;h0</span>:seg=<span class="hljs-number">8&#x27;b00111111</span>;<span class="hljs-comment">//&quot;0&quot;</span><span class="hljs-number">4&#x27;h1</span>:seg=<span class="hljs-number">8&#x27;b00000110</span>;<span class="hljs-comment">//&quot;1&quot;</span><span class="hljs-number">4&#x27;h2</span>:seg=<span class="hljs-number">8&#x27;b01011011</span>;<span class="hljs-comment">//&quot;2&quot;</span><span class="hljs-number">4&#x27;h3</span>:seg=<span class="hljs-number">8&#x27;b01001111</span>;<span class="hljs-comment">//&quot;3”</span><span class="hljs-number">4&#x27;h4</span>:seg=<span class="hljs-number">8&#x27;b01100110</span>;<span class="hljs-comment">//&quot;4&quot;</span><span class="hljs-number">4&#x27;h5</span>:seg=<span class="hljs-number">8&#x27;b01101101</span>;<span class="hljs-comment">//&quot;5&quot;</span><span class="hljs-number">4&#x27;h6</span>:seg=<span class="hljs-number">8&#x27;b01111101</span>;<span class="hljs-comment">//&quot;6&quot;</span><span class="hljs-number">4&#x27;h7</span>:seg=<span class="hljs-number">8&#x27;b00000111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;h8</span>:seg=<span class="hljs-number">8&#x27;b01111111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;h9</span>:seg=<span class="hljs-number">8&#x27;b01101111</span>;<span class="hljs-comment">//&quot;9&quot;</span><span class="hljs-number">4&#x27;hA</span>:seg=<span class="hljs-number">8&#x27;b01110111</span>;<span class="hljs-comment">//&quot;A&quot;</span><span class="hljs-number">4&#x27;hB</span>:seg=<span class="hljs-number">8&#x27;b01111100</span>;<span class="hljs-comment">//&quot;b&quot;</span><span class="hljs-number">4&#x27;hC</span>:seg=<span class="hljs-number">8&#x27;b00111001</span>;<span class="hljs-comment">//&quot;c&quot;</span><span class="hljs-number">4&#x27;hD</span>:seg=<span class="hljs-number">8&#x27;b01011110</span>;<span class="hljs-comment">//&quot;d&quot;</span><span class="hljs-number">4&#x27;hE</span>:seg=<span class="hljs-number">8&#x27;b01111001</span>;<span class="hljs-comment">//&quot;E&quot;</span><span class="hljs-number">4&#x27;hF</span>:seg=<span class="hljs-number">8&#x27;b01110001</span>;<span class="hljs-comment">//&quot;F&quot;</span><span class="hljs-keyword">default</span>:seg=<span class="hljs-number">8&#x27;b00000000</span>;<span class="hljs-comment">//&quot;dark&quot;</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="alu的暂存器组-midware">ALU的暂存器组 midware</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> midware(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]in,<span class="hljs-keyword">input</span> sel,<span class="hljs-keyword">input</span> wt,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] X,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Y);<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wt)<span class="hljs-keyword">if</span>(!sel)X = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">else</span>Y = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="alu运算器">ALU运算器</h2><p>注：cin绑定在按键上，所以改为!cin。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ALU(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] s,<span class="hljs-keyword">input</span> cin,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> overflow,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] F);<span class="hljs-keyword">reg</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] C;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(s)<span class="hljs-number">3&#x27;b000</span>: <span class="hljs-comment">//F清零</span><span class="hljs-keyword">begin</span> overflow=<span class="hljs-number">0</span>; F=<span class="hljs-number">0</span>;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b001</span>: <span class="hljs-comment">//逻辑乘</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F=A&amp;B;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b010</span>: <span class="hljs-comment">//逻辑加</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F=A|B;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b011</span>: <span class="hljs-comment">//逻辑异或</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F=A^B;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b100</span>: <span class="hljs-comment">//算术加</span><span class="hljs-keyword">begin</span>C = &#123;A[<span class="hljs-number">7</span>],A[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;+&#123;B[<span class="hljs-number">7</span>],B[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125; + !cin;F = C[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];overflow = C[<span class="hljs-number">8</span>]^C[<span class="hljs-number">7</span>];<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b101</span>: <span class="hljs-comment">//逻辑左移</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F = &#123;A[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>],<span class="hljs-number">1&#x27;b0</span>&#125;;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b110</span>: <span class="hljs-comment">//逻辑右移</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F = &#123;<span class="hljs-number">1&#x27;b0</span>,A[<span class="hljs-number">7</span>:<span class="hljs-number">1</span>]&#125;;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b111</span>: <span class="hljs-comment">//算数右移</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F = &#123;A[<span class="hljs-number">7</span>],A[<span class="hljs-number">7</span>:<span class="hljs-number">1</span>]&#125;;<span class="hljs-keyword">end</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h1 id="仿真波形">仿真波形</h1><figure><img src="https://pic2.imgdb.cn/item/646434ac0d2dde577715cc8e.png"alt="仿真波形" /><figcaption aria-hidden="true">仿真波形</figcaption></figure><h1 id="引脚配置">引脚配置</h1><table><colgroup><col style="width: 11%" /><col style="width: 10%" /><col style="width: 9%" /><col style="width: 9%" /><col style="width: 9%" /><col style="width: 17%" /><col style="width: 18%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th>Node Name</th><th>Direction</th><th>Location</th><th>I/O Bark</th><th>-</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr class="odd"><td>cin</td><td>Input</td><td>PIN_AH8</td><td>3</td><td>B3_N1</td><td>PIN_AH8</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>clk</td><td>Input</td><td>PIN_A14</td><td>8</td><td>B8_N0</td><td>PIN_A14</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>clr</td><td>Input</td><td>PIN_AH7</td><td>3</td><td>B3_N2</td><td>PIN_AH7</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>key_c[3]</td><td>PIN_AE14</td><td>3</td><td>B3_N0</td><td>PIN_AE14</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="odd"><td>key_c[2]</td><td>PIN_AF13</td><td>3</td><td>B3_N1</td><td>PIN_AF13</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="even"><td>key_c[1]</td><td>PIN_AD12</td><td>3</td><td>B3_N3</td><td>PIN_AD12</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="odd"><td>key_c[0]</td><td>PIN_AD11</td><td>3</td><td>B3_N3</td><td>PIN_AD11</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="even"><td>key_out[3]</td><td>PIN_E24</td><td>6</td><td>B6_N0</td><td>PIN_E24</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>key_out[2]</td><td>PIN_F22</td><td>7</td><td>B7_N0</td><td>PIN_F22</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>key_out[1]</td><td>PIN_E22</td><td>7</td><td>B7_N0</td><td>PIN_E22</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>key_out[0]</td><td>PIN_F21</td><td>7</td><td>B7_N0</td><td>PIN_F21</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>key_r[3]</td><td>PIN_AE11</td><td>3</td><td>B3_N0</td><td>PIN_AE11</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>key_r[2]</td><td>PIN_AF11</td><td>3</td><td>B3_N1</td><td>PIN_AF11</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>key_r[1]</td><td>PIN_AE12</td><td>3</td><td>B3_N0</td><td>PIN_AE12</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>key_r[0]</td><td>PIN_AE13</td><td>3</td><td>B3_N0</td><td>PIN_AE13</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_seg[7]</td><td>PIN_M21</td><td>6</td><td>B6_N1</td><td>PIN_M21</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_seg[6]</td><td>PIN_G12</td><td>8</td><td>B8_N2</td><td>PIN_G12</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_seg[5]</td><td>PIN_G14</td><td>8</td><td>B8_N0</td><td>PIN_G14</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_seg[4]</td><td>PIN_G15</td><td>7</td><td>B7_N3</td><td>PIN_G15</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_seg[3]</td><td>PIN_G18</td><td>7</td><td>B7_N2</td><td>PIN_G18</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_seg[2]</td><td>PIN_F18</td><td>7</td><td>B7_N1</td><td>PIN_F18</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_seg[1]</td><td>PIN_G17</td><td>7</td><td>B7_N2</td><td>PIN_G17</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_seg[0]</td><td>PIN_G16</td><td>7</td><td>B7_N3</td><td>PIN_G16</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_sel[2]</td><td>PIN_G9</td><td>8</td><td>B8_N3</td><td>PIN_G9</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_sel[1]</td><td>PIN_D22</td><td>7</td><td>B7_N0</td><td>PIN_D22</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_sel[0]</td><td>PIN_C22</td><td>7</td><td>B7_N1</td><td>PIN_C22</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>M[1]</td><td>Input</td><td>PIN_AA10</td><td>3</td><td>B3_N1</td><td>PIN_AA10</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>M[0]</td><td>Input</td><td>PIN_U8</td><td>2</td><td>B2_N3</td><td>PIN_U8</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>overflow</td><td>PIN_AE8</td><td>3</td><td>B3_N3</td><td>PIN_AE8</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>RA[1]</td><td>PIN_AF12</td><td>3</td><td>B3_N1</td><td>PIN_AF12</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="odd"><td>RA[0]</td><td>PIN_AG12</td><td>3</td><td>B3_N0</td><td>PIN_AG12</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="even"><td>rd</td><td>Input</td><td>PIN_AH6</td><td>3</td><td>B3_N2</td><td>PIN_AH6</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>reset</td><td>Input</td><td>PIN_AE3</td><td>2</td><td>B2_N3</td><td>PIN_AE3</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>s[2]</td><td>Input</td><td>PIN_AA8</td><td>2</td><td>B2_N1</td><td>PIN_AA8</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>s[1]</td><td>Input</td><td>PIN_AB8</td><td>2</td><td>B2_N3</td><td>PIN_AB8</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>s[0]</td><td>Input</td><td>PIN_AE4</td><td>2</td><td>B2_N3</td><td>PIN_AE4</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>sel</td><td>Input</td><td>PIN_AD4</td><td>2</td><td>B2_N3</td><td>PIN_AD4</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>sin</td><td>Input</td><td>PIN_AH12</td><td>3</td><td>B3_N1</td><td>PIN_AH12</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>sout</td><td>Input</td><td>PIN_AF14</td><td>3</td><td>B3_N0</td><td>PIN_AF14</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>wr</td><td>Input</td><td>PIN_AF5</td><td>3</td><td>B3_N2</td><td>PIN_AF5</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>wt</td><td>Input</td><td>PIN_AC5</td><td>2</td><td>B2_N3</td><td>PIN_AC5</td><td>2.5 V (default)</td><td>8mA (default)</td></tr></tbody></table><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理实验 </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理实验 - 实验五：CPU寄存器组的设计</title>
      <link href="/2023/05/10/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9ACPU%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/10/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9ACPU%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实验内容">实验内容</h1><p>实验要求:用VDH语言设计CPU寄存器组,其包括4个8位通用寄存器(R0~R3)和一个8位专用寄存器PC,R0-R3&amp;PC操作方式见下表格，之后要将PC和R0-R3(其中一个)输出并用4个数码管显示。<strong>R0-R3</strong>:</p><table><thead><tr class="header"><th>寄存器</th><th style="text-align: center;">控制信号 RA1 RA0 Wr Rd</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>R0</td><td style="text-align: center;">0 0 0 1</td><td>写入</td></tr><tr class="even"><td>R0</td><td style="text-align: center;">0 0 1 0</td><td>读出</td></tr><tr class="odd"><td>R1</td><td style="text-align: center;">0 1 0 1</td><td>写入</td></tr><tr class="even"><td>R1</td><td style="text-align: center;">0 1 1 0</td><td>读出</td></tr><tr class="odd"><td>R2</td><td style="text-align: center;">1 0 0 1</td><td>写入</td></tr><tr class="even"><td>R2</td><td style="text-align: center;">1 0 1 0</td><td>读出</td></tr><tr class="odd"><td>R3</td><td style="text-align: center;">1 1 0 1</td><td>写入</td></tr><tr class="even"><td>R3</td><td style="text-align: center;">11 1 0</td><td>读出</td></tr></tbody></table><p>RA控制R0~R3的选择，Wr和Rd控制输入和输出。</p><p><strong>PC</strong>：</p><table><thead><tr class="header"><th>寄存器</th><th style="text-align: center;">控制信号 M1 M0</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>PC</td><td style="text-align: center;">0 0</td><td>置数</td></tr><tr class="even"><td>PC</td><td style="text-align: center;">0 1</td><td>加一计数</td></tr><tr class="odd"><td>PC</td><td style="text-align: center;">1 0</td><td>减一计数</td></tr><tr class="even"><td>PC</td><td style="text-align: center;">1 1</td><td>保持</td></tr></tbody></table><p>reset为低电平有效的PC清零信号。</p><h1 id="实验代码">实验代码</h1><h2 id="顶层设计-exp5">顶层设计 exp5</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> exp5(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> clr, <span class="hljs-comment">//K[0]</span><span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] seg,<span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel,<span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] M,RA, <span class="hljs-comment">// k[6:7] K[2:3]</span><span class="hljs-keyword">input</span> wr,rd,reset, <span class="hljs-comment">// K[4] k[5] k[8]</span><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] PC,res,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] R0,R1,R2,R3,<span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] key_out);keymodule(clk,KEY_C,clr,KEY_R,key_out);CPU_register_group(M,RA,key_out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>],wr,rd,reset,clk,PC,res,R0,R1,R2,R3);segment_displays( clk,&#123;key_out,PC,res&#125;,seg,sel);<span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="cpu寄存器-cpu_register_group">CPU寄存器 CPU_register_group</h2><p>注：l用于分频，clk_alt是分频时钟信号。仿真时设置clk_alt&lt;=l[0]，实验时clk_alt&lt;=l[9]，l[9]可能还是太快了，可以设置的更高。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> CPU_register_group(<span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] M,RA,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] D,<span class="hljs-keyword">input</span> wr,rd,reset,<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] PC,res,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] R0,R1,R2,R3);<span class="hljs-keyword">reg</span> clk_alt;<span class="hljs-keyword">reg</span> [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>] l;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-comment">//分频</span><span class="hljs-keyword">begin</span>l&lt;=l+<span class="hljs-number">1</span>;clk_alt&lt;=l[<span class="hljs-number">9</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk_alt <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset) <span class="hljs-comment">//处理PC的值</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(!reset)PC = <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(M)<span class="hljs-number">0</span>:PC = D;<span class="hljs-number">1</span>:PC=PC+<span class="hljs-number">1</span>;<span class="hljs-number">2</span>:PC=PC-<span class="hljs-number">1</span>;<span class="hljs-keyword">default</span>:PC = PC;<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-comment">//处理寄存器的值</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(RA)<span class="hljs-number">0</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R0=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R0;<span class="hljs-keyword">end</span><span class="hljs-number">1</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R1=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R1;<span class="hljs-keyword">end</span><span class="hljs-number">2</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R2=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R2;<span class="hljs-keyword">end</span><span class="hljs-number">3</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R3=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R3;<span class="hljs-keyword">end</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="矩阵键盘-keymodule">矩阵键盘 keymodule</h2><p>注：COUNT_MAX用于防抖，当其小于10左右会出现抬起抖动读取，建议在实验时设置为100或1000；在仿真时设置为1。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> keymodule(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> clr,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] out);<span class="hljs-keyword">parameter</span> COUNT_MAX = <span class="hljs-number">32&#x27;d1000</span>; <span class="hljs-comment">//没有按键按下的延迟时间</span><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] cnt = <span class="hljs-number">2&#x27;d0</span>;<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] num =<span class="hljs-number">5&#x27;d16</span>;<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] count_num=COUNT_MAX;<span class="hljs-keyword">initial</span>KEY_R = <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-comment">//根据按钮的列扫描信号和行输入信号判断按钮是否被按下</span><span class="hljs-keyword">always</span>  @(<span class="hljs-keyword">posedge</span> clk,<span class="hljs-keyword">posedge</span> clr)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(clr)<span class="hljs-keyword">begin</span>cnt&lt;=<span class="hljs-number">2&#x27;b0</span>;out&lt;=<span class="hljs-number">16&#x27;h0000</span>;count_num&lt;=COUNT_MAX; <span class="hljs-comment">//让下一次就能读取</span><span class="hljs-keyword">end</span><span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(KEY_C==<span class="hljs-number">4&#x27;b1111</span>)<span class="hljs-keyword">begin</span><span class="hljs-comment">//num = 5&#x27;d16;</span>cnt = cnt + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">case</span> (cnt)<span class="hljs-number">2&#x27;b00</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-number">2&#x27;b01</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1101</span>;<span class="hljs-number">2&#x27;b10</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1011</span>;<span class="hljs-number">2&#x27;b11</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b0111</span>;         <span class="hljs-keyword">endcase</span><span class="hljs-comment">//计数分频防止位移过快</span><span class="hljs-keyword">if</span>(count_num &lt; COUNT_MAX)count_num = count_num + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>   <span class="hljs-keyword">case</span> (&#123;KEY_C, KEY_R&#125;) <span class="hljs-number">8&#x27;b_1110_1011</span>: num = <span class="hljs-number">5&#x27;d0</span>; <span class="hljs-number">8&#x27;b_0111_0111</span>: num = <span class="hljs-number">5&#x27;d1</span>; <span class="hljs-number">8&#x27;b_0111_1011</span>: num = <span class="hljs-number">5&#x27;d2</span>; <span class="hljs-number">8&#x27;b_0111_1101</span>: num = <span class="hljs-number">5&#x27;d3</span>;  <span class="hljs-number">8&#x27;b_1011_0111</span>: num = <span class="hljs-number">5&#x27;d4</span>; <span class="hljs-number">8&#x27;b_1011_1011</span>: num = <span class="hljs-number">5&#x27;d5</span>; <span class="hljs-number">8&#x27;b_1011_1101</span>: num = <span class="hljs-number">5&#x27;d6</span>; <span class="hljs-number">8&#x27;b_1101_0111</span>: num = <span class="hljs-number">5&#x27;d7</span>;    <span class="hljs-number">8&#x27;b_1101_1011</span>: num = <span class="hljs-number">5&#x27;d8</span>; <span class="hljs-number">8&#x27;b_1101_1101</span>: num = <span class="hljs-number">5&#x27;d9</span>; <span class="hljs-number">8&#x27;b_0111_1110</span>: num = <span class="hljs-number">5&#x27;d10</span>; <span class="hljs-number">8&#x27;b_1011_1110</span>: num = <span class="hljs-number">5&#x27;d11</span>;    <span class="hljs-number">8&#x27;b_1101_1110</span>: num = <span class="hljs-number">5&#x27;d12</span>; <span class="hljs-number">8&#x27;b_1110_1110</span>: num = <span class="hljs-number">5&#x27;d13</span>; <span class="hljs-number">8&#x27;b_1110_0111</span>: num = <span class="hljs-number">5&#x27;d14</span>; <span class="hljs-number">8&#x27;b_1110_1101</span>: num = <span class="hljs-number">5&#x27;d15</span>;    <span class="hljs-keyword">endcase</span>  <span class="hljs-keyword">if</span>(count_num &gt;= COUNT_MAX) <span class="hljs-comment">//没有按键按下的空闲时间够长（防抖）</span><span class="hljs-keyword">begin</span>count_num = <span class="hljs-number">32&#x27;b0</span>;<span class="hljs-comment">//移位</span>out=out&lt;&lt;<span class="hljs-number">4</span>;out[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = num[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end KER_R!=4&#x27;b1111</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end if(clr) else</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end always</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="数码管输出-segment_displays">数码管输出 segment_displays</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> segment_displays(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] N,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] seg,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel);<span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span>sel=sel+<span class="hljs-number">1</span>;<span class="hljs-keyword">case</span>(sel)<span class="hljs-number">3&#x27;b000</span>:num=N[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>];<span class="hljs-number">3&#x27;b001</span>:num=N[<span class="hljs-number">27</span>:<span class="hljs-number">24</span>];<span class="hljs-number">3&#x27;b010</span>:num=N[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<span class="hljs-number">3&#x27;b011</span>:num=N[<span class="hljs-number">19</span>:<span class="hljs-number">16</span>];<span class="hljs-number">3&#x27;b100</span>:num=N[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>];<span class="hljs-number">3&#x27;b101</span>:num=N[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>];<span class="hljs-number">3&#x27;b110</span>:num=N[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>];<span class="hljs-number">3&#x27;b111</span>:num=N[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span>@(num)<span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(num)<span class="hljs-number">4&#x27;h0</span>:seg=<span class="hljs-number">8&#x27;b00111111</span>;<span class="hljs-comment">//&quot;0&quot;</span><span class="hljs-number">4&#x27;h1</span>:seg=<span class="hljs-number">8&#x27;b00000110</span>;<span class="hljs-comment">//&quot;1&quot;</span><span class="hljs-number">4&#x27;h2</span>:seg=<span class="hljs-number">8&#x27;b01011011</span>;<span class="hljs-comment">//&quot;2&quot;</span><span class="hljs-number">4&#x27;h3</span>:seg=<span class="hljs-number">8&#x27;b01001111</span>;<span class="hljs-comment">//&quot;3”</span><span class="hljs-number">4&#x27;h4</span>:seg=<span class="hljs-number">8&#x27;b01100110</span>;<span class="hljs-comment">//&quot;4&quot;</span><span class="hljs-number">4&#x27;h5</span>:seg=<span class="hljs-number">8&#x27;b01101101</span>;<span class="hljs-comment">//&quot;5&quot;</span><span class="hljs-number">4&#x27;h6</span>:seg=<span class="hljs-number">8&#x27;b01111101</span>;<span class="hljs-comment">//&quot;6&quot;</span><span class="hljs-number">4&#x27;h7</span>:seg=<span class="hljs-number">8&#x27;b00000111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;h8</span>:seg=<span class="hljs-number">8&#x27;b01111111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;h9</span>:seg=<span class="hljs-number">8&#x27;b01101111</span>;<span class="hljs-comment">//&quot;9&quot;</span><span class="hljs-number">4&#x27;hA</span>:seg=<span class="hljs-number">8&#x27;b01110111</span>;<span class="hljs-comment">//&quot;A&quot;</span><span class="hljs-number">4&#x27;hB</span>:seg=<span class="hljs-number">8&#x27;b01111100</span>;<span class="hljs-comment">//&quot;b&quot;</span><span class="hljs-number">4&#x27;hC</span>:seg=<span class="hljs-number">8&#x27;b00111001</span>;<span class="hljs-comment">//&quot;c&quot;</span><span class="hljs-number">4&#x27;hD</span>:seg=<span class="hljs-number">8&#x27;b01011110</span>;<span class="hljs-comment">//&quot;d&quot;</span><span class="hljs-number">4&#x27;hE</span>:seg=<span class="hljs-number">8&#x27;b01111001</span>;<span class="hljs-comment">//&quot;E&quot;</span><span class="hljs-number">4&#x27;hF</span>:seg=<span class="hljs-number">8&#x27;b01110001</span>;<span class="hljs-comment">//&quot;F&quot;</span><span class="hljs-keyword">default</span>:seg=<span class="hljs-number">8&#x27;b00000000</span>;<span class="hljs-comment">//&quot;dark&quot;</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h1 id="仿真波形">仿真波形</h1><figure><img src="https://pic2.imgdb.cn/item/645afa090d2dde577701fd6c.png"alt="仿真波形" /><figcaption aria-hidden="true">仿真波形</figcaption></figure><h1 id="引脚配置">引脚配置</h1><table><thead><tr class="header"><th>信号</th><th>输出/输出</th><th>引脚</th><th>信号</th><th>输出/输出</th><th>引脚</th></tr></thead><tbody><tr class="odd"><td>KEY_C[3]</td><td>Input</td><td>PIN_AE14</td><td>rd</td><td>Input</td><td>PIN_AC5</td></tr><tr class="even"><td>KEY_C[2]</td><td>Input</td><td>PIN_AF13</td><td>reset</td><td>Input</td><td>PIN_AA10</td></tr><tr class="odd"><td>KEY_C[1]</td><td>Input</td><td>PIN_AD12</td><td>seg[7]</td><td>Output</td><td>PIN_M21</td></tr><tr class="even"><td>KEY_C[0]</td><td>Input</td><td>PIN_AD11</td><td>seg[6]</td><td>Output</td><td>PIN_G12</td></tr><tr class="odd"><td>KEY_R[3]</td><td>Output</td><td>PIN_AE11</td><td>seg[5]</td><td>Output</td><td>PIN_G14</td></tr><tr class="even"><td>KEY_R[2]</td><td>Output</td><td>PIN_AF11</td><td>seg[4]</td><td>Output</td><td>PIN_G15</td></tr><tr class="odd"><td>KEY_R[1]</td><td>Output</td><td>PIN_AE12</td><td>seg[3]</td><td>Output</td><td>PIN_G18</td></tr><tr class="even"><td>KEY_R[0]</td><td>Output</td><td>PIN_AE13</td><td>seg[2]</td><td>Output</td><td>PIN_F18</td></tr><tr class="odd"><td>M[1]</td><td>Input</td><td>PIN_AF12</td><td>seg[1]</td><td>Output</td><td>PIN_G17</td></tr><tr class="even"><td>M[0]</td><td>Input</td><td>PIN_AG12</td><td>seg[0]</td><td>Output</td><td>PIN_G16</td></tr><tr class="odd"><td>RA[1]</td><td>Input</td><td>PIN_AA8</td><td>sel[2]</td><td>Output</td><td>PIN_G9</td></tr><tr class="even"><td>RA[0]</td><td>Input</td><td>PIN_AB8</td><td>sel[1]</td><td>Output</td><td>PIN_D22</td></tr><tr class="odd"><td>clk</td><td>Input</td><td>PIN_A14</td><td>sel[0]</td><td>Output</td><td>PIN_C22</td></tr><tr class="even"><td>clr</td><td>Input</td><td>PIN_AH12</td><td>wr</td><td>Input</td><td>PIN_AE4</td></tr></tbody></table><h1 id="解释说明">解释说明</h1><figure><img src="https://pic2.imgdb.cn/item/645afa090d2dde577701fcfd.png"alt="RTL" /><figcaption aria-hidden="true">RTL</figcaption></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理实验 </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理实验 - 实验四：算数逻辑单元设计</title>
      <link href="/2023/05/06/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/06/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实验内容">实验内容</h1><p>请使用文本输入方式(VerilogHDL)设计一个8位算术逻辑单元，包括控制信号与相关功能，具体如表2所示。假设暂存器A、B中的操作数均为<strong>8位补码</strong>，包含一位符号位，并使用双符号位补码进行算术加法运算，需要判断运算结果是否<strong>溢出</strong>，考虑低位进位输入Cin。如果运算结果溢出，则需要将溢出标志位Overflow置为1，否则置为0。在逻辑运算时，Overflow均置为0。对于算术右移操作，需要按照补码的算术右移规则执行。</p><table><thead><tr class="header"><th>控制信号 s2 s1 s0</th><th>实现功能</th></tr></thead><tbody><tr class="odd"><td>000</td><td>F清零</td></tr><tr class="even"><td>001</td><td>A与B逻辑乘(&amp;)</td></tr><tr class="odd"><td>010</td><td>A与B逻辑加(|)</td></tr><tr class="even"><td>011</td><td>A与B逻辑异或(^)</td></tr><tr class="odd"><td>100</td><td>A与B算数加</td></tr><tr class="even"><td>101</td><td>A逻辑左移一位</td></tr><tr class="odd"><td>110</td><td>A逻辑右移一位</td></tr><tr class="even"><td>111</td><td>A算数右移一位</td></tr></tbody></table><p>将8位ALU的运算结果输出到七位数码管，Overflow绑定到LED灯</p><p><imgsrc="https://pic1.zhimg.com/v2-3b49784ea84b01db7622e4db200a8228_b.jpg" /></p><p>Sel用于选择数据写入啷个暂存器，Wt用于控制是否读入数据。本文使用矩阵键盘输入A和B。</p><h1 id="实验代码">实验代码</h1><h2 id="顶层设计-exp_4">顶层设计 exp_4</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> exp_4(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> sel,<span class="hljs-keyword">input</span> wt,<span class="hljs-keyword">input</span> clr,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] s,<span class="hljs-keyword">input</span> cin,<span class="hljs-keyword">output</span> overflow,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] LED_seg,<span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] LED_sel,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] F,<span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] indata,<span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num,<span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] N);keymodule (clk,KEY_R,clr,KEY_C,indata); <span class="hljs-comment">//键盘输入</span>midware (clk,indata,sel,wt,A,B);ALU (clk,s,cin,A,B,overflow,F);<span class="hljs-keyword">assign</span> N = &#123;A,B,<span class="hljs-number">8&#x27;h0</span>,F&#125;;segment_displays(clk,N,LED_seg,LED_sel,num);<span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="矩阵键盘-keymodule">矩阵键盘 keymodule</h2><p>注：COUNT_MAX用于防抖，当其小于10左右会出现抬起抖动读取，建议在实验时设置为100或1000；在仿真时设置为1。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> keymodule(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> clr,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] out);<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] cnt = <span class="hljs-number">2&#x27;d0</span>;<span class="hljs-keyword">reg</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] num=<span class="hljs-number">5&#x27;d16</span>;<span class="hljs-keyword">reg</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] count_num=<span class="hljs-number">32&#x27;d0</span>;<span class="hljs-keyword">parameter</span> COUNT_MAX = <span class="hljs-number">32&#x27;d100</span>; <span class="hljs-comment">//没有按键按下的延迟时间</span><span class="hljs-keyword">initial</span><span class="hljs-keyword">begin</span>KEY_R = <span class="hljs-number">4&#x27;b0111</span>;count_num = COUNT_MAX; <span class="hljs-comment">//让第一次就能读取</span><span class="hljs-keyword">end</span><span class="hljs-comment">//根据按钮的列扫描信号和行输入信号判断按钮是否被按下</span><span class="hljs-keyword">always</span>  @(<span class="hljs-keyword">posedge</span> clk,<span class="hljs-keyword">posedge</span> clr)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(clr)<span class="hljs-keyword">begin</span>cnt&lt;=<span class="hljs-number">2&#x27;b0</span>;out&lt;=<span class="hljs-number">16&#x27;h0000</span>;count_num&lt;=COUNT_MAX; <span class="hljs-comment">//让下一次就能读取</span><span class="hljs-keyword">end</span><span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(KEY_C==<span class="hljs-number">4&#x27;b1111</span>)<span class="hljs-keyword">begin</span><span class="hljs-comment">//num = 5&#x27;d16;</span>cnt = cnt + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">case</span> (cnt)<span class="hljs-number">2&#x27;b00</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-number">2&#x27;b01</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1101</span>;<span class="hljs-number">2&#x27;b10</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1011</span>;<span class="hljs-number">2&#x27;b11</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b0111</span>;         <span class="hljs-keyword">endcase</span><span class="hljs-comment">//计数分频防止位移过快</span><span class="hljs-keyword">if</span>(count_num &lt; COUNT_MAX)count_num = count_num + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>   <span class="hljs-keyword">case</span> (&#123;KEY_R, KEY_C&#125;) <span class="hljs-number">8&#x27;b1011_1110</span>: num = <span class="hljs-number">5&#x27;d0</span>; <span class="hljs-number">8&#x27;b0111_0111</span>: num = <span class="hljs-number">5&#x27;d1</span>; <span class="hljs-number">8&#x27;b1011_0111</span>: num = <span class="hljs-number">5&#x27;d2</span>; <span class="hljs-number">8&#x27;b1101_0111</span>: num = <span class="hljs-number">5&#x27;d3</span>;  <span class="hljs-number">8&#x27;b0111_1011</span>: num = <span class="hljs-number">5&#x27;d4</span>; <span class="hljs-number">8&#x27;b1011_1011</span>: num = <span class="hljs-number">5&#x27;d5</span>; <span class="hljs-number">8&#x27;b1101_1011</span>: num = <span class="hljs-number">5&#x27;d6</span>; <span class="hljs-number">8&#x27;b0111_1101</span>: num = <span class="hljs-number">5&#x27;d7</span>;    <span class="hljs-number">8&#x27;b1011_1101</span>: num = <span class="hljs-number">5&#x27;d8</span>; <span class="hljs-number">8&#x27;b1101_1101</span>: num = <span class="hljs-number">5&#x27;d9</span>; <span class="hljs-number">8&#x27;b1110_0111</span>: num = <span class="hljs-number">5&#x27;d10</span>; <span class="hljs-number">8&#x27;b1110_1011</span>: num = <span class="hljs-number">5&#x27;d11</span>;    <span class="hljs-number">8&#x27;b1110_1101</span>: num = <span class="hljs-number">5&#x27;d12</span>; <span class="hljs-number">8&#x27;b1110_1110</span>: num = <span class="hljs-number">5&#x27;d13</span>; <span class="hljs-number">8&#x27;b0111_1110</span>: num = <span class="hljs-number">5&#x27;d14</span>; <span class="hljs-number">8&#x27;b1101_1110</span>: num = <span class="hljs-number">5&#x27;d15</span>;    <span class="hljs-keyword">endcase</span>  <span class="hljs-keyword">if</span>(count_num &gt;= COUNT_MAX) <span class="hljs-comment">//没有按键按下的空闲时间够长（防抖）</span><span class="hljs-keyword">begin</span>count_num = <span class="hljs-number">32&#x27;b0</span>;<span class="hljs-comment">//移位</span>out=out&lt;&lt;<span class="hljs-number">4</span>;out[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = num[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end KER_R!=4&#x27;b1111</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end if(clr) else</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end always</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="暂存器-midware">暂存器 midware</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> midware(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]in,<span class="hljs-keyword">input</span> sel,<span class="hljs-keyword">input</span> wt,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] X,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Y);<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wt)<span class="hljs-keyword">if</span>(sel)X = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">else</span>Y = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="数码管输出-segment_displays">数码管输出 segment_displays</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> segment_displays(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] N,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] seg,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num);<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span>sel=sel+<span class="hljs-number">1</span>;<span class="hljs-keyword">case</span>(sel)<span class="hljs-number">3&#x27;b111</span>:num=N[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-number">3&#x27;b110</span>:num=N[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>];<span class="hljs-number">3&#x27;b101</span>:num=N[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>];<span class="hljs-number">3&#x27;b100</span>:num=N[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>];<span class="hljs-number">3&#x27;b011</span>:num=N[<span class="hljs-number">19</span>:<span class="hljs-number">16</span>];<span class="hljs-number">3&#x27;b010</span>:num=N[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<span class="hljs-number">3&#x27;b001</span>:num=N[<span class="hljs-number">27</span>:<span class="hljs-number">24</span>];<span class="hljs-number">3&#x27;b000</span>:num=N[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>];<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span>@(num)<span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(num)<span class="hljs-number">4&#x27;b0000</span>:seg=<span class="hljs-number">8&#x27;b00111111</span>;<span class="hljs-comment">//&quot;0&quot;</span><span class="hljs-number">4&#x27;b0001</span>:seg=<span class="hljs-number">8&#x27;b00000110</span>;<span class="hljs-comment">//&quot;1&quot;</span><span class="hljs-number">4&#x27;b0010</span>:seg=<span class="hljs-number">8&#x27;b01011011</span>;<span class="hljs-comment">//&quot;2&quot;</span><span class="hljs-number">4&#x27;b0011</span>:seg=<span class="hljs-number">8&#x27;b01001111</span>;<span class="hljs-comment">//&quot;3”</span><span class="hljs-number">4&#x27;b0100</span>:seg=<span class="hljs-number">8&#x27;b01100110</span>;<span class="hljs-comment">//&quot;4&quot;</span><span class="hljs-number">4&#x27;b0101</span>:seg=<span class="hljs-number">8&#x27;b01101101</span>;<span class="hljs-comment">//&quot;5&quot;</span><span class="hljs-number">4&#x27;b0110</span>:seg=<span class="hljs-number">8&#x27;b01111101</span>;<span class="hljs-comment">//&quot;6&quot;</span><span class="hljs-number">4&#x27;b0111</span>:seg=<span class="hljs-number">8&#x27;b00000111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;b1000</span>:seg=<span class="hljs-number">8&#x27;b01111111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;b1001</span>:seg=<span class="hljs-number">8&#x27;b01101111</span>;<span class="hljs-comment">//&quot;9&quot;</span><span class="hljs-number">4&#x27;b1010</span>:seg=<span class="hljs-number">8&#x27;b01110111</span>;<span class="hljs-comment">//&quot;A&quot;</span><span class="hljs-number">4&#x27;b1011</span>:seg=<span class="hljs-number">8&#x27;b01111100</span>;<span class="hljs-comment">//&quot;b&quot;</span><span class="hljs-number">4&#x27;b1100</span>:seg=<span class="hljs-number">8&#x27;b00111001</span>;<span class="hljs-comment">//&quot;c&quot;</span><span class="hljs-number">4&#x27;b1101</span>:seg=<span class="hljs-number">8&#x27;b01011110</span>;<span class="hljs-comment">//&quot;d&quot;</span><span class="hljs-number">4&#x27;b1110</span>:seg=<span class="hljs-number">8&#x27;b01111001</span>;<span class="hljs-comment">//&quot;E&quot;</span><span class="hljs-number">4&#x27;b1111</span>:seg=<span class="hljs-number">8&#x27;b01110001</span>;<span class="hljs-comment">//&quot;F&quot;</span><span class="hljs-keyword">default</span>:seg=<span class="hljs-number">8&#x27;b00000000</span>;<span class="hljs-comment">//&quot;dark&quot;</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h1 id="仿真波形">仿真波形</h1><figure><img src="https://pic2.imgdb.cn/item/6455bd1a0d2dde577758c113.png"alt="仿真" /><figcaption aria-hidden="true">仿真</figcaption></figure><h1 id="引脚配置">引脚配置</h1><figure><img src="https://pic2.imgdb.cn/item/6455bd1a0d2dde577758c166.png"alt="引脚绑定" /><figcaption aria-hidden="true">引脚绑定</figcaption></figure><h1 id="解释说明">解释说明</h1><p>注：有很多没有分配引脚的输出信号是为了方便在仿真的时候调试，可以把他们移除输出，改为wire。</p><figure><img src="https://pic2.imgdb.cn/item/6455bd190d2dde577758c09c.png"alt="RTL" /><figcaption aria-hidden="true">RTL</figcaption></figure><p><imgsrc="https://pic2.imgdb.cn/item/6455bd190d2dde577758c0c9.png" /></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理实验 </tag>
            
            <tag> verilog </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西南交通大学转专业与一般事务指南</title>
      <link href="/2023/03/24/27%E8%BD%AC%E4%B8%93%E4%B8%9A%E6%8C%87%E5%8D%97/"/>
      <url>/2023/03/24/27%E8%BD%AC%E4%B8%93%E4%B8%9A%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="更新日志">更新日志</h1><ul><li>2023/03/24 完成转专业后事务的课程替代和冲突选课部分</li><li>2023/06/29完成转专业后事务的选课、评奖评优、换宿舍部分和资源与信息部分</li><li>2023/07/03 修复了图片图床和转跳联结失效问题，补充了初审流程</li><li>2023/08/06 图片使用本地图片，更改了一些细节</li><li>2023/08/30 面试部分增加了内容</li></ul><h1 id="写在前面">写在前面</h1><p>这是一篇残缺的转专业指南，早在2022年9月转专业成功前后就想写了，但因为种种原因一直没写（忙、懒、已经有完善的指南了），如今已经过去半年之多很多细节也记不起来了。</p><p>学长说他觉得转专业毁了他两年的大学生活，对我来说——可能毁了一年吧。因为学长除了要补离散、OOP、高级语言程序设计外还要补修大物，相比起来我已经好多了……</p><h2 id="关于我">关于我</h2><ul><li>年级：2021级</li><li>原专业：交运学院 - 物流工程</li><li>现专业：计算机学院 - 软件工程</li></ul><h1 id="资源与信息">资源与信息</h1><h2 id="通知汇总">通知汇总</h2><p>每年的通知与时间结点都大致相同。</p><h3 id="教务网---转专业细则">教务网 - 转专业细则</h3><p>各学院转专业细则都在每年寒假给出</p><ul><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=C4F78F220DEF855D">关于公布2023年各学院转专业实施细则的通知</a>- 2022/12/22</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=0C0F62F3F20CEB30">关于公布2022年各学院转专业实施细则的通知</a>- 2021/12/18</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=A2D8ED682A8E583B">关于公布2021年各学院转专业实施细则的通知</a>- 2020/12/31</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=9C52FAC812FB848E">关于公布2020年各学院转专业实施细则的通知</a>- 2019/12/19</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=6AF9850FCAF7B593">关于公布2019年各学院转专业实施细则的通知</a>- 2018/12/18</li></ul><p>其中包含每年的重要文件：<ahref="http://jwc.swjtu.edu.cn/download/ueditor/jsp/upload/file/20221227/1672138715705083837.zip"><strong>学院转专业实施细则</strong></a></p><h3 id="教务网---转专业相关工作的通知初审">教务网 -转专业相关工作的通知（初审）</h3><ul><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=68B780B8696CB0FA">关于开展2022年本科生转专业相关工作的通知</a>- 2022/07/11</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=145C7B6E0890730D">关于开展2021年本科生转专业相关工作的通知</a>- 2021/07/23</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=9426D03269831795">关于2020年本科生转专业相关工作的通知</a>- 2020/07/15</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=E39111921A3869DE">关于2019年本科生转专业相关工作的通知</a>- 1019/07/11</li></ul><p>包含重要信息：转专业<strong>网上申请</strong>时间与安排</p><h3 id="教务网---转专业学院层面相关安排通知各学院考核安排">教务网 -转专业学院层面相关安排通知（各学院考核安排）</h3><ul><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=101EBE5E9BF0EDC1">2022年本科生转专业学院层面相关安排通知（动态更新）</a>- 2022/08/30</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=B7ABA971C04521A5">2020年本科生转专业学院考核、公示相关安排（动态更新）</a>- 2020/09/15</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=48140E7571915A12">2019年转专业学院考核安排通知及公示情况（持续更新）</a>- 2019/08/23</li></ul><p>可能包含的重要信息：入围结果、考核安排、联系方式</p><p>好像很多学院都会拉一个<strong>官方QQ群</strong>进行通知。</p><h3 id="教务网---转专业名单公示">教务网 - 转专业名单公示</h3><ul><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=00760F9760F3752F">西南交通大学2022年本科生转专业名单公示</a>- 2022/09/15</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=C65E90F019234F9C">西南交通大学2018年本科生转专业名单公示</a>- 2018/09/20</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=DEA3842E116C315C">西南交通大学2017年本科生转专业名单公示</a>- 2017/09/15</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=5403685A87EF2AD3">西南交通大学2016年本科生转专业名单公示</a>- 2016/09/03</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=25ABAB0697CFE335">西南交通大学2015年本科生转专业名单公示</a>- 2015/06/24</li></ul><p>重要文件：<ahref="http://jwc.swjtu.edu.cn/download/ueditor/jsp/upload/file/20220915/1663207815880017041.pdf">转专业名单</a></p><p><img src="2022转专业流动图（学院）.png" alt="2022转专业流动图（学院）" style="zoom: 30%;" /></p><p><img src="2022转专业流动图（专业）.png" alt="2022转专业流动图（专业）" style="zoom: 11%;" /></p><h3 id="学院官网---转专业名单公示计院">学院官网 -转专业名单公示（计院）</h3><ul><li><ahref="https://scai.swjtu.edu.cn/web/page-newsDetail.html?nid=c9923259-db46-444e-86c6-ee43fb03cb29">计算机与人工智能学院2022年转专业拟录取名单公示</a>- 2022/09/08</li><li><ahref="https://scai.swjtu.edu.cn/web/page-newsDetail.html?nid=c9f799b9-c287-4c99-bce2-881d98f70157">计算机学院2021年转专业拟录取名单公示</a>- 2021/09/18</li></ul><h2 id="各专业培养计划">各专业培养计划</h2><p>教务处 - <ahref="http://jwc.swjtu.edu.cn/vatuu/PublicInfoQueryAction?setAction=queryProgram">公共信息查询- 各培养计划下载</a></p><h2 id="群聊与咨询">群聊与咨询</h2><p>两个转专业交流群：</p><ul><li><ahref="http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=14vW7myw7a4F26rMWi7lxxgPkEO-wQHu&amp;authKey=xIUNlAa%2FLUC9dICIBeGIigGmKY45ZwrRZ4IcAa%2BtGmHii7XZTS1wzgL2wxf6kvPN&amp;noverify=0&amp;group_code=1058118797">转专业交流群</a></li><li><ahref="http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=BJGEUoUFq1b0lQxs45NwctxcBwkLezNk&amp;authKey=r2PP99mrAJgBE%2FVYPnIvwGaHlFSMHedIWmXpTiNmgbkCouQ2aAnSdyxHtkO1sJbp&amp;noverify=0&amp;group_code=423276278">西南交通大学转专业交流群</a></li></ul><p><img src="群1.png" alt="群1" style="zoom: 30%;" /></p><p><img src="群2.png" alt="群2" style="zoom: 30%;" /></p><p>群中有很多大佬和已经转专业成功的学长学姐，可以进行询问，平时也会发些相关通知在群里。</p><p>但是群聊可能造成信息冗杂、信息焦虑和引起焦虑，建议加入群助手。</p><h2 id="转专业资料">转专业资料</h2><p>我的转专业文件</p><ul><li><p>链接: https://pan.baidu.com/s/1vtmst5VZeEjxRwRAMIchWw?pwd=eq1y提取码: eq1y</p><div style="display: flex; justify-content: center;"><img src="转专业资料.jpg" alt="文件" style="zoom: 70%;" /></div></li></ul><h2 id="转专业分数线">转专业分数线</h2><h3 id="年转计院进入面试分数线">2022年转计院进入面试分数线</h3><figure><img src="rank.png" alt="2022计院分数线" /><figcaption aria-hidden="true">2022计院分数线</figcaption></figure><p>来源于<ahref="https://scai.swjtu.edu.cn/web/page-newsDetail.html?nid=563bf522-0548-448f-bb79-2c5aad260fbd">计算机学院2022年学生转专业考试及面试安排</a>附件。</p><p>注：其中<strong>浅蓝色背景的获得了面试资格</strong>，进入面试。</p><h2 id="专业推免数据专业卷与否">专业推免数据（专业卷与否）</h2><h3 id="届全校推免数据">2022 届全校推免数据</h3><table><colgroup><col style="width: 47%" /><col style="width: 9%" /><col style="width: 9%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /></colgroup><thead><tr class="header"><th>专业</th><th>推免指标</th><th>专业人数</th><th>推免最低分</th><th>推免平均分</th><th>一般推免率</th></tr></thead><tbody><tr class="odd"><td>土木工程</td><td>126</td><td>643</td><td>83.74</td><td>87.149</td><td>18.82%</td></tr><tr class="even"><td>铁道工程</td><td>28</td><td>145</td><td>82.112</td><td>86.664</td><td>18.62%</td></tr><tr class="odd"><td>城市地下空间工程</td><td>12</td><td>114</td><td>81.988</td><td>85.641</td><td>10.53%</td></tr><tr class="even"><td>道路桥梁与渡河工程</td><td>16</td><td>105</td><td>82.636</td><td>86.792</td><td>14.29%</td></tr><tr class="odd"><td>机械设计制造及其自动化</td><td>44</td><td>254</td><td>82.754</td><td>87.172</td><td>16.93%</td></tr><tr class="even"><td>测控技术与仪器</td><td>11</td><td>59</td><td>89.4</td><td>90.528</td><td>16.95%</td></tr><tr class="odd"><td>车辆工程</td><td>33</td><td>188</td><td>84.492</td><td>88.182</td><td>17.55%</td></tr><tr class="even"><td>工业工程</td><td>9</td><td>52</td><td>82.376</td><td>84.566</td><td>15.38%</td></tr><tr class="odd"><td>能源与动力工程</td><td>4</td><td>30</td><td>80.291</td><td>82.326</td><td>13.33%</td></tr><tr class="even"><td>建筑环境与能源应用工程</td><td>9</td><td>53</td><td>84.359</td><td>86.33</td><td>15.09%</td></tr><tr class="odd"><td>交通设备与控制工程</td><td>23</td><td>134</td><td>81.858</td><td>85.949</td><td>17.16%</td></tr><tr class="even"><td>电气工程及其自动化(电力电子与传动控制)</td><td>19</td><td>101</td><td>87.952</td><td>90.223</td><td>17.82%</td></tr><tr class="odd"><td>电子信息工程</td><td>26</td><td>131</td><td>88.455</td><td>91.583</td><td>17.56%</td></tr><tr class="even"><td>电气工程及其自动化(城轨与磁浮交通电气化)</td><td>4</td><td>23</td><td>87.183</td><td>88.867</td><td>13.04%</td></tr><tr class="odd"><td>电气工程及其自动化(轨道交通供电及其自动化)</td><td>17</td><td>96</td><td>88.113</td><td>90.453</td><td>17.71%</td></tr><tr class="even"><td>电气工程及其自动化(电力系统及其自动化)</td><td>19</td><td>107</td><td>87.146</td><td>90.513</td><td>17.76%</td></tr><tr class="odd"><td>电气工程与智能控制</td><td>20</td><td>120</td><td>85.106</td><td>89.172</td><td>16.67%</td></tr><tr class="even"><td>电气工程及其自动化(功率半导体器件及应用)</td><td>4</td><td>8</td><td>83.186</td><td>84.927</td><td>50.00%</td></tr><tr class="odd"><td>通信工程</td><td>18</td><td>97</td><td>87.954</td><td>91.206</td><td>17.53%</td></tr><tr class="even"><td>自动化</td><td>11</td><td>62</td><td>87.382</td><td>90.73</td><td>17.74%</td></tr><tr class="odd"><td>电子科学与技术(微电子技术)</td><td>11</td><td>62</td><td>83.428</td><td>89.695</td><td>17.74%</td></tr><tr class="even"><td>轨道交通信号与控制</td><td>17</td><td>89</td><td>85.732</td><td>89.623</td><td>17.98%</td></tr><tr class="odd"><td>网络工程(铁道信号)</td><td>25</td><td>140</td><td>85.191</td><td>87.584</td><td>17.14%</td></tr><tr class="even"><td>交通运输</td><td>31</td><td>147</td><td>85.84</td><td>89.137</td><td>18.37%</td></tr><tr class="odd"><td>交通工程</td><td>19</td><td>94</td><td>86.374</td><td>88.347</td><td>18.09%</td></tr><tr class="even"><td>安全工程</td><td>4</td><td>28</td><td>82.841</td><td>86.184</td><td>14.29%</td></tr><tr class="odd"><td>交通运输(城市轨道交通)</td><td>18</td><td>118</td><td>85.466</td><td>88.784</td><td>15.25%</td></tr><tr class="even"><td>交通运输(詹天佑学院)</td><td>8</td><td>29</td><td>85.551</td><td>87.328</td><td>27.59%</td></tr><tr class="odd"><td>物流工程</td><td>16</td><td>88</td><td>86.637</td><td>89.493</td><td>17.05%</td></tr><tr class="even"><td>物流管理</td><td>6</td><td>30</td><td>86.172</td><td>88.076</td><td>16.67%</td></tr><tr class="odd"><td>信息管理与信息系统</td><td>11</td><td>77</td><td>89.294</td><td>91.753</td><td>14.29%</td></tr><tr class="even"><td>工商管理</td><td>6</td><td>41</td><td>87.306</td><td>88.112</td><td>12.20%</td></tr><tr class="odd"><td>会计学</td><td>11</td><td>75</td><td>90.803</td><td>93.128</td><td>14.67%</td></tr><tr class="even"><td>工程管理</td><td>5</td><td>36</td><td>84.101</td><td>86.104</td><td>13.89%</td></tr><tr class="odd"><td>金融学</td><td>11</td><td>76</td><td>87.125</td><td>90.869</td><td>14.47%</td></tr><tr class="even"><td>经济学</td><td>11</td><td>74</td><td>84.427</td><td>86.051</td><td>13.51%</td></tr><tr class="odd"><td>汉语言文学</td><td>11</td><td>72</td><td>88.469</td><td>89.506</td><td>12.50%</td></tr><tr class="even"><td>音乐表演</td><td>6</td><td>61</td><td>86.025</td><td>87.511</td><td>9.84%</td></tr><tr class="odd"><td>传播学</td><td>10</td><td>75</td><td>89.276</td><td>90.661</td><td>12.00%</td></tr><tr class="even"><td>广告学</td><td>7</td><td>58</td><td>89.259</td><td>91.373</td><td>12.07%</td></tr><tr class="odd"><td>英语</td><td>6</td><td>47</td><td>90.2</td><td>91.717</td><td>12.77%</td></tr><tr class="even"><td>日语</td><td>3</td><td>25</td><td>92.872</td><td>93.226</td><td>12.00%</td></tr><tr class="odd"><td>德语</td><td>4</td><td>28</td><td>87.939</td><td>89.329</td><td>14.29%</td></tr><tr class="even"><td>法语</td><td>3</td><td>25</td><td>92.486</td><td>92.922</td><td>12.00%</td></tr><tr class="odd"><td>翻译</td><td>8</td><td>51</td><td>90.632</td><td>91.887</td><td>13.73%</td></tr><tr class="even"><td>汉语国际教育</td><td>6</td><td>45</td><td>92.34</td><td>93.192</td><td>13.33%</td></tr><tr class="odd"><td>商务英语</td><td>6</td><td>42</td><td>89.149</td><td>90.909</td><td>14.29%</td></tr><tr class="even"><td>绘画</td><td>3</td><td>28</td><td>85.966</td><td>88.101</td><td>10.71%</td></tr><tr class="odd"><td>建筑学</td><td>10</td><td>85</td><td>87.474</td><td>89.546</td><td>11.76%</td></tr><tr class="even"><td>城乡规划</td><td>6</td><td>45</td><td>88.427</td><td>88.827</td><td>11.11%</td></tr><tr class="odd"><td>风景园林</td><td>6</td><td>46</td><td>86.212</td><td>89.21</td><td>13.04%</td></tr><tr class="even"><td>视觉传达设计</td><td>8</td><td>63</td><td>85.951</td><td>87.294</td><td>11.11%</td></tr><tr class="odd"><td>环境设计</td><td>10</td><td>89</td><td>85.589</td><td>87.23</td><td>11.24%</td></tr><tr class="even"><td>产品设计</td><td>7</td><td>62</td><td>89.741</td><td>90.873</td><td>11.29%</td></tr><tr class="odd"><td>生物医学工程</td><td>9</td><td>53</td><td>85.029</td><td>88.876</td><td>16.98%</td></tr><tr class="even"><td>材料科学与工程(金属材料)</td><td>11</td><td>80</td><td>83.071</td><td>86.866</td><td>13.75%</td></tr><tr class="odd"><td>材料科学与工程(高分子材料)</td><td>12</td><td>67</td><td>86.4</td><td>89.233</td><td>17.91%</td></tr><tr class="even"><td>材料科学与工程(无机非金属)</td><td>5</td><td>11</td><td>82.331</td><td>84.815</td><td>45.45%</td></tr><tr class="odd"><td>材料成型及控制工程</td><td>13</td><td>76</td><td>83.237</td><td>87.201</td><td>17.11%</td></tr><tr class="even"><td>工程力学</td><td>28</td><td>115</td><td>86.186</td><td>90.164</td><td>21.74%</td></tr><tr class="odd"><td>飞行器设计与工程</td><td>7</td><td>30</td><td>80.394</td><td>87.026</td><td>23.33%</td></tr><tr class="even"><td>数学与应用数学</td><td>14</td><td>77</td><td>84.619</td><td>89.232</td><td>16.88%</td></tr><tr class="odd"><td>统计学</td><td>12</td><td>75</td><td>82.564</td><td>88.631</td><td>14.67%</td></tr><tr class="even"><td>电子信息科学与技术（光电子）</td><td>16</td><td>119</td><td>85.553</td><td>88.818</td><td>13.45%</td></tr><tr class="odd"><td>应用物理学</td><td>13</td><td>81</td><td>83.909</td><td>88.738</td><td>14.81%</td></tr><tr class="even"><td>电子信息科学与技术（电磁场）</td><td>17</td><td>96</td><td>86</td><td>90.006</td><td>14.58%</td></tr><tr class="odd"><td>计算机科学与技术</td><td>21</td><td>116</td><td>89.11</td><td>91.992</td><td>17.24%</td></tr><tr class="even"><td>软件工程</td><td>18</td><td>104</td><td>87.721</td><td>90.791</td><td>17.31%</td></tr><tr class="odd"><td>制药工程</td><td>16</td><td>107</td><td>87.519</td><td>90.081</td><td>13.08%</td></tr><tr class="even"><td>生物工程(生物制药)</td><td>8</td><td>56</td><td>84.308</td><td>89.001</td><td>14.29%</td></tr><tr class="odd"><td>生物工程(生物学)</td><td>4</td><td>21</td><td>81.561</td><td>87.843</td><td>19.05%</td></tr><tr class="even"><td>生物工程(生物信息)</td><td>4</td><td>25</td><td>86.264</td><td>90.075</td><td>16.00%</td></tr><tr class="odd"><td>测绘工程</td><td>10</td><td>63</td><td>83.016</td><td>85.879</td><td>15.87%</td></tr><tr class="even"><td>地质工程</td><td>12</td><td>66</td><td>82.835</td><td>85.198</td><td>16.67%</td></tr><tr class="odd"><td>遥感科学与技术</td><td>11</td><td>64</td><td>86.785</td><td>89.54</td><td>17.19%</td></tr><tr class="even"><td>环境工程</td><td>14</td><td>79</td><td>86.194</td><td>88.229</td><td>16.46%</td></tr><tr class="odd"><td>消防工程</td><td>10</td><td>58</td><td>80.368</td><td>83.103</td><td>17.24%</td></tr><tr class="even"><td>地理信息科学</td><td>10</td><td>56</td><td>87.279</td><td>89.701</td><td>16.07%</td></tr><tr class="odd"><td>资源勘查工程</td><td>3</td><td>18</td><td>85.321</td><td>86.099</td><td>16.67%</td></tr><tr class="even"><td>安全科学与工程类(中外合作办学)</td><td>9</td><td>59</td><td>85.693</td><td>88.894</td><td>15.25%</td></tr><tr class="odd"><td>法学</td><td>13</td><td>104</td><td>88.267</td><td>89.613</td><td>12.50%</td></tr><tr class="even"><td>政治学与行政学</td><td>3</td><td>20</td><td>87.941</td><td>89.937</td><td>15.00%</td></tr><tr class="odd"><td>公共事业管理</td><td>11</td><td>81</td><td>86.795</td><td>89.797</td><td>12.35%</td></tr><tr class="even"><td>思想政治教育</td><td>7</td><td>40</td><td>89.4</td><td>91.613</td><td>15.00%</td></tr><tr class="odd"><td>土木工程(利兹)</td><td>8</td><td>65</td><td>89.87</td><td>92.084</td><td>12.31%</td></tr><tr class="even"><td>机械设计制造及其自动化(利兹)</td><td>8</td><td>65</td><td>85.605</td><td>89.01</td><td>12.31%</td></tr><tr class="odd"><td>电子信息工程(利兹)</td><td>9</td><td>74</td><td>90.694</td><td>91.914</td><td>10.81%</td></tr><tr class="even"><td>计算机科学与技术(利兹)</td><td>9</td><td>74</td><td>92.793</td><td>94.476</td><td>12.16%</td></tr><tr class="odd"><td>应用心理学</td><td>6</td><td>42</td><td>92.411</td><td>93.784</td><td>14.29%</td></tr></tbody></table><p>来源于<a href="https://wiki.swjtu.top/free_major/">专业推免详细数据 |SWJTU-Wiki</a>。</p><p>从分数线可以大概了解一个专业保研压力大不大，和卷不卷。</p><h1 id="转专业重要事件结点">转专业重要事件结点</h1><h2 id="初审">初审</h2><p>时间：暑假</p><p>根据<ahref="#教务网-转专业相关工作的通知初审">转专业相关工作的通知</a>在提交转专业申请后，会对你个人进行初步的审核，这一步中便会筛选出部分同学，再进行之后的考核工作。</p><p>注意：要转专业的同学<strong>不建议实习替代</strong>！！因为实习替代会先打0分再替代，可能时间上赶不上初审申请结束时间，而拉低平均分。</p><h3 id="申请流程">申请流程</h3><p><a href="http://jwc.swjtu.edu.cn/vatuu/UserFramework">教务系统</a> -<ahref="https://jiaowu.swjtu.edu.cn/vatuu/WebSite?setAction=index"><code>网上办事</code></a></p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a256c71ddac507cc82aa74.jpg" style="zoom:25%;" /></div><p><ahref="https://jiaowu.swjtu.edu.cn/vatuu/WebSite?setAction=index">网上办事平台</a>- 转专业申请</p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a257431ddac507cc839f7b.jpg" style="zoom:25%;" /></div><p>转专业申请 - <code>点此申请</code></p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a257a21ddac507cc845328.jpg" style="zoom:25%;" /></div><p>此处也可以查看专业转入要求，然后点击<code>申请</code>进行转专业申请。</p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a259011ddac507cc86b6a8.jpg" style="zoom:25%;" /></div><p>会自动生成平均成绩、四六级成绩等相关信息，你只用填写申请理由、附件等就行了。</p><p>最后结果大致如下：</p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a259a61ddac507cc87d7e2.jpg" style="zoom:33%;" /></div><h2 id="笔试">笔试</h2><p>根据<ahref="#教务网-转专业学院层面相关安排通知各学院考核安排">各学院安排</a>，一般会有短信或者QQ群通知。</p><p>时间：开学第一周</p><p>我没有经历笔试……</p><blockquote><p>可以参考<ahref="https://blog.supersassw.com/p/univ-exchange_major/#笔试">西南交通大学转专业指南- 笔试</a></p></blockquote><h2 id="机考">机考</h2><p>根据<ahref="#教务网-转专业学院层面相关安排通知各学院考核安排">各学院安排</a>，一般会有短信或者QQ群通知。</p><p>时间：开学第一周</p><p>我没有参加机考，用CSP替代的……</p><blockquote><p>建议参看<ahref="https://blog.supersassw.com/p/univ-exchange_major/#机考">西南交通大学转专业指南- 机考</a></p></blockquote><h2 id="面试">面试</h2><p>根据<ahref="#教务网-转专业学院层面相关安排通知各学院考核安排">各学院安排</a>，一般会有短信或者QQ群通知。</p><p>时间：开学第一周</p><p>我的面试PPT和面试准备稿子都在<ahref="转专业资料">我的资料</a>中了。因为我们是线上面试，就可以读稿子……虽然回答还是只能随机应变了。</p><p>大概问了我：学了哪些语言，天梯赛情况，c++缺点（Python优缺点）等</p><h3 id="大致流程">大致流程</h3><ol type="1"><li>自我介绍环节</li><li>一个英文问答：一般是一个简单的生活问题或者专业相关问题</li><li>面试老师提问环节</li></ol><h3 id="具体问答">具体问答</h3><blockquote><p>建议参看<ahref="https://blog.supersassw.com/p/univ-exchange_major/#面试">西南交通大学转专业指南- 面试</a>。</p></blockquote><p>老师一般都是根据你的自我介绍，问答情况进行提问的，简单应对就好，这一点上其实很简单的——自信就好。</p><h3 id="可能的准备">可能的准备</h3><ol type="1"><li>准备一个自我介绍+英语问答+面试问答的稿子</li></ol><p>根据<ahref="#具体问答">具体问答</a>可以总结一些基本的问题，也可以自己猜想会问到什么，不一定有很大的用但是可以给自己心理上的鼓励。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我准备的稿子    </div>    <div class='spoiler-content'>        <p>（可以放映PPT吗？可以发简历到聊天框吗肖静杨燕）各位老师晚上好，非常高兴能参加此次面试。我是来自xxx的xxx，下面我将通过三个方面介绍自己。</p><p>首先是学习方面，我科目平均成绩为xx，综合素质评价成绩为xx，专业排名第x，有较强的自我学习能力。</p><p>当然，在大学生活中，不只有学习，锻炼社会工作能力，也是非常重要的。因此我积极参加社会实践，并有较强的能力。我不仅有举办学校年级活动的经历，还有在图书馆、学院团委、学术性社团的任职经历。我现在也担任着ACM协会部长的职位。</p><p>关于学科竞赛，我从初中就开始参加编程竞赛。在大学生活的第一年里，我作为ACM校队和数学建模学术部的成员，参加了大量的学科竞赛，获得了共计x个奖项。其中A类奖项有：南桥杯四川省一等奖，国家三等奖；程序设计天梯赛国家三等奖等，且在天梯赛中排名团队第一。同时也获得了许多有关程序设计的校级奖项，比如新秀杯一等奖，等等。此外，我参加了7场数学建模的比赛，其中4场获得一等奖。</p><p>诸如此些成就与能力，我相信如果我能进入软件工程专业学习，我一定能继续追求自我进步，为学院取得更多成就。我的自我介绍完毕，谢谢老师。</p><p><strong>Q：如何分配时间/为什么参加竞赛、活动</strong></p><p>因为作为一位学生，我自然而然想学到更多的知识，获得更多的技能，这并不算是学生的惯性，更多的是我自主的追求，我爱好编程，喜欢他让脑海中的想法得到实现的过程，并愿意付出时间，所以我才会从初中参加竞赛，进入大学并主动积极加入校队，并成为一员。关于时间，那也自然就是在没有上课的时间里画时间学习竞赛的知识了。至于活动，是调味品和也是另一种实现自我的方式吧。</p><p><strong>Q：数学建模与ACM关系</strong></p><p>我认为数学建模与ACM对于我来说其实是相互促进的关系。一方面我有比较深厚的ACM程序设计基础，作为数学建模的算手，因为有ACM的基础，我能较快的学习、构思并实现解决数学建模问题的代码；另一方面，数学建模的代码量大，能训练我程序设计的严谨性和debug能力。此外程序设计的算法、数据结构更像是理论部分，而数学建模能够帮助其实践运用，进而得到一篇完整的论文。</p><p><strong>Q：如果你转成专业了有什么规划和打算</strong></p><p>短期来看我马上面对着数学建模国赛，ACM网络赛，和各种区域赛；更长远的看，我希望我能进入实验室，在本科阶段做出成果，发表学术期刊，其实我已经在做这件事了；另外我希望能继续读研学习。</p><p><strong>Q：为什么转专业/失败怎么办</strong></p><p>我转专业其实是自然而然的过程，第一因为我有自主的学习内驱力，在学习上也得到了还算不错的成绩，第二是因为我追求挑战与创新，也一直喜欢并参加着程序设计竞赛有着基础，第三是遇到了可爱的同学学长们，以及敬爱的老师们帮助我。</p><p>如果失败了，确实对于我来说非常的遗憾，但我也不会放弃7年的追逐，我也会继续基于我的算法基础发展更多的技能，我会吸取教训，争取在研究生考试实现跨考，我也会专心学习原专业，用所学的知识做出学术成就吧。也感谢各位老师能给我这次转专业面试的机会。</p><p><strong>Q：对于原专业的看法/转专业动机</strong></p><p>在物流我度过了大学的第一学年，在这一年里我了解了物流的背景与发展方向，物流是供应链活动的一部分，带来的是他更像是一个更偏向管理或者说是文科的工科。</p><p>我从初中开始学习信息学竞赛到现在也7年了，在大学的一年里我也继续保持着对编程的爱好，也是校队的一员，也自然的想要转入软件工程来学习。在性格上我善于创新，追求挑战，所以想要进入软件工程；在学科本身上，软件编程本身是有规则的，有迹可循的，而不是基于实验/猜想得到的规律，这一点正是软件工程吸引我的原因。</p><p><strong>Q：为什么不报计算机科学/为什么想转软工</strong></p><p>计算机科学的培养目标更多是应用研究、技术开发或管理等方向，其理论性更强，相较之下软件工程面向软件系统研发等，更符合实践，也更符合我的兴趣与想要的研究方向。去解决问题去创造实现问题的方法这正是我追求的，这也是我运用编程能力积极参加数学建模的原因。</p><p><strong>Q：关于英语差</strong></p><p>从主观原因上，我英语基础不理想，其主要原因是曾经教育阶段的英语过分强调了背诵、记忆，而没有让英语的实用、媒介作用得到发挥。我擅长于理解，不善于单纯的记忆。客观原因上也有我用竞赛时间挤压的原因。</p><p>但是在大学里，我无论是在比赛上又或是在科研上都会接触英文题面与英语的论文。我更多的看到了英语的实际作用，现在我也经常阅读英文文献、书籍，对其中的陌生单词进行快速查找，留下记忆，因此我英语能力与语感得到了极大的提升，相信这不会成为一个难题。</p><p>自我介绍</p><p>Good evening teachers, I am very happy to attend this interview. I amWang Zixi from Logistics. I will introduce myself in three aspects.</p><p>First of all, I have an average grade of 88.95 in all subjects and anoverall quality assessment score of 93.29, ranking second in my major,so I have strong self-learning ability.</p><p>Of course, in university life, not only studying, but also exercisingsocial work skills, is very important. Therefore I actively participatein social practice and have a strong ability to do so. Not only do Ihave experience in organising school year activities, but I also haveexperience in serving in the library, the college committee and academicsocieties. I am also currently holding the position of Director of theACM Society.</p><p>Regarding subject competitions, I have been participating inprogramming competitions since junior high school. During my first yearof university life, I participated in a large number of subjectcompetitions as a member of the ACM varsity team and the academicsection of Mathematical Modelling, and also won a wealth of awards. Someof the A-class awards include: the first prize in Sichuan Province inthe Nanqiao Cup, the third prize in the country; the third prize in thecountry in the programming ladder competition, the second prize inSichuan Province in the team, the third prize in the country in theteam, and the first place in the team in the ladder competition. I havealso won many school-level awards related to programming, such as theRookie Cup, and so on. In addition, I have participated in sevenmathematical modelling competitions and won first prize in four ofthem.</p><p>With all these achievements and abilities, I believe that if I canenter the Software Engineering program, I will be able to continue topursue self improvement and achieve more for the college.</p><p>学校</p><p>Southwest Jiaotong University is a transportation-focused institutionof higher learning that has produced a large number ofprofessionals.</p><p>物流</p><p>Logistics originally meant "physical distribution", which is part ofthe supply chain activities</p><p>家乡</p><p>My hometown is Qianwei, a small town located in the south of Leshan,with beautiful natural scenery and local culture. It is rich in tea andit is my cradle forever.</p>    </div></div><ol start="2" type="1"><li>可以找熟悉的人模拟面试几次</li></ol><h1 id="转专业后事务">转专业后事务</h1><h2 id="选课">选课</h2><p>每学期末，教务网会发放第二学期的选课通知，如<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=572C043902FDE315">关于做好2023-2024学年第一学期选课工作的通知</a>，选课包含三次而前两次都在转专业结果出来之前，第三次选课是在转专业结果出来之后（一般是每学期的第二周），这个选课就是针对转专业学生重写选课的。</p><p>第一次第二次选课<strong>按照原专业的优选班选择</strong>。</p><h3 id="前言">前言</h3><p>大学生都知道选择好的（给分高）老师很重要。</p><p>在第一次选课期间要分配好权重，首先保证自己的英语老师不错。然后去研究咨询其他课的老师情况。</p><p>一般可以通过<ahref="https://huoshui.org/">活水</a>快速的了解一个老师的好坏，对于一些“名”师（好/坏）也可以直接看出来，评价的人越多，偏差越小。对于不了解的还可以询问同学、学长等。</p><div style="display: flex; justify-content: center;"><img src="活水.png" alt="活水" style="zoom:25%;" /></div><h3 id="换教学班攻略">换教学班攻略</h3><p>如果遇到了天坑老师或者有明确更换老师，</p><ol type="1"><li>可以直接在第一次选课不选这门课，方便在第二次选课的时候抢，<strong>节约取消选课的时间</strong>（抢过课的人应该懂的都懂）</li><li>需要<strong>提前查询并整理</strong>好相关课程、老师和时间的信息。第一是明确抢课步骤（PlanA，Plan B），第二是一般选课期间<ahref="https://huoshui.org/">活水</a>就查看不了了（访问量过大）。</li></ol><h3 id="一个选课整理的例子">一个选课整理的例子</h3><div class='spoiler collapsed'>    <div class='spoiler-title'>        大二上选课例子    </div>    <div class='spoiler-content'>        <p>我曾经选课整理的。</p><div class="hljs code-wrapper"><pre><code class="hljs diff">√第一步：概率论【已删】 换 程世娟（星期四 3-5节）/  赵春明（星期三 8-10）√第二步：供应链管理怕【已删】 换 王群智（星期三 3-5节）√第三步：【第二步成功】马原 换 米曙娟（星期一 3-5节）              【第二步失败】马原 换 袁雨宸（星期三 3-5节）X第四步：软件工程 换 另一个班√第五步：运筹学 换 王坤——————————————————————————概率论：星期三 3-5节 MATH001612<span class="hljs-deletion">-赵春明：有趣透彻*95；概帮帮主；给分不算高</span> （星期三 3-5 8-10）<span class="hljs-deletion">-程世娟：没有小测，给分高*8</span> （星期四 3-5节）★★★<span class="hljs-deletion">-左东：负责；板书；高中老师；看其他科目成绩；平时分平均分最高</span> （星期三 8-10）<span class="hljs-deletion">-彭皓：特别水；测验我没去，然后满分；雨课堂签到</span>运筹：【时间无法变动】<span class="hljs-deletion">-王坤：负责，课好，但严</span> （星期三 6-7）★<span class="hljs-deletion">-郑斌：课不算好，亲和，签到</span> （星期三 6-7）马原：<span class="hljs-deletion">-袁雨宸：年轻，不死板，有思考；有免考（平时拉满、读书笔记）；课堂表现20分（回答问题，可QQ）</span> （星期三 3-5）★<span class="hljs-deletion">-杨东：平时分拉满*11</span> （星期一 3-5节）<span class="hljs-deletion">-米曙娟：免考；温柔；送分*7</span> （星期一 3-5节）★供应链管理：【必跑！！！】<span class="hljs-deletion">-王群智：讲故事，有趣</span> （星期三 3-5节）★★软件工程<span class="hljs-deletion">-换一个班 ★</span>考虑”市场调查与分析竞赛训练“——————————————————通用学术英语<span class="hljs-deletion">-杨琼：给分高，上课不舒服</span><span class="hljs-deletion">-付华权：给分不高，上课舒服；不点名平时分也不是很高</span><span class="hljs-deletion">-余小玲：事不多；上课不用回答问题上课表现分就满了</span><span class="hljs-deletion">-里娜：事不多</span><span class="hljs-deletion">-张梅子：平时分能到55</span></code></pre></div>    </div></div><h3 id="转专业选课攻略">转专业选课攻略</h3><ul><li>两个专业都要修的课<ul><li><strong>最高优先级</strong>，例：概率论、马原</li><li><strong>重要</strong>：通过教务网、优选班课程表pdf、<ahref="http://jwc.swjtu.edu.cn/vatuu/CourseAction?setAction=queryCourseList&amp;selectTableType=ThisTerm">本学期课程表</a>和<ahref="http://jwc.swjtu.edu.cn/vatuu/CourseAction?setAction=queryCourseList&amp;selectTableType=NextTerm">下学期课程表</a>。<strong>同时参看本专业与转入专业的课</strong>（找同学或学长要）的教学安排时间，整理，最大可能的防止课程冲突，防止抢的课因为时间冲突又不得不放弃。（这是一个很困难很麻烦的事情，但是刚转入的那学期的课程冲突真的很麻烦）</li><li>更换策略参看<a href="#换教学班攻略">换教学班攻略</a></li></ul></li><li>原专业专业课<ul><li>次优先级</li><li>因为专业课调班的人不多，一般来说想调就调。</li></ul></li><li>转入专业专业课<ul><li>次优先级</li><li>对于大部分的同学来说，不会也<strong>没有必要</strong>在第二次选课就选上转入专业的课，也不用担心好的老师会被选完，因为专业课调班的人不多（相对于概率论、马原这种大家都修的课），而且转专业成功之后教务会与学生对接（会收集问卷等），<strong>第三次选课时会对每个老师的课程容量进行扩容</strong>。</li></ul></li><li>转入专业补休课<ul><li>次次优先级，对于简单的课程建议<ahref="#冲突选课"><strong>冲突选课</strong></a></li></ul></li><li>选修课/多元化<ul><li>次次优先级</li><li>一般来说建议大一下就修满选修课学分（大部分学院选修课要求四个通识学分）。这个<strong>一定要仔细研究现专业和转入专业的培养方案</strong>！！！尽量选择两个专业都能满足的课。部分专业的选修课或多元化课是多选一的课，不是随便选通识。</li></ul></li></ul><h3 id="选课页面与攻略">选课页面与攻略</h3><p>相信很多人经过一学期忘了选课界面了，而且非选课时间是打不开的。这里帮大家复习一下(?)。</p><p><ahref="http://jwc.swjtu.edu.cn/index.html?version=2020"><code>教务处</code></a>- <code>学生</code>即<ahref="http://jwc.swjtu.edu.cn/service/login.jsp">学生登录</a>，可以进入：</p><div style="display: flex; justify-content: center;"><img src="选课服务器.png" alt="选课服务器" style="zoom:33%;" /></div><p>可以考虑使用选课服务器，注意可以打开多个窗口进入选课，方便一边删除一边插入，同时不建议频发刷新网页（可能会更挤不进去）。听说用宽带接入学校内网是最快的，其次是去校外，最差的是校内使用非内网（热点）。</p><div style="display: flex; justify-content: center;"><img src="选课页面.png" alt="选课页面" style="zoom: 25%;" /></div><p>最常用的是选其他优选班，其次是撤销已有选课。可以多个网页进入<code>选其他优选班</code>，一个网页进<code>撤销已有选课</code>。</p><div style="display: flex; justify-content: center;"><img src="选其他班.png" alt="选其他班" style="zoom:25%;" /></div><p>通过提前存好的信息直接查询课。</p><h2 id="课程替代">课程替代</h2><p>转专业成功后会拉一个小群，会有教务老师、辅导员与转专业的学生进行指导对接。在课程替代上，你需要填写《转专业学生课程替代认定表》并打印两份，交由教务处审核并盖章然后返还你一份。</p><ul><li>最好提前找实习老师要来《XX实习课程大纲》（不是教务网能下载的那个）并连同认定表一起打印两份，两份分别装订。</li><li>实习需要“计算机程序设计基础”与原专业的“XX实习”课程二对一替代。</li></ul><p>注意：</p><ul><li>计算机学院在2022年取消了新生导论课的替代（承诺大三上开补修班补修【未实行】）。</li><li>计算机学院在2022年加强了实习替代的审核，只有与计算机相关的实习能够替代实习（建议大二下暑假上两个实习）。</li></ul><h2 id="冲突选课">冲突选课</h2><ol type="1"><li>建议对较为容易的课程进行冲突选课，如：高级语言程序设计、面向对象</li><li>如果有熟悉认识的老师就最好了</li><li>冲突选课的优点是：节约本来就很少的时间、为了选其他课（老师）把次要课程冲突</li></ol><p>每学期第一周<ahref="http://jwc.swjtu.edu.cn/">教务处</a>会印发本学期的选课安排通知（如：<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=50A9E994BCB9AC50">2022-2023学年第二学期第二阶段选课安排</a>）,本通知告知了第二阶段选课（即第二次选课和第三次选课）的时间安排，并在文末会提及到超学分选课相关安排和冲突选课申请安排，冲突选课申请时间为选课结束后的一周内。</p><blockquote><p>冲突选课申请安排通知如下：本学期冲突选课申请时间：2023年3月23日-2023年3月31日，具体操作流程及注意事项见《<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=959F806B5F4C9CD1">冲突选课申请流程</a>》，学生登录教务系统辅助平台；密码默认为身份证号码后6位，如果修改过则为修改过的密码。</p></blockquote><h3 id="官方流程">官方流程</h3><p>在教务网网上办事处<ahref="https://jiaowu.swjtu.edu.cn/vatuu/WebSite?setAction=detail&amp;tspId=0380707C53D59CD4&amp;tspSortId=61E92EF67418DC54">冲突选课</a>板块和教务处的<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=959F806B5F4C9CD1">冲突选课流程</a>告知了冲突选课的具体流程如下：</p><p><img src="http://jiaowu.swjtu.edu.cn/download/news/images/20211108/1636354222529071788.jpg" alt="冲突选课流程" style="zoom: 10%;" /></p><p>具体操作如下：</p><p>1、网上下载并填写<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=download&amp;fileType=file&amp;fileId=D328348E5032A442">《冲突选课申请表》</a>，填写时注意填写项要求；</p><p>2、任课教师审批冲突选课申请表；</p><p>3、学院审批冲突选课申请表；</p><p>4、在教务系统辅助平台网上提交冲突选课申请(http://180.85.38.138:8000/)</p><p>（1）学生登录<ahref="http://180.85.38.138:8000/">教务系统辅助平台</a>；密码默认为身份证号码后6位，如果修改过则为修改过的密码；</p><p>（2）点击【冲突选课申请】--【提交冲突选课】--“填写课程信息，务必填对选课编号”（提交的课程为教务网课表未选上的课程，每位同学最多提交2门课程）；</p><p>（3）提交冲突选课申请；</p><p>5、提交审批完的《冲突选课申请表》到教务处排课与考试中心（综合楼222办公室）；</p><p>6、教务处排课与考试中心审核《冲突选课申请表》和网上冲突选课申请；</p><p>7、审核通过，冲突选课生效，学生在教务网查询本学期个人课表，按课表上课。</p><p>注：每个学生每学期冲突选课不超过2门</p><h3 id="个人理解">个人理解</h3><p>以个人理解步骤如下：</p><ol type="1"><li>填写《冲突选课申请表》并打印两份，“学生承诺”处自己签字；</li><li>分别找冲突的两个课程的老师，并让他们在“任课教师签名”处签字；</li><li>找自己学院（本科）教务处老师在“学生所在学院意见”处写“同意”，在“教学院长签字”处签字；</li><li>找自己学院盖章处（通常第三步中的教务老师会告知你），在“学院公章”处盖章；</li><li>第三次选课结束后在<ahref="http://180.85.38.138:8000/">教务系统辅助平台</a>提交冲突选课申请；</li><li>把纸质的申请表交给学校教务处（综合楼222），即排课与考试中心。</li></ol><p>建议步骤1-4在第三次选课结束前完成。</p><h3 id="一些性质">一些性质</h3><ul><li>冲突选课<strong>可以无视课程容量限制选课</strong></li><li>冲突选课仅需要交作业和考试</li></ul><h2 id="评奖评优">评奖评优</h2><ul><li>评奖：即申请国家奖学金、国家励志奖学金、专项奖学金、一二三等奖学金等。</li><li>评优：即申请三好学生（标兵）、优秀学生干部等荣誉称号</li></ul><p>若转专业成功，<strong>评奖评优将在原学院进行</strong>。一切的评奖评优申报，包括国奖（国家奖学金）答辩、评选等都是在原学院进行。奖学金会自动打入<ahref="https://cwc.swjtu.edu.cn/">西南交大计划财务处</a>绑定的银行卡，奖学金证明和荣誉将会在转入学院发放（一般是班长发）。</p><p>这个时间线很长好在申请之后就不用关心这件事了，不用花费太多精力（转专业与大学生活非常消耗精力，这种事情能不在意就不要关心了）。</p><h3 id="前置学生信息拓展">*前置：学生信息拓展</h3><p><a href="http://xg.swjtu.edu.cn/web"><code>扬华素质网</code></a> -<code>用户登录</code> - <code>个人信息</code> -<code>学生拓展信息</code></p><p>申请自己获得的奖项、科研经历、实践活动等，并通过了辅导员审核，便于在申请评奖评优的时候直接引用（仅能引用）。</p><div style="display: flex; justify-content: center;"><img src="拓展信息.png" alt="拓展信息" style="zoom:25%;" /></div><h3 id="申请评奖评优">申请评奖评优</h3><p><a href="http://xg.swjtu.edu.cn/web"><code>扬华素质网</code></a> -<code>用户登录</code></p><p>即登录<ahref="http://xgsys.swjtu.edu.cn/userhall/smart/student">学工一体化平台</a>，一般若申请开放可以直接在首页的业务申请项里面看见；也可以点击“<code>办事大厅</code> - 评优管理项 - <code>学生评优管理</code>”进入。大致界面如下：</p><p><img src="评奖评优.png" alt="评奖评优" style="zoom:25%;" /></p><p>注意：</p><ul><li><p>这个网页非常卡，很可能要提交多次，建议把申请理由等复制到一个文档保存起来。</p></li><li><p>在这个网站，“<code>办事大厅</code> -<code>综合素质评价管理</code> ”下可以看自己综测结果</p></li></ul><h3 id="奖学金收入查询">奖学金收入查询</h3><p>路径： <ahref="https://cwc.swjtu.edu.cn/"><code>西南交大计划财务处</code></a> -<code>财务系统</code> - <code>登录</code> - <code>新版财务查询</code> -<code>我的收入查询</code> - <code>个人酬金查询</code></p><div style="display: flex; justify-content: center;"><img src="财务.png" alt="财务" style="zoom: 25%;" /></div><h2 id="更换宿舍">更换宿舍</h2><p>因为犀浦宿舍资源紧张（202?-2023），原则上不能申请新的宿舍，只能插入转入专业的有空位的宿舍（所以很多人也不会换宿舍）。但是九里的同学一定会换宿舍到犀浦的（新东部校区还没建好，情况未知）。</p><p>更换宿舍主要是辅导员安排，所以并不是一定在转入的时候就决定好。同时，可以自己联系有空位的宿舍（询问新同学，社恐噩梦QAQ俄），再询问辅导员进行调换，这样的效率会高很多（比如辅导员告诉我没有空位）。</p><p>更换宿舍，<strong>只需要填写一张表</strong>，按照表格操作即可。</p><h1 id="写在后面">写在后面</h1><p>嗟后人哉，世事沧桑，仰观昔日之辉煌。滕王阁上，巍峨高楼，昔日英杰何在？今朝风华，如云烟飘逝，往来者何去之？</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转专业 </tag>
            
            <tag> 大学事务 </tag>
            
            <tag> 西南交通大学 </tag>
            
            <tag> 攻略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和她的故事</title>
      <link href="/2023/02/19/26%E5%92%8C%E5%A5%B9%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2023/02/19/26%E5%92%8C%E5%A5%B9%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>好似那笼中雀扑向水中月。 <span id="more"></span></p></blockquote><h2 id="和她的故事">和她的故事</h2><p>我和她的故事如何讲起，是在那个还有这烟火味道的除夕？还是那年暑假的补课？时间过去了太久，久到我忘记了相知的细节，相处的悸动。</p><p>在那个除夕我天真的认为，真的是她大冒险输了，来询问我是否喜欢他人，再再一年后的补课，我出于什么心理坐在她身旁。我不能说这是少年的心动，因为这显得很廉价。在补课结束的那段时间我们慢慢聊了许多，再往后我要她写诗却写了一封信，信封从线上来到线下，配上周末的交谈，似乎便开始了。</p><p>我不知道如何定义这个开始，可以说是她偶尔口上说笑，也可以说是相知与心换心。那段时间太多事太多细节已经记不清，至少每天会有担心，激动，害羞，有多想的充实。入今看来如梦如幻的日子啊，其实早也有祸根，我会吃错，交流也大都限于线上。也许这就是我至今不能确定这究竟算不算谈，算不算那关系。</p><p>分开后的很长一段时间，我对她的定义是半个女友，这来自于离别的对话，但是我似乎是记错了。“我们还不算男女朋友关系吧”，“四舍五入也算了”。也许这段对话来自梦中？不管怎么样也快一年的联系就此断绝，在毕业后的第一天，从此山河相隔，再难相见。</p><p>一直还是意难平的。在那个长假里，我逝去了许多爱好和计划，或积极或消极的逃进大学，我单方面屏蔽了她的空间很长时间，再往后我偶尔会看到她的说说与朋友圈。我也自以为两人再难走入新的亲密关系——直到她曾经从来不让我知道的账号突然关注了我——直到我今天看见他元宵节的回答——直到我看见了她对前男友的叙事。恍恍忽，我才知道，所谓的影响如镜中花。笼中雀倒影着水中月。一切静下来，慢下来，其实也不过如此。</p><p>以为我想说什么？我眼泪早已在最后那一学期里留尽了。往后在她生日那天也再难哭出来，其实我并不逃避这段关系，我时常回想品味。已经很淡了，大学时间冲淡了太多东西，我是不想忘记的，也不可得。我只认为在无数的孤月下，会有两个独立又萧条的背影。如今看来，宛若秋风。</p><p>感性叙事并不能带来什么。但她真的回避依恋了吗？我怀疑了起来了。我不知道，我只知道我的心空了，空了很久——我记不起来了。</p><p>我现在，似乎很平静，也只是似乎罢了。一股电流从脚流到胸腔，它早就比不上当年的刺痛了。我又来这干什么呢？</p><p>——23.02.19 00:46</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 岁月录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 光点 </tag>
            
            <tag> 散文 </tag>
            
            <tag> 元熹 </tag>
            
            <tag> 爱情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年鉴 - 烟花</title>
      <link href="/2022/12/31/25%E5%B9%B4%E6%8A%A5/"/>
      <url>/2022/12/31/25%E5%B9%B4%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>        <div id="aplayer-rauJNOKm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"烟花落","author":"DarkSpirit","url":"http://music.163.com/song/media/outer/url?id=1314010312.mp3","pic":"http://p1.music.126.net/pLtzftMgZ1E1X-plEZlfWA==/109951163577838770.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-rauJNOKm");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><p>好久不上楼顶，久卧未眠心神不宁，所以登楼望风。竟窥到楼顶门外有光，轻轻推开门从门缝中窥视，才发现有人打灯在板凳上写着东西。敲敲门，推门而出，门外的人却骇然的收走了纸笔∶“现在还有人能看见夜里的人？”</p><p>我看见他呼的一声甩手把光亮甩灭，一个转身不见了身影，不由心中不安，一手扶着门框喊道∶“谁家的小孩，半夜不睡觉在楼顶晃悠？”听到这话那声音笑到“我当是谁，哪来的细杆子”，说着声音到了我耳边，“快快快，这边坐，都说这楼住都是老年人，这不就碰见稀客了吗”。感觉左肩后背被人推着向前引去，我浑身一颤，一回头看见了一个比我矮不了多少的模糊身影。</p><p>他自顾自的走着，嘟囔着什么，我四处瞧去，除了他身边有暗光一片以外就只有在城市灯光下围栏的剪影。什么都看不清的一片中他四处摸索，终于抬出一个破旧板凳来。“是你让我这蓬荜生辉了”他说着摸了摸，“实在是让你见笑了，现在人用火少了，年也不过了，我这里也不太富足。”缓缓的，一盏灯在他手里慢慢亮了起来。“你这铜灯有意思啊，这灯我都没见过，是古董了吧”说着把头凑过去想仔细看看这灯的构造。</p><p>火光猛地摇曳了一下，我余光看见了他的脸无比的熟悉，竟和我有些相似。“你什么人！”猛地双脚蹬起，猫腰着颇像受惊的猫。“就你们才能在夜里见得我！我就是你，你就是我。不信你且来仔细瞧瞧。”几近迟疑，还是从新坐下了，“你什么魑魅魍魉我也不怕，身正不怕影子斜德高何忧生是非，你若是鬼我倒是要抓你起做研究呢！”</p><p>他惊讶，“你胆子倒是大了不少，也变得油嘴滑舌了起来。”又耻笑道∶“穿着个破夹袄，就当孔乙己呢？你信不信我无所谓，我就想问你，你现在还写东西吗？”“你问这做甚，与你有什么干系！”好像又回想起什么，胀红了脸道，“你怎就认为我没写了，我前两周才写过信呢！”对面啧啧“想不到你竟沦落到这个地步，我构想的也够低了。你也没有必要解释什么，你要解释的我都知道，无非是什么没时间没心思没心境，是吧？”我脸色一边红一边紫“你你……你懂什么，搞学习学东西不花时间的吗？我还拿了那么多奖……”“是是是，你都没时间，你都在做‘正事’。”他把灯扣在扁凳上，火光熹微似乎就要灭了，“那你还带着个破眼镜，装自己和以前一样呢？我随便问你一点我都知道的东西你怕啥都不知道了吧——比如那个，那个retard是什么意思？”</p><p>“你你知道我英语不好就问英语是吧，有本事考古诗，或者考考数学！”“行，你想默写《蜀道难》还是求求初中的相似三角形题啊？你，我还不了解？”他嘲讽的说道，“古诗只会背，呵呵，还有就你那沾沾自喜的数学看你大学学的怎么样？你别给我说什么高数不一样的，就看你英语没有一点长进其他还都在落后我就看不起你！”。</p><p>我气结了，站起来起靠着围栏说“你也不看看你现在怎么样就说我，谁喜欢戴眼镜，谁喜欢舞文弄墨的，喜欢的人喜欢不上，在一起的人走不遥远，兴趣兴趣不能养成，一知半解一事无成。”“是呀是呀，这可总结的太到位了，我都想给您鼓掌了。希望不要再看见你晚上在外面喝酒，又什么缅怀过去的那个她，别人早把你忘了。你那样子，以后也脱不了单，没人理你，做你的工科生去把！”说着就消失了。</p><p>望着城市的老旧楼房，和一些格格不入伫立在城区和边郊的一些高楼。他们身上的霓虹灯也熄灭了，天边的红也消散了。再往上，星星三两点洒在天幕上，忽然星星就从眼角流了出来。</p><p>没人祝福自己，也没有能祝福的人，今天可是元旦啊。趴在栏杆上，让身体紧贴围栏那厚厚的水泥壁，这样腿可以轻松些，也多些依靠。冷，寒冷通过栏杆传递到胸口，把手攥起来缩进衣袖。想起了在寒风中披星戴月早出晚归去往图书馆；想起一个个冰冷的夜里在大厅熬夜，后背一瞬间被贴紧了，另一双手穿过了臂弯。还是有温度的不是吗？我挣扎着翻过了身，身上的束缚又消失开来。</p><p>“喂，你在哪？”</p><p>“喂，我想你了！”</p><p>“可我不想你，”油灯光芒收敛，他又蹦了出来。“你走不出过去，也走不通未来。还是现在一样”，他赌气的插着腰，“胆小、内向、懒惰怎么还是一模一样啊。”</p><p>“和以前一样吗？”</p><p>“一样什么一样，都变啦”他摸了摸鼻子，“你以为我为什么出现在这啊，你听过一句话吗，每个人心里都有个死小孩，我的小孩死啦，现在你的也死啦！”</p><p>“我还知道每个人都是小怪兽，最后都会正义的奥特曼消灭。”“你个半吊书袋子，怪不得找不到对象。”他抹着眼睛说到。“找不到就找不到，我还是有你啊。”“我你可再也见不到了”他哽咽着说，“没人记得我，没人会点灯放烟火纪念我们……你们都在追逐那些实际的利益与虚无的自我，你，你们……”</p><p>“是，是这样的”</p><p>“你就愿意看我远去？”</p><p>“没有人会一直回望过去的，当下和未来才是要面对的，你影响了我，你们也要为下一个我们负责不是吗？”</p><p>“就不会想我，纪念我？”</p><p>“会啊，时时刻刻，我就是你啊！”</p><p>毕了，那身影钻入灯花，消失不见了，忽然，远处微小的爆炸声想起，然后是第二声第三声，无数的花火在夜空绽开。在椅子上留下了发光的卡片与燃尽的油灯，看这温度，原来灯已经灭了好久了。</p><p>我醒了，记不得那似梦非梦的夜。窗外阳光刺眼，枕边一张白色信封躺着。上面有着印泥，手绘邮票，背后写着：</p><p>愿为烟火，与君相逢。</p><blockquote><p>记作《铜灯小记》</p></blockquote><p><img src="https://pic.imgdb.cn/item/63b120f12bbf0e7994637009.png" /></p><hr /><h1 id="学习">1 学习</h1><blockquote><p>为什么总是把学习放在第一位呢？大概是因为惯性和希望吧。长久以来学习都是最重要的——无论是家庭教育又或是学校的教育。当然我也一直认为我是求学之人，但这样的惯性是否是对的呢？选择似乎更重要。</p></blockquote><p>上半年的学习情况已经在<ahref="https://dramwig.github.io/2022/06/25/22年报/">半年鉴</a>中有写道。至于下半年基于学习习惯，我只是保持的低限度的学习——没有考试的压力也不会画很多时间来复习。但是期末考试推迟到了明年的开学，所以期末的压力也顺延了。</p><p>下半年来影响最大的事情是我转专业的成功，我成功到了一个我更加熟悉与得心应手的学院与专业。同时也有国赛失利、社团团体矛盾的事情拉扯，过的很累却又无所事事——经常在半夜还在外面吃夜宵与喝酒（有点难以切齿）。大概是累了，也放松了，所以学习才放下了那么多。</p><p>在竞赛上主要是参加了很多场ACM区域赛，也只获得了一枚区域赛铜牌，至少不是空手而归了。</p><h1 id="同道">2 同道</h1><p>感觉认识的人更多，熟悉的人更少了。</p><p>挚友和熟人圈几乎都没有变，要说变了还是有圈子破碎和友人渐远的感觉。我无心太去经营这些，毕竟我也改变不了别人。</p><h1 id="app年报">3 App年报</h1><ul><li><p>知乎</p><ul><li>2022年你在知乎发表了3个问题、32个回答、13篇文章、27个想法、172979个字</li><li>2022年你有108天发表了内容，2月是最高产时段</li><li>你的内容1被阅读了141331次，你在其他领域创作最多</li><li>你的创作被转发了56次，被收藏了1136次</li><li>你收到了2332个赞同</li><li>2022又有99个粉丝关注了你，最常浏览你内容的是@放之</li><li>今年你常常在深夜时段打开知乎刷刷推荐</li><li>8月2日你在知乎停留了5小时，是最久的一天</li><li>2022，你一共浏览了5740个问题、17537个回答、732篇文章、20275609个字</li><li>你浏览了4939位答主的回答461个万赞回答</li><li>你浏览最多的是科学工程、教育</li><li>2022年你发出了1432个赞同、522个喜欢</li><li>关键词：承认欲望</li></ul></li><li><p>QQ音乐</p><ul><li>2022年，你共听歌984首，81h33min</li><li>你与音乐的故事多发生在11月</li><li>你收听了11首收藏量小于999的歌，循环了89次”报国寺喝茶“</li><li>你收听了153首新歌</li><li>9月18日，你4:44还在听歌</li><li>年度关键词：天空</li><li>年度歌单1.报国寺喝茶 2.Dear Moments 3.落英 4.阿拉斯加湾 5.城南花已开6.马 7.acacia 8.白鸟过河滩</li></ul></li><li><p>网易云音乐</p><ul><li>听过187手歌、19小时25分钟</li><li>你大部分是时间在听10年代的歌</li><li>9月9日3:59还在听龙图</li><li>发现了只有104人听过的报国寺喝茶</li><li>春天：Reunion In TheWind，夏天：报国寺喝茶，秋天：画，冬天：Singularity</li><li>与耳机另一端一起听了21234分钟</li><li>年度歌曲：落日随山隐</li><li>11%逍遥 35%纯洁 54%云淡风轻</li></ul></li><li><p>QQ</p><ul><li>你最爱用”辣眼睛“”幽灵“</li><li>热聊TOP5：AFXR、蹦豆、莫栩、Yuyuse、长苏</li></ul><hr /><blockquote><p>疫情全面放开、经济下行、俄乌冲突……未来难料</p></blockquote></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 年报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程训练】二维导热 - 差分模拟</title>
      <link href="/2022/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E4%BA%8C%E7%BB%B4%E5%AF%BC%E7%83%AD/"/>
      <url>/2022/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E4%BA%8C%E7%BB%B4%E5%AF%BC%E7%83%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="显示迭代法">显示迭代法</h1><h2 id="问题">问题</h2><p>模拟绝热环境下有初始温度差的二维平面的温度随时间的变化情况。</p><p>（gif见知乎文章）</p><h2 id="代码">代码</h2><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%二维热传导过程显式差分模拟</span>clear;close <span class="hljs-built_in">all</span>;clc;t <span class="hljs-built_in">=</span> <span class="hljs-number">0.03</span>;       <span class="hljs-comment">%时间范围，计算到0.03h</span>x <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>;y <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">%空间范围，0-1m</span>m <span class="hljs-built_in">=</span> <span class="hljs-number">320</span>;        <span class="hljs-comment">%时间t方向分320个格子</span>n <span class="hljs-built_in">=</span> <span class="hljs-number">32</span>;         <span class="hljs-comment">%空间x方向分32个格子</span>k <span class="hljs-built_in">=</span> <span class="hljs-number">32</span>;         <span class="hljs-comment">%空间y方向分32个格子</span>ht <span class="hljs-built_in">=</span> t/(m-<span class="hljs-number">1</span>);   <span class="hljs-comment">%时间步长dt</span>hx <span class="hljs-built_in">=</span> x/(n-<span class="hljs-number">1</span>);   <span class="hljs-comment">%空间步长dx</span>hy <span class="hljs-built_in">=</span> y/(k-<span class="hljs-number">1</span>);   <span class="hljs-comment">%空间步长dy</span>u <span class="hljs-built_in">=</span> zeros(m,n,k);<span class="hljs-comment">%设置边界</span>[x,y] <span class="hljs-built_in">=</span> meshgrid(<span class="hljs-number">0</span>:hx:<span class="hljs-number">1</span>,<span class="hljs-number">0</span>:hy:<span class="hljs-number">1</span>);u(<span class="hljs-number">1</span>,:,:) <span class="hljs-built_in">=</span> sin(<span class="hljs-number">4</span>*pi*x)+cos(<span class="hljs-number">4</span>*pi*y);<span class="hljs-comment">%按照公式进行差分</span>for ii<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:m-<span class="hljs-number">1</span>    for jj<span class="hljs-built_in">=</span><span class="hljs-number">2</span>:n-<span class="hljs-number">1</span>        for kk<span class="hljs-built_in">=</span><span class="hljs-number">2</span>:k-<span class="hljs-number">1</span>            u(ii+<span class="hljs-number">1</span>,jj,kk) <span class="hljs-built_in">=</span> ht*(u(ii,jj+<span class="hljs-number">1</span>,kk)+u(ii,jj-<span class="hljs-number">1</span>,kk)-<span class="hljs-number">2</span>*u(ii,jj,kk))/hx^<span class="hljs-number">2</span> + ...                ht*(u(ii,jj,kk+<span class="hljs-number">1</span>)+u(ii,jj,kk-<span class="hljs-number">1</span>)-<span class="hljs-number">2</span>*u(ii,jj,kk))/hy^<span class="hljs-number">2</span> + u(ii,jj,kk);        end    endendfor i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:<span class="hljs-number">200</span>    figure(<span class="hljs-number">1</span>);    mesh(x,y,reshape(u(i,:,:),[n k]));    axis([<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> -<span class="hljs-number">2</span> <span class="hljs-number">2</span>]);        F<span class="hljs-built_in">=</span>getframe(gcf); <span class="hljs-comment">%捕获显示在屏幕上的当前坐标区作为影片帧</span>    I<span class="hljs-built_in">=</span>frame2im(F); <span class="hljs-comment">%将捕获的影片帧转换为图像数据</span>    [I,map]<span class="hljs-built_in">=</span>rgb2ind(I,<span class="hljs-number">256</span>);     <span class="hljs-built_in">if</span> i <span class="hljs-built_in">=</span><span class="hljs-built_in">=</span> <span class="hljs-number">1</span>        imwrite(I,map,<span class="hljs-string">&#x27;test.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;Loopcount&#x27;</span>,inf,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">0.05</span>);    <span class="hljs-built_in">else</span>        imwrite(I,map,<span class="hljs-string">&#x27;test.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;WriteMode&#x27;</span>,<span class="hljs-string">&#x27;append&#x27;</span>,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">0.05</span>);        endend</code></pre></div><h1 id="交替隐式迭代法">交替隐式迭代法</h1><h2 id="问题-1">问题</h2><p>模拟外界温度周期变化的影响下，二维地板的温度随时间的变化情况。</p><p>（gif见知乎文章）</p><h2 id="代码-1">代码</h2><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%二维热传导过程差分交替隐式迭代法(Alternating-direction implicit method)</span><span class="hljs-comment">%c过大会导致交替迭代非常不稳定</span>clear;close <span class="hljs-built_in">all</span>;clc;<span class="hljs-comment">%% 参数定义</span>t <span class="hljs-built_in">=</span> <span class="hljs-number">72</span>;               <span class="hljs-comment">%时间范围</span>xl <span class="hljs-built_in">=</span> <span class="hljs-number">20</span>;yl <span class="hljs-built_in">=</span> <span class="hljs-number">20</span>;      <span class="hljs-comment">%空间范围</span>ht <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>;             <span class="hljs-comment">%时间步长dt</span>nt <span class="hljs-built_in">=</span> t/ht;            <span class="hljs-comment">%时间t方向分格子</span>nx <span class="hljs-built_in">=</span> <span class="hljs-number">50</span>;              <span class="hljs-comment">%空间x方向分格子</span>ny <span class="hljs-built_in">=</span> <span class="hljs-number">50</span>;              <span class="hljs-comment">%空间y方向分3格子</span>hx <span class="hljs-built_in">=</span> xl/(nx-<span class="hljs-number">1</span>);       <span class="hljs-comment">%空间步长dx</span>hy <span class="hljs-built_in">=</span> yl/(ny-<span class="hljs-number">1</span>);       <span class="hljs-comment">%空间步长dy</span>k <span class="hljs-built_in">=</span> <span class="hljs-number">1.93</span>;             <span class="hljs-comment">%二维材料导热系数</span>c <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>e-<span class="hljs-number">1</span>;             <span class="hljs-comment">%与空气换热参数</span>u <span class="hljs-built_in">=</span> zeros(nt,ny,nx);sqt <span class="hljs-built_in">=</span> @(x) -<span class="hljs-number">12.5</span>*cos(<span class="hljs-number">3.1415926535</span>*x/<span class="hljs-number">12</span>)+<span class="hljs-number">72.5</span>; <span class="hljs-comment">%温度计算</span><span class="hljs-comment">%设置边界与初始温度</span>[x,y] <span class="hljs-built_in">=</span> meshgrid(-hx:hx:xl+hx,-hy:hy:yl+hy);u <span class="hljs-built_in">=</span> <span class="hljs-number">72.5</span>*ones(size(x));u(<span class="hljs-number">1</span>,:)<span class="hljs-built_in">=</span>sqt(ht)*ones(size(u(<span class="hljs-number">1</span>,:)));u(end,:)<span class="hljs-built_in">=</span>sqt(ht)*ones(size(u(end,:)));u(:,<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>sqt(ht)*ones(size(u(:,<span class="hljs-number">1</span>)));u(:,end)<span class="hljs-built_in">=</span>sqt(ht)*ones(size(u(:,end)));log(<span class="hljs-number">1</span>,:,:)<span class="hljs-built_in">=</span>u;<span class="hljs-comment">%% 构造迭代矩阵 A,B</span>A <span class="hljs-built_in">=</span> eye(ny)*(-<span class="hljs-number">2</span>);A(<span class="hljs-number">2</span>:end,<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>) <span class="hljs-built_in">=</span> A(<span class="hljs-number">2</span>:end,<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>)+eye(ny-<span class="hljs-number">1</span>);A(<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end) <span class="hljs-built_in">=</span> A(<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end)+eye(ny-<span class="hljs-number">1</span>);A <span class="hljs-built_in">=</span> A*(k*ht/hy^<span class="hljs-number">2</span>);<span class="hljs-comment">%A = inv(eye(ny)-A);</span>tmp <span class="hljs-built_in">=</span> zeros(size(A)+[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]);tmp(<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>) <span class="hljs-built_in">=</span> A;tmp(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>:<span class="hljs-number">3</span>) <span class="hljs-built_in">=</span> [ht*c/<span class="hljs-number">2</span>,-ht*c/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>];tmp(end-<span class="hljs-number">1</span>,end-<span class="hljs-number">2</span>:end) <span class="hljs-built_in">=</span> [<span class="hljs-number">0</span>,-ht*c/<span class="hljs-number">2</span>,ht*c/<span class="hljs-number">2</span>];<span class="hljs-comment">%tmp(1,1)=1;tmp(end,end)=1;</span>A <span class="hljs-built_in">=</span> tmp;B <span class="hljs-built_in">=</span> eye(nx)*(-<span class="hljs-number">2</span>);B(<span class="hljs-number">2</span>:end,<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>) <span class="hljs-built_in">=</span> B(<span class="hljs-number">2</span>:end,<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>)+eye(nx-<span class="hljs-number">1</span>);B(<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end) <span class="hljs-built_in">=</span> B(<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end)+eye(nx-<span class="hljs-number">1</span>);B <span class="hljs-built_in">=</span> B*(k*ht/hx^<span class="hljs-number">2</span>);<span class="hljs-comment">%B = eye(nx)+B;</span>tmp <span class="hljs-built_in">=</span> zeros(size(B)+[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]);tmp(<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>B;tmp(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">=</span> [ht*c/<span class="hljs-number">2</span>,-ht*c/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<span class="hljs-string">&#x27;;;</span><span class="hljs-string">tmp(end-2:end,end-1) = [0,-ht*c/2,ht*c/2]&#x27;</span>;<span class="hljs-comment">%tmp(1,1)=1;tmp(end,end)=1;</span>B <span class="hljs-built_in">=</span> tmp;<span class="hljs-comment">%% 差分模拟</span>for i <span class="hljs-built_in">=</span> <span class="hljs-number">2</span>:nt    <span class="hljs-comment">%维护空气温度</span>    u(<span class="hljs-number">1</span>,:)<span class="hljs-built_in">=</span>sqt(i*ht)*ones(size(u(<span class="hljs-number">1</span>,:)));    u(end,:)<span class="hljs-built_in">=</span>sqt(i*ht)*ones(size(u(end,:)));    u(:,<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>sqt(i*ht)*ones(size(u(:,<span class="hljs-number">1</span>)));    u(:,end)<span class="hljs-built_in">=</span>sqt(i*ht)*ones(size(u(:,end)));    <span class="hljs-comment">%交替隐式迭代法</span>    <span class="hljs-built_in">if</span> mod(i,<span class="hljs-number">2</span>)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>         u<span class="hljs-built_in">=</span>(eye(size(A))-A)\u*(eye(size(B))+B);    <span class="hljs-built_in">else</span>        u<span class="hljs-built_in">=</span>(eye(size(A))+A)*u/(eye(size(B))-B);    end    log(end+<span class="hljs-number">1</span>,:,:)<span class="hljs-built_in">=</span>u;end<span class="hljs-comment">%计算平均温度</span>for i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:nt    logMeanT(i)<span class="hljs-built_in">=</span>mean(mean(mean(log(i,<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>))));endfigure(<span class="hljs-number">1</span>);plot(ht:ht:t,logMeanT);fprintf(<span class="hljs-string">&#x27;极差:%d max:%d min:%d\n&#x27;</span>,max(logMeanT(<span class="hljs-number">48</span>/ht:<span class="hljs-number">72</span>/ht))-min(logMeanT(<span class="hljs-number">48</span>/ht:<span class="hljs-number">72</span>/ht)),max(logMeanT(<span class="hljs-number">48</span>/ht:<span class="hljs-number">72</span>/ht)),min(logMeanT(<span class="hljs-number">48</span>/ht:<span class="hljs-number">72</span>/ht)));<span class="hljs-comment">%% 可视化过程</span>for i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:nt    figure(<span class="hljs-number">2</span>);    mesh(x,y,reshape(log(i,:,:),size(u)));    xlabel(<span class="hljs-string">&#x27;x&#x27;</span>);    title(num2str(i*ht));    axis([<span class="hljs-number">0</span>-hx,xl+hx,<span class="hljs-number">0</span>-hy,yl+hy <span class="hljs-number">60</span> <span class="hljs-number">85</span>]);    pause(<span class="hljs-number">0.1</span>);        F<span class="hljs-built_in">=</span>getframe(gcf); <span class="hljs-comment">%捕获显示在屏幕上的当前坐标区作为影片帧</span>    I<span class="hljs-built_in">=</span>frame2im(F); <span class="hljs-comment">%将捕获的影片帧转换为图像数据</span>    [I,map]<span class="hljs-built_in">=</span>rgb2ind(I,<span class="hljs-number">256</span>);     <span class="hljs-built_in">if</span> i <span class="hljs-built_in">=</span><span class="hljs-built_in">=</span> <span class="hljs-number">1</span>        imwrite(I,map,<span class="hljs-string">&#x27;test.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;Loopcount&#x27;</span>,inf,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">0.05</span>);    <span class="hljs-built_in">else</span>        imwrite(I,map,<span class="hljs-string">&#x27;test.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;WriteMode&#x27;</span>,<span class="hljs-string">&#x27;append&#x27;</span>,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">0.05</span>);        endend</code></pre></div><h1 id="模型说明">模型说明</h1><p>二维热传导方程为</p><p><span class="math display">\[\frac{\partial T}{\partialt}=k\left(\frac{\partial^{2} T}{\partial x^{2}}+\frac{\partial^{2}T}{\partial y^{2}}\right)\]</span></p><h2 id="显式有限差分格式">显式有限差分格式</h2><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t}=\left(\frac{T_{i+1, j}^{n}-2 T_{i, j}^{n}+T_{i-1,j}^{n}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n}-2 T_{i, j}^{n}+T_{i,j-1}^{n}}{\Delta y^{2}}\right)\]</span></p><p>显式迭代格式免去了矩阵求解的麻烦，但却是条件稳定的。即只有保证时间步长和空间步长满足一定关系时才能获得收敛解，对于热传导问题需要满足：</p><p><span class="math display">\[\frac{\Delta t}{\min(\Delta x^2,\Deltay^2)}\le \frac{1}{2}\]</span></p><h2 id="隐式有限差分格式btcs">隐式有限差分格式(BTCS)</h2><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t}=\left(\frac{T_{i+1, j}^{n+1}-2 T_{i, j}^{n+1}+T_{i-1,j}^{n+1}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n+1}-2 T_{i, j}^{n+1}+T_{i,j-1}^{n+1}}{\Delta y^{2}}\right)\]</span></p><p>需要注意BTCS法是无条件稳定的，即时间步长可以任意取都不会计算发散（不发散不代表算得准）。由于BTCS时间项采用向后差分，因此该方法在时间层精度为一阶，而空间层精度为二阶。</p><h2id="隐式有限差分格式cranknicolson">隐式有限差分格式(Crank–Nicolson)</h2><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t}=0.5\left(\frac{T_{i+1, j}^{n+1}-2 T_{i,j}^{n+1}+T_{i-1, j}^{n+1}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n+1}-2 T_{i,j}^{n+1}+T_{i, j-1}^{n+1}}{\Delta y^{2}}\right) \\+0.5\left(\frac{T_{i+1, j}^{n}-2 T_{i, j}^{n}+T_{i-1, j}^{n}}{\Deltax^{2}}+\frac{T_{i, j+1}^{n}-2 T_{i, j}^{n}+T_{i, j-1}^{n}}{\Deltay^{2}}\right)\]</span></p><p>作为隐式方法，Crank–Nicolson格式是无条件稳定的，且其时间离散精度为二阶。</p><h2id="交替隐式迭代法alternating-direction-implicit-method">交替隐式迭代法(Alternating-directionimplicit method)</h2><ol type="1"><li>x方向隐式更新</li></ol><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t}=k\left(\frac{T_{i+1, j}^{n+1}-2 T_{i, j}^{n+1}+T_{i-1,j}^{n+1}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n}-2 T_{i, j}^{n}+T_{i,j-1}^{n}}{\Delta y^{2}}\right)\]</span></p><ol start="2" type="1"><li>y方向隐式更新</li></ol><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t / 2}=k\left(\frac{T_{i+1, j}^{n}-2 T_{i, j}^{n}+T_{i-1,j}^{n}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n+1}-2 T_{i, j}^{n+1}+T_{i,j-1}^{n+1}}{\Delta y^{2}}\right)\]</span></p><p>交替隐式迭代法是无条件稳定的，且时间和空间离散精度均为二阶，同时矩阵求解计算量优于上述其他隐式算法，具有独特的优势。</p><h1 id="参考">参考</h1><ul><li>matlab练习程序（差分法解二维热传导方程）. <ahref="http://t.zoukankan.com/tiandsp-p-14406223.html"class="uri">http://t.zoukankan.com/tiandsp-p-14406223.html</a></li><li>一文看懂交替隐式迭代法. <ahref="https://zhuanlan.zhihu.com/p/522899015"class="uri">https://zhuanlan.zhihu.com/p/522899015</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 显式差分 </tag>
            
            <tag> 交替隐式差分 </tag>
            
            <tag> 偏微分方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拟牛顿法</title>
      <link href="/2022/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
      <url>/2022/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>拟牛顿法(Quasi-Newton Methods)<br />是求解非线性优化问题最有效的方法之一。其在牛顿法的基础上，利用相邻两个点的位移和一阶导数信息构造与二阶导数阵相似的正定矩阵。从而以在不直接计算Hessian矩阵的情况下实现高维问题的超线性收敛。</p><p>牛顿法通过计算每一步的梯度 <span class="math inline">\(\nablaf\left(\mathbf{x}_{k}\right)\)</span> 与Hessian矩阵 <spanclass="math inline">\(\mathbf{H}_{f}\left(\mathbf{x}_{k}\right)\)</span>迭代更逼近驻点的 <spanclass="math inline">\(\mathbf{x}_{k+1}\)</span></p><p><spanclass="math display">\[\mathbf{x}_{k+1}=\mathbf{x}_{k}-\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)\nabla f\left(\mathbf{x}_{k}\right).\]</span></p><p>其最大难度在于求解维度超大的Hessian矩阵与其逆矩阵 <spanclass="math inline">\(\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)\)</span>，而拟牛顿法则通过一维导数（梯度）的变化便可以得到近似的Hessian矩阵，而大大降低了求解难度与求逆的时间。</p><h1 id="基本步骤">基本步骤</h1><p>（以下高维向量、矩阵不再加粗表示）</p><p>记 <span class="math inline">\(B_k\)</span> 表示第 <spanclass="math inline">\(k\)</span>次迭代的近似Hessian矩阵称为切线刚度矩阵，其初始为单位矩阵，即 <spanclass="math inline">\(B_0=I\)</span>. 根据</p><p><span class="math display">\[B_kp_k=-\nablaf\left(x_{k}\right)\]</span></p><p>计算 <span class="math inline">\(p_k\)</span>，作为每一次迭代的步。</p><p><span class="math display">\[x_{k+1}=x_k+\alpha p_k\]</span></p><p>其中 <span class="math inline">\(\alpha\)</span> 一般计为 <spanclass="math inline">\(1.0\)</span>，也可以从 <spanclass="math inline">\(1.0\)</span> 折半查找，直到 <spanclass="math inline">\(f(x_{k+1})\)</span> 更优。计算</p><p><span class="math display">\[s_k=\alpha p_k\ ,\ y_k=\nablaf\left(x_{k+1}\right)-\nabla f\left(x_{k}\right).\]</span></p><p>计算新的刚度矩阵</p><p><span class="math display">\[B_{k+1}=B_{k}-\frac{B_{k} s_{k}s_{k}^{T} B_{k}}{s_{k}^{T} B_{k} s_{k}}+\frac{y_{k} y_{k}^{T}}{y_{k}^{T}s_{k}} （BFGS算法）.\]</span></p><p>若误差足够小，如等式约束两端误差小于 <spanclass="math inline">\(\epsilon\)</span> 则得到解，否则继续迭代。</p><h1 id="刚度矩阵算法">刚度矩阵算法</h1><p>以上以BFGS法为例，介绍了基本的拟牛顿法步骤，其他方法也仅仅在计算刚度矩阵上进行的变化。</p><h2 id="dfp法">DFP法</h2><p><span class="math display">\[B_{k+1}=B_{k}-\frac{B_{k} y_{k}y_{k}^{T} B_{k}}{y_{k}^{T} B_{k} y_{k}}+\frac{s_{k} s_{k}^{T}}{y_{k}^{T}s_{k}}\]</span></p><p>DFP方法是秩-2更新的一种，由它产生的矩阵 <spanclass="math inline">\(B_k\)</span> 是正定的，而且满足这样的极小性：</p><p><span class="math display">\[\min _{B}\left|B-B_{k}\right| \text {s.t. } B=B^{T}, B s_{k}=y_{k}\]</span></p><h2 id="bfgs法">BFGS法</h2><p><span class="math display">\[B_{k+1}=B_{k}-\frac{B_{k} s_{k}s_{k}^{T} B_{k}}{s_{k}^{T} B_{k} s_{k}}+\frac{y_{k} y_{k}^{T}}{y_{k}^{T}s_{k}} \]</span></p><p>该方法 <span class="math inline">\(B_k\)</span>同样正定，也同样满足上述的极小性。</p><p>且BFGS和DFP公式在形式上是对称的，但是BFGS比DFP更加有效。</p><h2 id="对称秩1sr1法">对称秩1（SR1）法</h2><p><span class="math display">\[B_{k+1}=B_{k}+\frac{\left(y_{k}-B_{k}s_{k}\right)\left(y_{k}-B_{k} s_{k}\right)^{T}}{\left(y_{k}-B_{k}s_{k}\right)^{T} s_{k}}\]</span></p><p>有别于DFP和BFG方法，SR1是一种秩-1更新。</p><p>SR1公式不要求矩阵 <span class="math inline">\(B_k\)</span>保持正定性，从而更逼近真实的Hesse矩阵，所以适用于信赖域方法(Trust RegionMethods)。</p><h2 id="broyden族">Broyden族</h2><p><span class="math display">\[B_{k+1}=\left(1-c_{k}\right) B_{k+1}^{BF G S}+c_{k} B_{k+1}^{D F P}\]</span></p><p>当 <span class="math inline">\(c_k=0\)</span>时，Broyden族公式就变成了BFGS公式；当 <spanclass="math inline">\(c_k=1\)</span>时，Broyden族公式就变成了DFP公式。因此BFGS和DFP均可看成Broyden族的特殊形式或者其中一员。</p><h1 id="参考">参考</h1><ul><li><ahref="https://baike.baidu.com/item/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/9340944"class="uri">https://baike.baidu.com/item/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/9340944</a></li><li><a href="https://zhuanlan.zhihu.com/p/45221013"class="uri">https://zhuanlan.zhihu.com/p/45221013</a></li><li><a href="https://zhuanlan.zhihu.com/p/222899764"class="uri">https://zhuanlan.zhihu.com/p/222899764</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拟牛顿法 </tag>
            
            <tag> BFGS法 </tag>
            
            <tag> DFP法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛顿迭代与高斯牛顿法</title>
      <link href="/2022/08/19/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
      <url>/2022/08/19/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一元函数下">一元函数下</h1><p>对于一元函数 <span class="math inline">\(f(x)\)</span>，其泰勒二阶展开如下为</p><p><spanclass="math display">\[f(x_{k+1})=f(x_k)+f&#39;(x_k)(x_{k+1}-x_k)+\frac{1}{2}f&#39;&#39;(x_k)(x_{k+1}-x_k)^2+O(x^2).\]</span></p><p>记 <span class="math inline">\(z=x_{k+1}-x_k\)</span>省略余项可表示为</p><p><span class="math display">\[f(x_{k+1})\approxf(x_k)+f&#39;(x_k)\cdot z+\frac{1}{2}f&#39;&#39;(x_k)\cdotz^2=g(x).\]</span></p><ul><li>若要求 <span class="math inline">\(f(x)\)</span>的<strong>零点</strong>，即想要 <spanclass="math inline">\(f(x_{k+1})=0\)</span>，省略二阶展开易得</li></ul><p><span class="math display">\[f(x_k)+f&#39;(x_k)\cdotz=0,\]</span></p><p><spanclass="math display">\[z=-\frac{f(x_k)}{f&#39;(x_k)},\]</span></p><p><spanclass="math display">\[x_{k+1}=x_k-\frac{f(x_k)}{f&#39;(x_k)}.\]</span></p><ul><li>若要求 <span class="math inline">\(f(x)\)</span>的<strong>极值点</strong>，即想要 <spanclass="math inline">\(f&#39;(x_{k+1})=0\)</span>，也就是 <spanclass="math inline">\(g&#39;(z)=0\)</span> ，有</li></ul><p><spanclass="math display">\[g&#39;(z)=f&#39;(x_k)+f&#39;&#39;(x_k)\cdotz=0，\]</span></p><p><spanclass="math display">\[z=-\frac{f&#39;(x_k)}{f&#39;&#39;(x_k)},\]</span></p><p><spanclass="math display">\[x_{k+1}=x_k-\frac{f&#39;(x_k)}{f&#39;&#39;(x_k)}.\]</span></p><h1 id="多元函数下">多元函数下</h1><p>基本过程为：</p><ol type="1"><li>二阶逼近</li><li>逼近式对增量求一阶导为零</li><li>求出增量计算格式</li><li>代回得到迭代式</li></ol><p>二阶逼近为</p><p><span class="math display">\[f\left(\mathbf{x}_{k}+\mathbf{z}\right)\approx f\left(\mathbf{x}_{k}\right)+\left[\nablaf\left(\mathbf{x}_{k}\right)\right]^{T} \mathbf{z}+\frac{1}{2}\mathbf{z}^{T}\left[\nabla^{2} f\left(\mathbf{x}_{k}\right)\right]\mathbf{z}.\]</span></p><p>其中 <span class="math inline">\(\mathbf{x}=\left(x_1,x_2\cdotsx_n\right)^T\)</span>，<spanclass="math inline">\(\mathbf{z}=\left(z_1,z_2\cdotsz_n\right)^T.\)</span> 有</p><p><span class="math display">\[\nablaf\left(\mathbf{x}_{k}\right)=\left(\begin{array}{cccc}\frac{\partial f(\mathbf{x})}{\partial x_{1}} &amp;\frac{\partial f(\mathbf{x})}{\partial x_{2}} &amp;\cdots &amp;\frac{\partial f(\mathbf{x})}{\partial x_{n}}\end{array}\right)^T.\]</span></p><p>又有</p><p><span class="math display">\[\nabla^{2} \mathbf{f}=\nabla \otimes\nabla \mathbf{f}=\left[\begin{array}{cccc}\frac{\partial^{2} f}{\partial^{2} x_{1}} &amp; \frac{\partial^{2}f}{\partial x_{1} \partial x_{2}} &amp; \cdots &amp; \frac{\partial^{2}f}{\partial x_{1} \partial x_{n}} \\\frac{\partial^{2} f}{\partial x_{2} \partial x_{1}} &amp;\frac{\partial^{2} f}{\partial x_{2} \partial x_{2}} &amp; \cdots &amp;\frac{\partial^{2} f}{\partial x_{2} \partial x_{n}} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\frac{\partial^{2} f}{\partial x_{n} \partial x_{1}} &amp; \cdots &amp;\ldots &amp; \frac{\partial^{2} f}{\partial^{2} x_{n}}\end{array}\right]\]</span></p><p>这就是Hessian矩阵，记为 <spanclass="math inline">\(\mathbf{H}_{f}(\mathbf{x})\)</span>.</p><p>令一阶导为 <span class="math inline">\(0\)</span>，得到</p><p><span class="math display">\[\nablaf\left(\mathbf{x}_{k}\right)+\left[\nabla^{2}f\left(\mathbf{x}_{k}\right)\right] \mathbf{z}=0,\]</span></p><p><spanclass="math display">\[\mathbf{z}=-\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)\nabla f\left(\mathbf{x}_{k}\right),\]</span></p><p><spanclass="math display">\[\mathbf{x}_{k+1}=\mathbf{x}_{k}-\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)\nabla f\left(\mathbf{x}_{k}\right).\]</span></p><p>因为这里Hessian矩阵不一定可逆，最简单直接的思路是在 <spanclass="math inline">\(\mathbf{H}^{-1}_{f}(\mathbf{x})\)</span>的对角线上加上一个正数：</p><p><spanclass="math display">\[\mathbf{x}_{k+1}=\mathbf{x}_{k}-\left(\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)+\mu\mathbf{I}\right) \nabla f\left(\mathbf{x}_{k}\right).\]</span></p><h1 id="求最小二乘问题">求最小二乘问题</h1><p>记损失函数为</p><p><spanclass="math display">\[\ell(\mathbf{w})=\frac{1}{2}\|f(\mathbf{X} ,\mathbf{w})-\mathbf{Y}\|^{2}=\frac{1}{2} \mathbf{e}^{2}.\]</span></p><p>其中 <span class="math inline">\(\mathbf{w}\)</span>是全体参数组成的向量， <span class="math inline">\(\mathbb{e}\)</span>是误差值组成的向量。其二阶展开式如下</p><p><spanclass="math display">\[\ell\left(\mathbf{w}_{k}+\mathbf{z}\right)\approx \ell\left(\mathbf{w}_{k}\right)+\left(\nabla\ell\left(\mathbf{w}_{k}\right)\right)^{T} \mathbf{z}+\frac{1}{2}\mathbf{z}^{T}\left(\nabla^{2} \ell\left(\mathbf{w}_{k}\right)\right)\mathbf{z}.\]</span></p><p>因为最小二乘法的特殊性，可以简化为</p><p><span class="math display">\[\nabla\ell(\mathbf{w})=\frac{\partial\left(\frac{1}{2}\mathbf{e}^{2}\right)}{\partial \mathbf{w}}=\left(\frac{\partial\mathbf{e}}{\partial \mathbf{w}}\right)^{T}\mathbf{e}=\mathbf{J}_{\mathbf{e}}^{T}(\mathbf{w})\mathbf{e}.\]</span></p><p>这就是Jacobian矩阵即为 <spanclass="math inline">\(\mathbf{J}_{\mathbf{e}}^{}(\mathbf{w})\)</span>.注意始终保证最后的结果是列向量。求二阶导为</p><p><span class="math display">\[\nabla^{2}\ell(\mathbf{w})=\nabla(\nabla\ell(\mathbf{w}))=\frac{\partial\left(\left(\frac{\partial\mathbf{e}}{\partial \mathbf{w}}\right)^{T} \mathbf{e}\right)}{\partial\mathbf{w}}=\left(\frac{\partial \mathbf{e}}{\partial\mathbf{w}}\right)^{T}\left(\frac{\partial \mathbf{e}}{\partial\mathbf{w}}\right)+\frac{\partial^{2} \mathbf{e}}{\partial\mathbf{w}^{2}} \mathbf{e}\]</span></p><p><span class="math display">\[=\mathbf{J}_{\mathbf{e}}^{T}(\mathbf{w})\mathbf{J}_{\mathbf{e}}(\mathbf{w})+\frac{\partial^{2}\mathbf{e}}{\partial \mathbf{w}^{2}} \mathbf{e}\]</span></p><p>代回得到迭代式</p><p><spanclass="math display">\[\mathbf{w}_{k+1}=\mathbf{w}_{k}-\left.\left(\left(\mathbf{J}_{\mathbf{e}}^{T}(\mathbf{w})\mathbf{J}_{\mathbf{e}}(\mathbf{w})+\frac{\partial^{2}\mathbf{e}}{\partial \mathbf{w}^{2}} \mathbf{e}\right)^{-1}\mathbf{J}_{\mathbf{e}}^{T}(\mathbf{w})\mathbf{e}\right)\right|_{\mathbf{w}=\mathbf{w}_{k}}\]</span></p><h1 id="高斯-牛顿法">高斯-牛顿法</h1><p>在文章 Theoria motus corporum coelestium in sectionibus conicis solemambientum (1809), pp. 179-180. 中，高斯提到 <spanclass="math inline">\(\nabla^{2} \ell(\mathbf{w})\)</span>的二阶项应该很小，所以直接省略，于是再对符号简化一下，这个Hessian近似就可以写成：</p><p><span class="math display">\[\nabla^{2}\ell(\mathbf{w})=\mathbf{J}^T\mathbf{J}.\]</span></p><p>这个式子就是著名的 Gauss-Newton 法的迭代公式。但 <spanclass="math inline">\(\mathbf{J}^T\mathbf{J}\)</span>通常是半正定的，但不一定可逆的于是在对角线上加上一个正数，得到Levenberg-Marquardt 算法。</p><p><spanclass="math display">\[\mathbf{w}_{k+1}=\mathbf{w}_{k}-\left(\mathbf{J}^{T}\mathbf{J}+\mu \mathbf{I}\right)^{-1} \mathbf{J}^{T}\mathbf{e}\]</span></p><h1 id="代码">代码</h1><h2 id="一元函数">一元函数</h2><p>求<ahref="https://zhuanlan.zhihu.com/p/514647478">核酸混检问题</a>中， <spanclass="math display">\[E(x)=1-(1-p)^k-\frac{1}{k}\]</span>的最小值点。</p><div class="hljs code-wrapper"><pre><code class="hljs matlab">clc;clear;p=<span class="hljs-number">0.01</span>;syms k; <span class="hljs-comment">%自变量</span>E=@(k) <span class="hljs-number">1</span>-(<span class="hljs-number">1</span>-p).^k+<span class="hljs-number">1.</span>/k; <span class="hljs-comment">%每个人检测次数的期望</span>kDif=matlabFunction(diff(E,k,<span class="hljs-number">1</span>));kDiif=matlabFunction(diff(E,k,<span class="hljs-number">2</span>));<span class="hljs-comment">%% 牛顿迭代法</span>x=[<span class="hljs-number">0.1</span>];<span class="hljs-comment">%当x过大kDiif(x)为负，函数为凸，会倾向于寻找极大值</span><span class="hljs-keyword">while</span> <span class="hljs-built_in">abs</span>(kDif(x(<span class="hljs-keyword">end</span>)))&gt;<span class="hljs-number">1e-10</span>    z=-kDif(x(<span class="hljs-keyword">end</span>))/kDiif(x(<span class="hljs-keyword">end</span>));    x(<span class="hljs-keyword">end</span>+<span class="hljs-number">1</span>)=<span class="hljs-built_in">abs</span>(x(<span class="hljs-keyword">end</span>)+z);<span class="hljs-comment">%因为kDif(x)是偶函数</span><span class="hljs-keyword">end</span>fprintf(<span class="hljs-string">&#x27;ans=%d\n&#x27;</span>,x(<span class="hljs-keyword">end</span>));<span class="hljs-comment">%% 画图</span>xx = <span class="hljs-number">-10</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">100</span>;yy=kDif(xx);<span class="hljs-built_in">plot</span>(xx,yy,<span class="hljs-string">&#x27;LineWidth&#x27;</span>,<span class="hljs-number">3</span>);<span class="hljs-built_in">hold</span> on;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(x,<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;    <span class="hljs-built_in">plot</span>([x(<span class="hljs-built_in">i</span>),x(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>)],[kDif(x(<span class="hljs-built_in">i</span>)),<span class="hljs-number">0</span>]);    <span class="hljs-built_in">plot</span>([x(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>),x(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>)],[<span class="hljs-number">0</span>,kDif(x(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>))]);<span class="hljs-keyword">end</span>axis([<span class="hljs-number">-10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">-0.1</span>,<span class="hljs-number">1</span>]);</code></pre></div><h1 id="参考">参考</h1><p>本文几乎全部复制于<ahref="https://www.zhihu.com/question/419979308/answer/1461043023">知乎回答</a>，仅作学习使用。</p><ul><li><a href="https://www.zhihu.com/question/419979308/answer/1461043023"class="uri">https://www.zhihu.com/question/419979308/answer/1461043023</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛顿迭代 </tag>
            
            <tag> 高斯牛顿法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【摘抄】夜访镜小记</title>
      <link href="/2022/06/29/24/"/>
      <url>/2022/06/29/24/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>注意！此文仅作摘抄，禁止挪用从事商业用途！</p>          </div><p>前语：这是一篇蹩脚语言模仿写就的文章。倘若有人阅读它，发现点什么的话，我需要说明，它没有任何嘲讽谁的意思，你的一切发现，请算作是我的弊病。</p><h1 id="夜访镜小记">《夜访镜小记》</h1><p>今夜瞧见镜子跟前有道亮光晃眼，走近才发现有人在里面点灯写着东西。敲敲镜面，里头的人看到我大吃一惊，骇得合上笔记：“现在还有人看得到镜里头有人？”</p><p>看到镜中人就是我，却一副难以置信的表情，不禁生疑，忙大声呵斥：“心中有愧，才鬼鬼祟祟，大半夜不睡，还点灯在桌前做什么？”听到这话，里头的人却大笑起来。</p><p>“有愧的人对镜方见得我！我就是你们，你们就是我。不信你且进来仔细瞧瞧。”几近迟疑，还是迈起步子进了镜。这下他更吃惊了：“快请坐！看来我境界远不及你。听闻一个人面孔越是有多张，越是狡诈虚伪，越是能够在镜内外顺畅而行。别看我长得和你一般模样，此刻心里却是恭敬极了。”</p><p>我试图寻找一个凳子坐下，环顾四周，除了他的桌子前有暗光一片，其他地方什么也看不清：“是我叫你这里蓬荜生暗了！我也想坐下，但是这里丝毫没有一点亮光，我找不到板凳。”他四处摸索一番，终于搬出一个破凳子：“实在招待不周，是我让你见了笑话。镜子里的光从来都是趁人家照镜子的时候收集起来，现在照镜子的人越来越少，我们也没什么像样的光能收集。好不容易以为人家照了镜子，结果全是在一颗小小的摄像头里成像，这样来的光，又能亮到哪里去？不瞒你说，我现在这里光也快耗尽了。我看到那面成像的镜子里头光鲜亮丽，和我这里照出来的，完全是两码模样。照来照去，我们几乎快一般黑了。”我对他的遭遇十分同情，拍了拍他肩膀：“想必过去这里一定辉煌！”</p><p>他高兴起来，连声喊道：“那是！那是！再早一点，黏附我们的人占了半个地球，大家以照镜子为荣，好写自我批评为风气，那时候此地终年不暗，镜内富丽堂皇，顶得上半个地球！”我没想到衰落如此迅捷，不由得唉声叹了口气。但我仍然很有疑惑：“那你们和镜子外的人，比方你和我，到底像不像？”</p><p>镜中人不高兴，头摇似波浪鼓。“枉我初觉你境界比我高来的，不曾想，还是落入下乘！我们面孔几时会倒映出那么多张？说到底只有一张罢，但偏是奇怪，虽然只有这一张脸，但又会看起来很多张。我这面镜子能知晓两张脸已然不错，而你们却有更多。”我一时间不能明白其中深意，只能请求他继续说。</p><p>好似尝到点甜头，他嘴如弹簧：“比方说一位道貌岸然的人，背地里想法不知道有多龌龊。越是光明正大，背地越是暗——如同现在镜中一般，因为人始终不是透明的。我越是表现得对这些东西不感兴趣，我就有可能越是知道它是个什么东西。别看有时候我是主席、书记、党员，但是我成为他的过程并不是我觉悟良知觉醒的过程，我依旧仰仗那点特权来行事。我身居其位，冠冕堂皇，但一无作为。我对于名利，表现得好像永不热衷，但你要叫我触碰到它，我定俯下身子渴求迎接它。”</p><p>一个镜中人胆敢妄议外界，我大声呵斥他：“这实在荒唐！那么多人怎因你一句话而什么也不是？”镜中人朝我微微一拜：“不得不说我实在对您是越来越崇敬了。刚才应是我走了眼，现在这副为人师的说教模样背后，是什么我可一清二楚，但您现在就是会叫我相信您的劝诫。我无意冒犯，因为钻空子、伪造材料仅仅有损道德的事我也做的太多，这方面怎么说都是五十步笑百步罢了。”我一时面红耳赤。镜中人赶忙赔不是：“我初衷不是要羞辱您的，您且相信我——我仍然打心眼佩服您，如同佩服您之于卡尔维诺文学理论、谢林深奥的哲学语言的评述一般。”</p><p>我面色稍微好看，但仍然冷哼：“不必如此捧杀我，我说不上通晓，仅仅是了解罢了。那些情况或许有，当然不是全部……”镜中人打断我：“对，您说的极是！就是这样只字未看或一无所知而大谈特谈的境界让我望尘莫及。我正是这样子，倘若有人爱好看书写文章，我就说他杜甫再世；有人家底殷实，不过看了两眼乞丐，我就说他悲天悯怀。如此大家也多愿意照照镜子。”</p><p>我不得接语，只得敷衍：“也行。”镜中人依旧兴奋，喋喋不语：“这就是您第三副面孔了，好似不反对我，也不同意我，俨然一个和事佬。但您此刻定在嘲笑我的自负。我贬低他人，贬低事物，当然是为了抬高我个人的精神境界。但我要装作有反思的模样，对这些时刻感到羞愧，方见的我的道德本心。我虽没有恒心与高见，我虽懒惰而成天沉溺网络，但这不妨碍我和大众——不论对错，一起抨击世界的黑暗。”</p><p>“这样非此即彼的事物被你提出来，你也敢说你了解我们么？”我希望在此刻为镜外扳回一城，看向他桌子前的文稿。上面写着诸如“去标签化”“非黑即白”“女拳”“爹味”一类的词语。镜中人注意到我的眼光，示意我翻翻看：“这些东西也叫您看个乐呵。我每天记录着镜外的思想，想要融入其中，但仍然有这些叫我摸不着头脑的词语。我看见您们总是闹腾，总是互相对立，围绕主题谈及社会、国家、性别等议题，好不热闹，恳请您向我讲述它们的含义。它们是否也如人们互相贬低一般，好彰显自己的高尚？”</p><p>我详细阐述这些语词，又表达自己看法，少数发言人不意味更多在都是，经验的归纳始终有其整体的缺陷。他听完低下了头，将唯一的灯光拢在文稿前，终于表露自己的惭愧：“看来我始终自以为是来理解镜外。看我的第一页吧，我将其和大家的左右逢源作比较，一面说着某人的坏话，一面与某人接触，这好似是‘非黑即白’的相处方式；并且做上了密密麻麻的注脚，用别人与我们说自己的秘密，我们权当它似一阵风四处散播。但其中无穷奥秘，难以参透。”</p><p>我翻看到第三页之后，惊呼于镜中人有其耐心，对这些事物皆有详细记录。第一章题头文字是“无关个人微小利益的语言传播”，第二章是“利益的牵涉与道德的反比关系研究”。我夸赞他已经在向人类学家路上迈进，这些值得被分享。他摇摇头：“看来我离得仍远，仍一无所知。而且我是一个自私的人，分享这些见不到我的大公，什么时候来了像样的活动，我定然会去参与，叫世人瞧瞧来自镜中的哲学。虽然您们自诩某种团体，因此有其骄傲，但我对此是不服气的，我虽无学历，难道就一定走得比你们差些么？”</p><p>当我想继续回答他时，最后一点灯光忽然灭了。迎接的是半晌得沉默。末了，他叹口气：“始终是大家窥探别人来满足自己太多，常和人交锋、闲聊彼此太多，不愿意照镜子了。我想大概你也很难再见到我罢。”我大声喊：“请继续等待，仍有人有良知本心！”</p><p>只听来一声，“你看看现在，我如何能等待”，即被大力推出镜外，还有一份未竟稿也落在地上，上面写满个人与义务、自由与责任等的讨论，显得矛盾而混乱，看来他没有得到想要的结果。将稿折成两半收起来，我再看看镜子，一片漆黑，偶有亮光，那是假反思、假羞愧的折射，偶尔露出镜中人——我的其他面孔。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 摘抄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程训练】路径存储与迷宫寻路 - 指针</title>
      <link href="/2022/06/26/23/"/>
      <url>/2022/06/26/23/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题描述">问题描述</h1><p>试图充分运用所学的C++面向对象的知识和封装性，完成一个拓展度高，可编辑型高，有多种兼容性接口的程序。能完成对路径和结点的简历和存储，以此进行最短寻路。达到对所学内容的巩固。</p><h1 id="结果展示">结果展示</h1><figure><img src="https://s2.loli.net/2022/06/26/M8XfT6bvKjAFGny.png"alt="可视化结果" /><figcaption aria-hidden="true">可视化结果</figcaption></figure><h1 id="代码">代码</h1><p>注：以下为合并后的代码，根据注释是可以拆分为很多头文件的，更加可读和可编辑。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">/*</span><span class="hljs-comment">//point.h</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&#123;</span><span class="hljs-comment">//模板函数</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> identify;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Point</span>(<span class="hljs-keyword">int</span> x):<span class="hljs-built_in">identify</span>(x)&#123;        <span class="hljs-comment">//printf(&quot;create Point %d.\n&quot;,identify);</span>    &#125;    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Point</span>()&#123;        <span class="hljs-comment">//printf(&quot;clear Point %d.\n&quot;,identify);</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_ID</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> identify;&#125;&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment">path.h 与 node.h 的合并，防止相互引用头文件</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">#include&quot;point.h&quot;</span><span class="hljs-comment">#include&lt;cstdio&gt;</span><span class="hljs-comment">#include&lt;cstdlib&gt;</span><span class="hljs-comment">using namespace std;</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Path</span>&#123;</span>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> val;    Node *to;    Path *nxt;<span class="hljs-keyword">public</span>:        <span class="hljs-function">Path* <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> nxt;&#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vall</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> val;&#125;    <span class="hljs-function">Node* <span class="hljs-title">gono</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> to;&#125;    <span class="hljs-built_in">Path</span>(<span class="hljs-keyword">int</span> w,Node *go_v,Path *nex=<span class="hljs-literal">NULL</span>) : <span class="hljs-built_in">val</span>(w) &#123;        <span class="hljs-keyword">if</span>(w&lt;<span class="hljs-number">0</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[WAR]there are nagetive val way!\n&quot;</span>);        to=go_v;        nxt=nex;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create way val %d.\n&quot;</span>,w);    &#125;    ~<span class="hljs-built_in">Path</span>()&#123;        <span class="hljs-comment">//printf(&quot;clear way val %d.\n&quot;,val);</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><span class="hljs-keyword">public</span> Point&#123;    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_dist</span><span class="hljs-params">(Node &amp;a,Node &amp;b)</span></span>;    <span class="hljs-comment">//friend void spfa(Node &amp;u,Refmark &amp;R);</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> x,y;<span class="hljs-comment">//坐标</span>    Path *way_head;<span class="hljs-comment">//出路链表</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">bool</span> vis;<span class="hljs-keyword">int</span> dis;Node *Last;<span class="hljs-keyword">bool</span> If_Pass;    <span class="hljs-function">Path* <span class="hljs-title">head</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> way_head;    &#125;    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y):<span class="hljs-built_in">Point</span>(p),<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y)&#123;        dis=INF;        vis=<span class="hljs-number">0</span>;        way_head=<span class="hljs-literal">NULL</span>;        Last=<span class="hljs-literal">NULL</span>;        If_Pass=<span class="hljs-number">0</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create Node %d at (%d,%d), init.\n&quot;</span>,<span class="hljs-built_in">get_ID</span>(),x,y);    &#125;    ~<span class="hljs-built_in">Node</span>()&#123;        <span class="hljs-keyword">for</span>(Path *t2,*t = way_head;t!=<span class="hljs-literal">NULL</span>;t=t2)&#123;            t2=t-&gt;nxt;            <span class="hljs-keyword">delete</span> t;        &#125;        <span class="hljs-comment">//printf(&quot;clear Node %d at (%d,%d).\n&quot;,get_ID(),x,y);</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_dis</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-keyword">if</span>(dis==<span class="hljs-number">-1</span>)            <span class="hljs-keyword">return</span> INF;        <span class="hljs-keyword">if</span>(dis&lt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]get_dis error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">return</span> dis;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_way</span><span class="hljs-params">(Node *to,<span class="hljs-keyword">int</span> val)</span></span>&#123;        <span class="hljs-keyword">if</span>(way_head==<span class="hljs-literal">NULL</span>)&#123;            way_head= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Path</span>(val,to);        &#125;<span class="hljs-keyword">else</span>&#123;            way_head= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Path</span>(val,to,way_head);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add way %d to %d, val %d.\n&quot;</span>,<span class="hljs-built_in">get_ID</span>(),to-&gt;<span class="hljs-built_in">get_ID</span>(),val);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_way</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(Path *t = way_head;t!=<span class="hljs-literal">NULL</span>;t=t-&gt;nxt)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d &quot;</span>,<span class="hljs-built_in">get_ID</span>(),t-&gt;to-&gt;<span class="hljs-built_in">get_ID</span>());            cnt++;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;. totally %d ways.\n&quot;</span>,cnt);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_dist</span><span class="hljs-params">(Node &amp;a,Node &amp;b)</span></span>&#123;<span class="hljs-comment">//Point的友元函数 曼哈顿距离</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a.x-b.x)+<span class="hljs-built_in">abs</span>(a.y-b.y);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">queue_node.h 队列</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">#include&quot;graph.h&quot;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue_node_element</span>&#123;</span><span class="hljs-keyword">public</span>:    Node *element;    Queue_node_element *nxt;    <span class="hljs-built_in">Queue_node_element</span>(Node &amp;x,Queue_node_element *p=<span class="hljs-literal">NULL</span>):<span class="hljs-built_in">element</span>(&amp;x),<span class="hljs-built_in">nxt</span>(p)&#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue_node</span>&#123;</span><span class="hljs-keyword">private</span>:    Queue_node_element *head,*tail;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Queue_node</span>()&#123;head=tail=<span class="hljs-literal">NULL</span>;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//head</span>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]Queue_node pop error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        Queue_node_element *cl = head;        head = head-&gt;nxt;           <span class="hljs-keyword">delete</span> cl;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Node &amp;x)</span></span>&#123;<span class="hljs-comment">//tail</span>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;            head=tail= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Queue_node_element</span>(x,<span class="hljs-literal">NULL</span>);            <span class="hljs-keyword">return</span>;        &#125;        tail-&gt;nxt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Queue_node_element</span>(x,<span class="hljs-literal">NULL</span>);        tail = tail-&gt;nxt;    &#125;    <span class="hljs-function">Node&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//head</span>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]Queue_node front error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">return</span> *(head-&gt;element);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment">refmark.h</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">#include&quot;graph.h&quot;</span><span class="hljs-comment">#include&quot;node.h&quot;</span><span class="hljs-comment">#include&quot;path.h&quot;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e2</span>;<span class="hljs-comment">//1e3会过大</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm = <span class="hljs-number">1e2</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Refmark</span>&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> n,m;    Node *ref_p[maxn*maxm];<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-keyword">return</span> (x<span class="hljs-number">-1</span>)*m+y;    &#125;    <span class="hljs-function">Node* <span class="hljs-title">new_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;        <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">1</span>||p&gt;n*m)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]new_ref error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span>(ref_p[p]!=<span class="hljs-literal">NULL</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[WAR]new_ref cover old!\n&quot;</span>);        ref_p[p]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(p,(p<span class="hljs-number">-1</span>)/m+<span class="hljs-number">1</span>,(p<span class="hljs-number">-1</span>)%m+<span class="hljs-number">1</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init new ref %d.\n&quot;</span>,p);        <span class="hljs-keyword">return</span> ref_p[p];    &#125;    <span class="hljs-function">Node* <span class="hljs-title">new_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//重载</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_ref</span>(<span class="hljs-built_in">mark</span>(x,y));    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-function">Node* <span class="hljs-title">ask_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-comment">//询问对应的Node</span>        <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">1</span>||p&gt;n*m)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]ask_ref error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span>(ref_p[p]==<span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_ref</span>(p);        <span class="hljs-keyword">return</span> ref_p[p];    &#125;    <span class="hljs-function">Node* <span class="hljs-title">ask_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//重载</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask_ref</span>(<span class="hljs-built_in">mark</span>(x,y));    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">if_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-comment">//询问对应的Node是否存在</span>        <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">1</span>||p&gt;n*m)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]ask_ref error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span>(ref_p[p]==<span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">if_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//重载</span>        <span class="hljs-keyword">return</span> if_ref(<span class="hljs-built_in">mark</span>(x,y));    &#125;    <span class="hljs-built_in">Refmark</span>(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m):<span class="hljs-built_in">n</span>(n),<span class="hljs-built_in">m</span>(m)&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n*m) ref_p[i]=<span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;creat ref %d*%d, init.\n&quot;</span>,n,m);    &#125;    ~<span class="hljs-built_in">Refmark</span>()&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n*m)            <span class="hljs-keyword">delete</span> ref_p[i];        <span class="hljs-comment">//printf(&quot;clear ref.\n&quot;);</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memset_vis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>)</span></span>&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n*m)&#123;            <span class="hljs-keyword">if</span>(ref_p[i]==<span class="hljs-literal">NULL</span>)                <span class="hljs-keyword">continue</span>;            ref_p[i]-&gt;vis=k;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memset ref_p as %d.\n&quot;</span>,k);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_way</span><span class="hljs-params">(Node *u,Node *v,<span class="hljs-keyword">int</span> w=<span class="hljs-number">1</span>)</span></span>&#123;    u-&gt;<span class="hljs-built_in">add_way</span>(v,w);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_way</span><span class="hljs-params">(Refmark &amp;R,<span class="hljs-keyword">int</span> p1,<span class="hljs-keyword">int</span> p2,<span class="hljs-keyword">int</span> w=<span class="hljs-number">1</span>)</span></span>&#123;    R.<span class="hljs-built_in">ask_ref</span>(p1)-&gt;<span class="hljs-built_in">add_way</span>(R.<span class="hljs-built_in">ask_ref</span>(p2),w);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_way</span><span class="hljs-params">(Refmark &amp;R,<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> y1,<span class="hljs-keyword">int</span> x2,<span class="hljs-keyword">int</span> y2,<span class="hljs-keyword">int</span> w=<span class="hljs-number">1</span>)</span></span>&#123;    R.<span class="hljs-built_in">ask_ref</span>(x1,y1)-&gt;<span class="hljs-built_in">add_way</span>(R.<span class="hljs-built_in">ask_ref</span>(x2,y2),w);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">spfa.h</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">#include&quot;refmark.h&quot;</span><span class="hljs-comment">#include&quot;queue_node.h&quot;</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(Node &amp;u,Refmark &amp;R)</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nbegin spfa at %d.\n&quot;</span>,u.<span class="hljs-built_in">get_ID</span>());    Queue_node q;    R.<span class="hljs-built_in">memset_vis</span>(<span class="hljs-number">0</span>);    q.<span class="hljs-built_in">push</span>(u);u.vis=<span class="hljs-number">1</span>;    u.dis=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        Node &amp;u =q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        u.vis=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(Path *t = u.<span class="hljs-built_in">head</span>();t!=<span class="hljs-literal">NULL</span>;t=t-&gt;<span class="hljs-built_in">next</span>())&#123;            Node &amp;v = *(t-&gt;<span class="hljs-built_in">gono</span>());            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d\n&quot;</span>,u.<span class="hljs-built_in">get_ID</span>(),v.<span class="hljs-built_in">get_ID</span>());            <span class="hljs-keyword">if</span>(v.dis&gt;u.dis+t-&gt;<span class="hljs-built_in">vall</span>())&#123;                v.dis = u.dis + t-&gt;<span class="hljs-built_in">vall</span>();                 v.Last=&amp;u;            &#125;             <span class="hljs-comment">//printf(&quot;%d %d %d\n&quot;,v.dis,u.dis,t-&gt;vall());</span>            <span class="hljs-keyword">if</span>(v.vis)                <span class="hljs-keyword">continue</span>;            q.<span class="hljs-built_in">push</span>(v);            v.vis=<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end spfa.\n\n&quot;</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">main.cpp</span><span class="hljs-comment">#include&quot;refmark.h&quot;</span><span class="hljs-comment">#include&quot;queue_node.h&quot;</span><span class="hljs-comment">#include&quot;spfa.h&quot;</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Node *S,*T;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入地图大小：&quot;</span>);    cin&gt;&gt;n&gt;&gt;m;    Refmark R=<span class="hljs-built_in">Refmark</span>(n,m);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入地图路径：&quot;</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">int</span> x1,y1,x2,y2;        cin&gt;&gt;x1;        <span class="hljs-keyword">if</span>(x1==<span class="hljs-number">-1</span>)            <span class="hljs-keyword">break</span>;        cin&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;        <span class="hljs-built_in">build_way</span>(R,x1,y1,x2,y2);    &#125;    <span class="hljs-keyword">int</span> x,y;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n请输入出发点坐标：&quot;</span>);    cin&gt;&gt;x&gt;&gt;y;    S=R.<span class="hljs-built_in">ask_ref</span>(x,y);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入终点坐标：&quot;</span>);    cin&gt;&gt;x&gt;&gt;y;    T=R.<span class="hljs-built_in">ask_ref</span>(x,y);    <span class="hljs-built_in">spfa</span>(*S,R);<span class="hljs-comment">//出发点</span>    cout&lt;&lt;<span class="hljs-string">&quot;ans=&quot;</span>&lt;&lt;T-&gt;dis&lt;&lt;endl;    Node *P = T;    <span class="hljs-keyword">if</span>(T-&gt;dis&lt;INF)        <span class="hljs-keyword">while</span>(P!=S)&#123;            P-&gt;If_Pass=<span class="hljs-number">1</span>;            P = P-&gt;Last;        &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-keyword">if</span>(R.if_ref(i,j)==<span class="hljs-number">0</span>)&#123;                cout&lt;&lt;<span class="hljs-string">&quot; # &quot;</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//cout&lt;&lt;setw(3)&lt;&lt;R.ask_ref(i,j)-&gt;dis;</span>                <span class="hljs-keyword">if</span>(R.<span class="hljs-built_in">ask_ref</span>(i,j)==S)&#123;                    cout&lt;&lt;<span class="hljs-string">&quot; @ &quot;</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(R.<span class="hljs-built_in">ask_ref</span>(i,j)==T)&#123;                    cout&lt;&lt;<span class="hljs-string">&quot; $ &quot;</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(R.<span class="hljs-built_in">ask_ref</span>(i,j)-&gt;If_Pass)&#123;                    cout&lt;&lt;<span class="hljs-string">&quot; . &quot;</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                cout&lt;&lt;<span class="hljs-string">&quot;   &quot;</span>;            &#125;        &#125;        cout&lt;&lt;endl;    &#125;    cout&lt;&lt;endl;    cout&lt;&lt;<span class="hljs-string">&quot;END&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">10 10</span><span class="hljs-comment">1 1 1 2</span><span class="hljs-comment">1 2 2 2</span><span class="hljs-comment">2 2 2 3</span><span class="hljs-comment">2 3 3 3</span><span class="hljs-comment">3 3 4 3</span><span class="hljs-comment">4 3 4 4</span><span class="hljs-comment">4 4 4 5</span><span class="hljs-comment">4 5 5 5</span><span class="hljs-comment">5 5 6 5</span><span class="hljs-comment">6 5 7 5</span><span class="hljs-comment">7 5 7 6</span><span class="hljs-comment">7 6 7 7</span><span class="hljs-comment">7 7 7 8</span><span class="hljs-comment">7 8 8 8</span><span class="hljs-comment">8 8 9 8 </span><span class="hljs-comment">-1</span><span class="hljs-comment">1 1</span><span class="hljs-comment">5 5</span><span class="hljs-comment">*/</span></code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 大学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
            <tag> SPFA </tag>
            
            <tag> 栈 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022a半年鉴 - 界</title>
      <link href="/2022/06/25/22%E5%B9%B4%E6%8A%A5/"/>
      <url>/2022/06/25/22%E5%B9%B4%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>你还好吗？要继续走啊……</p></blockquote>        <div id="aplayer-qJkUJUep" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"报国寺喝茶","author":"孔柏森 / 汪漾","url":"http://music.163.com/song/media/outer/url?id=1306585974.mp3","pic":"http://p2.music.126.net/4haOyOxkyFS2EzE3-TWnRg==/109951163527208913.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-qJkUJUep");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><hr /><h1 id="学习">1 学习</h1><h2 id="部分学科总结">1.1 部分学科总结</h2><p>来到大学，已然是一年了，一年以来的成长让我褪去的从前，改变了高中的习模式，也成为了一个真正的大学生。</p><p>问题依然显著。在今年一二月的寒假里，我提前完成了大学物理（浏览）、高等数学II、概率论与数理统计的预习，本以为能带来极大的先发优势和减轻学习压力，但是事实并不如人意。</p><p>对于大物，我仅仅是翻看完了整本书记，凭借高中物理竞赛的底，评估结果为难度不大，但是这学期里发现大物的许多公式并没有理解，同时考试与作业并不需要记底层的公式，仅仅需要记住简单的二级结论。这虽然大大减轻了学习难度，但是也给我带了了割裂感——我的大物并没有展现出应有的能力，特别是在经典力学（转动惯量）之后，进入狭义相对论与电磁场后，问题突出，我是在考试前一天才翻看理解了这部分的书上的内容。</p><p>对于高等数学，预习的成效还是有的，但是并不显著，以至于课上我开小差后甚至并不能跟上，究其原因是没有完全的深入的理解和记录内容，同时缺少题目的练习导致的缺陷。</p><p>对英语的学习时间少，同时逃避心理加剧，导致英语依然是严重的漏洞。</p><h2 id="学习时间与状态">1.2 学习时间与状态</h2><p>大概是在半期左右的以前，我基本上都做到了坚持的学习计划安排，特别是在开学的一个月内，心里巨大的压力，促成了我的早起较早睡的，包括早上7:10后起，7:30到达图书馆，9:20去上课的时间表，以及非上课时间段都在图书馆的习惯，可惜的是，学习效率并不理想。一直到几次数学建模比赛又大大的改变了我的作息，破坏了我的生物钟和脑海的鉴定，有小段时间的荒废，直到期末考试的压力下的重新奔走图书馆。这便是这学期大致的学习状态的变化。</p><p>关于心理状态，其实是渐渐减弱的，刚开学时我给自己的压力非常大。可能那是一面墙，一面光怪陆离仿佛是大千世界的壁障，在黑暗的宇宙里向我压下来。来自工作、学习、竞赛队伍的压力随着时间渐渐减弱……压力大到被自我调节了。</p><h1 id="竞赛">2 竞赛</h1><p>看起来每年的上半年和学年的下期，才是我所参加竞赛的集中展开时间。依托ACM/ICPC类的程序设计比赛的举办和数学建模风暴月，我获得了可观的奖项数和一定的质量，这大大增添了我的简历，但也开始成为群里被“阴阳”和捧杀的对象。</p><h1 id="同道">3 同道</h1><p>换届大大削减了我过多的所在集体，最后仅仅还有：ACM校队（协会）、数学建模学术部（老头痛部长团）、惟悦工作室</p><p>对我刺痛最深的是数学建模协会没能任选与留任，具体情况已经有写过了，不作赘述。但是，在“老头乐”的欢乐谷之旅以及后来的两次烧烤摊故事会和最近的会长脱单行动里和大家打成一片，也很好……</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 年报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程训练】山区地貌 - 插值</title>
      <link href="/2022/05/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E5%B1%B1%E5%8C%BA%E5%9C%B0%E8%B2%8C/"/>
      <url>/2022/05/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E5%B1%B1%E5%8C%BA%E5%9C%B0%E8%B2%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题描述">问题描述</h1><p>山区地貌:在某山区测得一些地点的高程为一个矩阵。（平面区域<spanclass="math inline">\(1200&lt;=x&lt;=4000,1200&lt;=y&lt;=3600\)</span>）</p><p>试作出该山区的地貌图和等高线图，并对几种插值方法进行比较。</p><h1 id="结果展示">结果展示</h1><figure><img src="https://s2.loli.net/2022/05/07/VnZ9MyY8WvLqhtd.png"alt="原始数据" /><figcaption aria-hidden="true">原始数据</figcaption></figure><figure><img src="https://s2.loli.net/2022/05/07/cuavoiRJ46zNBFg.png"alt="插值后" /><figcaption aria-hidden="true">插值后</figcaption></figure><h1 id="插值代码">插值代码</h1><p>注：以下采用的是两组线性插值来得到二维平面的插值数据。</p><p>对于相同的题型，仅需要修改下面<code>x,y,z</code>。 [MATLAB] main.m主程序</p><div class="hljs code-wrapper"><pre><code class="hljs m">clc;clear;x <span class="hljs-built_in">=</span> [<span class="hljs-number">1200</span><span class="hljs-number">1600</span><span class="hljs-number">2000</span><span class="hljs-number">2400</span><span class="hljs-number">2800</span><span class="hljs-number">3200</span><span class="hljs-number">3600</span><span class="hljs-number">4000</span>];y <span class="hljs-built_in">=</span> [<span class="hljs-number">3600</span><span class="hljs-number">3200</span><span class="hljs-number">2800</span><span class="hljs-number">2400</span><span class="hljs-number">2000</span><span class="hljs-number">1600</span><span class="hljs-number">1200</span>]<span class="hljs-string">&#x27;;</span><span class="hljs-string">z = [1480150015501510143013001200980</span><span class="hljs-string">     15001550160015501600160016001550</span><span class="hljs-string">     15001200110015501600155013801070</span><span class="hljs-string">     15001200110013501450120011501010</span><span class="hljs-string">     1390150015001400900    11001060950</span><span class="hljs-string">     13201450142014001300700    900    850</span><span class="hljs-string">     11301250128012301040900    500    700];</span><span class="hljs-string"></span><span class="hljs-string">figure(2);</span><span class="hljs-string">    [X,Y]=meshgrid(x,y);</span><span class="hljs-string">    mesh(X,Y,z);</span><span class="hljs-string">    title(&#x27;</span>原数据<span class="hljs-string">&#x27;);</span><span class="hljs-string"></span><span class="hljs-string">%% init</span><span class="hljs-string">h = 1;</span><span class="hljs-string">xco = [x(1):h:x(end)];</span><span class="hljs-string">yco = [y(1):-h:y(end)]&#x27;</span>;zco <span class="hljs-built_in">=</span> [];zco2 <span class="hljs-built_in">=</span> [];<span class="hljs-comment">%% spline</span>for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(z,<span class="hljs-number">1</span>)    zco(i,:) <span class="hljs-built_in">=</span> spline(x,z(i,:),xco);endfor j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(zco,<span class="hljs-number">2</span>)    zco2(:,j)<span class="hljs-built_in">=</span>spline(y,zco(:,j),yco);endfigure(<span class="hljs-number">1</span>);    [X,Y]<span class="hljs-built_in">=</span>meshgrid(xco,yco);    Z<span class="hljs-built_in">=</span>zco2;    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">%三维图</span>        mesh(X,Y,Z);    subtitle(<span class="hljs-string">&#x27;插值后三维图&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">%三维等高线</span>        contour3(X,Y,Z,<span class="hljs-number">20</span>);    title(<span class="hljs-string">&#x27;三次样条插值&#x27;</span>,<span class="hljs-string">&#x27;Color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>);    subtitle(<span class="hljs-string">&#x27;插值后三维等高线&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">%平面等高线</span>        contour(X,Y,Z,<span class="hljs-number">20</span>);    subtitle(<span class="hljs-string">&#x27;插值后平面等高线&#x27;</span>);<span class="hljs-comment">%% pchip</span>for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(z,<span class="hljs-number">1</span>)    zco(i,:) <span class="hljs-built_in">=</span> pchip(x,z(i,:),xco);endfor j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(zco,<span class="hljs-number">2</span>)    zco2(:,j) <span class="hljs-built_in">=</span> pchip(y,zco(:,j),yco);endfigure(<span class="hljs-number">1</span>);    [X,Y]<span class="hljs-built_in">=</span>meshgrid(xco,yco);    Z<span class="hljs-built_in">=</span>zco2;    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">%三维图</span>        mesh(X,Y,Z);    subtitle(<span class="hljs-string">&#x27;插值后三维图&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">%三维等高线</span>        contour3(X,Y,Z,<span class="hljs-number">20</span>);    title(<span class="hljs-string">&#x27;分段三次 Hermite 插值多项式&#x27;</span>,<span class="hljs-string">&#x27;Color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>);    subtitle(<span class="hljs-string">&#x27;插值后三维等高线&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">%平面等高线</span>        contour(X,Y,Z,<span class="hljs-number">20</span>);    subtitle(<span class="hljs-string">&#x27;插值后平面等高线&#x27;</span>);<span class="hljs-comment">%% makima</span>for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(z,<span class="hljs-number">1</span>)    zco(i,:) <span class="hljs-built_in">=</span> makima(x,z(i,:),xco);endfor j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(zco,<span class="hljs-number">2</span>)    zco2(:,j) <span class="hljs-built_in">=</span> makima(y,zco(:,j),yco);endfigure(<span class="hljs-number">1</span>);    [X,Y]<span class="hljs-built_in">=</span>meshgrid(xco,yco);    Z<span class="hljs-built_in">=</span>zco2;    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>); <span class="hljs-comment">%三维图</span>        mesh(X,Y,Z);    subtitle(<span class="hljs-string">&#x27;插值后三维图&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>); <span class="hljs-comment">%三维等高线</span>        contour3(X,Y,Z,<span class="hljs-number">20</span>);    title(<span class="hljs-string">&#x27;修正 Akima 分段三次 Hermite 插值&#x27;</span>,<span class="hljs-string">&#x27;Color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>);    subtitle(<span class="hljs-string">&#x27;插值后三维等高线&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">%平面等高线</span>        contour(X,Y,Z,<span class="hljs-number">20</span>);    subtitle(<span class="hljs-string">&#x27;插值后平面等高线&#x27;</span>);</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维插值 </tag>
            
            <tag> 分段插值 </tag>
            
            <tag> 多项式插值 </tag>
            
            <tag> 埃尔米特插值 </tag>
            
            <tag> 样条插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火锅、大雨和欢庆</title>
      <link href="/2022/04/30/18/"/>
      <url>/2022/04/30/18/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>这雨湿透了整片夜，夜色下的徒步奔走与嬉戏，化为了礼物与分别。</p></blockquote><p>这一晚上过的很愉快，很难想象，在大学还能有这样的氛围，这样的环境，这样的经历。所以呢？回味吧，毕竟，可能没有下次了。</p><p><br></p><p><span class="math display">\[\tiny就老去吧，孤独别醒来\\就歌唱吧，眼睛眯起来\]</span></p><p><br></p>        <div id="aplayer-HEHeYrWl" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"理想三旬","author":"陈鸿宇","url":"http://music.163.com/song/media/outer/url?id=31445772.mp3","pic":"http://p2.music.126.net/cqTTEPAaxXG3cOwaE4E_-g==/109951163104103366.jpg?param=130y130","lrc":""},{"title":"理想三旬（女生版）","author":"花柒柒柒","url":"http://music.163.com/song/media/outer/url?id=1432542306.mp3","pic":"http://p2.music.126.net/qIJZ6B7jw6nyZMzQhCvtWw==/109951164821687515.jpg?param=130y130","lrc":""}]};  options.element = document.getElementById("aplayer-HEHeYrWl");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><center><hr width=300px></center><p>从买奶茶-吃火锅-去ktv可以作为的第一阶段；从雨中奔波-ktv活动-返回学校可以作为另一阶段。</p><p>因为凯德广场的ktv没位置了，不得不转战另一家ktv，在去这ktv的最后一段路，是一公里余的公路边的步行，那时候已经是网上十一点多了，而且下起了大雨，这便是上文中提到的那一场雨。</p><p>在去第二家ktv时也有想回学校的还有想看电影的，但是因为氛围，大家还是一个不落的去到了ktv，玩到了晚上两点半。真是这第二阶段让整段记忆，变得有意思了起来。</p><p>上面那首歌，便是ktv里面我给我留下最深印象的歌，从英口中歌唱出来的歌曲，给我的感觉很深刻，以至于第二天在我脑海中单曲循环，不，应该是单句循环。</p><p>通过ktv的游戏，与几人能够“交换”出故事，了解对方的思想，这在大学是非常珍贵的。也确实给了我很大感触，与之同时带来的还有疑惑和恐惧——我居然问不出问题了——对于我所好奇的人。</p><p>这里倒不是那么严重，只是到了活动后期，大家都没有很好的问题问了，就好像已经没有疑惑了，或者是，到此就已经满足了。</p><p>也许是自我的变化，也许是整个大环境，潜移默化，我们而丧失了部分好奇，丧失了询问一个人所想的能力。</p><p>凯德，是高中毕业聚餐的地方，也是流落了记忆的地方，在十一个月以前的那个夜晚，烟花散尽后，的落寞，还有之后的那一个早上，她的离开。相同的地点，我又来到了他的前面，不过还好，我没能进去，还好没进去，那段记忆就留在那里吧。</p><p>雨中漫步，也是很久没有的事情了……高中我还经常下课散步看雨，而上一次仔细的听雨，看雨，是多久？早已经不清楚了吧？</p><p>真心话大冒险，其实更重要的是提供了大家真心交流的机会，不仅仅是感情，还可以是三观，思想等等的了解。心灵的互动是必要的，是难得的，是珍贵的，希望还能有机会……</p><center><hr width=300px></center><p>另外有一个有意思的是，最后分礼品（活动剩下的奖品）的时候，是摇色子，谁大就能得到奖品，而我一直想要那一把扇子。但是我抽奖等的运气从来就不好，所以知道规矩后我基本上是无望了的，第一次抽另一个电子钟的数仿佛已经证实了这点，但是抽扇子的时候，我第一次投出了六，和我一样是六的就只有另一个女生；之后她先投，我再投，但是忘了把她投的色子取出来，就要重新投，我好像还是投了个六，最后，我还是投出了六……很惊讶，惊喜？（联想到第一把斗地主我直接春天）</p><p>我这个运气……不好评价，很有玄妙的感觉，但是这并不是重点，最终我还是在回学校的车上个人打算把扇子让给那位女生——在活动的时候，她就把玩了扇子，那时候她的旗袍和扇子很搭配，我们哦都说她很合适，而她？大概也是想要吧。</p><p>而我做出了这个让出的扇子的决定，我也有些思考，奇怪，我为什么会这样做？毕竟，我更倾向于是自私的人，同时她对于我并没有什么特别的，此外，我曾经一直是不会考虑别人的感受的，而这次？</p><p>也许是那晚上的环境使然，也许是成长使然吧。那把折扇更适合曾经的我，和现在的她。我希望这折扇，是因为曾经的喜欢，而今天的我，应该把它让给更合适的人吧。这算是什么呢？</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程训练】旅行商问题(TSP) - 遗传算法</title>
      <link href="/2022/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>注意！此题目版权归本人指导老师卢鹏所有，禁止外传！</p>          </div><h1 id="问题描述">问题描述</h1><p>某公司计划在某个地区做广告选宣传，推销员从城市 1出发，经过各个乡镇，再回到城市1，城镇的坐标位置见下表。为节约开支，公司希望推销员走过这 50个城镇的总距离最少，请你使用 LINGO 和 MATLAB软件编程求出最少总距离及其路径（需画出最后的线路图）。</p><p><img src="https://s2.loli.net/2022/04/27/69d7PcNYHeZD2ES.png" /></p><p>数学模型：</p><p><span class="math display">\[\min \sum_{i \neq j} d_{i j} x_{ij}\]</span> <span class="math display">\[s.t.  \left\{\begin{array}{l}\sum\nolimits_{j=1}^{50} x_{i j}=1, i=1,2, \ldots, 50 , ,\small(每个点只有一条边出去),\\\sum\nolimits_{i=1}^{50} x_{i j}=1, j=1,2, \ldots, 50, \small (\text {每个点只有一条边进去), } \\\sum\nolimits_{i, j \in s} x_{i j} \leq|s|-1,2 \leq|s| \leq n-1, s\subset\{1,2, \ldots, 50\},\\\small 即  S  为  \{1,2, \ldots, 50\}  的真子集 (除终点和起点外,各边不构成圈),  \\x_{i j} \in\{0,1\}, i, j=1,2, \ldots 50, i \neq j\end{array}\right.\]</span></p><p>说明：</p><p>采用 LINGO求解主要是约束当中第三个不好写，可以采用下面的约束替换：</p><p>计算详细步骤略。</p><p><span class="math display">\[{} \text { \small 破圈约束: } \quadu_{i}-u_{j}+n x_{i j} \leq n-1 ; u_{i}, u_{j} \geq 0 ; i=1,2, \cdots, n; j=2, \cdots, n ; i \neq j\]</span></p><h1 id="遗传算法代码">遗传算法代码</h1><h2 id="lingo">LINGO</h2><div class="hljs code-wrapper"><pre><code class="hljs lg4">model:set:    c/1..50/:xco,yco,u;    link(c,c):d,x; !d表示距离，x表示路径;endsetsdata:  xco=185 21 127 177 180 73 123 144 110 47      131 85 200 52 151 5 148 102 77 161      157 165 114 43 30 78 36 134 180 89      175 4 9 12 77 88 89 99 69 6      104 49 4 43 114 68 114 185 29 164;  yco=151 15 32 87 196 137 19 157 14 144      41 36 109 171 143 181 95 79 33 182      49 3 93 104 164 3 150 50 56 21      179 104 12 95 101 164 184 150 106 43      179 8 40 185 178 46 157 143 196 57;enddata@for(link(i,j): !初始化d;d(i,j)=@if(i #ne#j ,@sqrt( (xco(i)-xco(j))*(xco(i)-xco(j)) + (yco(i)-yco(j))*(yco(i)-yco(j))),100000); );min = @sum(c(i):@sum(c(j):d(i,j)*x(i,j))); !破圈约束;n = @size(c);@for(link(i,j)|i #ne# j #and# i #ne# 1 #and# j #ne# 1:u(i) - u(j) + n * x(i,j) &lt;= n - 1);@for(c(i):@sum(c(j)|i #ne# j :x(i,j))=1; !约束出度为1;@sum(c(j)|i #ne# j :x(j,i))=1; !约束入度为1;);@for(link(i,j):@bin(x(i,j))); !约束x为0-1，可以不要;end</code></pre></div><h2 id="未优化matlab">未优化MATLAB</h2><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%%数据初始化</span>clc;clear;xco<span class="hljs-built_in">=</span>[<span class="hljs-number">185</span> <span class="hljs-number">21</span> <span class="hljs-number">127</span> <span class="hljs-number">177</span> <span class="hljs-number">180</span> <span class="hljs-number">73</span> <span class="hljs-number">123</span> <span class="hljs-number">144</span> <span class="hljs-number">110</span> <span class="hljs-number">47</span> <span class="hljs-number">131</span> <span class="hljs-number">85</span> <span class="hljs-number">200</span> <span class="hljs-number">52</span> <span class="hljs-number">151</span> <span class="hljs-number">5</span> <span class="hljs-number">148</span> <span class="hljs-number">102</span> <span class="hljs-number">77</span> <span class="hljs-number">161</span> <span class="hljs-number">157</span> <span class="hljs-number">165</span> <span class="hljs-number">114</span> <span class="hljs-number">43</span> <span class="hljs-number">30</span> <span class="hljs-number">78</span> <span class="hljs-number">36</span> <span class="hljs-number">134</span> <span class="hljs-number">180</span> <span class="hljs-number">89</span> <span class="hljs-number">175</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">77</span> <span class="hljs-number">88</span> <span class="hljs-number">89</span> <span class="hljs-number">99</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span> <span class="hljs-number">104</span> <span class="hljs-number">49</span> <span class="hljs-number">4</span> <span class="hljs-number">43</span> <span class="hljs-number">114</span> <span class="hljs-number">68</span> <span class="hljs-number">114</span> <span class="hljs-number">185</span> <span class="hljs-number">29</span> <span class="hljs-number">164</span>];yco<span class="hljs-built_in">=</span>[<span class="hljs-number">151</span> <span class="hljs-number">15</span> <span class="hljs-number">32</span> <span class="hljs-number">87</span> <span class="hljs-number">196</span> <span class="hljs-number">137</span> <span class="hljs-number">19</span> <span class="hljs-number">157</span> <span class="hljs-number">14</span> <span class="hljs-number">144</span> <span class="hljs-number">41</span> <span class="hljs-number">36</span> <span class="hljs-number">109</span> <span class="hljs-number">171</span> <span class="hljs-number">143</span> <span class="hljs-number">181</span> <span class="hljs-number">95</span> <span class="hljs-number">79</span> <span class="hljs-number">33</span> <span class="hljs-number">182</span> <span class="hljs-number">49</span> <span class="hljs-number">3</span> <span class="hljs-number">93</span> <span class="hljs-number">104</span> <span class="hljs-number">164</span> <span class="hljs-number">3</span> <span class="hljs-number">150</span> <span class="hljs-number">50</span> <span class="hljs-number">56</span> <span class="hljs-number">21</span> <span class="hljs-number">179</span> <span class="hljs-number">104</span> <span class="hljs-number">12</span> <span class="hljs-number">95</span> <span class="hljs-number">101</span> <span class="hljs-number">164</span> <span class="hljs-number">184</span> <span class="hljs-number">150</span> <span class="hljs-number">106</span> <span class="hljs-number">43</span> <span class="hljs-number">79</span> <span class="hljs-number">8</span> <span class="hljs-number">40</span> <span class="hljs-number">185</span> <span class="hljs-number">178</span> <span class="hljs-number">46</span> <span class="hljs-number">157</span> <span class="hljs-number">143</span> <span class="hljs-number">196</span> <span class="hljs-number">57</span>];city_n<span class="hljs-built_in">=</span>size(xco,<span class="hljs-number">2</span>);for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:city_n    for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:city_n        dis(i,j)<span class="hljs-built_in">=</span>sqrt((xco(i)-xco(j))*(xco(i)-xco(j))+(yco(i)-yco(j))*(yco(i)-yco(j)));    endend<span class="hljs-comment">%%遗传算法</span><span class="hljs-comment">%生成初始路径</span>best_way<span class="hljs-built_in">=</span>[];best_fit<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;best_dist<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;new<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;fit_time<span class="hljs-built_in">=</span>[];dis_time<span class="hljs-built_in">=</span>[];way_n<span class="hljs-built_in">=</span><span class="hljs-number">10</span>;for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n    way0(i,:)<span class="hljs-built_in">=</span>randperm(city_n);end<span class="hljs-comment">%开始迭代</span>for o <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">100000</span>    way<span class="hljs-built_in">=</span>way0;    for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n         d(i)<span class="hljs-built_in">=</span>fit(way(i,:),dis);<span class="hljs-comment">%路径距离</span>    end    v<span class="hljs-built_in">=</span>ones([<span class="hljs-number">1</span>,way_n])*sum(d)./d;<span class="hljs-comment">%适应度</span>    for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n         <span class="hljs-built_in">if</span> v(i)&gt;best_fit            best_fit<span class="hljs-built_in">=</span>v(i);            best_way<span class="hljs-built_in">=</span>way(i,:);            best_dist<span class="hljs-built_in">=</span>d(i);            new<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;        end;    end    v<span class="hljs-built_in">=</span>v/sum(v);<span class="hljs-comment">%选择概率</span>    q<span class="hljs-built_in">=</span>v(<span class="hljs-number">1</span>);    for i <span class="hljs-built_in">=</span> <span class="hljs-number">2</span>:way_n        q(i)<span class="hljs-built_in">=</span>q(i-<span class="hljs-number">1</span>)+v(i);<span class="hljs-comment">%累积概率</span>    end    for l <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">5</span>        <span class="hljs-comment">%选择第一条路</span>        q_rand <span class="hljs-built_in">=</span> rand();        k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;<span class="hljs-comment">%为选择的路径编号</span>        for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n            <span class="hljs-built_in">if</span> q_rand&gt;q(i)                k<span class="hljs-built_in">=</span>i+<span class="hljs-number">1</span>;            end        end        way1<span class="hljs-built_in">=</span>k;        <span class="hljs-comment">%选择第二条路</span>        q_rand <span class="hljs-built_in">=</span> rand();        k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;<span class="hljs-comment">%为选择的路径编号</span>        for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n            <span class="hljs-built_in">if</span> q_rand&gt;q(i)                k<span class="hljs-built_in">=</span>i+<span class="hljs-number">1</span>;            end        end        way2<span class="hljs-built_in">=</span>k;        <span class="hljs-comment">%交配</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.9</span> &amp;&amp; i~<span class="hljs-built_in">=</span>j)            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            <span class="hljs-comment">%交叉互换</span>            for i <span class="hljs-built_in">=</span> ran1:ran2                k<span class="hljs-built_in">=</span>way(way1,i);                way(way1,i)<span class="hljs-built_in">=</span>way(way2,i);                way(way2,i)<span class="hljs-built_in">=</span>k;            end            <span class="hljs-comment">%查重与去重way1</span>            mark<span class="hljs-built_in">=</span>zeros([<span class="hljs-number">1</span>,city_n]);            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                mark(way(way1,i))<span class="hljs-built_in">=</span>mark(way(way1,i))+<span class="hljs-number">1</span>;            end            p1<span class="hljs-built_in">=</span>[];p2<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>                    p1(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">2</span>                    p2(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end            end            ran<span class="hljs-built_in">=</span>randperm(size(p1,<span class="hljs-number">2</span>));<span class="hljs-comment">%随机化</span>            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(p2,<span class="hljs-number">2</span>);                for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                    <span class="hljs-built_in">if</span> (j&lt;ran1 || j&gt;ran2) &amp;&amp; way(way1,j)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>p2(i)                        way(way1,j)<span class="hljs-built_in">=</span>p1(ran(i));                        break;                    end                end            end            <span class="hljs-comment">%查重与去重way2</span>            mark<span class="hljs-built_in">=</span>zeros([<span class="hljs-number">1</span>,city_n]);            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                mark(way(way2,i))<span class="hljs-built_in">=</span>mark(way(way2,i))+<span class="hljs-number">1</span>;            end            p1<span class="hljs-built_in">=</span>[];p2<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>                    p1(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">2</span>                    p2(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end            end            ran<span class="hljs-built_in">=</span>randperm(size(p1,<span class="hljs-number">2</span>));<span class="hljs-comment">%随机化</span>            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(p2,<span class="hljs-number">2</span>);                for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                    <span class="hljs-built_in">if</span> (j&lt;ran1 || j&gt;ran2) &amp;&amp; way(way2,j)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>p2(i)                        way(way2,j)<span class="hljs-built_in">=</span>p1(ran(i));                        break;                    end                end            end            <span class="hljs-comment">%</span>        end        <span class="hljs-comment">%变异</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.2</span>)            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            k<span class="hljs-built_in">=</span>way(way1,ran1);            way(way1,ran1)<span class="hljs-built_in">=</span>way(way1,ran2);            way(way1,ran2)<span class="hljs-built_in">=</span>k;            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            k<span class="hljs-built_in">=</span>way(way2,ran1);            way(way2,ran1)<span class="hljs-built_in">=</span>way(way2,ran2);            way(way2,ran2)<span class="hljs-built_in">=</span>k;        end        <span class="hljs-comment">%存储为下一代</span>        way0(l*<span class="hljs-number">2</span>-<span class="hljs-number">1</span>,:)<span class="hljs-built_in">=</span>way(way1,:);        way0(l*<span class="hljs-number">2</span>,:)<span class="hljs-built_in">=</span>way(way2,:);    end    <span class="hljs-comment">%绘图</span>    figure(<span class="hljs-number">1</span>)    <span class="hljs-built_in">if</span> new<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">1</span>        new<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;        gox<span class="hljs-built_in">=</span>[];goy<span class="hljs-built_in">=</span>[];        for i<span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n            gox(i)<span class="hljs-built_in">=</span>xco(best_way(i));            goy(i)<span class="hljs-built_in">=</span>yco(best_way(i));        end        gox(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>xco(best_way(<span class="hljs-number">1</span>));        goy(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>yco(best_way(<span class="hljs-number">1</span>));        plot(gox,goy,<span class="hljs-string">&#x27;o--&#x27;</span>);        title(best_fit,best_dist);        drawnow;        <span class="hljs-comment">%pause(0);</span>    end    fit_time(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>best_fit;    dis_time(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>best_dist;endfigure(<span class="hljs-number">2</span>)plot(fit_time);figure(<span class="hljs-number">3</span>)plot(dis_time);clear ran d i j k l o mark new p1 p2 l q q_rand ran1 ran2 v way way0 way1 way2 ;clear dis gox goy xco yco;</code></pre></div><h2 id="优化后matlab">优化后MATLAB</h2><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%%数据初始化</span>clc;clear;xco<span class="hljs-built_in">=</span>[<span class="hljs-number">185</span> <span class="hljs-number">21</span> <span class="hljs-number">127</span> <span class="hljs-number">177</span> <span class="hljs-number">180</span> <span class="hljs-number">73</span> <span class="hljs-number">123</span> <span class="hljs-number">144</span> <span class="hljs-number">110</span> <span class="hljs-number">47</span> <span class="hljs-number">131</span> <span class="hljs-number">85</span> <span class="hljs-number">200</span> <span class="hljs-number">52</span> <span class="hljs-number">151</span> <span class="hljs-number">5</span> <span class="hljs-number">148</span> <span class="hljs-number">102</span> <span class="hljs-number">77</span> <span class="hljs-number">161</span> <span class="hljs-number">157</span> <span class="hljs-number">165</span> <span class="hljs-number">114</span> <span class="hljs-number">43</span> <span class="hljs-number">30</span> <span class="hljs-number">78</span> <span class="hljs-number">36</span> <span class="hljs-number">134</span> <span class="hljs-number">180</span> <span class="hljs-number">89</span> <span class="hljs-number">175</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">77</span> <span class="hljs-number">88</span> <span class="hljs-number">89</span> <span class="hljs-number">99</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span> <span class="hljs-number">104</span> <span class="hljs-number">49</span> <span class="hljs-number">4</span> <span class="hljs-number">43</span> <span class="hljs-number">114</span> <span class="hljs-number">68</span> <span class="hljs-number">114</span> <span class="hljs-number">185</span> <span class="hljs-number">29</span> <span class="hljs-number">164</span>];yco<span class="hljs-built_in">=</span>[<span class="hljs-number">151</span> <span class="hljs-number">15</span> <span class="hljs-number">32</span> <span class="hljs-number">87</span> <span class="hljs-number">196</span> <span class="hljs-number">137</span> <span class="hljs-number">19</span> <span class="hljs-number">157</span> <span class="hljs-number">14</span> <span class="hljs-number">144</span> <span class="hljs-number">41</span> <span class="hljs-number">36</span> <span class="hljs-number">109</span> <span class="hljs-number">171</span> <span class="hljs-number">143</span> <span class="hljs-number">181</span> <span class="hljs-number">95</span> <span class="hljs-number">79</span> <span class="hljs-number">33</span> <span class="hljs-number">182</span> <span class="hljs-number">49</span> <span class="hljs-number">3</span> <span class="hljs-number">93</span> <span class="hljs-number">104</span> <span class="hljs-number">164</span> <span class="hljs-number">3</span> <span class="hljs-number">150</span> <span class="hljs-number">50</span> <span class="hljs-number">56</span> <span class="hljs-number">21</span> <span class="hljs-number">179</span> <span class="hljs-number">104</span> <span class="hljs-number">12</span> <span class="hljs-number">95</span> <span class="hljs-number">101</span> <span class="hljs-number">164</span> <span class="hljs-number">184</span> <span class="hljs-number">150</span> <span class="hljs-number">106</span> <span class="hljs-number">43</span> <span class="hljs-number">79</span> <span class="hljs-number">8</span> <span class="hljs-number">40</span> <span class="hljs-number">185</span> <span class="hljs-number">178</span> <span class="hljs-number">46</span> <span class="hljs-number">157</span> <span class="hljs-number">143</span> <span class="hljs-number">196</span> <span class="hljs-number">57</span>];city_n<span class="hljs-built_in">=</span>size(xco,<span class="hljs-number">2</span>);for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:city_n    for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:city_n        dis(i,j)<span class="hljs-built_in">=</span>sqrt((xco(i)-xco(j))*(xco(i)-xco(j))+(yco(i)-yco(j))*(yco(i)-yco(j)));    endend<span class="hljs-comment">%%遗传算法</span><span class="hljs-comment">%生成初始路径</span>best_way<span class="hljs-built_in">=</span>[];best_fit<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;best_dist<span class="hljs-built_in">=</span><span class="hljs-number">100000</span>;new<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;<span class="hljs-comment">%记录最优解</span>fit_time<span class="hljs-built_in">=</span>[];dis_time<span class="hljs-built_in">=</span>[];<span class="hljs-comment">%记录最优解变化</span>way_n<span class="hljs-built_in">=</span><span class="hljs-number">10</span>;for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n    way0(i,:)<span class="hljs-built_in">=</span>randperm(city_n);end<span class="hljs-comment">%开始迭代</span>for o <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">10000</span>    way<span class="hljs-built_in">=</span>way0;    for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n         d(i)<span class="hljs-built_in">=</span>fit(way(i,:),dis);<span class="hljs-comment">%路径距离</span>    end    v<span class="hljs-built_in">=</span>ones([<span class="hljs-number">1</span>,way_n])*sum(d)./d;<span class="hljs-comment">%适应度</span>    for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n         <span class="hljs-built_in">if</span> d(i)&lt;best_dist <span class="hljs-comment">%改动1：以距离评判最优解</span>            best_fit<span class="hljs-built_in">=</span>v(i);            best_way<span class="hljs-built_in">=</span>way(i,:);            best_dist<span class="hljs-built_in">=</span>d(i);            new<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;        end;    end    v<span class="hljs-built_in">=</span>v/sum(v);<span class="hljs-comment">%选择概率</span>    q<span class="hljs-built_in">=</span>v(<span class="hljs-number">1</span>);    for i <span class="hljs-built_in">=</span> <span class="hljs-number">2</span>:way_n        q(i)<span class="hljs-built_in">=</span>q(i-<span class="hljs-number">1</span>)+v(i);<span class="hljs-comment">%累积概率</span>    end    for l <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">5</span>        <span class="hljs-comment">%选择第一条路</span>        q_rand <span class="hljs-built_in">=</span> rand();        k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;<span class="hljs-comment">%为选择的路径编号</span>        for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n            <span class="hljs-built_in">if</span> q_rand&gt;q(i)                k<span class="hljs-built_in">=</span>i+<span class="hljs-number">1</span>;            end        end        way1<span class="hljs-built_in">=</span>k;        <span class="hljs-comment">%选择第二条路</span>        q_rand <span class="hljs-built_in">=</span> rand();        k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;<span class="hljs-comment">%为选择的路径编号</span>        for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n            <span class="hljs-built_in">if</span> q_rand&gt;q(i)                k<span class="hljs-built_in">=</span>i+<span class="hljs-number">1</span>;            end        end        way2<span class="hljs-built_in">=</span>k;        <span class="hljs-comment">%交配</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.9</span> &amp;&amp; i~<span class="hljs-built_in">=</span>j)            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            <span class="hljs-comment">%交叉互换</span>            for i <span class="hljs-built_in">=</span> ran1:ran2                k<span class="hljs-built_in">=</span>way(way1,i);                way(way1,i)<span class="hljs-built_in">=</span>way(way2,i);                way(way2,i)<span class="hljs-built_in">=</span>k;            end            <span class="hljs-comment">%查重与去重way1</span>            mark<span class="hljs-built_in">=</span>zeros([<span class="hljs-number">1</span>,city_n]);            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                mark(way(way1,i))<span class="hljs-built_in">=</span>mark(way(way1,i))+<span class="hljs-number">1</span>;            end            p1<span class="hljs-built_in">=</span>[];p2<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>                    p1(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">2</span>                    p2(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end            end            ran<span class="hljs-built_in">=</span>randperm(size(p1,<span class="hljs-number">2</span>));<span class="hljs-comment">%随机化</span>            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(p2,<span class="hljs-number">2</span>);                for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                    <span class="hljs-built_in">if</span> (j&lt;ran1 || j&gt;ran2) &amp;&amp; way(way1,j)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>p2(i)                        way(way1,j)<span class="hljs-built_in">=</span>p1(ran(i));                        break;                    end                end            end            <span class="hljs-comment">%查重与去重way2</span>            mark<span class="hljs-built_in">=</span>zeros([<span class="hljs-number">1</span>,city_n]);            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                mark(way(way2,i))<span class="hljs-built_in">=</span>mark(way(way2,i))+<span class="hljs-number">1</span>;            end            p1<span class="hljs-built_in">=</span>[];p2<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>                    p1(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">2</span>                    p2(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end            end            ran<span class="hljs-built_in">=</span>randperm(size(p1,<span class="hljs-number">2</span>));<span class="hljs-comment">%随机化</span>            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(p2,<span class="hljs-number">2</span>);                for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                    <span class="hljs-built_in">if</span> (j&lt;ran1 || j&gt;ran2) &amp;&amp; way(way2,j)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>p2(i)                        way(way2,j)<span class="hljs-built_in">=</span>p1(ran(i));                        break;                    end                end            end            <span class="hljs-comment">%</span>        end        <span class="hljs-comment">%变异1：交换两点</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.2</span>)            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            k<span class="hljs-built_in">=</span>way(way1,ran1);            way(way1,ran1)<span class="hljs-built_in">=</span>way(way1,ran2);            way(way1,ran2)<span class="hljs-built_in">=</span>k;            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            k<span class="hljs-built_in">=</span>way(way2,ran1);            way(way2,ran1)<span class="hljs-built_in">=</span>way(way2,ran2);            way(way2,ran2)<span class="hljs-built_in">=</span>k;        end        <span class="hljs-comment">%改动2</span>        <span class="hljs-comment">%变异2：路径翻折 能有效防止路径交叉、加速迭代出最优解的改动</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.2</span>) <span class="hljs-comment">%概率越大，迭代优解速度越快，但解微微变差</span>            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            way3<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n <span class="hljs-comment">%存储旋转</span>                way3(mod(i+ran1,city_n)+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>way(way1,i);            end            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            <span class="hljs-built_in">if</span>(ran1&gt;ran2)                 k<span class="hljs-built_in">=</span>ran1;                ran1<span class="hljs-built_in">=</span>ran2;                ran2<span class="hljs-built_in">=</span>k;            end            for i <span class="hljs-built_in">=</span> ran1 : (ran2+ran1)/<span class="hljs-number">2</span>;<span class="hljs-comment">%翻转</span>                k<span class="hljs-built_in">=</span>way3(i);                way3(i)<span class="hljs-built_in">=</span>way3(ran2+ran1-i);                way3(ran2+ran1-i)<span class="hljs-built_in">=</span>k;            end            way(way1,:)<span class="hljs-built_in">=</span>way3;        end         <span class="hljs-comment">%存储为下一代</span>        way0(l*<span class="hljs-number">2</span>-<span class="hljs-number">1</span>,:)<span class="hljs-built_in">=</span>way(way1,:);        way0(l*<span class="hljs-number">2</span>,:)<span class="hljs-built_in">=</span>way(way2,:);        ran <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,way_n]);         way0(ran,:)<span class="hljs-built_in">=</span>best_way; <span class="hljs-comment">%改动3 ：最显著的改动</span>    end    <span class="hljs-comment">%绘图</span>    figure(<span class="hljs-number">1</span>)    <span class="hljs-built_in">if</span> new<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">1</span>        new<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;        gox<span class="hljs-built_in">=</span>[];goy<span class="hljs-built_in">=</span>[];        for i<span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n            gox(i)<span class="hljs-built_in">=</span>xco(best_way(i));            goy(i)<span class="hljs-built_in">=</span>yco(best_way(i));        end        gox(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>xco(best_way(<span class="hljs-number">1</span>));        goy(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>yco(best_way(<span class="hljs-number">1</span>));        plot(gox,goy,<span class="hljs-string">&#x27;o--&#x27;</span>);        title(best_fit,best_dist);        drawnow;        <span class="hljs-comment">%pause(0);</span>    end    fit_time(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>best_fit;    dis_time(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>best_dist;endfigure(<span class="hljs-number">2</span>)plot(fit_time);figure(<span class="hljs-number">3</span>)plot(dis_time);clear ran d i j k l o mark new p1 p2 l q q_rand ran1 ran2 v way way0 way1 way2 ;clear dis gox goy xco yco;</code></pre></div><h1 id="结果说明">结果说明</h1><p><img src="https://s2.loli.net/2022/04/27/3wy2MexZS8fKHlA.png" /></p><p>评价：</p><ol type="1"><li>经过多次迭代检验，新的程序能在减少一个数量级的迭代次数情况下，每次都能得到一个近似的最优解（局部最优解），且其效率快，得到结果较优。</li><li>同时注意到其适应度迭代曲线，反应适应度（竞争优势度）并不能很好反应个体的优劣，猜想得验证。</li></ol><p><img src="https://s2.loli.net/2022/04/27/aFjB89XECsOKIG3.png" /></p><p>依然存在的问题：</p><p>经过手动多次迭代才找到了一个几乎是最优的解。根据迭代曲线可以看出解在前段已经收敛，且极难跳出当前解，而解的产生很大程度上取决于随机的初始化以及随机过程。为让解进一步迭代和增大单次运行找到最优解的可能性，应该引入更多可能的变异情况，而走出因为变异的单一性和局限性导致难以产生更优解的情况。</p><p>Ps：虽然我有想法，但是懒得改了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行商问题 </tag>
            
            <tag> TSP </tag>
            
            <tag> MATLAB </tag>
            
            <tag> 遗传算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程训练】登山问题 - 梯度上升法</title>
      <link href="/2022/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E7%99%BB%E5%B1%B1%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E7%99%BB%E5%B1%B1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>注意！此题目版权归本人指导老师卢鹏所有，禁止外传！</p>          </div><h1 id="问题描述">问题描述</h1><p>有一座小山，其表面方程可以用 <spanclass="math inline">\(z=1-x^2-2y^2\)</span> 底部为 <spanclass="math inline">\(xOy\)</span> ，记起点为 <spanclass="math inline">\(P(0.7,0.5,0.01)\)</span>，从该起点开始爬山，要求登山线路沿着梯度方向前进。试着研究一下从起点到顶点的登山曲线。</p><p>计算注意要点：</p><ol type="1"><li>每个具体位置的梯度方向并不完全相同，所以必须采用逐步迭代的方法登上山顶；</li><li>因为梯度有两个方向（x和y），所以不能简单取一个步长，合理的方式可以在梯度方向上取单位向量并乘以取定步长（参考值 0.01）来确定x和y方向上的变化；</li><li>判断登上山顶条件，可以取高度大于 0.9999即为登顶。（循环退出条件）；</li><li>函数的空间图形与空间登上曲线画在一个图形里面；</li><li>平面线路图形的意思是需要画出空间曲线在平面中的投影曲线以及函数的等高线。注：方法并不唯一，同学们也可以发挥想象完成此题！</li></ol><h1 id="结果展示">结果展示</h1><p><img src="https://s2.loli.net/2022/04/27/o1HkqYFcv76eKwD.png" /></p><h1 id="梯度上升法代码">梯度上升法代码</h1><p>对于相同的题型，仅需要修改下面三个function。</p><p>此外可以调整主函数的迭代参数。</p><p>[MATLAB] f.m 原函数</p><div class="hljs code-wrapper"><pre><code class="hljs m">function z <span class="hljs-built_in">=</span> f(x,y)    z<span class="hljs-built_in">=</span><span class="hljs-number">1</span>-x.*x-<span class="hljs-number">2</span>*y.*y;end</code></pre></div><p>[MATLAB] fx.m 偏导x</p><div class="hljs code-wrapper"><pre><code class="hljs m">function k <span class="hljs-built_in">=</span> fx(x,y)    k<span class="hljs-built_in">=</span>-<span class="hljs-number">2</span>*x;end</code></pre></div><p>[MATLAB] fy.m 偏导y</p><div class="hljs code-wrapper"><pre><code class="hljs m">function k <span class="hljs-built_in">=</span> fy(x,y)    k<span class="hljs-built_in">=</span>-<span class="hljs-number">4</span>*y;end</code></pre></div><p>[MATLAB] main.m 主程序</p><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%%开始绘图</span>clear;clc;x<span class="hljs-built_in">=</span>[-<span class="hljs-number">0.5</span>:<span class="hljs-number">0.005</span>:<span class="hljs-number">0.5</span>];y<span class="hljs-built_in">=</span>[-<span class="hljs-number">0.5</span>:<span class="hljs-number">0.005</span>:<span class="hljs-number">0.5</span>];[X,Y]<span class="hljs-built_in">=</span>meshgrid(x,y);<span class="hljs-comment">%Z=1-X.*X - 2*Y.*Y;</span>Z<span class="hljs-built_in">=</span>f(X,Y);<span class="hljs-comment">%%迭代和绘图</span>figure(<span class="hljs-number">1</span>);hold on;    subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);        mesh(X,Y,Z);<span class="hljs-comment">%绘制三维图</span>        xlabel(<span class="hljs-string">&#x27;X&#x27;</span>);ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>);zlabel(<span class="hljs-string">&#x27;Z&#x27;</span>);        hold on;        x0<span class="hljs-built_in">=</span><span class="hljs-number">0.1</span>;y0<span class="hljs-built_in">=</span><span class="hljs-number">0.5</span>; <span class="hljs-comment">%起始点</span>        z0<span class="hljs-built_in">=</span>f(x0,y0);        way_x<span class="hljs-built_in">=</span>[x0];way_y<span class="hljs-built_in">=</span>[y0];way_z<span class="hljs-built_in">=</span>[z0];        t<span class="hljs-built_in">=</span><span class="hljs-number">0.1</span>; <span class="hljs-comment">%步长：方向向量*t</span>        <span class="hljs-comment">%%开始迭代 梯度上升</span>        while z0&lt;<span class="hljs-number">0.999</span> &amp;&amp; t&gt;<span class="hljs-number">0.00001</span>             x1<span class="hljs-built_in">=</span>x0+fx(x0,y0)*t;<span class="hljs-comment">% fx为偏x</span>            y1<span class="hljs-built_in">=</span>y0+fy(x0,y0)*t; <span class="hljs-comment">%fy为偏y</span>            z1<span class="hljs-built_in">=</span>f(x1,y1);            <span class="hljs-built_in">if</span>(z1&gt;z0) <span class="hljs-comment">%防止步长过大</span>                x0<span class="hljs-built_in">=</span>x1;                y0<span class="hljs-built_in">=</span>y1;                z0<span class="hljs-built_in">=</span>z1;                way_x(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>x0; <span class="hljs-comment">%记录迭代路径</span>                way_y(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>y0;                way_z(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>z0;            <span class="hljs-built_in">else</span>                t<span class="hljs-built_in">=</span>t*<span class="hljs-number">0.1</span>; <span class="hljs-comment">%步长过大，“降温”</span>            end        end        <span class="hljs-comment">%%开始绘图</span>        plot3(way_x,way_y,way_z,<span class="hljs-string">&#x27;-o&#x27;</span>,<span class="hljs-string">&#x27;Color&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;MarkerSize&#x27;</span>,<span class="hljs-number">10</span>,...,        <span class="hljs-string">&#x27;MarkerFaceColor&#x27;</span>,<span class="hljs-string">&#x27;#D9FFFF&#x27;</span>);<span class="hljs-comment">% 绘制迭代点        </span>        camorbit(<span class="hljs-number">180</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;data&#x27;</span>,[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>])<span class="hljs-comment">% 转180度方便看</span>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">%三维等高线和迭代图</span>    contour3(X,Y,Z,<span class="hljs-number">20</span>);        hold on;        plot3(way_x,way_y,way_z,<span class="hljs-string">&#x27;*--&#x27;</span>)        camorbit(<span class="hljs-number">180</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;data&#x27;</span>,[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>]) <span class="hljs-comment">% 转180度方便看</span>     subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">%平面等高线和迭代图</span>        contour(X,Y,Z,<span class="hljs-number">20</span>);        hold on;        plot3(way_x,way_y,way_z,<span class="hljs-string">&#x27;o--&#x27;</span>)        camorbit(<span class="hljs-number">180</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;data&#x27;</span>,[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>]) <span class="hljs-comment">% 转180度方便看</span>hold off;</code></pre></div><h1 id="补充">补充</h1><p>梯度下降法是一种“显而易见”的方法，其思维复合常理没有太多难度所以在这里不对该方法进行详细叙述。</p><p>基于梯度下降法和其思想诞生了很多行之有效的方法，例如动量梯度下降法、自适应梯度算法等改进算法，这种改进思想可以在很多算法上得到运用。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 梯度上升 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022—蓝桥杯C++A组复盘</title>
      <link href="/2022/04/27/16%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
      <url>/2022/04/27/16%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="链接">链接</h1><div class="note note-info">            <p><ahref="http://oj.ecustacm.cn/viewnews.php?id=1021"><b>补题传送门</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/fzl194/article/details/124347039"><b>参考的博客</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><p>非常失败的一次比赛……</p><h2 id="a---裁纸刀">A - 裁纸刀 √</h2><p>题意： 一张纸上打印了20 2020行22 2222列共440440440个二维码，至少需要裁多少次可以全部裁出。如下图，2 22行333列共需要裁9 99次。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> f[maxn][maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    n=<span class="hljs-number">22</span>;<span class="hljs-comment">//=read();</span>    m=<span class="hljs-number">20</span>;<span class="hljs-comment">//=read();</span>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)            f[i][j]=<span class="hljs-number">0x3f3f3f3f</span>;    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-built_in">FOR</span>(k1,<span class="hljs-number">0</span>,i)                <span class="hljs-built_in">FOR</span>(k2,<span class="hljs-number">0</span>,j)&#123;                    f[i][j]=<span class="hljs-built_in">min</span>((k1==<span class="hljs-number">0</span>||k1==i?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>)+(k2==<span class="hljs-number">0</span>||k2==j?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>)+(k1!=<span class="hljs-number">0</span>&amp;&amp;k1!=i&amp;&amp;k2!=<span class="hljs-number">0</span>&amp;&amp;k2!=j?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>)                    +f[k1][k2]+f[i-k1][k2]+f[k1][j-k2]+f[i-k1][j-k2],f[i][j]);                &#125;            <span class="hljs-comment">//cout&lt;&lt;f[i][j]&lt;&lt;&quot; &quot;;</span>        &#125;        <span class="hljs-comment">//cout&lt;&lt;endl;</span>    &#125;    cout&lt;&lt;f[n][m]+<span class="hljs-number">4</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="b---灭鼠先锋-x">B - 灭鼠先锋 x</h2><p>题意： 在2 22行4 44列的棋盘中，两人轮流操作，每次可选择在空位上放置111个棋子，或者在同一行连续的两个空位上放置棋子。最后使得棋盘放满的人输掉。</p><p>先手存在4 44种初始局面如下所示，O OO表示空，XXX表示已放置。每人均以最优策略放棋子。判断先手胜利（输出VVV）还是后手胜利（输出L LL）。</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">XOOO XXOO OXOO OXXO</span><span class="hljs-attribute">OOOO OOOO OOOO OOOO</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">///判断是否仅存在一个空格</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string s)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : s)<span class="hljs-keyword">if</span>(x == <span class="hljs-string">&#x27;O&#x27;</span>)        tot++;    <span class="hljs-keyword">return</span> tot == <span class="hljs-number">1</span>;&#125;map&lt;string, <span class="hljs-keyword">bool</span>&gt;SG;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(SG.<span class="hljs-built_in">count</span>(s))        <span class="hljs-keyword">return</span> SG[s];    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(s))        <span class="hljs-keyword">return</span> SG[s] = <span class="hljs-literal">false</span>;    <span class="hljs-comment">///模拟放1个棋子</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;O&#x27;</span>)    &#123;        string tmp = s;        tmp[i] = <span class="hljs-string">&#x27;X&#x27;</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(tmp) == <span class="hljs-literal">false</span>)<span class="hljs-comment">///可以到达必败态均为必胜态</span>            <span class="hljs-keyword">return</span> SG[s] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">///模拟放2个棋子</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; i != <span class="hljs-number">3</span>)    &#123;        string tmp = s;        tmp[i] = tmp[i + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;X&#x27;</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(tmp) == <span class="hljs-literal">false</span>)<span class="hljs-comment">///可以到达必败态均为必胜态</span>            <span class="hljs-keyword">return</span> SG[s] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">///运行到此，说明只能转移到必胜态，此时为必败态</span>    <span class="hljs-keyword">return</span> SG[s] = <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string s[] = &#123;<span class="hljs-string">&quot;XOOOOOOO&quot;</span>, <span class="hljs-string">&quot;XXOOOOOO&quot;</span>, <span class="hljs-string">&quot;OXOOOOOO&quot;</span>, <span class="hljs-string">&quot;OXXOOOOO&quot;</span>&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(s[i]))cout&lt;&lt;<span class="hljs-string">&quot;L&quot;</span>;<span class="hljs-comment">///此时为必胜态，说明后手面临的局面必胜，输出L</span>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;V&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="c---求和-x-30">C - 求和 x 30%</h2><p>题意：给定数组 <span class="math inline">\(a\)</span> ，求 <spanclass="math inline">\(\sum_{i=1}^n\sum_{j=i+1}^n\)</span>。</p><p>我的：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span>+<span class="hljs-number">100</span>;<span class="hljs-comment">//const int maxm = 4e5+100;</span><span class="hljs-keyword">int</span> a[maxn],num[maxn]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    cin&gt;&gt;n;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        a[i]=<span class="hljs-built_in">read</span>();        num[i]=num[i<span class="hljs-number">-1</span>]+a[i];    &#125;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        ans+=a[i]*num[i<span class="hljs-number">-1</span>];    &#125;    cout&lt;&lt;ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;ll a[maxn], sum[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    ll ans = <span class="hljs-number">0</span>;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">///预处理前缀和</span>        cin &gt;&gt; a[i], sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">///求和即可</span>        ans += a[i] * (sum[n] - sum[i]);    cout&lt;&lt;ans&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="d---选数异或-x-40">D - 选数异或 x 40%</h2><p>题意： 给定数组 <span class="math inline">\(a\)</span> 和整数 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(m\)</span>次询问，每次询问区间 <span class="math inline">\([l,r]\)</span>是否存在两个数字使得异或值等于 <spanclass="math inline">\(x\)</span>。</p><p>我的暴力：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//const int maxm = 4e5+100;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m,x;    n=<span class="hljs-built_in">read</span>();    m=<span class="hljs-built_in">read</span>();    x=<span class="hljs-built_in">read</span>();    <span class="hljs-comment">//±©Á¦</span>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1000</span>)&#123;        <span class="hljs-keyword">int</span> a[<span class="hljs-number">1020</span>];        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)            a[i]=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">int</span> l,r;        <span class="hljs-keyword">while</span>(m--)&#123;            <span class="hljs-keyword">int</span> f=<span class="hljs-number">0</span>;            l=<span class="hljs-built_in">read</span>();            r=<span class="hljs-built_in">read</span>();            <span class="hljs-built_in">FOR</span>(i,l,r)&#123;                <span class="hljs-built_in">FOR</span>(j,i+<span class="hljs-number">1</span>,r)&#123;                    <span class="hljs-keyword">if</span>((a[i]^a[j])==x)&#123;                        f=<span class="hljs-number">1</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(f)                    <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(f)                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);            <span class="hljs-keyword">else</span>                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100000</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> tree[maxn &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> Left[maxn], pos[(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>) + <span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> a[maxn], n, m, x;<span class="hljs-comment">//线段树模板</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l == r)    &#123;        tree[o] = Left[l];        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid);    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);    tree[o] = <span class="hljs-built_in">max</span>(tree[o &lt;&lt; <span class="hljs-number">1</span>], tree[o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)<span class="hljs-keyword">return</span> tree[o];    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(L &lt;= mid)ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R));    <span class="hljs-keyword">if</span>(R &gt; mid)ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R));    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//预处理Left数组</span>    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);        Left[i] = pos[a[i] ^ x];        pos[a[i]] = i;    &#125;    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<span class="hljs-comment">//线段树建树</span>    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-keyword">int</span> l, r;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) &gt;= l)<span class="hljs-comment">//查询区间最值</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="e---爬树的甲壳虫-x">E - 爬树的甲壳虫 x</h2><p>题意： 甲壳虫想要爬上高度为 <span class="math inline">\(n\)</span>的树，开始位于树根，高度为 0，当它尝试从高度 <spanclass="math inline">\(i-1\)</span> 爬到高度为 <spanclass="math inline">\(i\)</span> 的位置时有 <spanclass="math inline">\(P_i\)</span>的概率会掉回树根，求它从树根爬到树顶时，经过的时间的期望值是多少。</p><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">998244353</span>;ll x[maxn], y[maxn];<span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll a, ll b, ll m)</span></span><span class="hljs-function"></span>&#123;    ll ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(b)    &#123;        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)ans = ans * a % m;        b &gt;&gt;= <span class="hljs-number">1</span>;        a = a * a % m;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ksm</span>(x, MOD - <span class="hljs-number">2</span>, MOD);&#125;<span class="hljs-function">ll <span class="hljs-title">extgcd</span><span class="hljs-params">(ll a, ll b, ll&amp;x, ll&amp;y)</span><span class="hljs-comment">//ax+by = gcd(a, b)的解。返回值为gcd</span></span><span class="hljs-function"></span>&#123;    ll d = a;    <span class="hljs-keyword">if</span>(b)    &#123;       d = <span class="hljs-built_in">extgcd</span>(b, a % b, y, x);       y -= (a / b) * x;    &#125;    <span class="hljs-keyword">else</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; x[i] &gt;&gt; y[i];        ll g = __gcd(x[i], y[i]);        x[i] = x[i] / g;        y[i] = y[i] / g;    &#125;    ll a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--)    &#123;        ll p = x[i] * <span class="hljs-built_in">inv</span>(y[i]) % MOD, p_1 = (y[i] - x[i]) * <span class="hljs-built_in">inv</span>(y[i]) % MOD;        a = (p + p_1 * a) % MOD;        b = (<span class="hljs-number">1</span> + p_1 * b) % MOD;    &#125;    <span class="hljs-comment">///cout&lt;&lt;x[1]&lt;&lt;&quot; &quot;&lt;&lt;y[1]&lt;&lt;&quot; &quot;&lt;&lt;inv(y[1])&lt;&lt;endl;</span>    <span class="hljs-comment">///dp[0] = a * dp[0] + b</span>    <span class="hljs-comment">///(a-1)dp[0]+k * MOD = MOD - b</span>    <span class="hljs-comment">///(a - 1)x + MOD * y = MOD - b</span>    <span class="hljs-comment">///cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span>    ll c = a - <span class="hljs-number">1</span>, d = MOD, x, y;    ll g = <span class="hljs-built_in">extgcd</span>(c, d, x, y);    <span class="hljs-comment">///cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span>    ll x1 = x * (MOD - b) / g;    ll y1 = y * (MOD - b) / g;    cout&lt;&lt;(x1 % MOD + MOD ) % MOD&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="f---青蛙过河-x-10">F - 青蛙过河 x 10%</h2><p>题意：小青蛙住在一条河边，它想到河对岸的学校去学习。小青蛙打算经过河里的石头跳到对岸。河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。不过，每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就会下降1，当石头的高度下降到0 时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 0是允许的）。</p><p>小青蛙一共需要去学校上x天课，所以它需要往返2x次。当小青蛙具有一个跳跃能力y时，它能跳不超过y的距离。请问小青蛙的跳跃能力至少是多少才能用这些石头上完x次课。</p><p>我的：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//const int maxm = 4e5+100;</span><span class="hljs-keyword">int</span> n,x;<span class="hljs-keyword">int</span> h[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q)</span></span>&#123;    <span class="hljs-keyword">int</span> f[maxn];    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//=h[0];</span>    f[<span class="hljs-number">0</span>]=h[<span class="hljs-number">0</span>];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        num+=f[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(i-q<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)            num-=f[i-q<span class="hljs-number">-1</span>];        <span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;num&lt;&lt;endl;</span>        f[i]=<span class="hljs-built_in">min</span>(num,h[i]);    &#125;    <span class="hljs-comment">// cout&lt;&lt;q&lt;&lt;&quot;:&quot;;</span>    <span class="hljs-comment">// FOR(i,1,n)</span>    <span class="hljs-comment">//     cout&lt;&lt;f[i]&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">// cout&lt;&lt;endl;</span>    <span class="hljs-keyword">if</span>(f[n]&gt;=x)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=n;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span>(l&lt;r)&#123;        mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;            r=mid;        &#125;<span class="hljs-keyword">else</span>&#123;            l=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//cout&lt;&lt;l&lt;&lt;&quot;-&quot;&lt;&lt;r&lt;&lt;endl;</span>    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    n=<span class="hljs-built_in">read</span>();    x=<span class="hljs-built_in">read</span>();    x*=<span class="hljs-number">2</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)        h[i]=<span class="hljs-built_in">read</span>();    h[<span class="hljs-number">0</span>]=h[n]=<span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-built_in">solve</span>();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x * w;&#125;<span class="hljs-keyword">int</span> h[maxn], sum[maxn];<span class="hljs-keyword">int</span> n, x;<span class="hljs-comment">//判断所有长度为mid的区间之和是否大于等于2x</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mid)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + mid - <span class="hljs-number">1</span> &lt;= n; i++)        <span class="hljs-keyword">if</span>(sum[i + mid - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">2</span> * x)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">read</span>(n); <span class="hljs-built_in">read</span>(x);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; i++)<span class="hljs-comment">//预处理前缀和</span>        <span class="hljs-built_in">read</span>(h[i]), sum[i] = sum[i - <span class="hljs-number">1</span>] + h[i];    sum[n] = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = n, ans = n;    <span class="hljs-keyword">while</span>(left &lt;= right)<span class="hljs-comment">//二分答案</span>    &#123;        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))            ans = mid, right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//求最小合法解</span>        <span class="hljs-keyword">else</span>            left = mid + <span class="hljs-number">1</span>;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="g---最长不下降子序列-x-30">G - 最长不下降子序列 x 30%</h2><p>题意：给定数组a，可以修改连续的K个数字变成一个相同值。请计算修改后的最长不下降子序列长度。</p><p>我的：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<span class="hljs-comment">//const int maxm = 4e5+100;</span><span class="hljs-keyword">int</span> n,q;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-keyword">int</span> b[maxn];<span class="hljs-keyword">int</span> d[maxn];<span class="hljs-keyword">int</span> l[maxn];<span class="hljs-keyword">int</span> len;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    d[<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>];    l[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span> (a[i]&gt;=d[len])&#123;  <span class="hljs-comment">//如果可以接在len后面就接上，如果是最长上升子序列，这里变成&gt; </span>            d[++len]=a[i];            l[i]=len;        &#125;         <span class="hljs-keyword">else</span>  <span class="hljs-comment">//否则就找一个最该替换的替换掉 </span>        &#123;            <span class="hljs-keyword">int</span> j=<span class="hljs-built_in">upper_bound</span>(d+<span class="hljs-number">1</span>,d+len+<span class="hljs-number">1</span>,a[i])-d;  <span class="hljs-comment">//找到第一个大于它的d的下标，如果是最长上升子序列，这里变成lower_bound </span>            d[j]=a[i];             l[i]=j;        &#125;    &#125;    <span class="hljs-comment">//printf(&quot;%d\n&quot;,len);  </span>    <span class="hljs-comment">// FOR(i,1,n)</span>    <span class="hljs-comment">//     cout&lt;&lt;l[i]&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">// cout&lt;&lt;endl;</span>&#125;<span class="hljs-keyword">int</span> l1[maxn],l2[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-built_in">solve</span>();    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        l1[i]=l[i];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        b[i]=<span class="hljs-number">1e6</span>-a[<span class="hljs-number">1</span>+n-i];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        a[i]=b[i];    <span class="hljs-built_in">solve</span>();    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        l2[i]=l[<span class="hljs-number">1</span>+n-i];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        b[i]=<span class="hljs-number">1e6</span>-a[<span class="hljs-number">1</span>+n-i];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        a[i]=b[i];    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    l1[<span class="hljs-number">0</span>]=l2[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    a[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    a[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-keyword">if</span>(i+q&gt;n+<span class="hljs-number">1</span>)            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>(a[i+q]&gt;=a[i<span class="hljs-number">-1</span>])            ans=<span class="hljs-built_in">max</span>(ans,l1[i<span class="hljs-number">-1</span>]+l2[i+q]+q);    &#125;    cout&lt;&lt;ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">6 1</span><span class="hljs-comment">1 1 5 4 6 1</span><span class="hljs-comment">*/</span></code></pre></div><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x * w;&#125;<span class="hljs-keyword">int</span> a[maxn], b[maxn];<span class="hljs-keyword">int</span> dp[maxn];<span class="hljs-comment">///dp[i]表示以i结尾的最长上升子序列</span><span class="hljs-comment">///权值线段树，维护dp数组</span><span class="hljs-keyword">int</span> tree[maxn &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    tree[o] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l == r)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid);    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l == r)    &#123;        tree[o] = <span class="hljs-built_in">max</span>(tree[o], val);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x &lt;= mid)<span class="hljs-built_in">update</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, val);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, val);    tree[o] = <span class="hljs-built_in">max</span>(tree[o &lt;&lt; <span class="hljs-number">1</span>], tree[o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)        <span class="hljs-keyword">return</span> tree[o];    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(L &lt;= mid)ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R));    <span class="hljs-keyword">if</span>(R &gt; mid)ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R));    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n, k, tot = <span class="hljs-number">0</span>;    <span class="hljs-built_in">read</span>(n); <span class="hljs-built_in">read</span>(k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-built_in">read</span>(a[i]), b[++tot] = a[i];    <span class="hljs-keyword">if</span>(n == k)    &#123;        cout&lt;&lt;n&lt;&lt;endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">///离散化</span>    <span class="hljs-built_in">sort</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + tot);    tot = <span class="hljs-built_in">unique</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + tot) - (b + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        a[i] = <span class="hljs-built_in">lower_bound</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + tot, a[i]) - b;        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot);    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">///从前往后遍历a，放入权值线段树中</span>    &#123;        <span class="hljs-comment">///dp[i] = max(dp[j]) 满足j=1...i-1 &amp;&amp; a[j] &lt;= a[i]</span>        dp[i] = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, <span class="hljs-number">1</span>, a[i]) + <span class="hljs-number">1</span>;        <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, a[i], dp[i]);    &#125;    <span class="hljs-comment">///重新清空</span>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt; k; i--)<span class="hljs-comment">///从后往前遍历a，放入权值线段树中</span>    &#123;        <span class="hljs-comment">///a[i-k+1] ... a[i]相等 均等于a[i-k]</span>        <span class="hljs-comment">///最后一段要注意：查询的是[a[i-k],tot]中的最大值</span>        ans = <span class="hljs-built_in">max</span>(ans, dp[i - k] + k - <span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, a[i - k], tot) + <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, a[i], tot) + <span class="hljs-number">1</span>; <span class="hljs-comment">///以a[i]开始的最长上升子序列长度</span>        ans = <span class="hljs-built_in">max</span>(ans, tmp + k);        <span class="hljs-comment">///插入的是a[i]</span>        <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, a[i], tmp);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="h---扫描游戏">H - 扫描游戏</h2><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x = x * w;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    ll x, y, z;    <span class="hljs-keyword">int</span> id;&#125;a[maxn];ll n;__int128 L;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Quadrant</span><span class="hljs-params">(point a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a.x &gt;= <span class="hljs-number">0</span> &amp;&amp; a.y &gt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">///y的正半轴放到第一象限</span>    <span class="hljs-keyword">if</span>(a.x &gt; <span class="hljs-number">0</span> &amp;&amp; a.y &lt;= <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">///x的正半轴放到第二象限</span>    <span class="hljs-keyword">if</span>(a.x &lt;= <span class="hljs-number">0</span> &amp;&amp; a.y &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">cross</span><span class="hljs-params">(point a, point b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(point a, point b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Quadrant</span>(a) == <span class="hljs-built_in">Quadrant</span>(b))    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cross</span>(a, b) == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> a.x * a.x + a.y * a.y &lt; b.x * b.x + b.y * b.y;        <span class="hljs-keyword">else</span>           <span class="hljs-keyword">return</span> <span class="hljs-built_in">cross</span>(a, b) &lt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Quadrant</span>(a) &lt; <span class="hljs-built_in">Quadrant</span>(b);&#125;__int128 mi[maxn &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span><span class="hljs-function"></span>&#123;    mi[o] = <span class="hljs-built_in">min</span>(mi[o &lt;&lt; <span class="hljs-number">1</span>], mi[o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l == r)    &#123;        mi[o] = a[l].x * a[l].x + a[l].y * a[l].y;        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid);    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);    <span class="hljs-built_in">push_up</span>(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> x, __int128 val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l == r)    &#123;        mi[o] = val;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x &lt;= mid)<span class="hljs-built_in">update</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, val);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, val);    <span class="hljs-built_in">push_up</span>(o);&#125;<span class="hljs-comment">///找右边第一个小于等于z^2的数字</span>ll idx;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, __int128 z)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(L &gt; R)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(l == r)    &#123;        idx = l;        <span class="hljs-keyword">return</span> mi[o] &lt;= z;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L &lt;= mid)    &#123;        <span class="hljs-keyword">if</span>((mi[o &lt;&lt; <span class="hljs-number">1</span>] &lt;= z) &amp;&amp; <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, z))            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span>(R &gt; mid)    &#123;        <span class="hljs-keyword">if</span>((mi[o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] &lt;= z) &amp;&amp; <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, z))            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">read</span>(n);<span class="hljs-built_in">read</span>(L);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        <span class="hljs-built_in">read</span>(a[i].x);<span class="hljs-built_in">read</span>(a[i].y);<span class="hljs-built_in">read</span>(a[i].z);        a[i].id = i;        ans[i] = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n, cmp);    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> lastcnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;  <span class="hljs-comment">///上一个位置</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)    &#123;        <span class="hljs-keyword">bool</span> ok = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, last + <span class="hljs-number">1</span>, n, L * L);        <span class="hljs-keyword">if</span>(ok)L = L + a[idx].z;        <span class="hljs-keyword">else</span>        &#123;            ok = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, last - <span class="hljs-number">1</span>, L * L);            <span class="hljs-keyword">if</span>(ok)L = L + a[idx].z;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx, <span class="hljs-number">1e32</span>);        <span class="hljs-keyword">if</span>(last)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Quadrant</span>(a[last]) == <span class="hljs-built_in">Quadrant</span>(a[idx]) &amp;&amp; <span class="hljs-built_in">cross</span>(a[last], a[idx]) == <span class="hljs-number">0</span>)                ans[a[idx].id] = lastcnt, ++cnt;            <span class="hljs-keyword">else</span>                ans[a[idx].id] = ++cnt, lastcnt = cnt;        &#125;        <span class="hljs-keyword">else</span>            ans[a[idx].id] = ++cnt, lastcnt = cnt;        last = idx;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        cout&lt;&lt;ans[i];        <span class="hljs-keyword">if</span>(i != n)cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="i---数的拆分">I - 数的拆分</h2><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x * w;&#125;<span class="hljs-keyword">bool</span> not_prime[<span class="hljs-number">4010</span>];<span class="hljs-keyword">int</span> prime[<span class="hljs-number">4010</span>], tot;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<span class="hljs-keyword">if</span>(!not_prime[i])    &#123;        prime[++tot] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + i; j &lt;= n; j += i)            not_prime[j] = <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">///检查平方数</span>    ll y = <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">0.5</span>);    <span class="hljs-keyword">if</span>(y * y == x || (y + <span class="hljs-number">1</span>) * (y + <span class="hljs-number">1</span>) == x)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">///检查立方数</span>    y = <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">1.0</span> / <span class="hljs-number">3</span>);    <span class="hljs-keyword">if</span>(y * y * y == x || (y + <span class="hljs-number">1</span>) * (y + <span class="hljs-number">1</span>) * (y + <span class="hljs-number">1</span>) == x || (y + <span class="hljs-number">2</span>) * (y + <span class="hljs-number">2</span>) * (y + <span class="hljs-number">2</span>) == x)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">init</span>(<span class="hljs-number">4000</span>);    <span class="hljs-keyword">int</span> T;    <span class="hljs-built_in">read</span>(T);    <span class="hljs-keyword">while</span>(T--)    &#123;        ll x;        <span class="hljs-built_in">read</span>(x);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(x))        &#123;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;yes&quot;</span>);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++)<span class="hljs-keyword">if</span>(x % prime[i] == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(x % prime[i] == <span class="hljs-number">0</span>)            &#123;                now++;                x /= prime[i] ;            &#125;            <span class="hljs-comment">///cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;endl;</span>            <span class="hljs-keyword">if</span>(now == <span class="hljs-number">1</span>)            &#123;                flag = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag &amp; <span class="hljs-built_in">check</span>(x))        &#123;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;yes&quot;</span>);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;no&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="j---推导部分和-x-10">J - 推导部分和 x 10%</h2><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x = x * w;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> ll INF = <span class="hljs-number">-1e13</span>;<span class="hljs-keyword">int</span> n, m, q;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> v; ll w;    <span class="hljs-built_in">edge</span>()&#123;&#125;    <span class="hljs-built_in">edge</span>(<span class="hljs-keyword">int</span> v, ll w):<span class="hljs-built_in">v</span>(v), <span class="hljs-built_in">w</span>(w)&#123;&#125;&#125;;vector&lt;edge&gt;Map[maxn];ll sum[maxn];<span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, ll d)</span></span><span class="hljs-function"></span>&#123;    vis[u] = <span class="hljs-number">1</span>;    sum[u] = d;    <span class="hljs-comment">///cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : Map[u])    &#123;        <span class="hljs-keyword">int</span> v = x.v; ll w = x.w;        <span class="hljs-keyword">if</span>(vis[v])<span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs</span>(v, d + w);    &#125;&#125;queue&lt;pair&lt;<span class="hljs-keyword">int</span>,ll&gt; &gt;Q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, ll d)</span></span><span class="hljs-function"></span>&#123;    vis[u] = <span class="hljs-number">1</span>;    sum[u] = d;    Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(u, d));    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())    &#123;        <span class="hljs-keyword">auto</span> now = Q.<span class="hljs-built_in">front</span>();        Q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">int</span> u = now.first; ll d = now.second;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : Map[u])        &#123;            <span class="hljs-keyword">int</span> v = x.v; ll w = x.w;            <span class="hljs-keyword">if</span>(vis[v])<span class="hljs-keyword">continue</span>;            vis[v] = <span class="hljs-number">1</span>;            sum[v] = d + w;            Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(v, d + w));        &#125;    &#125;&#125;<span class="hljs-keyword">int</span> f[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x == f[x] ? x : f[x] = <span class="hljs-built_in">Find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">read</span>(n);<span class="hljs-built_in">read</span>(m);<span class="hljs-built_in">read</span>(q);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)f[i] = i;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)    &#123;        <span class="hljs-keyword">int</span> l, r; ll s;        <span class="hljs-built_in">read</span>(l);<span class="hljs-built_in">read</span>(r);<span class="hljs-built_in">read</span>(s);        <span class="hljs-comment">///cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;endl;</span>        <span class="hljs-comment">///sum[r] - sum[l - 1] = s</span>        Map[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(r, s));        Map[r].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(l - <span class="hljs-number">1</span>, -s));        f[<span class="hljs-built_in">Find</span>(l - <span class="hljs-number">1</span>)] = <span class="hljs-built_in">Find</span>(r);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<span class="hljs-keyword">if</span>(!vis[i])        <span class="hljs-built_in">bfs</span>(i, <span class="hljs-number">0</span>);    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-keyword">int</span> l, r;        <span class="hljs-built_in">read</span>(l), <span class="hljs-built_in">read</span>(r);        --l;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Find</span>(l) != <span class="hljs-built_in">Find</span>(r))<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;UNKNOWN&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum[r] - sum[l]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022—GPLT程序设计天梯赛复盘</title>
      <link href="/2022/04/27/17%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
      <url>/2022/04/27/17%E5%A4%A9%E6%A2%AF%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>注：本文1-4题因为没有保存源码，使用的是下述参考博客的代码，其他代码均为本人比赛场上的ac代码。</p>          </div><h1 id="链接">链接</h1><div class="note note-info">            <p><a href="https://gplt.patest.cn/rank/student"><b>比赛官网</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/m0_46381590/article/details/124368368"><b>参考的博客</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><figure><img src="https://pic.imgdb.cn/item/6268dde3239250f7c5634740.png"alt="最终成绩" /><figcaption aria-hidden="true">最终成绩</figcaption></figure><h2 id="l1-1-今天我要赢-5-分">L1-1 今天我要赢 (5 分)</h2><p><strong>题目大意：</strong> 2018 年我们曾经出过一题，是输出“2018我们要赢”。今年是 2022年，你要输出的句子变成了“我要赢！就在今天！”然后以比赛当天的日期落款。</p><p>输入格式：</p><p>本题没有输入。</p><p>输出格式：</p><p>输出分 2 行。在第一行中输出 I’m gonna win! Today!，在第二行中用年年年年-月月-日日 的格式输出比赛当天的日期。已知比赛的前一天是2022-04-22。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs">无</code></pre></div><p>输出样例（第二行的内容要你自己想一想，这里不给出）：</p><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">I’m gonna win! Today!</code></pre></div><p>这一行的内容我不告诉你…… 你要自己输出正确的日期呀~</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m gonna win! Today!&quot;</span>&lt;&lt;endl; cout&lt;&lt;<span class="hljs-string">&quot;2022-04-23&quot;</span>;&#125; </code></pre></div><h2 id="l1-2-种钻石-5-分">L1-2 种钻石 (5 分)</h2><p>2019年10月29日，中央电视台专题报道，中国科学院在培育钻石领域，取得科技突破。科学家们用金刚石的籽晶片作为种子，利用甲烷气体在能量作用下形成碳的等离子体，慢慢地沉积到钻石种子上，一周“种”出了一颗1 克拉大小的钻石。</p><p>本题给出钻石的需求量和人工培育钻石的速度，请你计算出货需要的时间。</p><p>输入格式：</p><p>输入在一行中给出钻石的需求量 N（不超过 107的正整数，以微克拉为单位）和人工培育钻石的速度v（1≤v≤200，以微克拉/天为单位的整数）。</p><p>输出格式：</p><p>在一行中输出培育 N微克拉钻石需要的整数天数。不到一天的时间不算在内。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">102000 </span><span class="hljs-number">130</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs">784</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> n,m; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;n/m;&#125;</code></pre></div><h2 id="l1-3-谁能进图书馆-10-分">L1-3 谁能进图书馆 (10 分)</h2><p>为了保障安静的阅读环境，有些公共图书馆对儿童入馆做出了限制。例如“12岁以下儿童禁止入馆，除非有 18 岁以上（包括 18岁）的成人陪同”。现在有两位小/大朋友跑来问你，他们能不能进去？请你写个程序自动给他们一个回复。</p><p>输入格式：</p><p>输入在一行中给出 4 个整数：</p><p>禁入年龄线 陪同年龄线 询问者1的年龄 询问者2的年龄</p><p>这里的禁入年龄线是指严格小于该年龄的儿童禁止入馆；陪同年龄线是指大于等于该年龄的人士可以陪同儿童入馆。默认两个询问者的编号依次分别为1 和 2；年龄和年龄线都是 [1, 200] 区间内的整数，并且保证 陪同年龄线严格大于 禁入年龄线。</p><p>输出格式：</p><p>在一行中输出对两位询问者的回答，如果可以进就输出 年龄-Y，否则输出年龄-N，中间空 1 格，行首尾不得有多余空格。</p><p>在第二行根据两个询问者的情况输出一句话：</p><ul><li><p>如果两个人必须一起进，则输出 qing X zhao gu hao Y，其中 X是陪同人的编号， Y 是小孩子的编号；</p></li><li><p>如果两个人都可以进但不是必须一起的，则输出 huan ying ruguan；</p></li><li><p>如果两个人都进不去，则输出 zhang da zai lai ba；</p></li><li><p>如果一个人能进一个不能，则输出 X: huan ying ru guan，其中 X是可以入馆的那个人的编号。</p></li></ul><p>输入样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">18</span> <span class="hljs-number">18</span> <span class="hljs-number">8</span></code></pre></div><p>输出样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">18</span>-Y <span class="hljs-number">8</span>-Y<span class="hljs-attribute">qing</span> <span class="hljs-number">1</span> zhao gu hao <span class="hljs-number">2</span></code></pre></div><p>输入样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">18</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span></code></pre></div><p>输出样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">10</span>-N <span class="hljs-number">15</span>-Y<span class="hljs-attribute">2</span>: huan ying ru guan</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> a,b,c,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; <span class="hljs-keyword">int</span> x,y; <span class="hljs-keyword">if</span>(c&lt;a)&#123;  <span class="hljs-keyword">if</span>(d&lt;a)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-N &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-N&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;zhang da zai lai ba&quot;</span>&lt;&lt;endl;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;=a&amp;&amp;d&lt;b)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-N &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;2: huan ying ru guan&quot;</span>;  &#125;  <span class="hljs-keyword">else</span>&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;qing 2 zhao gu hao 1&quot;</span>;  &#125; &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c&gt;=b)&#123;  <span class="hljs-keyword">if</span>(d&lt;a)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;qing 1 zhao gu hao 2&quot;</span>;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;=a)&#123;        cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;        cout&lt;&lt;<span class="hljs-string">&quot;huan ying ru guan&quot;</span>;  &#125; &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-keyword">if</span>(d&lt;a)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-N&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;1: huan ying ru guan&quot;</span>;  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;=a)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;       cout&lt;&lt;<span class="hljs-string">&quot;huan ying ru guan&quot;</span>;  &#125; &#125;&#125;</code></pre></div><h2 id="l1-4-拯救外星人-10-分">L1-4 拯救外星人 (10 分)</h2><p>你的外星人朋友不认得地球上的加减乘除符号，但是会算阶乘 —— 正整数 N的阶乘记为 “N!”，是从 1 到 N的连乘积。所以当他不知道“5+7”等于多少时，如果你告诉他等于“12!”，他就写出了“479001600”这个答案。</p><p>本题就请你写程序模仿外星人的行为。</p><p>输入格式：</p><p>输入在一行中给出两个正整数 A 和 B。</p><p>输出格式：</p><p>在一行中输出 (A+B) 的阶乘。题目保证 (A+B) 的值小于 12。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">6</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs">362880</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,i,j,k,s=<span class="hljs-number">1</span>,m; cin&gt;&gt;m&gt;&gt;n; <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n+m;i++) s*=i; cout&lt;&lt;s;&#125;</code></pre></div><h2 id="l1-5-试试手气-15-分">L1-5 试试手气 (15 分)</h2><p>我们知道一个骰子有 6 个面，分别刻了 1 到 6 个点。下面给你 6个骰子的初始状态，即它们朝上一面的点数，让你一把抓起摇出另一套结果。假设你摇骰子的手段特别精妙，每次摇出的结果都满足以下两个条件：</p><ol type="1"><li>每个骰子摇出的点数都跟它之前任何一次出现的点数不同；</li><li>在满足条件 1 的前提下，每次都能让每个骰子得到可能得到的最大点数。那么你应该可以预知自己第 n 次（1≤n≤5）摇出的结果。 输入格式：输入第一行给出 6 个骰子的初始点数，即 [1,6]之间的整数，数字间以空格分隔；第二行给出摇的次数 n（1≤n≤5）。 输出格式：在一行中顺序列出第 n 次摇出的每个骰子的点数。数字间必须以 1个空格分隔，行首位不得有多余空格。 输入样例：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><span class="hljs-number">3</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span></code></pre></div><p>样例解释：</p><p>这 3 次摇出的结果依次为：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a[<span class="hljs-number">8</span>];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>) cin&gt;&gt;a[i];    <span class="hljs-keyword">int</span> k;    cin&gt;&gt;k;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">7</span>-k;        <span class="hljs-keyword">if</span>(ans&lt;=a[i])            ans--;        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">6</span>)            cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;        <span class="hljs-keyword">else</span>                cout&lt;&lt;ans;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="l1-6-斯德哥尔摩火车上的题-15-分">L1-6 斯德哥尔摩火车上的题 (15分)</h2><p>上图是新浪微博上的一则趣闻，是瑞典斯德哥尔摩火车上的一道题，看上去是段伪代码：</p><div class="hljs code-wrapper"><pre><code class="hljs gcode">s = ‘’a = ‘<span class="hljs-number">1112031584</span>’for <span class="hljs-comment">(i = 1; i &lt; length(a)</span>; i++) &#123;<span class="hljs-keyword">if</span> <span class="hljs-comment">(a[i] % 2 == a[i-1] % 2)</span> &#123;s += max<span class="hljs-comment">(a[i], a[i-1])</span>&#125;&#125;goto_url<span class="hljs-comment">(‘www.multisoft.se/’ + s)</span></code></pre></div><p>其中字符串的 +操作是连接两个字符串的意思。所以这道题其实是让大家访问网站www.multisoft.se/112358（注意：比赛中千万不要访问这个网址！！！）。</p><p>当然，能通过上述算法得到 112358 的原始字符串 a是不唯一的。本题就请你判断，两个给定的原始字符串，能否通过上述算法得到相同的输出？</p><p>输入格式：</p><p>输入为两行仅由数字组成的非空字符串，长度均不超过104，以回车结束。</p><p>输出格式：</p><p>对两个字符串分别采用上述斯德哥尔摩火车上的算法进行处理。如果两个结果是一样的，则在一行中输出那个结果；否则分别输出各自对应的处理结果，每个占一行。题目保证输出结果不为空。</p><p>输入样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">1112031584</span><span class="hljs-number">011102315849</span></code></pre></div><p>输出样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs">112358</code></pre></div><p>输入样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs">11120315841233412341112031584</code></pre></div><p>输出样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">1123583</span><span class="hljs-number">112358</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e4</span>+<span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> c[maxn];    <span class="hljs-keyword">int</span> a[maxn];    <span class="hljs-keyword">int</span> ans1[maxn],cnt1=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> ans2[maxn],cnt2=<span class="hljs-number">0</span>;    cin&gt;&gt;c;    <span class="hljs-keyword">int</span>  l = <span class="hljs-built_in">strlen</span>(c);    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">0</span>,l<span class="hljs-number">-1</span>)        a[i]=c[i]-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; l; i++) &#123;        <span class="hljs-keyword">if</span> (a[i] % <span class="hljs-number">2</span> == a[i<span class="hljs-number">-1</span>] % <span class="hljs-number">2</span>)             ans1[++cnt1] = <span class="hljs-built_in">max</span>(a[i], a[i<span class="hljs-number">-1</span>]);    &#125;    cin&gt;&gt;c;    l = <span class="hljs-built_in">strlen</span>(c);    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">0</span>,l<span class="hljs-number">-1</span>)        a[i]=c[i]-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; l; i++) &#123;        <span class="hljs-keyword">if</span> (a[i] % <span class="hljs-number">2</span> == a[i<span class="hljs-number">-1</span>] % <span class="hljs-number">2</span>)             ans2[++cnt2] = <span class="hljs-built_in">max</span>(a[i], a[i<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(cnt1!=cnt2) f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(f)    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt1)&#123;        <span class="hljs-keyword">if</span>(ans1[i]!=ans2[i])&#123;            f=<span class="hljs-number">0</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(f)&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt1)            cout&lt;&lt;ans1[i];    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt1)            cout&lt;&lt;ans1[i];        cout&lt;&lt;endl;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt2)            cout&lt;&lt;ans2[i];    &#125;&#125;</code></pre></div><h2 id="l1-7-机工士姆斯塔迪奥-20-分">L1-7 机工士姆斯塔迪奥 (20 分)</h2><p>在 MMORPG《最终幻想14》的副本“乐欲之所瓯博讷修道院”里，BOSS机工士姆斯塔迪奥将会接受玩家的挑战。</p><p>你需要处理这个副本其中的一个机制：N×M 大小的地图被拆分为了 N×M 个 1×1的格子，BOSS会选择若干行或/及若干列释放技能，玩家不能站在释放技能的方格上，否则就会被击中而失败。</p><p>给定 BOSS所有释放技能的行或列信息，请你计算出最后有多少个格子是安全的。</p><p>输入格式:</p><p>输入第一行是三个整数 N,M,Q (1≤N×M≤105，0≤Q≤1000)，表示地图为 N 行 M列大小以及选择的行/列数量。</p><p>接下来 Q 行，每行两个数 Ti​,Ci​，其中 Ti​=0 表示 BOSS选择的是一整行，Ti​=1 表示选择的是一整列，Ci​ 为选择的行号/列号。</p><p>行和列的编号均从 1 开始。</p><p>输出格式:</p><p>输出一个数，表示安全格子的数量。</p><p>输入样例:</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-symbol">0 </span><span class="hljs-number">2</span><span class="hljs-symbol">0 </span><span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span></code></pre></div><p>输出样例:</p><div class="hljs code-wrapper"><pre><code class="hljs">12</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">bool</span> e[<span class="hljs-number">2</span>][maxn]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    cin&gt;&gt;n&gt;&gt;m;    <span class="hljs-keyword">int</span> q;    cin&gt;&gt;q;    <span class="hljs-keyword">while</span>(q--)&#123;        <span class="hljs-keyword">int</span> t,c;        cin&gt;&gt;t&gt;&gt;c;        e[t][c]=<span class="hljs-number">1</span>;    &#125;    ll a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-keyword">if</span>(e[<span class="hljs-number">0</span>][i]==<span class="hljs-number">0</span>)            a++;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,m)        <span class="hljs-keyword">if</span>(e[<span class="hljs-number">1</span>][i]==<span class="hljs-number">0</span>)            b++;    cout&lt;&lt;a*b;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="l1-8-静静的推荐-20-分">L1-8 静静的推荐 (20 分)</h2><p>天梯赛结束后，某企业的人力资源部希望组委会能推荐一批优秀的学生，这个整理推荐名单的任务就由静静姐负责。企业接受推荐的流程是这样的：</p><ul><li>只考虑得分不低于 175 分的学生；</li><li>一共接受 K 批次的推荐名单；</li><li>同一批推荐名单上的学生的成绩原则上应严格递增；</li><li>如果有的学生天梯赛成绩虽然与前一个人相同，但其参加过 PAT考试，且成绩达到了该企业的面试分数线，则也可以接受。</li></ul><p>给定全体参赛学生的成绩和他们的 PAT考试成绩，请你帮静静姐算一算，她最多能向企业推荐多少学生？</p><p>输入格式：</p><p>输入第一行给出 3个正整数：N（≤105）为参赛学生人数，K（≤5×103）为企业接受的推荐批次，S（≤100）为该企业的PAT 面试分数线。</p><p>随后 N 行，每行给出两个分数，依次为一位学生的天梯赛分数（最高分290）和 PAT 分数（最高分 100）。</p><p>输出格式：</p><p>在一行中输出静静姐最多能向企业推荐的学生人数。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">2</span> <span class="hljs-number">90</span><span class="hljs-symbol">203 </span><span class="hljs-number">0</span><span class="hljs-symbol">169 </span><span class="hljs-number">91</span><span class="hljs-symbol">175 </span><span class="hljs-number">88</span><span class="hljs-symbol">175 </span><span class="hljs-number">0</span><span class="hljs-symbol">175 </span><span class="hljs-number">90</span><span class="hljs-symbol">189 </span><span class="hljs-number">0</span><span class="hljs-symbol">189 </span><span class="hljs-number">0</span><span class="hljs-symbol">189 </span><span class="hljs-number">95</span><span class="hljs-symbol">189 </span><span class="hljs-number">89</span><span class="hljs-symbol">256 </span><span class="hljs-number">100</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs">8</code></pre></div><p>样例解释： 第一批可以选择 175、189、203、256这四个分数的学生各一名，此外 175 分 PAT 分数达到 90 分的学生和 189 分PAT 分数达到 95 分的学生可以额外进入名单。第二批就只剩下 175、189两个分数的学生各一名可以进入名单了。最终一共 8 人进入推荐名单。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">291</span>],b[<span class="hljs-number">291</span>];<span class="hljs-comment">//175-290的桶</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,k,s;    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-keyword">int</span> x,y;        cin&gt;&gt;x&gt;&gt;y;        a[x]++;        <span class="hljs-keyword">if</span>(y&gt;=s)            b[x]++;    &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">175</span>,<span class="hljs-number">290</span>)&#123;        ans+=<span class="hljs-built_in">min</span>(a[i]-b[i],k)+b[i];    &#125;    cout&lt;&lt;ans;&#125;</code></pre></div><h2 id="l2-1-插松枝-25-分">L2-1 插松枝 (25 分)</h2><p>就是这道题卡了我好久，最后重新写才A的QAQ。</p><p>人造松枝加工场的工人需要将各种尺寸的塑料松针插到松枝干上，做成大大小小的松枝。他们的工作流程（并不）是这样的：</p><ul><li>每人手边有一只小盒子，初始状态为空。</li><li>每人面前有用不完的松枝干和一个推送器，每次推送一片随机型号的松针片。</li><li>工人首先捡起一根空的松枝干，从小盒子里摸出最上面的一片松针 ——如果小盒子是空的，就从推送器上取一片松针。将这片松针插到枝干的最下面。</li><li>工人在插后面的松针时，需要保证，每一步插到一根非空松枝干上的松针片，不能比前一步插上的松针片大。如果小盒子中最上面的松针满足要求，就取之插好；否则去推送器上取一片。如果推送器上拿到的仍然不满足要求，就把拿到的这片堆放到小盒子里，继续去推送器上取下一片。注意这里假设小盒子里的松针片是按放入的顺序堆叠起来的，工人每次只能取出最上面（即最后放入）的一片。</li><li>当下列三种情况之一发生时，工人会结束手里的松枝制作，开始做下一个：</li></ul><p>（1）小盒子已经满了，但推送器上取到的松针仍然不满足要求。此时将手中的松枝放到成品篮里，推送器上取到的松针压回推送器，开始下一根松枝的制作。</p><p>（2）小盒子中最上面的松针不满足要求，但推送器上已经没有松针了。此时将手中的松枝放到成品篮里，开始下一根松枝的制作。</p><p>（3）手中的松枝干上已经插满了松针，将之放到成品篮里，开始下一根松枝的制作。</p><p>现在给定推送器上顺序传过来的 N片松针的大小，以及小盒子和松枝的容量，请你编写程序自动列出每根成品松枝的信息。</p><p>输入格式：</p><p>输入在第一行中给出 3个正整数：N（≤103），为推送器上松针片的数量；M（≤20）为小盒子能存放的松针片的最大数量；K（≤5）为一根松枝干上能插的松针片的最大数量。</p><p>随后一行给出 N 个不超过 100的正整数，为推送器上顺序推出的松针片的大小。</p><p>输出格式：</p><p>每支松枝成品的信息占一行，顺序给出自底向上每片松针的大小。数字间以 1个空格分隔，行首尾不得有多余空格。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><span class="hljs-symbol">20 </span><span class="hljs-number">25</span> <span class="hljs-number">15</span> <span class="hljs-number">18</span> <span class="hljs-number">20</span> <span class="hljs-number">18</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">20 </span><span class="hljs-number">15</span><span class="hljs-symbol">20 </span><span class="hljs-number">18</span> <span class="hljs-number">18</span> <span class="hljs-number">8</span><span class="hljs-symbol">25 </span><span class="hljs-number">5</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e3</span>+<span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">int</span> pus[maxn],pus_long;<span class="hljs-keyword">int</span> box[maxn],box_long;<span class="hljs-keyword">int</span> tre[maxn],tre_long;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">out_tre</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,tre_long)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,tre[i]);        <span class="hljs-keyword">if</span>(i!=tre_long)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    tre_long=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m,k;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)        pus[i]=<span class="hljs-built_in">read</span>();    pus_long=n;    tre[<span class="hljs-number">0</span>]=<span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-keyword">while</span>(box_long||pus_long||tre_long)&#123;        <span class="hljs-keyword">if</span>( (box_long==m&amp;&amp;pus[pus_long]&gt;tre[tre_long]&amp;&amp;box[box_long]&gt;tre[tre_long]) ||            (box[box_long]&gt;tre[tre_long]&amp;&amp;pus_long==<span class="hljs-number">0</span>) ||            (tre_long==k) ||            (box_long==<span class="hljs-number">0</span>&amp;&amp;pus_long==<span class="hljs-number">0</span>)            )        &#123;            <span class="hljs-built_in">out_tre</span>();        &#125;        <span class="hljs-keyword">if</span>(box_long&gt;<span class="hljs-number">0</span>&amp;&amp;box[box_long]&lt;=tre[tre_long])&#123;            tre[++tre_long]=box[box_long--];        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pus_long&gt;<span class="hljs-number">0</span>&amp;&amp;pus[pus_long]&lt;=tre[tre_long])&#123;            tre[++tre_long]=pus[pus_long--];        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pus_long&gt;<span class="hljs-number">0</span>&amp;&amp;box_long&lt;m)&#123;            box[++box_long]=pus[pus_long--];        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="l2-2-老板的作息表-25-分">L2-2 老板的作息表 (25 分)</h2><p>新浪微博上有人发了某老板的作息时间表，表示其每天 4:30就起床了。但立刻有眼尖的网友问：这时间表不完整啊，早上九点到下午一点干啥了？</p><p>本题就请你编写程序，检查任意一张时间表，找出其中没写出来的时间段。</p><p>输入格式：</p><p>输入第一行给出一个正整数 N，为作息表上列出的时间段的个数。随后 N行，每行给出一个时间段，格式为：</p><p>hh:mm:ss - hh:mm:ss</p><p>其中 hh、mm、ss分别是两位数表示的小时、分钟、秒。第一个时间是开始时间，第二个是结束时间。题目保证所有时间都在一天之内（即从00:00:00 到 23:59:59）；每个区间间隔至少 1秒；并且任意两个给出的时间区间最多只在一个端点有重合，没有区间重叠的情况。</p><p>输出格式：</p><p>按照时间顺序列出时间表中没有出现的区间，每个区间占一行，格式与输入相同。题目保证至少存在一个区间需要输出。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">8</span><span class="hljs-attribute">13</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">18</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-attribute">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">05</span><span class="hljs-attribute">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">09</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-attribute">07</span>:<span class="hljs-number">10</span>:<span class="hljs-number">59</span> - <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-attribute">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">05</span> - <span class="hljs-number">04</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span><span class="hljs-attribute">06</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span> - <span class="hljs-number">07</span>:<span class="hljs-number">10</span>:<span class="hljs-number">58</span><span class="hljs-attribute">05</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span> - <span class="hljs-number">06</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span><span class="hljs-attribute">18</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">19</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">04</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span> - <span class="hljs-number">05</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span><span class="hljs-attribute">07</span>:<span class="hljs-number">10</span>:<span class="hljs-number">58</span> - <span class="hljs-number">07</span>:<span class="hljs-number">10</span>:<span class="hljs-number">59</span><span class="hljs-attribute">09</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">13</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-attribute">19</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">23</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> h1,m1,s1;    <span class="hljs-keyword">int</span> h2,m2,s2;    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> c=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> d=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> e=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> f=<span class="hljs-number">0</span>):<span class="hljs-built_in">h1</span>(a),<span class="hljs-built_in">m1</span>(b),<span class="hljs-built_in">s1</span>(c),<span class="hljs-built_in">h2</span>(d),<span class="hljs-built_in">m2</span>(e),<span class="hljs-built_in">s2</span>(f)&#123;&#125;&#125;e[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span>&#123;    <span class="hljs-keyword">if</span>(a.h1!=b.h1)        <span class="hljs-keyword">return</span> a.h1&lt;b.h1;    <span class="hljs-keyword">if</span>(a.m1!=b.m1)        <span class="hljs-keyword">return</span> a.m1&lt;b.m1;    <span class="hljs-keyword">return</span> a.s1&lt;b.s1;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">com</span><span class="hljs-params">(node a,node b)</span></span>&#123;    <span class="hljs-keyword">if</span>(a.h2!=b.h1)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(a.m2!=b.m1)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(a.s2!=b.s1)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0%d&quot;</span>,x);    <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    cin&gt;&gt;n;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d - %d:%d:%d&quot;</span>,&amp;e[i].h1,&amp;e[i].m1,&amp;e[i].s1,&amp;e[i].h2,&amp;e[i].m2,&amp;e[i].s2);        <span class="hljs-comment">//printf(&quot;%d %d %d %d %d %d\n&quot;,e[i].h1,e[i].m1,e[i].s1,e[i].h2,e[i].m2,e[i].s2);</span>    &#125;    e[<span class="hljs-number">0</span>]=<span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    e[n+<span class="hljs-number">1</span>]=<span class="hljs-built_in">node</span>(<span class="hljs-number">23</span>,<span class="hljs-number">59</span>,<span class="hljs-number">59</span>,<span class="hljs-number">23</span>,<span class="hljs-number">59</span>,<span class="hljs-number">59</span>);    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+<span class="hljs-number">1</span>+n,cmp);    <span class="hljs-comment">// FOR(i,0,n+1)&#123;</span>    <span class="hljs-comment">//     //scanf(&quot;%d:%d:%d - %d:%d:%d&quot;,&amp;e[i].h1,&amp;e[i].m1,&amp;e[i].s1,&amp;e[i].h2,&amp;e[i].m2,&amp;e[i].s2);</span>    <span class="hljs-comment">//     printf(&quot;%d %d %d %d %d %d\n&quot;,e[i].h1,e[i].m1,e[i].s1,e[i].h2,e[i].m2,e[i].s2);</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">0</span>,n)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">com</span>(e[i],e[i+<span class="hljs-number">1</span>]))            <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//printf(&quot;%d:%d:%d - %d:%d:%d\n&quot;,e[i].h2,e[i].m2,e[i].s2,e[i+1].h2,e[i+1].m2,e[i+1].s2);</span>                <span class="hljs-built_in">prin</span>(e[i].h2);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-built_in">prin</span>(e[i].m2);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-built_in">prin</span>(e[i].s2);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; - &quot;</span>);        <span class="hljs-built_in">prin</span>(e[i+<span class="hljs-number">1</span>].h1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-built_in">prin</span>(e[i+<span class="hljs-number">1</span>].m1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-built_in">prin</span>(e[i+<span class="hljs-number">1</span>].s1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;&#125;</code></pre></div><h2 id="l2-3-龙龙送外卖-25-分">L2-3 龙龙送外卖 (25 分)</h2><p>龙龙是“饱了呀”外卖软件的注册骑手，负责送帕特小区的外卖。帕特小区的构造非常特别，都是双向道路且没有构成环——你可以简单地认为小区的路构成了一棵树，根结点是外卖站，树上的结点就是要送餐的地址。</p><p>每到中午 12点，帕特小区就进入了点餐高峰。一开始，只有一两个地方点外卖，龙龙简单就送好了；但随着大数据的分析，龙龙被派了更多的单子，也就送得越来越累……</p><p>看着一大堆订单，龙龙想知道，从外卖站出发，访问所有点了外卖的地方至少一次（这样才能把外卖送到）所需的最短路程的距离到底是多少？每次新增一个点外卖的地址，他就想估算一遍整体工作量，这样他就可以搞明白新增一个地址给他带来了多少负担。</p><p>输入格式:</p><p>输入第一行是两个数 N 和 M (2≤N≤105,1≤M≤105)，分别对应树上节点的个数（包括外卖站），以及新增的送餐地址的个数。</p><p>接下来首先是一行 N 个数，第 i 个数表示第 i个点的双亲节点的编号。节点编号从 1 到 N，外卖站的双亲编号定义为 −1。</p><p>接下来有 M 行，每行给出一个新增的送餐地点的编号Xi​。保证送餐地点中不会有外卖站，但地点有可能会重复。</p><p>为了方便计算，我们可以假设龙龙一开始一个地址的外卖都不用送，两个相邻的地点之间的路径长度统一设为1，且从外卖站出发可以访问到所有地点。</p><p>注意：所有送餐地址可以按任意顺序访问，且完成送餐后无需返回外卖站。</p><p>输出格式:</p><p>对于每个新增的地点，在一行内输出题目需要求的最短路程的距离。</p><p>输入样例:</p><div class="hljs code-wrapper"><pre><code class="hljs tap">7 4-1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>35624</code></pre></div><p>输出样例:</p><div class="hljs code-wrapper"><pre><code class="hljs">2446</code></pre></div><h2 id="l2-4-大众情人-25-分">L2-4 大众情人 (25 分)</h2><p>人与人之间总有一点距离感。我们假定两个人之间的亲密程度跟他们之间的距离感成反比，并且距离感是单向的。例如小蓝对小红患了单相思，从小蓝的眼中看去，他和小红之间的距离为1，只差一层窗户纸；但在小红的眼里，她和小蓝之间的距离为108000，差了十万八千里……另外，我们进一步假定，距离感在认识的人之间是可传递的。例如小绿觉得自己跟小蓝之间的距离为2，则即使小绿并不直接认识小红，我们也默认小绿早晚会认识小红，并且因为跟小蓝很亲近的关系，小绿会觉得自己跟小红之间的距离为1+2=3。当然这带来一个问题，如果小绿本来也认识小红，或者他通过其他人也能认识小红，但通过不同渠道推导出来的距离感不一样，该怎么算呢？我们在这里做个简单定义，就将小绿对小红的距离感定义为所有推导出来的距离感的最小值。</p><p>一个人的异性缘不是由最喜欢他/她的那个异性决定的，而是由对他/她最无感的那个异性决定的。我们记一个人i 在一个异性 j 眼中的距离感为 Dij​；将 i 的“异性缘”定义为1/maxj∈S(i)​{Dij​}，其中 S(i) 是相对于 i的所有异性的集合。那么“大众情人”就是异性缘最好（值最大）的那个人。</p><p>本题就请你从给定的一批人与人之间的距离感中分别找出两个性别中的“大众情人”。</p><p>输入格式：</p><p>输入在第一行中给出一个正整数N（≤500），为总人数。于是我们默认所有人从 1 到 N 编号。</p><p>随后 N 行，第 i 行描述了编号为 i 的人与其他人的关系，格式为：</p><p>性别 K 朋友1:距离1 朋友2:距离2 …… 朋友K:距离K</p><p>其中 性别 是这个人的性别，F 表示女性，M 表示男性；K（小于 N的非负整数）为这个人直接认识的朋友数；随后给出的是这 K个朋友的编号、以及这个人对该朋友的距离感。距离感是不超过 106的正整数。</p><p>题目保证给出的关系中一定两种性别的人都有，不会出现重复给出的关系，并且每个人的朋友中都不包含自己。</p><p>输出格式：</p><p>第一行给出自身为女性的“大众情人”的编号，第二行给出自身为男性的“大众情人”的编号。如果存在并列，则按编号递增的顺序输出所有。数字间以一个空格分隔，行首尾不得有多余空格。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">6</span><span class="hljs-attribute">F</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>:<span class="hljs-number">1</span><span class="hljs-attribute">F</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>:<span class="hljs-number">3</span> <span class="hljs-number">4</span>:<span class="hljs-number">10</span><span class="hljs-attribute">F</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span>:<span class="hljs-number">2</span> <span class="hljs-number">2</span>:<span class="hljs-number">2</span><span class="hljs-attribute">M</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span>:<span class="hljs-number">1</span> <span class="hljs-number">3</span>:<span class="hljs-number">2</span><span class="hljs-attribute">M</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>:<span class="hljs-number">2</span> <span class="hljs-number">6</span>:<span class="hljs-number">2</span><span class="hljs-attribute">M</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>:<span class="hljs-number">1</span> <span class="hljs-number">2</span>:<span class="hljs-number">5</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><span class="hljs-number">4</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">510</span>;<span class="hljs-keyword">int</span> e[maxn][maxn];<span class="hljs-keyword">int</span> mark[maxn];<span class="hljs-keyword">int</span> v[maxn];<span class="hljs-keyword">int</span> ma[<span class="hljs-number">2</span>][maxn],cnt[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(e,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(e));    <span class="hljs-keyword">int</span> n;    cin&gt;&gt;n;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        e[i][i]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> c;        cin&gt;&gt;c;        mark[i]=(c==<span class="hljs-string">&#x27;F&#x27;</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> m;        cin&gt;&gt;m;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-keyword">int</span> x,y;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d&quot;</span>,&amp;x,&amp;y);            e[i][x]=y;            <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&quot;-&gt;&quot;&lt;&lt;i&lt;&lt;endl;</span>        &#125;    &#125;    <span class="hljs-comment">// FOR(i,1,n)&#123;</span>    <span class="hljs-comment">//     FOR(j,1,n)&#123;</span>    <span class="hljs-comment">//         cout&lt;&lt;(e[i][j]==0x3f3f3f3f?9:e[i][j])&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     cout&lt;&lt;endl;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)            <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,n)&#123;                e[i][j]=<span class="hljs-built_in">min</span>(e[i][j],e[i][k]+e[k][j]);            &#125;    &#125;    <span class="hljs-comment">// cout&lt;&lt;endl;</span>    <span class="hljs-comment">// FOR(i,1,n)&#123;</span>    <span class="hljs-comment">//     FOR(j,1,n)&#123;</span>    <span class="hljs-comment">//         cout&lt;&lt;e[i][j]&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     cout&lt;&lt;endl;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,n)&#123;            <span class="hljs-keyword">if</span>(mark[i]^mark[j]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//ÒìÐÔ</span>                v[i]=<span class="hljs-built_in">max</span>(v[i],e[j][i]);                <span class="hljs-comment">//cout&lt;&lt;j&lt;&lt;&quot;-&quot;&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;e[j][i]&lt;&lt;endl;</span>            &#125;        &#125;        <span class="hljs-keyword">if</span>(v[i]&lt;v[ ma[mark[i]][<span class="hljs-number">1</span>] ]||cnt[mark[i]]==<span class="hljs-number">0</span>)&#123;            cnt[mark[i]]=<span class="hljs-number">0</span>;            ma[mark[i]][++cnt[mark[i]]]=i;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[i]==v[ ma[mark[i]][<span class="hljs-number">1</span>] ])            ma[mark[i]][++cnt[mark[i]]]=i;    &#125;    <span class="hljs-comment">// cout&lt;&lt;endl;</span>    <span class="hljs-comment">// FOR(i,1,n)</span>    <span class="hljs-comment">//     cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">// cout&lt;&lt;endl;</span>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt[<span class="hljs-number">0</span>])&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ma[<span class="hljs-number">0</span>][i]);        <span class="hljs-keyword">if</span>(i!=cnt[<span class="hljs-number">0</span>])            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);    &#125;    cout&lt;&lt;endl;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt[<span class="hljs-number">1</span>])&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ma[<span class="hljs-number">1</span>][i]);        <span class="hljs-keyword">if</span>(i!=cnt[<span class="hljs-number">1</span>])            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;&#125;</code></pre></div><h2 id="l3-1-千手观音-30-分">L3-1 千手观音 (30 分)</h2><p>人类喜欢用 10 进制，大概是因为人类有一双手 10根手指用于计数。于是在千手观音的世界里，数字都是 10 000进制的，因为每位观音有 1 000 双手 ……</p><p>千手观音们的每一根手指都对应一个符号（但是观音世界里的符号太难画了，我们暂且用小写英文字母串来代表），就好像人类用自己的10 根手指对应 0 到 9 这 10 个数字。同样的，就像人类把这 10个数字排列起来表示更大的数字一样，ta们也把这些名字排列起来表示更大的数字，并且也遵循左边高位右边低位的规则，相邻名字间用一个点. 分隔，例如 pat.pta.cn 表示千手观音世界里的一个 3 位数。</p><p>人类不知道这些符号代表的数字的大小。不过幸运的是，人类发现了千手观音们留下的一串数字，并且有理由相信，这串数字是从小到大有序的！于是你的任务来了：请你根据这串有序的数字，推导出千手观音每只手代表的符号的相对顺序。</p><p>注意：有可能无法根据这串数字得到全部的顺序，你只要尽量推出能得到的结果就好了。当若干根手指之间的相对顺序无法确定时，就暂且按它们的英文字典序升序排列。例如给定下面几个数字：</p><div class="hljs code-wrapper"><pre><code class="hljs stylus">patcnlao<span class="hljs-selector-class">.cn</span>lao<span class="hljs-selector-class">.oms</span>pta<span class="hljs-selector-class">.lao</span>pta<span class="hljs-selector-class">.pat</span>cn.pat</code></pre></div><p>我们首先可以根据前两个数字推断 pat &lt;cn；根据左边高位的顺序可以推断 lao &lt; pta &lt;cn；再根据高位相等时低位的顺序，可以推断出 cn &lt; oms，lao &lt;pat。综上我们得到两种可能的顺序：lao &lt; pat &lt; pta &lt; cn &lt;oms；或者 lao &lt; pta &lt; pat &lt; cn &lt; oms，即 pat 和 pta之间的相对顺序无法确定，这时我们按字典序排列，得到 lao &lt; pat &lt; pta&lt; cn &lt; oms。</p><p>输入格式：</p><p>输入第一行给出一个正整数 N (≤105)，为千手观音留下的数字的个数。随后 N行，每行给出一个千手观音留下的数字，不超过 10 位数，每一位的符号用不超过3 个小写英文字母表示，相邻两符号之间用 . 分隔。</p><p>我们假设给出的数字顺序在千手观音的世界里是严格递增的。题目保证数字是104 进制的，即符号的种类肯定不超过 104 种。</p><p>输出格式：</p><p>在一行中按大小递增序输出符号。当若干根手指之间的相对顺序无法确定时，按它们的英文字典序升序排列。符号间仍然用. 分隔。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">7</span>patcnlao<span class="hljs-selector-class">.cn</span>lao<span class="hljs-selector-class">.oms</span>pta<span class="hljs-selector-class">.lao</span>pta<span class="hljs-selector-class">.pat</span>cn.pat</code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs stylus">lao<span class="hljs-selector-class">.pat</span><span class="hljs-selector-class">.pta</span><span class="hljs-selector-class">.cn</span>.oms</code></pre></div><h2id="l3-2-关于深度优先搜索和逆序对的题应该不会很难吧这件事-30-分">L3-2关于深度优先搜索和逆序对的题应该不会很难吧这件事 (30 分)</h2><p>背景知识</p><p>深度优先搜索与 DFS 序</p><p>深度优先搜索算法（DFS）是一种用于遍历或搜索树或图的算法。以下伪代码描述了在树T 上进行深度优先搜索的过程：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">procedure <span class="hljs-title">DFS</span><span class="hljs-params">(T, u, L)</span> <span class="hljs-comment">// T 是被深度优先搜索的树</span></span><span class="hljs-function"><span class="hljs-comment">// u 是当前搜索的节点</span></span><span class="hljs-function"><span class="hljs-comment">// L 是一个链表，保存了所有节点被第一次访问的顺序</span></span><span class="hljs-function">append u to L <span class="hljs-comment">// 将节点 u 添加到链表 L 的末尾</span></span><span class="hljs-function"><span class="hljs-keyword">for</span> v in u.children <span class="hljs-keyword">do</span> <span class="hljs-comment">// 枚举节点 u 的所有子节点 v</span></span><span class="hljs-function"><span class="hljs-title">DFS</span><span class="hljs-params">(T, v)</span> <span class="hljs-comment">// 递归搜索节点 v</span></span></code></pre></div><p>令 r 为树 T 的根，调用 DFS(T, r, L) 即可完成对 T的深度优先搜索，保存在链表 L 中的排列被称为 DFS序。相信聪明的你已经发现了，如果枚举子节点的顺序不同，最终得到的 DFS序也会不同。</p><p>逆序对</p><p>给定一个长度为 n 的整数序列a1​,a2​,⋯,an​，该序列的逆序对数量是同时满足以下条件的有序数对 (i,j)的数量：</p><ul><li>1≤i&lt;j≤n；</li><li>ai​&gt;aj​。</li></ul><p>问题求解</p><p>给定一棵 n 个节点的树，其中节点 r 为根。求该树所有可能的 DFS序中逆序对数量之和。</p><p>输入格式</p><p>第一行输入两个整数 n，r（2≤n≤3×105，1≤r≤n）表示树的大小与根节点。</p><p>对于接下来的 (n−1) 行，第 i 行输入两个整数 ui​ 与vi​（1≤ui​,vi​≤n），表示树上有一条边连接节点 ui​ 与 vi​。</p><p>输出格式</p><p>输出一行一个整数，表示该树所有可能的 DFS序中逆序对数量之和。由于答案可能很大，请对 109+7 取模后输出。</p><p>样例输入 1</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span></code></pre></div><p>样例输出 1</p><div class="hljs code-wrapper"><pre><code class="hljs">24</code></pre></div><p>样例输入 2</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">5</span><span class="hljs-symbol">10 </span><span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><span class="hljs-symbol">10 </span><span class="hljs-number">7</span><span class="hljs-symbol">7 </span><span class="hljs-number">1</span><span class="hljs-symbol">7 </span><span class="hljs-number">9</span><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><span class="hljs-symbol">10 </span><span class="hljs-number">8</span><span class="hljs-symbol">3 </span><span class="hljs-number">6</span></code></pre></div><p>样例输出 2</p><div class="hljs code-wrapper"><pre><code class="hljs">516</code></pre></div><p>样例解释</p><p>下图展示了样例 1 中的树。</p><p>该树共有 4 种可能的 DFS 序：</p><ul><li>{3,4,5,1,2}，有 6 个逆序对；</li><li>{3,4,5,2,1}，有 7 个逆序对；</li><li>{3,5,1,2,4}，有 5 个逆序对；</li><li>{3,5,2,1,4}，有 6 个逆序对。</li></ul><p>此答案为 6+7+5+6=24。</p><h2 id="l3-3-教科书般的亵渎-30-分">L3-3 教科书般的亵渎 (30 分)</h2><p>九条可怜最近在玩一款卡牌游戏。在每一局游戏中，可怜都要使用抽到的卡牌来消灭一些敌人。每一名敌人都有一个初始血量，而当血量降低到0 及以下的时候，这名敌人就会立即被消灭并从场上消失。</p><p>现在，可怜面前有 n 个敌人，其中第 i 名敌人的血量是ai​，而可怜手上只有如下两张手牌：</p><p>1.如果场上还有敌人，等概率随机选中一个敌人并对它造成一点伤害（即血量减1），重复 K 次。</p><p>2.对所有敌人造成一点伤害，重复该效果直到没有新的敌人被消灭。</p><p>下面是这两张手牌效果的一些示例：</p><p>1.假设存在两名敌人，他们的血量分别是 1,2 且K=2。那么在可怜打出第一张手牌后，可能会发生如下情况：</p><ul><li><p>第一轮中，两名敌人各有 0.5的概率被选中。假设第一名敌人被选中，那么它会被造成一点伤害。这时它的血量变成了0，因此它被消灭并消失了。</p></li><li><p>第二轮中，因为场上只剩下了第二名敌人，所以它一定会被选中并被造成一点伤害。这时它剩下的血量为1。</p></li></ul><p>2.同样假设存在两名敌人且血量分别为1,2。那么在可怜打出第二张手牌后，会发生如下情况：</p><ul><li>第一轮中，所有敌人被造成了一点伤害。这时第一名敌人被消灭了，因此卡牌效果会被重复一遍。</li><li>第二轮中，所有敌人（此时只剩下第二名敌人了）被造成了一点伤害。这时第二名敌人也被消灭了，因此卡牌效果会被再重复一遍。</li><li>第三轮中，所有敌人（此时没有敌人剩下了）被造成了一点伤害。因为没有新的敌人被消灭了，所以卡牌效果结束。</li></ul><p>3.如果面对的是四名血量分别为 1,2,2,4的敌人，那么在可怜打出第二张手牌后，只有第四名敌人还会存活，且它的剩余血量为1。</p><p>现在，可怜先打出了第一张手牌，再打出了第二张手牌。她发现，在第一张手牌效果结束后，没有任何一名敌人被消灭，但是在第二张手牌的效果结束后，所有敌人都被消灭了。</p><p>可怜想让你计算一下这种情况发生的概率是多少。</p><p>输入格式：</p><p>第一行输入两个整数n,K(1≤n,K≤50)，分别表示敌人的数量以及第一张卡牌效果的发动次数。</p><p>第二行输入 n 个由空格隔开的整数ai​(1≤ai​≤50)，表示每个敌人的初始血量。</p><p>输出格式：</p><p>在一行中输出一个整数，表示发生概率对 998244353 取模后的结果。</p><p>具体来说，如果概率的最简分数表示为a/b(a≥0,b≥1,gcd(a,b)=1)，那么你需要输出 a×b998244351mod998244353。</p><p>输入样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span></code></pre></div><p>输出样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">665496236</span></code></pre></div><p>样例解释 1：</p><p>在第一张手牌的效果结束后，三名敌人的剩余血量只可能在如下几种中：[1,3,2],[1,2,3], [2,1,3] 和 [2,3,1]。前两种发生的概率是 2/9，后两种发生的概率是1/9。因此答案为 2/3，输出 2×3998244351mod998244353=665496236。 输入样例2：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span></code></pre></div><p>输出样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">776412275</span></code></pre></div><p>样例解释 2:</p><p>在第一张手牌的效果结束后，三名敌人的剩余血量只可能在如下几种中：[1,2,2]、[2,1,2]和 [2,2,1]。第一种发生的概率是 2/9，后两种发生的概率是 1/9。因此答案为4/9，输出 4×9998244351mod998244353=776412275。</p><p>输入样例 3：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span></code></pre></div><p>输出样例 3：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">367353922</span></code></pre></div><p>输入样例 4：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">12</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span></code></pre></div><p>输出样例 4：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">452061016</span></code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022—SWJTU寒假选拔赛第五场复盘</title>
      <link href="/2022/02/26/15/"/>
      <url>/2022/02/26/15/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>又是一篇迟到许久的复盘，终于在回到学校的第一天补上了。</p><h1 id="链接">链接</h1><div class="note note-info">            <p><ahref="https://vjudge.net/contest/480842"><b>2022—SWJTU寒假选拔赛第五场</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><figure><img src="https://pic.imgdb.cn/item/621a02102ab3f51d915a71aa.png"alt="RANK" /><figcaption aria-hidden="true">RANK</figcaption></figure><h2 id="a---codeforces-114e-很强的素数">A - CodeForces 114E 很强的素数×</h2><p><strong>题目大意：</strong></p><p>　　　　给定区间[L,R]，求区间内满足条件的数的个数：</p><p>　　　　条件1）z是素数</p><p>　　　　条件2）z=x<sup>2+y</sup>2 x和y为任意的正整数</p><p><strong>解题思路：</strong></p><p>　　　　其实就是求满足费马定理的数的个数。</p><p>　　　**费马定理：一个奇素数z可以表示成z=x<sup>2+y</sup>2的形式,当且仅当z可以表示成4*t+1的时候。（偶素数2=1<sup>2+1</sup>2）**</p><p>　　　　LR的范围是1到3*10^8用普通的筛选法求素数表，时间空间都会超。使用两次筛选来求素数。</p><p>　　　　3*10^8的平方根小于17500，用17500以内的素数可以筛出范围内的所有素数。在通过判断是否满足z=t%4+1来累加。</p><p>　　　　又由于z的范围过大，但对于唯一确定的z来说，t也唯一确定，故可以用t作为数组下标即(z-1)/4。数组大小就会小4倍左右。</p><p>　　　　具体细节看代码备注。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bitset&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 17500</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;bitset&lt;MAXN&gt;ISP; <span class="hljs-comment">//类似于bool型，可以存01</span>bitset&lt;300000000/4+10&gt;result;<span class="hljs-keyword">int</span> prime[MAXN];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_prime</span><span class="hljs-params">()</span><span class="hljs-comment">//先筛选1-17500的素数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>;    ISP[<span class="hljs-number">0</span>]=ISP[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=MAXN; i++)        <span class="hljs-keyword">if</span> (ISP[i]==<span class="hljs-number">0</span>)        &#123;            prime[p++]=i;<span class="hljs-comment">//用prime素组将素数存起来留到后面筛选用。。</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=i+i; j&lt;=MAXN; j+=i)                ISP[j]=<span class="hljs-number">1</span>;        &#125;    <span class="hljs-keyword">return</span> p<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> p=<span class="hljs-built_in">is_prime</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;=p; j++)    &#123;        <span class="hljs-keyword">int</span> x=L/prime[j];        <span class="hljs-keyword">if</span> (x*prime[j]&lt;L) x++;        <span class="hljs-keyword">if</span> (x==<span class="hljs-number">1</span>) x++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=x*prime[j]; k&lt;=R; k+=prime[j]) <span class="hljs-comment">//通过素数表再来筛选[L,R]中的素数</span>               <span class="hljs-keyword">if</span> (k%<span class="hljs-number">4</span>==<span class="hljs-number">1</span>) <span class="hljs-comment">//标记符合条件2且不符合条件1的数</span>                result[(k<span class="hljs-number">-1</span>)/<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=L;i&lt;=R;i+=<span class="hljs-number">4</span>)        <span class="hljs-keyword">if</span> (!result[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">4</span>]) cnt++;    <span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">is_prime</span>();    <span class="hljs-keyword">int</span> L,R;    <span class="hljs-keyword">int</span> ok=<span class="hljs-number">0</span>;    cin&gt;&gt;L&gt;&gt;R;    <span class="hljs-keyword">if</span> (L&lt;=<span class="hljs-number">2</span>&amp;&amp;R&gt;=<span class="hljs-number">2</span>) ok=<span class="hljs-number">1</span>; <span class="hljs-comment">//2作为偶素数且符合条件 单独判断</span>    <span class="hljs-keyword">while</span> (L%<span class="hljs-number">4</span>!=<span class="hljs-number">1</span>||L==<span class="hljs-number">1</span>) <span class="hljs-comment">//将区间边界缩小到符合 %4==1</span>        L++;    <span class="hljs-keyword">while</span> (R%<span class="hljs-number">4</span>!=<span class="hljs-number">1</span>)        R--;    cout&lt;&lt;<span class="hljs-built_in">cnt</span>(L,R)+ok;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="b---codeforces-514c-字符串">B - CodeForces 514C 字符串</h2><p><strong>思路一：哈希表</strong></p><p>字符串hash<br />因为只有3个字符<br />所以权值就为3^x;<br />找个大质数取模就好；<br />不够大就再大一点。。<br />然后对于每一位,尝试换成其他两个字母,看看存不存在</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,rt&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rt&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep1(i,a,b) for (int i = a;i &lt;= b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep2(i,a,b) for (int i = a;i &gt;= b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ps push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rei(x) scanf(<span class="hljs-meta-string">&quot;%d&quot;</span>,&amp;x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rel(x) scanf(<span class="hljs-meta-string">&quot;%lld&quot;</span>,&amp;x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ref(x) scanf(<span class="hljs-meta-string">&quot;%lf&quot;</span>,&amp;x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,y) memset(x,y,sizeof x)</span><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;LL,LL&gt; pll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dy[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">6e5</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> LL MOD = <span class="hljs-number">1e12</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n,m;LL p[N];string s;set&lt;LL&gt; myset;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen(&quot;F:\\rush.txt&quot;,&quot;r&quot;,stdin);</span>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep1</span>(i,<span class="hljs-number">1</span>,N<span class="hljs-number">-2</span>)        p[i] = (p[i<span class="hljs-number">-1</span>]*<span class="hljs-number">3</span>)%MOD;    <span class="hljs-built_in">rei</span>(n),<span class="hljs-built_in">rei</span>(m);    <span class="hljs-built_in">rep1</span>(i,<span class="hljs-number">1</span>,n)    &#123;        cin &gt;&gt; s;        LL temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">rep1</span>(j,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>)            temp = (temp*<span class="hljs-number">3</span>+s[j]-<span class="hljs-string">&#x27;0&#x27;</span>)%MOD;        myset.<span class="hljs-built_in">insert</span>(temp);    &#125;    <span class="hljs-built_in">rep1</span>(i,<span class="hljs-number">1</span>,m)    &#123;        cin &gt;&gt; s;        <span class="hljs-keyword">bool</span> ok = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();        LL temp = <span class="hljs-number">0</span>,ttemp;        <span class="hljs-built_in">rep1</span>(j,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>)            temp = (temp*<span class="hljs-number">3</span>+s[j]-<span class="hljs-string">&#x27;0&#x27;</span>)%MOD;        <span class="hljs-built_in">rep1</span>(j,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>)        &#123;            <span class="hljs-keyword">char</span> t = s[j];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> d=<span class="hljs-string">&#x27;a&#x27;</span>;d&lt;=<span class="hljs-string">&#x27;c&#x27;</span>;d++)            <span class="hljs-keyword">if</span> (t!=d)            &#123;                ttemp = (temp-(t-<span class="hljs-string">&#x27;0&#x27;</span>)*p[len-j<span class="hljs-number">-1</span>])%MOD;                <span class="hljs-keyword">if</span> (ttemp&lt;<span class="hljs-number">0</span>) ttemp=(ttemp+MOD)%MOD;                ttemp=(ttemp+(d-<span class="hljs-string">&#x27;0&#x27;</span>)*p[len-j<span class="hljs-number">-1</span>])%MOD;                <span class="hljs-keyword">if</span> (myset.<span class="hljs-built_in">count</span>(ttemp))                &#123;                    ok = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (ok) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span> (ok)            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);    &#125;    <span class="hljs-comment">//printf(&quot;\n%.2lf sec \n&quot;, (double)clock() / CLOCKS_PER_SEC);</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>思路二：字典树</strong></p><p>考虑字典树。</p><p>首先把n个单词插入字典树中。</p><p>询问的时候用dfs，flag表示搜索到当前是否已经改变过一个字符。</p><p>如果已经改变过那只能按照当前剩下的字符串一条路查询下去。</p><p>否则可以按老字符或新字符进行查询。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b)    for (int i(a); i &lt;= (b); ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i, a, b)    for (int i(a); i &gt;= (b); --i)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e7</span> + <span class="hljs-number">3</span>; <span class="hljs-keyword">char</span> s[<span class="hljs-number">600010</span>];<span class="hljs-keyword">int</span> n, q, ans, len, tot = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ch[N][<span class="hljs-number">3</span>];bitset &lt;N&gt; cnt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span></span>&#123;    ++tot;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) ch[tot][i] = <span class="hljs-number">0</span>;    cnt[tot] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> tot;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span></span>&#123;    <span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i]; ++i)&#123;        <span class="hljs-keyword">int</span> w = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">if</span> (!ch[now][w]) ch[now][w] = <span class="hljs-built_in">newnode</span>();        now = ch[now][w];    &#125;    cnt[now] = <span class="hljs-number">1</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> now)</span></span>&#123;    <span class="hljs-keyword">if</span> (ans) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (x == len &amp;&amp; flag &amp;&amp; cnt[now])&#123; ans = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span>;&#125;    <span class="hljs-keyword">if</span> (x &gt;= len) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (flag)&#123;        <span class="hljs-keyword">int</span> w = s[x] - <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">if</span> (ch[now][w]) <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, flag, ch[now][w]);    &#125;     <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> (i != s[x] - <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; x + <span class="hljs-number">1</span> == len &amp;&amp; ch[now][i] &amp;&amp; cnt[ch[now][i]]) ans = <span class="hljs-number">1</span>;         <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> (i != s[x] - <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch[now][i])&#123;            <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ch[now][i]);        &#125;         <span class="hljs-keyword">int</span> w = s[x] - <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">if</span> (ch[now][w])&#123;            <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, flag, ch[now][w]);        &#125;             &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);        <span class="hljs-built_in">insert</span>(s);    &#125;     <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, q)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);        len = <span class="hljs-built_in">strlen</span>(s);        ans = <span class="hljs-number">0</span>;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-built_in">puts</span>(ans ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>);    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="c---codeforces-243a-或">C - CodeForces 243A 或 ×</h2><p>我着实没想到真的用枚举</p><p><strong>思路一: 枚举+剪枝</strong></p><p>枚举左端点,在枚举 <code>&gt;i</code> 的每一个 <code>j</code>。求两个值，以i为起点的和，与以 <code>i+1</code>为起点的或和。如果两个值是一样的说明没必要 <code>a[i]</code>没必要在此区间存在</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> a[<span class="hljs-number">200005</span>];set&lt;<span class="hljs-keyword">int</span>&gt;s;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> n; cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cin &gt;&gt; a[i];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">int</span> x = a[i], y = <span class="hljs-number">0</span>;        s.<span class="hljs-built_in">insert</span>(x);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;        x |= a[j], y |= a[j];        s.<span class="hljs-built_in">insert</span>(x);        <span class="hljs-keyword">if</span> (x == y) <span class="hljs-comment">//离谱的剪枝</span>        &#123; <span class="hljs-keyword">break</span>; &#125;        &#125;    &#125;    cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>思路二:st表+贪心.</strong></p><p>st表可以求出每个区间的或和.我们枚举点,再枚举每一位 <code>j</code>,对于点的第 <code>j</code> 位为 <code>i</code>的点,我们直接记录当前最右的第 <code>j</code> 位为 1 的位置是<code>i</code> , <code>last[j]=i</code>.如果 <code>i</code> 的第<code>j</code> 位不为 1 ,那么求 <code>(last[j],i)</code> 之间的或和,用<code>set</code> 记录.这样是不会漏解的.</p><p>相当于把每个点作为右端点 <code>r</code>，找到能使得<code>(l,r)</code> 间的亦或与 <code>r</code> 的第 <code>j</code>位相异的最靠右的左端点，即 <code>last[j]</code>。本质是每次的记录<code>ask(last[j],i)</code> 都是能改变(相异于) <code>a[i]</code>的。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>,M = <span class="hljs-number">21</span>;<span class="hljs-keyword">int</span> a[N],n,last[M],f[N][M];set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//st表预处理与的区间和. </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;M;j++)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++)    <span class="hljs-keyword">if</span>(!j) f[i][j] = a[i];    <span class="hljs-keyword">else</span> f[i][j] = f[i][j<span class="hljs-number">-1</span>]|f[i+(<span class="hljs-number">1</span>&lt;&lt;j<span class="hljs-number">-1</span>)][j<span class="hljs-number">-1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(!l) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> len = r-l+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> k = <span class="hljs-built_in">log</span>(len)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> f[l][k]|f[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;s.<span class="hljs-built_in">insert</span>(a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;M;j++)&#123;<span class="hljs-keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="hljs-number">1</span>) last[j] = i;<span class="hljs-keyword">else</span> s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">ask</span>(last[j],i));&#125;&#125;s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s.<span class="hljs-built_in">size</span>());<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="d---codeforces-864c-校车">D - CodeForces 864C 校车 √</h2><p>其实是用省略重复情况的模拟，经常遇到，但是我经常被卡很久，因为各种细节考虑情况。</p><p><strong>题面：</strong> 一辆校车的路线是在坐标轴上的 0 点到 a点之间往返，每消耗一升汽油能行驶一个单位长度。油箱容量为 b ，在 0 点和 a点之间有一个加油站，位置是 f 点，在加油站，校车能把油加满。校车从 0点出发，出发时油是满的。我们称校车从 0 点到 a 点或者从 a 点到 0点为一趟，请问要进行 k 趟，校车最少要加几次油。</p><p>将 0 - a 的 k 次往返的路径展开为一条轴，则题目变成小车从 0 驶向 k·a的单项行驶，再考虑加油站与油箱最大容积的问题。每次 while循环为当前点加满油驶向下一个最远的加油站的计算，若移动后位置不变，则为无法驶向下一个加油站，若情况满足直接输出“无解”；还要考虑是否为起步，是否已经为第k 趟，能否直接到达终点。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a,b,f,k;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;k;    <span class="hljs-keyword">int</span> x=f,y=a-f;    <span class="hljs-keyword">if</span>(b&lt;x)&#123;        cout&lt;&lt;<span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> l,r,o,m;    r=k;l=<span class="hljs-number">1</span>;    o=b-x;    m=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> xy=<span class="hljs-number">2</span>*x+<span class="hljs-number">2</span>*y;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> mm=<span class="hljs-number">1</span>;    <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span>    <span class="hljs-keyword">while</span>(l&lt;=r)&#123;        <span class="hljs-keyword">if</span>(l==r)&#123;            <span class="hljs-keyword">if</span>(o&gt;=(m==<span class="hljs-number">0</span>?y:x))                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">int</span> l1=l;        l+=(o/xy)*<span class="hljs-number">2</span>;        o=o%xy;        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(o&gt;=<span class="hljs-number">2</span>*y)&#123;                l++;                m=<span class="hljs-number">1</span>;                o-=<span class="hljs-number">2</span>*y;            &#125;                        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(o&gt;=<span class="hljs-number">2</span>*x)&#123;                l++;                m=<span class="hljs-number">0</span>;                o-=<span class="hljs-number">2</span>*x;            &#125;        &#125;        <span class="hljs-comment">//cout&lt;&lt;o&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(l==r)&#123;            <span class="hljs-keyword">if</span>(o&gt;=(m==<span class="hljs-number">0</span>?y:x))                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">break</span>;        o=b;        ans++;        <span class="hljs-keyword">if</span>(l==l1&amp;&amp;mm!=<span class="hljs-number">1</span>)&#123;            ans=<span class="hljs-number">-1</span>;            <span class="hljs-keyword">break</span>;        &#125;        mm=<span class="hljs-number">0</span>;        <span class="hljs-comment">//cout&lt;&lt;l&lt;&lt;&quot;:&quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl;</span>    &#125;    cout&lt;&lt;ans;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre></div><h2 id="e---codeforces-753a-送给你的新年礼物">E - CodeForces 753A送给你的新年礼物 √</h2><p>签到题，构造红包数最多的情况</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;n-k&gt;=<span class="hljs-number">0</span>;k++)&#123;        n-=k;    &#125;    k--;    cout&lt;&lt;k&lt;&lt;endl;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,k<span class="hljs-number">-1</span>)        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    cout&lt;&lt;k+n;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre></div><h2 id="f---codeforces-923a-升级">F - CodeForces 923A 升级 ×</h2><p>一个数论</p><p>【题解】</p><blockquote><p>考虑怎么得到数字x2=N,假设是质数p的倍数那么x1肯定在x2-p+1~x2这个范围内才行 因为p的倍数要刚好大于等于x1,所以x1肯定是在这两个倍数之间才行 结果已经很显然了 肯定让p的值越大越好。这样得到的x1才可能越小。 枚举x1在x2-p+1~x2之间。用同样的方式得到x0就好。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> x0,x1,x2;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxfac</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> j = x;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;        <span class="hljs-keyword">if</span> (x%i==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">while</span> (x%i==<span class="hljs-number">0</span>)&#123;                x/=i;            &#125;            j = i;        &#125;    &#125;    <span class="hljs-keyword">if</span> (x&gt;<span class="hljs-number">1</span>) j = x;    <span class="hljs-keyword">return</span> j;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>),cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; x2;    <span class="hljs-keyword">int</span> p = x2-<span class="hljs-built_in">maxfac</span>(x2)+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ans = x2;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x1 = p;x1 &lt;= x2;x1++)&#123;        <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">maxfac</span>(x1);        <span class="hljs-keyword">if</span> (temp!=x1)&#123;            x0 = x1-temp+<span class="hljs-number">1</span>;            ans = <span class="hljs-built_in">min</span>(ans,x0);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n,ans;<span class="hljs-keyword">int</span> f[maxn]; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x&lt;y?x:y; &#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    ans = n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++) &#123;        <span class="hljs-keyword">if</span> (!f[i]) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*i; j&lt;=n; j+=i) f[j] = i;        &#125;        f[i] = i-f[i]+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=f[n]; i&lt;=n; i++) ans = <span class="hljs-built_in">Min</span>(ans,f[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="g---codeforces-961d-贯穿">G - CodeForces 961D 贯穿 √</h2><p><strong>题目复述：</strong>对于二维坐标系上的给出的一系列点，是否能用两条直线涵盖所有点。（n&lt;100000）</p><p><strong>解题思路：</strong>我们假设题目成立，在条件成立的情况下，尝试找到这两条直线。对于这一系列点的任意三个点，三个点表示的三条直线中一定有一条为两条直线中的一条。即，对次三条线各做一次尝试，若被第一条线排除后的点能被另一条线贯穿则题目成立。三条线都不满足则题目不成立。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> ll maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<span class="hljs-keyword">const</span> ll inf = <span class="hljs-number">0x3f3f3f3f</span>; ll n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    ll x, y;&#125;pre[maxn];<span class="hljs-keyword">bool</span> vis[maxn]; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">kkk</span><span class="hljs-params">(node a, node b, node c)</span></span>&#123;<span class="hljs-comment">//注意不能用除法</span>    ll k1 = (b.y-a.y)*(c.x-a.x);    ll k2 = (c.y-a.y)*(b.x-a.x);    <span class="hljs-keyword">return</span> k1==k2?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll a, ll b)</span></span>&#123;         <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));    vis[a] = vis[b] = <span class="hljs-literal">true</span>;         <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        <span class="hljs-keyword">if</span> (i == a || i == b) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">kkk</span>(pre[a], pre[b], pre[i])) vis[i] = <span class="hljs-literal">true</span>;    &#125;    ll p1=<span class="hljs-number">-1</span>, p2=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        <span class="hljs-keyword">if</span> (!vis[i])&#123;            <span class="hljs-keyword">if</span>(p1 == <span class="hljs-number">-1</span>) &#123;p1=i;&#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2==<span class="hljs-number">-1</span>)&#123;p2=i;&#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (p1==<span class="hljs-number">-1</span>||p2==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        <span class="hljs-keyword">if</span> (i == p1 || i == p2) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; !<span class="hljs-built_in">kkk</span>(pre[p1], pre[p2], pre[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        cin&gt;&gt;pre[i].x&gt;&gt;pre[i].y;           &#125;    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span> || <span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) || <span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) || <span class="hljs-built_in">check</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="h---codeforces-733d-球球人">H - CodeForces 733D 球球人 √</h2><p><strong>题目复述：</strong> 对于 n个长方体，输出能使得单个或两个长方体拼合的新长方体的最短棱长最长的情况。（n&lt;100000）</p><p>我最开始以为可以无数个长方体拼在一起，就放了，后来才发现只能两个或一个。</p><p><strong>解题思路：</strong></p><p>考虑单个：直接一边读入，一边记录长方体的最短棱长的最长值和长方体对应编号</p><p>考虑两个：两个长方体能拼合当且仅当两个长方体各有两条棱长对应相等，而为了使得拼合后超越单个的情况，拼合的两个长方体一定是补短，即拼合的面是最长棱和第二长棱构成的面。考虑时间复杂度不能两两匹配尝试，考虑将最长棱和第二长棱相同的长方体聚集在一起，考虑以第二棱长、第一棱长、第三棱长的优先级排序O(nlogn)，再线性的扫描一遍，因为能拼合的一定相邻，最大的情况只可能为第二棱长、第一棱长相同的，且第三棱长在此基础上最长的两个，一定相邻。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100000</span>+<span class="hljs-number">100</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> a,b,c;<span class="hljs-keyword">int</span> k;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sor</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b);        <span class="hljs-keyword">if</span>(b&gt;c) <span class="hljs-built_in">swap</span>(b,c);        <span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b);    &#125;&#125;x[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node e1,node e2)</span></span>&#123;    <span class="hljs-keyword">if</span>(e1.b!=e2.b) <span class="hljs-keyword">return</span> e1.b&gt;e2.b;    <span class="hljs-keyword">if</span>(e1.c!=e2.c) <span class="hljs-keyword">return</span> e1.c&gt;e2.c;    <span class="hljs-keyword">return</span> e1.a&gt;e2.a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> ma=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>,q=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        cin&gt;&gt;x[i].a&gt;&gt;x[i].b&gt;&gt;x[i].c;        x[i].k=i;        x[i].<span class="hljs-built_in">sor</span>();        <span class="hljs-keyword">if</span>(x[i].a&gt;ma)&#123;            ma=x[i].a;            p=i;        &#125;    &#125;    <span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+n,cmp);    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;        <span class="hljs-keyword">if</span>(x[i].b&lt;=ma) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(x[i].b==x[i+<span class="hljs-number">1</span>].b&amp;&amp;x[i].c==x[i+<span class="hljs-number">1</span>].c)&#123;            <span class="hljs-keyword">if</span>(x[i].a+x[i+<span class="hljs-number">1</span>].a&gt;ma)&#123;                ma=x[i].a+x[i+<span class="hljs-number">1</span>].a;                p=x[i].k;                q=x[i+<span class="hljs-number">1</span>].k;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(q)&#123;        cout&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;endl;        cout&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;q;    &#125;<span class="hljs-keyword">else</span>&#123;        cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;        cout&lt;&lt;p;    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre></div><h2 id="i---codeforces-687c-经验书">I - CodeForces 687C 经验书</h2><p>题意：给你n个数，然后让这些数相加组合，然后在这些组合的数里可以再相加组合搞出给定k，输出这些组合的数。</p><p>思路： DP。 <code>dp[i][j]</code>代表数值为i时值为j能否被构成那么如果<code>dp[i][j]</code>能被构成那么<code>dp[i+x][j]</code> <code>dp[i+x][j+x]</code>都能被构成，这样状态转移方程就出来了</p><p>在枚举到第i个coin的时，<code>dp[i][j]</code>,i肯定能被<code>a[i]</code>组合，<br />然后再枚举<code>&lt;=a[i]</code>的部分，<code>dp[i][j]</code>的具体意义就是在coin值是i的时候，能用j去组合。<br />为了防止重复利用coin，从j枚举到<code>a[i]</code>;<br />最后<code>dp[k][h]==1</code>的把h塞到容器里去，最后输出。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> qq = <span class="hljs-number">505</span>;<span class="hljs-keyword">int</span> dp[qq][qq];<span class="hljs-comment">//代表当数值为i的时候，j数字能否被构成 </span><span class="hljs-keyword">int</span> num[qq]; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n,k;cin &gt;&gt; n &gt;&gt; k;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>; l&lt;n; ++l)&#123;<span class="hljs-keyword">int</span> x; cin &gt;&gt; x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k; i&gt;=x; --i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;=k-x; ++j)<span class="hljs-keyword">if</span>(dp[i-x][j])dp[i][j] = dp[i][j+x] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=k; ++i)<span class="hljs-keyword">if</span>(dp[k][i])num[tot++] = i;cout &lt;&lt; tot &lt;&lt; endl;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tot; ++i)cout &lt;&lt; num[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;cout &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>典型相关分析</title>
      <link href="/2022/02/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>典型相关分析 （Canonical Correlation Analysis ，CCA）<br />是为了研究两组变量（向量）之间的关联关系，其目的是找出两组变量的各自的<span class="math inline">\(r\)</span>组线性组合，线性组合的相关性从大到小排列，以主成分思想衡量两组变量之间的线性关系。</p><p><spanclass="math display">\[[\boldsymbol{x}_1,\boldsymbol{x}_2,\dotsb,\boldsymbol{x}_p],[\boldsymbol{y}_1,\boldsymbol{y}_2,\dotsb,\boldsymbol{y}_q]\]</span></p><p>首先分别在每组变量中找出第 <span class="math inline">\(k\)</span>对线性组合，使其具有第 <span class="math inline">\(k\)</span>大最大相关性，即</p><p><span class="math display">\[\left\{\begin{matrix}  \boldsymbol{u}_k=\alpha_{k1}\boldsymbol{x}_1+\alpha_{k2}\boldsymbol{x}_2+\dotsb+\alpha_{kp}\boldsymbol{x}_p\\\boldsymbol{v}_k=\alpha_{k1}\boldsymbol{y}_1+\alpha_{k2}\boldsymbol{y}_2+\dotsb+\alpha_{kq}\boldsymbol{y}_q\end{matrix}\right. \]</span> <spanclass="math display">\[\left(k=1,2,\dotsb,r \small \leqslant\min(p,q)\right)\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{u}_k\)</span> 与 <spanclass="math inline">\(\boldsymbol{u}_1,\boldsymbol{u}_2,\dots,\boldsymbol{u}_{k-1}\)</span>线性无关， <span class="math inline">\(\boldsymbol{v}_k\)</span> 与<spanclass="math inline">\(\boldsymbol{v}_1,\boldsymbol{v}_2,\dots,\boldsymbol{v}_{k-1}\)</span>线性无关，且相关性从小到大依次排列。</p><h1 id="典型相关分析数学模型">典型相关分析数学模型</h1><h2 id="典型相关和典型相关变量定义">典型相关和典型相关变量定义</h2><p>设两组随机变量为 <span class="math inline">\(\small\boldsymbol{X}=[\boldsymbol{x}_1,\boldsymbol{x}_2,\dotsb,\boldsymbol{x}_p]^T,\boldsymbol{Y}=[\boldsymbol{y}_1,\boldsymbol{y}_2,\dotsb,\boldsymbol{y}_q]^T\)</span>。我们希望找到 <span class="math inline">\(\small\boldsymbol{\alpha}=[\alpha_1,\dotsb,\alpha_p],\boldsymbol{\beta}=[\beta_1,\dotsb,\beta_p]\)</span> 使得 <spanclass="math inline">\(\small\rho(\boldsymbol{\alpha}\boldsymbol{X},\boldsymbol{\beta}\boldsymbol{Y})\)</span>最大。由相关系数定义：</p><p><span class="math display">\[\rho\left(\boldsymbol{\alpha X},\boldsymbol{\betaY}\right)=\frac{\operatorname{Cov}\left(\boldsymbol{\alphaX},\boldsymbol{ \betaY}\right)}{\sqrt{\operatorname{Var}\left(\boldsymbol{\alpha X}\right)}\sqrt{\operatorname{Var}\left(\boldsymbol{\beta Y}\right)}}\]</span></p><p>对于任意常数 <span class="math inline">\(k_1,k_2,c_1,c_2\)</span> 有<span class="math display">\[\rho(k_1\boldsymbol{\alphaX}+c_1,k_2\boldsymbol{\beta Y}+c_2)=\rho(\boldsymbol{\alphaX},\boldsymbol{\beta Y})\]</span></p><p>说明 <span class="math inline">\(\boldsymbol{\alphaX},\boldsymbol{\beta Y}\)</span> 不唯一，故限定 <spanclass="math inline">\(\small{Var}(\boldsymbol{\alphaX})=1,Var(\boldsymbol{\beta Y})=1\)</span> 即满足与协方差矩阵的关系<span class="math inline">\(\small\boldsymbol{\alpha}\boldsymbol{\Sigma}_{\tiny\boldsymbol{XX}}\boldsymbol{\alpha}^T=1,\boldsymbol{\beta}\boldsymbol{\Sigma}_{\tiny\boldsymbol{YY}}\boldsymbol{\beta}^T=1\)</span> 。</p><p>如果存在 <spanclass="math inline">\(\boldsymbol{\alpha}_k=[\alpha_{k1},\alpha_{k2},\dotsb,\alpha_{kp}],\boldsymbol{\beta}_k=[\beta_{k1},\beta_{k2},\dotsb,\beta_{kq}]\)</span>使得</p>$$ {<span class="math display">\[\begin{array}{l}\rho(\boldsymbol{\alpha}_k\boldsymbol{X},\boldsymbol{\alpha}_j\boldsymbol{X})=0,\rho(\boldsymbol{\beta}_k\boldsymbol{Y},\boldsymbol{\beta}_j\boldsymbol{Y})=0,\smallj=1,2,\dots,k-1&amp;\\\rho(\boldsymbol{\alpha}_k\boldsymbol{X},\boldsymbol{\beta}_k\boldsymbol{Y})=\max_{}\rho(\boldsymbol{\alpha}\boldsymbol{X},\boldsymbol{\beta}\boldsymbol{Y})&lt;\rho(\boldsymbol{\alpha}_{k-1}\boldsymbol{X},\boldsymbol{\beta}_{k-1}\boldsymbol{Y})\\\boldsymbol{\alpha}_k\boldsymbol{\Sigma}_{\tiny\boldsymbol{XX}}\boldsymbol{\alpha}_k^T=1,\boldsymbol{\beta}_k\boldsymbol{\Sigma}_{\tiny\boldsymbol{YY}}\boldsymbol{\beta}_k^T=1\\\end{array}\]</span><p>. $$</p><p>则称 <spanclass="math inline">\(\boldsymbol{\alpha}_k\boldsymbol{X},\boldsymbol{\beta}_k\boldsymbol{Y}\)</span>是 <span class="math inline">\(\boldsymbol{X},\boldsymbol{Y}\)</span>的<strong>第 <span class="math inline">\(k\)</span>对（组）典型相关变量</strong>，他们之间的相关系数称之为<strong>第 <spanclass="math inline">\(k\)</span> 个典型相关系数</strong> <spanclass="math inline">\(\small\left(k=1,2,\dots,min(p,q)\right)\)</span>。</p><h2 id="典型相关变量的解法">典型相关变量的解法</h2><p>将两组变量的协方差矩阵分块得</p><p><span class="math display">\[Cov\begin{bmatrix}\boldsymbol{X} \\\boldsymbol{Y} \\\end{bmatrix}     =\begin{bmatrix}  Var(\boldsymbol{X})&amp; Cov(\boldsymbol{X},\boldsymbol{Y})   \\Cov(\boldsymbol{Y},\boldsymbol{X}) &amp;Var(\boldsymbol{Y})  \\     \end{bmatrix}=\begin{bmatrix}  \boldsymbol{\Sigma_{XX}} &amp;\boldsymbol{\Sigma_{XY}}   \\ \boldsymbol{\Sigma_{YX}}&amp;  \boldsymbol{\Sigma_{YY}} \\     \end{bmatrix}\]</span></p><p>此时</p><p><spanclass="math display">\[\rho(\boldsymbol{u},\boldsymbol{v})=\frac{Cov(\boldsymbol{\alphaX},\boldsymbol{\beta Y})}{\sqrt{D(\boldsymbol{\alphaX})}\sqrt{D(\boldsymbol{\beta Y})}}=\boldsymbol{\alpha\Sigma_{\tinyXY}\beta^T}\]</span></p><p>此问题转换为在 <span class="math inline">\(\small\boldsymbol{\alpha}\boldsymbol{\Sigma}_{\tiny\boldsymbol{XX}}\boldsymbol{\alpha}^T=1,\boldsymbol{\beta}\boldsymbol{\Sigma}_{\tiny\boldsymbol{YY}}\boldsymbol{\beta}^T=1\)</span> 条件下求 <spanclass="math inline">\(\small \boldsymbol{\alpha\Sigma_{\tiny XY}\beta^T}\)</span> 的极大值。</p><p>引入拉格朗日乘数 <span class="math inline">\(\lambda,\omega\)</span>即问题为求下式的最大值。</p><p><spanclass="math display">\[S(\boldsymbol{\alpha},\boldsymbol{\beta})=\boldsymbol{\alpha\Sigma_{\tinyXY}\beta^T}-\frac{\lambda}{2}(\boldsymbol{\alpha}\boldsymbol{\Sigma}_{\tiny\boldsymbol{XX}}\boldsymbol{\alpha}^T-1)-\frac{\omega}{2}(\boldsymbol{\beta}\boldsymbol{\Sigma}_{\tiny\boldsymbol{YY}}\boldsymbol{\beta}^T-1)\]</span></p><p>由极值的必要条件得到偏导方程组</p><p><span class="math display">\[\left\{\begin{matrix}  \frac{\partial S}{\partial \boldsymbol{\alpha}}=\boldsymbol{\Sigma_{\tiny XY}\beta }-\lambda\boldsymbol{\Sigma_{\tiny XX}\alpha }=0\\  \frac{\partial S}{\partial \boldsymbol{\beta}}=\boldsymbol{\Sigma_{\tiny YX}\alpha }-\omega\boldsymbol{\Sigma_{\tiny YY}\beta }=0\\\end{matrix}\right.\]</span></p><p>中间过程略，详见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第268页.">[1]</span></a></sup>或<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="高惠璇. 应用多元统计分析[M]. 第2版. 第354页.">[3]</span></a></sup>。得</p><p><span class="math display">\[\left\{\begin{matrix}  \left(\boldsymbol{\Sigma_{XY}}\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}}-\lambda^2\boldsymbol{\Sigma_{XX}}\right)\boldsymbol{\alpha}=0\\  \left(\boldsymbol{\Sigma_{YX}}\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}-\lambda^2\boldsymbol{\Sigma_{YY}}\right)\boldsymbol{\beta}=0\\\end{matrix}\right.\]</span></p><p>记</p><p><spanclass="math display">\[M_1=\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}},M_{2}=\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}}\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}\]</span></p><p>得</p><p><spanclass="math display">\[M_1\boldsymbol{\alpha}=\lambda^2\boldsymbol{\alpha},M_2\boldsymbol{\beta}=\lambda^2\boldsymbol{\beta}\]</span></p><p>记 <span class="math inline">\(\smallT=\boldsymbol{\Sigma_{XX}^{-1/2}\Sigma_{XY}\Sigma_{YY}^{-1/2}}\)</span>有 <span class="math inline">\(\smallM_1=TT^{\prime},M_2=T^{\prime}T\)</span> 故 <spanclass="math inline">\(M_1,M_2\)</span> 有相同的非零特征值</p><p>说明 <span class="math inline">\(\lambda^2\)</span> 既是 <spanclass="math inline">\(M_1\)</span> 又是 <spanclass="math inline">\(M_2\)</span> 的特征根， <spanclass="math inline">\(\boldsymbol{\alpha},\boldsymbol{\beta}\)</span>是对应的特征向量， <span class="math inline">\(M_1,M_2\)</span>的特征根非负数且在区间 <span class="math inline">\([0,1]\)</span>上，非零特征根的数量不妨设为 <span class="math inline">\(\smallr=\min(p,q)\)</span>。</p><p>设特征根排列为 <span class="math inline">\(\small \lambda_1^2 \ge\lambda_2^2 \ge \dotsb \ge \lambda_r^2\)</span> 其余特征根为 <spanclass="math inline">\(0\)</span> ,称 <spanclass="math inline">\(\lambda_1,\lambda_2,\dotsb,\lambda_r\)</span>为典型相关系数。对应从 <span class="math inline">\(\smallM_1\boldsymbol{\alpha}=\lambda^2\boldsymbol{\alpha}\)</span>解出的特征向量为 <span class="math inline">\(\small\boldsymbol{\alpha}_1,\dotsb,\boldsymbol{\alpha}_r\)</span> ；从 <spanclass="math inline">\(\smallM_2\boldsymbol{\beta}=\lambda^2\boldsymbol{\beta}\)</span>解出的特征向量为 <span class="math inline">\(\small\boldsymbol{\beta}_1,\dotsb,\boldsymbol{\beta}_r\)</span> 。可得到 <spanclass="math inline">\(\boldsymbol{u_k}\)</span> <spanclass="math inline">\(\boldsymbol{v_k}\)</span> 的线性组合： <spanclass="math display">\[\boldsymbol{u}_k=\boldsymbol{\alpha}_k\boldsymbol{X},\boldsymbol{v}_k=\boldsymbol{\beta}_k\boldsymbol{X},k=1,2,\dotsb,r,\]</span></p><p>满足：</p><p><spanclass="math display">\[Cov(\boldsymbol{u}_i,\boldsymbol{u}_j)=0,Cov(\boldsymbol{v}_i,\boldsymbol{v}_j)=0,{\smalli \ne j}\\Cov(\boldsymbol{u}_i,\boldsymbol{v}_i)=\lambda_i,Cov(\boldsymbol{u}_i,\boldsymbol{v}_j)=0,\smalli \ne j\]</span></p><h1 id="样本典型相关分析步骤">样本典型相关分析步骤</h1><p>设样本总体 <span class="math inline">\(\small\boldsymbol{Z}=[\boldsymbol{x}_1,\dotsb,\boldsymbol{x}_p,\boldsymbol{y}_1,\dotsb,\boldsymbol{y}_q]^T\)</span></p><p>对于每次观测</p><p><span class="math display">\[Z_{(t)}=\left[\begin{array}{l}\boldsymbol{X}_{(t)} \\\boldsymbol{Y}_{(t)}\end{array}\right]_{(p+q) \times 1} \quad(t=1,2, \cdots, n)\]</span></p><p>于是样本数据矩阵为</p><p><span class="math display">\[\left(\left[\begin{array}{cccc:cccc}x_{11} &amp; x_{21} &amp; \cdots &amp; x_{p1} &amp; y_{11} &amp; y_{21}&amp; \cdots &amp; y_{q1} \\x_{12} &amp; x_{22} &amp; \cdots &amp; x_{p2} &amp; y_{12} &amp; y_{22}&amp; \cdots &amp; y_{q2} \\\vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots &amp; \vdots &amp;&amp; \vdots \\x_{1n} &amp; x_{2n} &amp; \cdots &amp; x_{pn} &amp; y_{1n} &amp; y_{2n}&amp; \cdots &amp; y_{qn}\end{array}\right]^T\right)_{(p+q)\times n}\]</span></p><p>协方差矩阵的无偏估计为</p><p><span class="math display">\[\boldsymbol{\hat{\Sigma}}=\frac{1}{n-1}\sum_{t=1}^{n}\left(Z_{(t)}-\bar{Z}\right)\left(Z_{(t)}-\bar{Z}\right)^{\prime}\]</span></p><p>其中 <spanclass="math inline">\(\bar{Z}=\frac{1}{n}\sum\limits_{i=1}^nX_{(i)}\)</span></p><p>记样本矩阵 <span class="math inline">\(\boldsymbol{Z}_{\tiny(p+q)\times n}\)</span> 每个元素减去每一行的平均值得到矩阵 <spanclass="math inline">\(\boldsymbol{Z}^*_{\tiny (p+q)\timesn}\)</span></p><p><spanclass="math display">\[\boldsymbol{\hat{\Sigma}}=\frac{1}{n-1}\boldsymbol{Z}^*(\boldsymbol{Z}^*)^T=\left[\begin{array}{c:c}\boldsymbol{\hat{\Sigma}_{\tiny XX}} &amp;\boldsymbol{\hat{\Sigma}_{\tiny XY}} \\\hdashline \boldsymbol{\hat{\Sigma}_{\tiny Y X}} &amp;\boldsymbol{\hat{\Sigma}_{\tiny YY}}\end{array}\right]\begin{array}{c}\tiny p\\\tiny q\end{array}\]</span></p><h2 id="样本典型相关变量和系数">样本典型相关变量和系数</h2><p>以下用 <span class="math inline">\(\boldsymbol{\hat{\Sigma}}\)</span>替换 <span class="math inline">\(\boldsymbol{\Sigma}\)</span> 。</p><ul><li><strong>方法一</strong></li></ul><p>记</p><p><spanclass="math display">\[M_1=\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}}\\M_{2}=\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}}\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}\]</span></p><p>分别求出 <span class="math inline">\(M_1,M_2\)</span>的特征值与特征向量，特征值从大到小排列为 <spanclass="math inline">\(\lambda_1^2,\lambda_2^2,\dots\)</span>，其对应的特征向量分别为 <spanclass="math inline">\((\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\dots)\)</span>和 <spanclass="math inline">\((\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\dots)\)</span></p><ul><li><strong>方法二</strong></li></ul><p>令 <spanclass="math inline">\(T=\boldsymbol{\Sigma_{XX}^{-1/2}\Sigma_{XY}\Sigma_{YY}^{-1/2}}\)</span>，计算 <span class="math inline">\(TT^{\prime}\)</span>的特征值从大到小排列为 <spanclass="math inline">\(\lambda_1^2,\lambda_2^2,\dots\)</span> ，记 <spanclass="math inline">\(\boldsymbol{l}_k\)</span> 为 <spanclass="math inline">\(TT^{\prime}\)</span> 的特征根 <spanclass="math inline">\(\lambda_k^2\)</span>对应的单位正交特征向量。令</p><p><span class="math display">\[\left\{\begin{array}{c}  \boldsymbol{\alpha}_k=\boldsymbol{\Sigma_{\tinyXX}^{-1/2}}\boldsymbol{l}_k,\\  \boldsymbol{\beta}_k=\lambda_k^{-1}\boldsymbol{\Sigma_{\tinyYY}^{-1}\Sigma_{YX}}\boldsymbol{\alpha}_k,\end{array}\right.\]</span></p><h2 id="原始变量与典型变量相关性">原始变量与典型变量相关性</h2><h3 id="原始变量与典型变量的相关系数">原始变量与典型变量的相关系数</h3><p><span class="math display">\[\begin{array}{l}\rho\left(\boldsymbol{x}_{i},\boldsymbol{u}_{j}\right)=\sum\limits_{k=1}^{p} \alpha_{k j}\operatorname{Cov}\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{k}\right) /\sqrt{D\left(\boldsymbol{x}_{i}\right)}, j=1, \cdots, s_{\circ} \\\rho\left(\boldsymbol{x}_{i},\boldsymbol{v}_{j}\right)=\sum\limits_{k=1}^{q} \beta_{k j}\operatorname{Cov}\left(\boldsymbol{x}_{i}, \boldsymbol{y}_{k}\right) /\sqrt{D\left(\boldsymbol{x}_{i}\right)}, j=1, \cdots, s, \\\rho\left(\boldsymbol{y}_{i},\boldsymbol{u}_{j}\right)=\sum\limits_{k=1}^{p} \alpha_{k j}\operatorname{Cov}\left(\boldsymbol{y}_{i}, \boldsymbol{x}_{k}\right) /\sqrt{D\left(\boldsymbol{y}_{i}\right)}, j=1, \cdots, s, \\\rho\left(\boldsymbol{y}_{i},\boldsymbol{v}_{j}\right)=\sum\limits_{k=1}^{q} \beta_{k j}\operatorname{Cov}\left(\boldsymbol{y}_{i}, \boldsymbol{y}_{k}\right) /\sqrt{D\left(\boldsymbol{y}_{i}\right)}, j=1, \cdots, s_{\circ}\end{array}\]</span></p><h3id="各组原始变量被典型变量所解释的方差比例">各组原始变量被典型变量所解释的方差比例</h3><p>原始变量 <span class="math inline">\(\boldsymbol{X}\)</span> 被 <spanclass="math inline">\(\boldsymbol{u}_i\)</span> 解释的方差比例 <spanclass="math display">\[m_{u_i}=\sum_{k=1}^p\rho^2(\boldsymbol{u}_i,\boldsymbol{x}_k)/p\]</span></p><p>原始变量 <span class="math inline">\(\boldsymbol{X}\)</span> 被 <spanclass="math inline">\(\boldsymbol{v}_i\)</span> 解释的方差比例 <spanclass="math display">\[m_{v_i}=\sum_{k=1}^p\rho^2(\boldsymbol{v}_i,\boldsymbol{x}_k)/p\]</span></p><p>原始变量 <span class="math inline">\(\boldsymbol{Y}\)</span> 被 <spanclass="math inline">\(\boldsymbol{u}_i\)</span> 解释的方差比例 <spanclass="math display">\[n_{u_i}=\sum_{k=1}^q\rho^2(\boldsymbol{u}_i,\boldsymbol{y}_k)/q\]</span></p><p>原始变量 <span class="math inline">\(\boldsymbol{Y}\)</span> 被 <spanclass="math inline">\(\boldsymbol{v}_i\)</span> 解释的方差比例 <spanclass="math display">\[n_{v_i}=\sum_{k=1}^q\rho^2(\boldsymbol{v}_i,\boldsymbol{y}_k)/q\]</span></p><h2 id="样本典型相关系数显著性检验">样本典型相关系数显著性检验</h2><h3 id="整体检验">整体检验</h3><p><spanclass="math display">\[H_0:\lambda_1=\lambda_2=\dotsb=\lambda_r=0\quad,{\tiny即\boldsymbol{\Sigma_{\tiny XY}}=0}\\H_1:\lambda_i\small(i=1,2,\dots,r)中至少有一个非0,{\tiny即\boldsymbol{\Sigma_{\tinyXY}}\ne0}\]</span></p><p>记 <spanclass="math display">\[\Lambda_{1}=\frac{|\hat{\boldsymbol{\Sigma}}|}{\left|\hat{\boldsymbol{\Sigma}}_{XX}\right|\left|\hat{\boldsymbol{\Sigma}}_{Y Y}\right|}\\\]</span> 得<spanclass="math display">\[\Lambda_{1}=\left|\boldsymbol{I}_{p}-\hat{\boldsymbol{\Sigma}}_{XX}^{-1} \hat{\boldsymbol{\Sigma}}_{X Y} \hat{\boldsymbol{\Sigma}}_{YY}^{-1} \hat{\boldsymbol{\Sigma}}_{YX}\right|=\prod_{i=1}^{r}\left(1-\lambda_{i}^{2}\right)\]</span></p><p>验证统计量 <spanclass="math display">\[Q_{1}=-\left[n-1-\frac{1}{2}(p+q+1)\right] \ln\Lambda_{1}\]</span></p><p>近似服从自由度为 <span class="math inline">\(pq\)</span> 的 <spanclass="math inline">\(\chi ^2\)</span> 分布，在给定的显著性水平 <spanclass="math inline">\(\alpha\)</span> 下，若 <spanclass="math inline">\(Q_1\ge \chi_\alpha^2(pq)\)</span>，则拒绝原假设，认为至少第一对典型变量之间相关性显著。</p><h3 id="部分总体为零的检验">部分总体为零的检验</h3><p><spanclass="math display">\[H_0:\lambda_2=\lambda_3=\dotsb=\lambda_r=0,\\H_1:\lambda_2,\lambda_3,\dotsb,\lambda_r\small至少有一个非零\]</span></p><p>若原假设 <span class="math inline">\(H_0\)</span>被接受，则认为只有第一对典型变量有用；若 <spanclass="math inline">\(H_0\)</span>被拒绝，则第二对典型变量也有用，并进行进一步假设</p><p><spanclass="math display">\[H_0:\lambda_3=\lambda_4=\dotsb=\lambda_r=0,\\H_1:\lambda_3,\lambda_4,\dotsb,\lambda_r\small至少有一个非零\]</span></p><p>如此进行下去直到对于某个 <span class="math inline">\(k\)</span><br /><spanclass="math display">\[H_0:\lambda_k=\lambda_{k+1}=\dotsb=\lambda_r=0,\\H_1:\lambda_k,\lambda_{k+1},\dotsb,\lambda_r\small至少有一个非零\]</span></p><p>记</p><p><spanclass="math display">\[\Lambda_{k}=\prod_{i=k}^{r}\left(1-\lambda_{i}^{2}\right)\]</span>在原假设为真的情况下 <spanclass="math display">\[Q_k=-\left[n-k-\frac{1}{2}(p+q+1)\right] \ln\Lambda_{k}\]</span> 近似服从自由度为 <spanclass="math inline">\((p-k+1)(p-k+1)\)</span> 的 <spanclass="math inline">\(\chi ^2\)</span> 分布。在显著性水平 <spanclass="math inline">\(\alpha\)</span> 下若 <spanclass="math inline">\(Q_k\ge\chi_\alpha^2\left[(p-k+1)(p-k+1)\right]\)</span>，则拒绝原假设，则至少认为第 <span class="math inline">\(k\)</span>对典型变量之间相关性显著。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第268页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/372774724"class="uri">https://zhuanlan.zhihu.com/p/372774724</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>高惠璇. 应用多元统计分析[M].第2版. 第354页.<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相关系数矩阵 </tag>
            
            <tag> 典型相关分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因子分析</title>
      <link href="/2022/02/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因子分析（Factor Analysis，FA）<br />用少数几个假象变量来表示其根本的数据结构，能反应原来众多变量的主要信息。因子分析的前提条件是观测变量间有较强的相关性，这样才能有共享因子。</p><figure><img src="https://s2.loli.net/2022/02/18/56XgZSYPbUt9LHW.png"alt="高中生成绩分析" /><figcaption aria-hidden="true">高中生成绩分析</figcaption></figure><h1 id="步骤">步骤</h1><ul><li>选择分析变量</li><li>计算所选原始变量的相关系数矩阵</li><li>提取公共因子，确定因子数目</li><li>因子旋转，解释因子</li><li>计算因子得分</li></ul><h1 id="模型">模型</h1><blockquote><p>本文的变量名大体可分为三种：大写粗体、大写、小写。<br />大写粗体一般表示整个矩阵，一般为二维；大写参数一般表示为指标/因子，包含<span class="math inline">\(n\)</span>个元素（观测值）可以看作向量；小写表示元素或单个变量。</p></blockquote><h2 id="数学模型">数学模型</h2><p>记 <span class="math inline">\(m\)</span> 个观测值 <spanclass="math inline">\(X_i(i=1,2,\dots,m)\)</span> 可以表示为</p><p><span class="math display">\[X_{i}=\mu_{i}+\alpha_{i 1}F_{1}+\cdots+\alpha_{i m} F_{m}+\varepsilon_{i}\]</span></p><p>即 <span class="math display">\[\left[\begin{array}{c}X_{1} \\X_{2} \\\vdots \\X_{m}\end{array}\right]=\left[\begin{array}{c}\mu_{1} \\\mu_{2} \\\vdots \\\mu_{m}\end{array}\right]+\left[\begin{array}{cccc}\alpha_{11} &amp; \alpha_{12} &amp; \cdots &amp; \alpha_{1 r} \\\alpha_{21} &amp; \alpha_{22} &amp; \cdots &amp; \alpha_{2 r} \\\vdots &amp; \vdots &amp; &amp; \vdots \\\alpha_{m 1} &amp; \alpha_{m 2} &amp; \cdots &amp; \alpha_{m r}\end{array}\right]\left[\begin{array}{c}F_{1} \\F_{2} \\\vdots \\F_{r}\end{array}\right]+\left[\begin{array}{c}\varepsilon_{1} \\\varepsilon_{2} \\\vdots\\\varepsilon_{m}\end{array}\right]\]</span> 即 <spanclass="math display">\[\boldsymbol{X}-\boldsymbol{\mu}=\boldsymbol{\Lambda}\boldsymbol{F}+\boldsymbol{\varepsilon}\]</span></p><p>满足：</p><ol type="1"><li><span class="math inline">\(E(\boldsymbol{F})=0\)</span> 且 <spanclass="math inline">\(E(\boldsymbol{\varepsilon})=0\)</span></li><li>载荷因子 <span class="math inline">\(F_i\)</span> 之间无线性关系：<span class="math inline">\(Cov(\boldsymbol{F})=E_m\)</span></li><li>特殊因子 <span class="math inline">\(\varepsilon_i\)</span>之间无线性关系： <spanclass="math inline">\(Cov(\boldsymbol{\varepsilon})=D(\boldsymbol{\varepsilon})=diag(\sigma_1^2,\sigma _2^2,\dots,\sigma _m^2)\)</span></li><li>特殊因子和载荷因子无线性关系：<spanclass="math inline">\(Cov(\boldsymbol{F},\boldsymbol{\varepsilon})=0\)</span></li></ol><h3 id="模型的性质">模型的性质</h3><ul><li><strong>原子变量 <span class="math inline">\(\boldsymbol{X}\)</span>的协方差矩阵分解</strong></li></ul><p>由 <spanclass="math inline">\(\boldsymbol{X}-\boldsymbol{\mu}=\boldsymbol{\Lambda}\boldsymbol{F}+\boldsymbol{\varepsilon}\)</span>得 <spanclass="math inline">\(Cov(\boldsymbol{X}-\boldsymbol{\mu})=\boldsymbol{\Lambda}Cov(\boldsymbol{F})\boldsymbol{\Lambda}^T+Cov(\boldsymbol{\varepsilon})\)</span>即</p><p><spanclass="math display">\[Cov(\boldsymbol{X})=\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+D(\boldsymbol{\Lambda})\]</span></p><p><span class="math inline">\(\sigma _1^2,\sigma _2^2,\dots,\sigma_m^2\)</span> 的值越小，公共因子贡献成分越多。</p><ul><li><strong>因子载荷矩阵不唯一（可旋转的原因）</strong></li></ul><p>设 <span class="math inline">\(\Gamma\)</span> 是一个标准正交矩阵，有<spanclass="math display">\[\widetilde{\boldsymbol{\Lambda}}=\boldsymbol{\Lambda}\Gamma, \widetilde{\boldsymbol{F}}=\Gamma^{\tiny T}\boldsymbol{F} \]</span><spanclass="math display">\[\boldsymbol{X}=\boldsymbol{\mu}+\widetilde{\boldsymbol{\Lambda}}\widetilde{\boldsymbol{F}}+\boldsymbol{\varepsilon}\]</span></p><h3 id="载荷矩阵统计性质">载荷矩阵统计性质</h3><ul><li><strong><span class="math inline">\(\alpha_{i j}\)</span>的含义</strong></li></ul><p>因子载荷矩阵 <span class="math inline">\(\alpha_{i j}\)</span> 表示第<span class="math inline">\(i\)</span> 个变量与第 <spanclass="math inline">\(j\)</span> 个公共因子的相关系数，反应第 <spanclass="math inline">\(i\)</span> 个变量与第 <spanclass="math inline">\(j\)</span> 个公共因子的相关重要性。 <spanclass="math inline">\(|\alpha_{i j}|\)</span>越大，相关的密切程度越高。</p><ul><li><strong>变量共同度的统计意义</strong></li></ul><p>变量 <span class="math inline">\(X_i\)</span>的共同度是因子载荷矩阵第 <span class="math inline">\(i\)</span>行的元素平方和，记 <spanclass="math inline">\(h_i^2=\sum\limits_{j=1}^{r}\alpha_{ij}^2\)</span></p><p>因为</p><p><spanclass="math display">\[Var(X_i)=\alpha_{i1}^2Var(F_1)+\dots+\alpha_{ir}^2Var(F_r)+Var(\varepsilon_i)\]</span></p><p>得</p><p><spanclass="math display">\[1=\sum\limits_{j=1}^{r}\alpha_{ij}^2+\sigma_i^2\]</span></p><p>可以看出 <span class="math inline">\(h_i^2\)</span> 越靠近 <spanclass="math inline">\(1\)</span> ， <spanclass="math inline">\(\sigma_i^2\)</span> 越靠近 <spanclass="math inline">\(0\)</span> ， 原变量 <spanclass="math inline">\(X_i\)</span> 被公共因子表现的越好。</p><ul><li><strong>公共因子 <span class="math inline">\(F_j\)</span>的方差贡献统计意义</strong></li></ul><p>因子 <span class="math inline">\(F_j\)</span>的方差贡献和是因子载荷矩阵第 <span class="math inline">\(j\)</span>列的平方和，记为 <span class="math inline">\(S_j=\sum\limits_{i=1}^{m}\alpha_{ij}^2=\lambda_j\)</span></p><p>用于衡量 <span class="math inline">\(F_j\)</span> 的相对重要性。</p><ul><li><strong>残差阵</strong></li></ul><p>用原协方差阵减去公因子协方差阵与特殊因子协方差阵，得到残差阵</p><p><span class="math display">\[(\epsilon_{ij})_{m\times m} =\boldsymbol{R}-(\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+\boldsymbol{D})\]</span></p><p>残差阵元素的平方和为残差平方和</p><p><spanclass="math display">\[Q(m)=\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}\epsilon_{ij}^2\le \sum\limits_{k=r+1}^{m}\lambda_k^2\]</span></p><h2 id="因子载荷矩阵估计法">因子载荷矩阵估计法</h2><h3 id="主成分分析法">主成分分析法</h3><blockquote><p>和“主成分分析”本质相同，主成分分析是将样本经过载荷矩阵 <spanclass="math inline">\(\boldsymbol{P}\)</span>变换到坐标轴上使得坐标轴方向方差最大；因子分析的主成分分析法相当于主成分分析的逆过程，因子代表的<span class="math inline">\(\R^r\)</span> 空间上的点，经过因子载荷矩阵<span class="math inline">\(\boldsymbol{\Lambda}\)</span>变换后得原样本点。</p></blockquote><p>设样本相关系数矩阵为 <spanclass="math inline">\(\boldsymbol{R}\)</span> ，计算其特征值为 <spanclass="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_m\)</span>(<span class="math inline">\(\lambda_1\ge \lambda_2\ge \dots\ge\lambda_m\)</span>) ，对应的特征向量为 <spanclass="math inline">\(\boldsymbol{\eta} _1,\boldsymbol{\eta}_2,\dots,\boldsymbol{\eta} _m\)</span> ，记 <spanclass="math inline">\(\boldsymbol{H}=[\boldsymbol{\eta}_1,\boldsymbol{\eta }_2,\dots,\boldsymbol{\eta }_m]\)</span> 有</p><p><spanclass="math display">\[\boldsymbol{R}=\boldsymbol{H}\begin{bmatrix}  \boldsymbol{\lambda_1}&amp;  &amp;  &amp; \\  &amp; \boldsymbol{\lambda_2} &amp;  &amp; \\  &amp;  &amp;\ddots &amp; \\  &amp;  &amp;  &amp; \boldsymbol{\lambda_1}\end{bmatrix}\boldsymbol{H}^T=\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+D\]</span></p><p>（ <span class="math inline">\(\small\boldsymbol{D}\)</span>被忽略）即因子载荷矩阵为</p><p><spanclass="math display">\[\boldsymbol{\Lambda}=[\sqrt{\lambda_1}\boldsymbol{\eta_1},\sqrt{\lambda_2}\boldsymbol{\eta_2},\dots,\sqrt{\lambda_m}\boldsymbol{\eta_m}]\]</span></p><p>使得公共因子方差贡献<spanclass="math inline">\(S_j=\lambda_j\)</span></p><p>根据碎石图，用碎石原则确定因子个数 <spanclass="math inline">\(r\)</span>。</p><p>特殊因子方差可以用 <spanclass="math inline">\(\boldsymbol{R}-\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T\)</span>的主对角线元素估计： <spanclass="math display">\[\sigma_i^2=1-\sum_{j=1}^m\alpha_{ij}^2\]</span></p><p><strong>缺点</strong>：上式有一个假定，模型中的特殊因子是不重要的，因而从<span class="math inline">\(\boldsymbol{R}\)</span>的<strong>分解中忽略了特殊因子的方差</strong>。所得的特殊因子 <spanclass="math inline">\(\varepsilon_{1}，\varepsilon_{2},...,\varepsilon_{p}\)</span>之间并不相互独立，不完全符合假设前提。因此，当共同度较大时，特殊因子所起作用小时，它们之间存在的相关性所带来的影响可以几乎忽略。实际应用中，可以先用主成分法进行分析，再尝试其他方法。</p><h3 id="主因子法">主因子法</h3><p>主因子方法是对主成分方法的修正，假定我们首先对变量进行标准化变换。则</p><p><spanclass="math display">\[\boldsymbol{R}=\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+\boldsymbol{D}\\\boldsymbol{R}^*=\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T=\boldsymbol{R}-\boldsymbol{D}\]</span></p><p>式中 <span class="math inline">\(\boldsymbol{R}^*\)</span>为约相关系数矩阵，其对角线上的元素为 <spanclass="math inline">\(h_i^2\)</span> 。</p><p>特殊因子方差是未知的，一般通过样本估计得到。方法可以有；</p><ol type="1"><li>取 <span class="math inline">\(\hat{h_i^2}=1\)</span>，这种情况下主因子解与主成分分解等价</li><li>取 <span class="math inline">\(\hat{h_i^2}=\max\limits_{\tiny i \nej}|r_{ij}|\)</span> ，取 <span class="math inline">\(X_i\)</span>与其他指标简单相关系数最大者</li><li>取 <spanclass="math inline">\(\hat{h_i^2}=\frac{1}{m-1}\sum\limits_{sj=1,j\nei}^{m}r_{ij}\)</span> ，其中要求该值为正数</li></ol><p>记</p><p><spanclass="math display">\[\boldsymbol{R}^*=\boldsymbol{R}-\boldsymbol{D}=\left[\begin{array}{cccc}\hat{h_{1}^{2}} &amp; r_{12} &amp; \cdots &amp; r_{1 m} \\r_{21} &amp; \hat{h_{2}^{2}} &amp; \cdots &amp; r_{2 m} \\\vdots &amp; \vdots &amp; &amp; \vdots \\r_{m 1} &amp; r_{m 2} &amp; \cdots &amp; \hat{h_{m}^{2}}\end{array}\right]\]</span></p><p>直接求出 <span class="math inline">\(\boldsymbol{R}^*\)</span>的特征值为 <spanclass="math inline">\(\lambda_1^*,\lambda_2^*,\dots,\lambda_m^*\)</span>(<span class="math inline">\(\lambda_1^*\ge \lambda_2^*\ge \dots\ge\lambda_m^*\)</span>) ，和对应的特征向量为 <spanclass="math inline">\(\boldsymbol{\eta} _1^*,\boldsymbol{\eta}_2^*,\dots,\boldsymbol{\eta} _m^*\)</span> ，得到载荷矩阵：</p><p><spanclass="math display">\[\boldsymbol{\Lambda}=[\sqrt{\lambda_1^*}\boldsymbol{\eta}_1^*,\sqrt{\lambda_2^*}\boldsymbol{\eta}_2^*,\dots,\sqrt{\lambda_m^*}\boldsymbol{\eta}_m^*]\]</span></p><h3 id="极大似然估计法">极大似然估计法</h3><p>假设数据 <span class="math inline">\(X_1,...,X_n\)</span> 服从 <spanclass="math inline">\(m\)</span>元正态，公因子与特殊因子也假定服从正态。</p><p><span class="math display">\[L(\mu, \boldsymbol{\Lambda},\boldsymbol{D})=\prod_{i=1}^{d} \frac{1}{(2 \pi)^{m /2}|\boldsymbol{R}|^{1 / 2}} \exp\left[-\frac{1}{2}\left(\boldsymbol{X}_{\mathbf{i}}-\mu\right)^{\prime}\boldsymbol{\boldsymbol{R}}^{-1}\left(\boldsymbol{X}_{\mathbf{i}}-\mu\right)\right]\]</span></p><p>用数值极大化的方法可以得到极大似然估计。</p><p>Matlab 工具箱求因子载荷矩阵使用的是最大似然估计，其命令为<code>factoran</code> 。</p><h2 id="因子旋转">因子旋转</h2><p>建立因子模型不仅要得到公共因子，还要能解释这些公共因子的具体含义。</p><p>由于因子载荷矩阵不唯一，所以可以对载荷矩阵进行旋转，使得载荷矩阵每行或每列的元素平方值向<span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>两极分化，即使信息分布尽可能不均匀，也就是信息要集中分布于几个不同的因子上。</p><p><span class="math display">\[\boldsymbol{X} = \boldsymbol{\Lambda}\Gamma {\Gamma ^{ - 1}} \boldsymbol{F} +\boldsymbol{\varepsilon}\]</span></p><figure><img src="https://s2.loli.net/2022/02/18/jwF6TtrqLuAHeoD.png"alt="旋转结果（r=4）" /><figcaption aria-hidden="true">旋转结果（r=4）</figcaption></figure><p>因为是对整个 <span class="math inline">\(\R^r\)</span>的空间正交变换（可以理解为坐标轴旋转或者样本旋转），所以银子旋转不会是损耗信息量只会改变因子载荷矩阵的权重分配，<strong>变量共同度<span class="math inline">\(h_i^2\)</span>不变</strong>，<strong>因子方差贡献 <spanclass="math inline">\(S_j\)</span>不变</strong>（正交旋转不改变向量长度）。</p><p>对于任意两列，正交矩阵形式可以设为</p><p><span class="math display">\[\Gamma=\left[\begin{array}{ll} \cos \phi&amp; -\sin \phi \\ \sin \phi &amp; \cos \phi\end{array}\right]\\\]</span></p><p>带入得到</p><p><spanclass="math display">\[\boldsymbol{\Lambda}^*=\boldsymbol{\Lambda}\Gamma=\left[\begin{array}{ll} \alpha_{11} \cos \phi+\alpha_{12} \sin\phi &amp; -\alpha_{11} \sin \phi+\alpha_{12} \cos \phi \\ \vdots &amp;\vdots \\ \alpha_{p 1} \cos \phi+a_{p 2} \sin \phi &amp; -\alpha_{p 1}\sin \phi+\alpha_{p 2} \cos \phi \end{array}\right]=\left[\begin{array}{ll}\alpha_{11}^* &amp;  \alpha_{12}^*\\\vdots &amp;  \vdots \\\alpha_{m 1}^* &amp;\alpha_{m2}^*\end{array}\right]\]</span></p><h3 id="方差最大的正交旋转">方差最大的正交旋转</h3><p><strong>基本思想：</strong> <spanclass="math inline">\(\alpha_{ij}^*\)</span> 表示变量 <spanclass="math inline">\(i\)</span> 与因子 <spanclass="math inline">\(j\)</span>的关联程度，要使每一列的元素值越分散，就要<strong>使因子载荷矩阵的每一列元素的方差更大</strong>。</p><p>因为 <span class="math inline">\(r&lt;m\)</span>，每一行向量的长度不统一，所以先对每一行都除以共同度 <spanclass="math inline">\(h_i^2\)</span> ，记</p><p><span class="math display">\[d_{i j}=\frac{ { \alpha_{i j}^{*} }^2}{h_i^2} , \scriptsize  (i=1,2,\dots,m,j=1,2,\dots,r)\]</span></p><p>定义因子载荷第 j 列的方差为</p><p><span class="math display">\[V_{j}=\frac{1}{m}\sum\limits_{\tinyi=1}^{\tiny m}\left(d_{ij}^{2}-\bar{d}_{j}\right)^{2}=\frac{1}{m^2}\left[m \sum_{i=1}^{m}d_{ij}^2-{\left(\sum_{i=1}^{m} d_{ij}\right)}^{2}\right]\\\]</span></p><p>其中 <span class="math inline">\(\bar{d}_{j}=\frac{1}{m}\sum\limits_{\tiny i=1}^{\tiny m} d_{i j}^{2}\)</span></p><p>定义因子载荷矩阵 <spanclass="math inline">\(\boldsymbol{\Lambda}\)</span>的方差等于每一列的方差之和</p><p><spanclass="math display">\[V=\sum_{j=1}^rV_{j}=\frac{1}{m^2}\sum_{j=1}^{r}\left[m\sum_{i=1}^{m} d_{ij}^2-{\left(\sum_{i=1}^{m}d_{ij}\right)}^{2}\right]\]</span></p><ul><li><strong>二维空间</strong></li></ul><p>设因子载荷矩阵有两列 <span class="math inline">\(r=2\)</span> ，</p><p><spanclass="math display">\[\boldsymbol{\Lambda}^*=\boldsymbol{\Lambda}\Gamma=\left[\begin{array}{ll}\alpha_{11}^* &amp;  \alpha_{12}^*\\\vdots &amp;  \vdots \\\alpha_{m 1}^* &amp;\alpha_{m2}^*\end{array}\right]\\\]</span></p><p>将 <span class="math inline">\(\boldsymbol{\Lambda}^*\)</span> 带入<span class="math inline">\(V_{\boldsymbol{\Lambda}}\)</span> ，让 <spanclass="math inline">\(V_{\boldsymbol{\Lambda}^*}\)</span> 对 <spanclass="math inline">\(\phi\)</span> 求导数</p><p>令</p><p><span class="math display">\[\frac{\partialV_{\boldsymbol{\Lambda}}}{\partial \phi}=0\]</span></p><p>得到 <span class="math inline">\(\phi\)</span> 应该满足</p><p><span class="math display">\[\tan 4 \phi=\frac{d-2 ab /m}{c-\left(a^{2}-b^{2}\right) / m}\]</span></p><p>其中，若记</p><p><span class="math display">\[\mu_{i}=d_{i1}-d_{i2} , \quad \nu_{i}=2\frac{\alpha_{i 1}\alpha_{i2}}{h_{i}^{2}}=2\sqrt{d_{i1}d_{i2}}\]</span></p><p>则</p><p><span class="math display">\[\begin{array}{c}a=\sum\limits_{i=1}^{m} \mu_{i}, \quad b=\sum\limits_{i=1}^{m} \nu_{i},\\c=\sum\limits_{i=1}^{m}\left(\mu_{i}^{2}-\nu_{i}^{2}\right), \quad d=2\sum\limits_{i=1}^{m} \mu_{i} \nu_{i} .\end{array}\]</span></p><ul><li><strong>高维空间</strong></li></ul><p>当 <span class="math inline">\(m{\small&gt;}2\)</span> 时,可逐次对每两个因子 <span class="math inline">\(F_{i}, F_{j}\small (i\neq j)\)</span> 进行以上旋转。</p><p>选择正交旋转的角度 <span class="math inline">\(\varphi_{i j}\)</span>，即使这两个因子的方差之和达最大。 <spanclass="math inline">\(m\)</span> 个因子的全部配对旋转， 共需旋转 <spanclass="math inline">\(C_{m}^{2}\)</span> 次，全部旋转 完毕即算一次循环(或一轮)。经第一轮旋转后计算所得的因子载荷 方差 <spanclass="math inline">\(V_{(1)}\)</span> ， 此时不能认为 <spanclass="math inline">\(V_{(1)}\)</span>就是最大方差，还需从旋转后的载荷矩 阵出发, 再进行第二轮、第三轮旋转,直到 <span class="math inline">\(V\)</span>不能再增大为止<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="高惠璇. 应用多元统计分析[M]. 第2版. 第310页.">[5]</span></a></sup>。</p><h3 id="四次方最大化旋转">四次方最大化旋转</h3><p><strong>基本思想：</strong>使得因子载荷的每一行只在少部分地方取较大的值，每个变量只在一个因子上有较高的载荷，即<strong>使因子载荷矩阵每一行的元素方差最大化</strong>。</p><p>用于度量方差的量为</p><p><span class="math display">\[Q=\sum_{i=1}^{m}\sum_{j=1}^{r}\left({\alpha_{i j}^{*}}^2-\frac{1}{r}\right)^{2}\overset{\tiny 化}{=} \sum_{i=1}^{m} \sum_{j=1}^{r}\left({\alpha_{ij}^{*}}^4-2+\frac{m}{r}\right)\]</span></p><p>得到最简式</p><p><span class="math display">\[Q=\sum_{i=1}^{m}\sum_{j=1}^{r}{\alpha_{i j}^{*}}^4\]</span></p><p>这里的 <span class="math inline">\(1/r\)</span>可以理解为近似的每一行均值。</p><h3 id="等量最大法">等量最大法</h3><p><strong>基本思想：</strong>同时考虑载荷矩阵每行的方差和每列的方差，对其加权平均最大化。</p><p><span class="math inline">\(V\)</span> 近似化简为 <spanclass="math display">\[V=-\frac{1}{m}\sum_{j=1}^{r}{\left(\sum_{i=1}^{m}d_{ij}\right)}^{2}\quad\color{Gray} \tiny ,\sum_{i=1}^{m} d_{ij}^2\approx  1 ,\quad d_{ij}\approx \alpha_{i j}^{*} \]</span></p><p><span class="math inline">\(Q\)</span> 近似化简为 <spanclass="math display">\[Q=\sum_{i=1}^{m} \sum_{j=1}^{r}{\alpha_{ij}^{*}}^4\color{Gray}\quad \tiny ,\frac{1}{r}\approx\sum_{j=1}^rd_{ij}^2  ,\quad d_{ij}\approx \alpha_{i j}^{*}\]</span></p><p>构造</p><p><span class="math display">\[E=\sum_{i=1}^{m}\sum_{j=1}^{r}{\alpha_{i j}^{*}}^4 -\frac{\gamma  }{m}\sum_{j=1}^{r}{\left(\sum_{i=1}^{m}d_{ij}\right)}^{2}\]</span></p><p>其中 <span class="math inline">\(\gamma\)</span> 取 <spanclass="math inline">\(\frac{m}{2}\)</span></p><h2 id="因子得分">因子得分</h2><p>利用已知的观测值 <span class="math inline">\(\boldsymbol{X}\)</span>与构造的因子载荷矩阵 <spanclass="math inline">\(\boldsymbol{\Lambda}\)</span>可以对公共因子测度，即给出公共因子的值。</p><p>因子分析的数学模型已经给出，为</p><p><span class="math display">\[\left[\begin{array}{c}X_{1} \\X_{2} \\\vdots \\X_{m}\end{array}\right]=\left[\begin{array}{c}\mu_{1} \\\mu_{2} \\\vdots \\\mu_{m}\end{array}\right]+\left[\begin{array}{cccc}\alpha_{11} &amp; \alpha_{12} &amp; \cdots &amp; \alpha_{1 r} \\\alpha_{21} &amp; \alpha_{22} &amp; \cdots &amp; \alpha_{2 r} \\\vdots &amp; \vdots &amp; &amp; \vdots \\\alpha_{m 1} &amp; \alpha_{m 2} &amp; \cdots &amp; \alpha_{m r}\end{array}\right]\left[\begin{array}{c}F_{1} \\F_{2} \\\vdots \\F_{r}\end{array}\right]+\left[\begin{array}{c}\varepsilon_{1} \\\varepsilon_{2} \\\vdots\\\varepsilon_{m}\end{array}\right]\]</span></p><p>注：此处的 <spanclass="math inline">\(X_1,X_2\dots;F_1,F_2\dots;\varepsilon_1,\varepsilon_2\dots\)</span>都表示为一个指标下的一组 <span class="math inline">\(n\)</span>个样本的值，即 <spanclass="math inline">\(X_i=[x_{i1},x_{i2},\dotsb,x_{in}]\)</span></p><p>原变量 <span class="math inline">\(\boldsymbol{X}\)</span>被表示为公共因子的线性组合，载荷矩阵旋转后，公共因子可以做出解释，现在目的是把公共因子用原变量线性表示出来。</p><p>记因子得分函数为</p><p><spanclass="math display">\[F_j=c_j+\beta_{j1}X_1+\dotsb+\beta_{jm}X_m,\quadj=1,2,\dots,r\]</span></p><p>要求因子的得分，我们想要得分函数的系数，而因为 <spanclass="math inline">\(m&gt;r\)</span>不能得到精确的得分，载荷矩阵也不存在逆矩阵。</p><h3id="加权最小二乘法巴特莱特因子得分">加权最小二乘法（巴特莱特因子得分）</h3><p>把 <span class="math inline">\(X_i\)</span>看作因变量，把因子载荷矩阵看作自变量(不妨设 <spanclass="math inline">\(\mu_i=0\)</span> )。</p><p><span class="math display">\[\left\{\begin{array}{l}X_{1}=\alpha _{11} F_{1}+\alpha_{12} F_{2}+\cdots+\alpha_{1 r}F_{r}+\varepsilon_{1} \\X_{2}=\alpha_{21} F_{1}+\alpha_{22} F_{2}+\cdots+\alpha_{2 r}F_{r}+\varepsilon_{2} \\\cdots \\X_{m}=\alpha_{\tiny m 1} F_{1}+\alpha_{\tiny m 2}F_{2}+\cdots+\alpha_{\tiny m r} F_{r}+\varepsilon_{p}\end{array}\right.\]</span></p><p>考虑特殊因子方差相异，用加权的最小二乘法，使</p><p><spanclass="math display">\[\sum_{i=1}^m\frac{1}{\sigma_i^2}\left[(X_i)-(\alpha_{i1}\hat{F_1}+\dotsb+a_{ir}\hat{F_r})\right]^2\]</span></p><p>最小的 <spanclass="math inline">\(\hat{F_1},\hat{F_2},\dots,\hat{F_r}\)</span>是相应各个样本的因子得分。</p><p>矩阵表示： <spanclass="math display">\[\boldsymbol{X}=\boldsymbol{\Lambda}\boldsymbol{F}+\boldsymbol{\varepsilon}\]</span>要使 <spanclass="math display">\[(\boldsymbol{X}-\bold{\Lambda}\hat{\boldsymbol{F}})^T\boldsymbol{D}^{-1}(\boldsymbol{X}-\bold{\Lambda}\hat{\boldsymbol{F}})\]</span></p><p>即取偏导，令</p><p><span class="math display">\[\frac{\partial\phi(\boldsymbol{F})}{\partial \boldsymbol{F}}=2\boldsymbol{\Lambda}^{T}(\boldsymbol{X}-\boldsymbol{\Lambda}\boldsymbol{F})=0\]</span></p><p>达到最小，计算得</p><ul><li><p><spanclass="math display">\[\hat{\boldsymbol{F}}=(\boldsymbol{\Lambda}^T\boldsymbol{\Lambda})^{-1}\boldsymbol{\Lambda}^T\boldsymbol{X}\]</span></p></li><li><p><spanclass="math display">\[\hat{\boldsymbol{F}}=(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1}\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{X}\]</span></p></li></ul><blockquote><p>这种方法得到的因子得分 <spanclass="math inline">\(F_i=[f_{i1},\dots,f_{in}]\)</span>与主成分分析结果 <spanclass="math inline">\(Z_i=[z_{i1},\dots,z_{in}]\)</span>，仅仅相差一个常数：<span class="math inline">\(f_{ij}=z_{ij}/\sqrt{\lambda_j}\)</span></p></blockquote><h3 id="回归法汤普森因子得分">回归法（汤普森因子得分）</h3><p>设</p><p><span class="math display">\[\left[\begin{array}{c}X_{1} \\X_{2} \\\vdots \\X_{m}\end{array}\right]=\left[\begin{array}{cccc}\alpha_{11} &amp; \alpha_{12} &amp; \cdots &amp; \alpha_{1 r} \\\alpha_{21} &amp; \alpha_{22} &amp; \cdots &amp; \alpha_{2 r} \\\vdots &amp; \vdots &amp; &amp; \vdots \\\alpha_{m 1} &amp; \alpha_{m 2} &amp; \cdots &amp; \alpha_{m r}\end{array}\right]\left[\begin{array}{c}F_{1} \\F_{2} \\\vdots \\F_{r}\end{array}\right]+\left[\begin{array}{c}\varepsilon_{1} \\\varepsilon_{2} \\\vdots\\\varepsilon_{m}\end{array}\right]\]</span> 记第 <span class="math inline">\(j\)</span>个因子得分函数为</p><p><spanclass="math display">\[F_j=\beta_{j1}X_1+\dotsb+\beta_{jm}X_m,\quadj=1,2,\dots,r\]</span></p><p>因子载荷矩阵的元素表示了样本和因子的相关系数，有</p><p><span class="math display">\[\alpha_{ij}=\gamma_{\tiny X_iF_j}=E(X_iF_j)=E[X_i(\beta_{j1}X_1+\dotsb+\beta_{jm}X_m)]=\beta_{j1}\gamma_{i1}+\dotsb+\beta_{jm}\gamma_{im}\]</span></p><p>有</p><p><span class="math display">\[\begin{bmatrix}\gamma_{11} &amp; \gamma_{12} &amp; \dotsb &amp; \gamma_{1m}\\  \gamma_{21}&amp;\gamma_{22}  &amp; \dotsb &amp; \gamma_{2m}\\  \vdots &amp;  \vdots  &amp; \ddots &amp;  \vdots \\  \gamma_{m1}&amp;\gamma_{m2}  &amp; \dotsb &amp; \gamma_{mm}\end{bmatrix}\begin{bmatrix}\beta_{j1}\\  \beta_{j2}\\\vdots\\\beta_{jm}\end{bmatrix}=\begin{bmatrix}\alpha_{1j}\\\alpha_{2j} \\\vdots\\\alpha_{mj}\end{bmatrix}\]</span></p><p>其中三个矩阵分布代表原始变量系数相关系数矩阵 <spanclass="math inline">\(\boldsymbol{R}\)</span> 、第 <spanclass="math inline">\(j\)</span> 个因子得分函数系数、载荷矩阵第 <spanclass="math inline">\(j\)</span> 列。</p><p>得</p><p><span class="math display">\[\begin{bmatrix}\beta_{11} &amp; \beta_{12} &amp; \dotsb &amp; \beta_{1m}\\  \beta_{21}&amp;\beta_{22}  &amp; \dotsb &amp; \beta_{2m}\\  \vdots &amp;  \vdots  &amp; \ddots &amp;  \vdots \\  \beta_{m1}&amp;\beta_{m2}  &amp; \dotsb &amp; \beta_{rm}\end{bmatrix}^T=\boldsymbol{R}^{-1}\boldsymbol{\Lambda}\]</span></p><p>因此，因子得分估计为</p><ul><li><p><spanclass="math display">\[\hat{\boldsymbol{F}}=\boldsymbol{\Lambda}^T\boldsymbol{R}^{-1}\boldsymbol{X}\]</span></p></li><li><p><spanclass="math display">\[\hat{\boldsymbol{F}}=\boldsymbol{\Lambda}^T(\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+\boldsymbol{D})\boldsymbol{X}\]</span></p></li></ul><blockquote><p>司守奎给出的结果有误</p></blockquote><h3 id="两种估计方法的比较">两种估计方法的比较</h3><p><spanclass="math display">\[\begin{array}{l}\hat{\boldsymbol{F}}(1)=(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1}\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{X},\\\hat{\boldsymbol{F}}(2)=\boldsymbol{\Lambda}^T(\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+\boldsymbol{D})\boldsymbol{X}\end{array}\]</span></p><ul><li><strong>两者得分关系</strong></li></ul><p><spanclass="math display">\[\hat{\boldsymbol{F}}(1)=(I_r+(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1})\hat{\boldsymbol{F}}(2)\]</span></p><p><spanclass="math inline">\((\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1}\)</span>正定性得到 <span class="math inline">\(\hat{\boldsymbol{F}}(1)\)</span>不小于 <span class="math inline">\(\hat{\boldsymbol{F}}(2)\)</span> ；<spanclass="math inline">\(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda}\)</span>近似 <span class="math inline">\(0\)</span> 时，结果几乎相等。</p><ul><li><strong>无偏性</strong></li></ul><p><spanclass="math display">\[E(\hat{\boldsymbol{F}}(1)|\boldsymbol{F})=\boldsymbol{F}\\E(\hat{\boldsymbol{F}}(2)|\boldsymbol{F})=(I_r+(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1})\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda}\boldsymbol{F}\]</span></p><p>第一种估计无偏，回归估计有偏。</p><ul><li><strong>均方误差</strong></li></ul><p><spanclass="math display">\[\mathrm{E}\left[(\hat{\boldsymbol{F}}(1)-\boldsymbol{F})(\hat{\boldsymbol{F}}(1)-{}^{I} \boldsymbol{F})^{\prime} \mid\boldsymbol{F}\right]=\left(\boldsymbol{\Lambda}^{\prime}\boldsymbol{D}^{-1} \boldsymbol{\Lambda}\right)^{-1} \\\mathrm{E}\left[(\hat{\boldsymbol{F}}(2)-\boldsymbol{F})(\hat{\boldsymbol{F}}(2)-{}^{I} \boldsymbol{F})^{\prime} \mid\boldsymbol{F}\right]=\left(I_{m}+\boldsymbol{\Lambda}^{\prime}\boldsymbol{D}^{-1} \boldsymbol{\Lambda}\right)^{-1}\]</span></p><p>这表示第二种估计（汤普森因子得分）有较小的平均预报误差.</p><h1 id="缺陷">缺陷</h1><p>因子分析是十分主观的，在许多出版的资料中，因子分析模型都用少数可命名因子提供了合理解释。实际上，绝大多数因子分析并没有产生如此明确的结果。评价因子分析质量的法则尚未很好量化，因子分析的质量参差不齐。</p><h1 id="参考">参考</h1><ul><li>本文章花费大量时间查询比较各版本的过程，最终以司守奎的参数名为主体，调整了部分参数命名以符合笔者习惯。</li><li>本文章的格式不清晰，多次差错后依然有公式格式，变量名错误的问题，还请见谅。</li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第240页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/340497643<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://www.jianshu.com/p/2456837720fb<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/24008426<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>高惠璇. 应用多元统计分析[M].第2版. 第310页.<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>Wolfgang Hardle LeopoldSimar. Applied Multivariate Statistical Analysis[M].<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相关系数矩阵 </tag>
            
            <tag> 因子分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分分析</title>
      <link href="/2022/02/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主成分分析（Principal Component Analysis，PCA）<br />目的是用较少的变量代表解释原有的变量。将相关性高的变量转换为相互独立的变量<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第231页.">[1]</span></a></sup>。</p><p>原理：降维，有关联的变量反映的信息有一定的重叠。对于原有变量，将重复的变量（关系紧密的变量）删去，建立尽可能少的新变量，使得新变量是两两不相关的<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://baike.baidu.com/item/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/829840">[3]</span></a></sup>，且能<strong>尽可能保持原有的信息</strong>（方差最大化）和解释原有变量，使样本具有相对较好的区分性。</p><p>定义：一个正交化线性变换，把数据（包含降维）变换到一个新的坐标系统中，使得这一数据的任何投影的第一大方差在第一个坐标（称为第一主成分）上，第二大方差在第二个坐标（第二主成分）上，依次类推<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/342659017">[4]</span></a></sup>。</p><h1 id="方法">方法</h1><p>主成分分析仅是变量转换，以下是得到变量转换的方法。</p><p>记 <span class="math inline">\(Z_1,Z_2,\dots,Z_r\)</span> 为主成分<span class="math display">\[\left\{\begin{array}{c}Z_{1}=c_{11} X_{1}+c_{12} X_{2}+\cdots+c_{1 m} X_{m} \\Z_{2}=c_{21} X_{1}+c_{22} X_{2}+\cdots+c_{2 m} X_{m} \\\vdots \\Z_{r}=c_{r 1} X_{1}+c_{r 2} X_{2}+\cdots+c_{r m} X_{m}\end{array}\right.\]</span></p><p>即 <span class="math display">\[\begin{bmatrix}\boldsymbol{Z}_1\\  \boldsymbol{Z}_2\\\vdots\\\boldsymbol{Z}_r\end{bmatrix}=\begin{bmatrix}  c_{11}&amp; c_{12} &amp; \cdots  &amp; c_{1m}\\  c_{21}&amp; c_{22} &amp; \cdots   &amp;c_{2m} \\  \vdots &amp;  \vdots &amp;  &amp; \vdots\\  c_{r1}&amp; c_{r2} &amp; \cdots &amp; c_{rm}\end{bmatrix}\begin{bmatrix}\boldsymbol{X}_1\\  \boldsymbol{X}_2\\\vdots\\\boldsymbol{X}_m\end{bmatrix}\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{X}_i\)</span> 和 <spanclass="math inline">\(\boldsymbol{Z}_i\)</span> 都表示为长度为 <spanclass="math inline">\(n\)</span> 的观察值向量； <spanclass="math inline">\([ c_{i1}, c_{i2} , \cdots , c_{im}]\)</span> 为第<span class="math inline">\(i\)</span> 个特征向量 <spanclass="math inline">\(\boldsymbol{\alpha}_i\)</span> 。</p><h2 id="步骤">步骤</h2><p>设有 <span class="math inline">\(m\)</span> 个指标，<spanclass="math inline">\(n\)</span> 组观测值 <spanclass="math inline">\(\boldsymbol{X}=[\boldsymbol{X}_1,\boldsymbol{X}_2,\dots,\boldsymbol{X}_m]\)</span><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/342659017">[4]</span></a></sup></p><ol type="1"><li>将各指标数据标准化(去除量纲)和中心化，即 <spanclass="math inline">\(x_{ik}&#39;=\frac{x_{ik}-\mu_k}{\sigma_k}\)</span>，得到矩阵 <span class="math inline">\(\boldsymbol{X&#39;}\)</span>；</li><li>计算相关系数矩阵 <spanclass="math inline">\(\boldsymbol{R}=\frac{1}{n-1}\boldsymbol{A&#39;}^T\boldsymbol{A&#39;}\)</span>；</li><li>（特征值分解或奇异值分解）求出协方差矩阵的特征值 <spanclass="math inline">\(\lambda\)</span> 及对应的特征向量 <spanclass="math inline">\(\boldsymbol{\alpha}\)</span> ；</li><li>计算累计贡献率确定解释度 <spanclass="math inline">\(\alpha\)</span>，取前 <spanclass="math inline">\(r\)</span>个特征向量（标准化、正交化）<strong>按行排列</strong>组成矩阵 <spanclass="math inline">\(\boldsymbol{P}\)</span> ；</li><li><span class="math inline">\((\boldsymbol{Z}_{ij})_{r1}=\boldsymbol{P}_{rn}(\boldsymbol{X}^T)_{n 1}\)</span> ；</li><li>解释主成分的含义。</li></ol><p>注：若不能够给出主成分的较好解释，整个主成分分析也就失败了，可以采用因子分析。</p><h2 id="计算贡献">计算贡献</h2><ul><li>贡献率（特征值占比） <spanclass="math display">\[\frac{\lambda_{i}}{\sum_{k=1}^{r} \lambda_{k}}\quad(i=1,2, \cdots, r)\]</span></li><li>累计贡献率 <span class="math display">\[\frac{\sum_{k=1}^{i}\lambda_{k}}{\sum_{i=1}^{r} \lambda_{k}}\quad(i=1,2, \cdots,r)\]</span></li><li>对原始变量 <span class="math inline">\(\boldsymbol{x}_i\)</span>贡献值（相关系数平方和） <spanclass="math display">\[\rho_i=\sum\limits_{j=1}^{r}r^2(\boldsymbol{z}_j,\boldsymbol{x}_i)\]</span></li></ul><h1 id="理解">理解</h1><h2 id="主成分含义">主成分含义</h2><p>记 <span class="math inline">\(Z_1,Z_2,\dots,Z_r\)</span>为主成分</p><p><span class="math display">\[\left\{\begin{array}{c}Z_{1}=c_{11} X_{1}+c_{12} X_{2}+\cdots+c_{1 m} X_{m} \\Z_{2}=c_{21} X_{1}+c_{22} X_{2}+\cdots+c_{2 m} X_{m} \\\vdots \\Z_{r}=c_{r 1} X_{1}+c_{r 2} X_{2}+\cdots+c_{r m} X_{m}\end{array}\right.\]</span></p><p>对于每一个式子有 <spanclass="math inline">\(c_{i1}^2+c_{i2}^2+\dots+c_{im}^2=1\)</span>（单位向量）。</p><p><span class="math inline">\([c_{11},c_{12},\dots,c_{1m}]\)</span>使得 <span class="math inline">\(Var(Z_1)\)</span>的值最大（信息量最大）；<spanclass="math inline">\([c_{21},c_{22},\dots,c_{2m}]\)</span> 垂直于 <spanclass="math inline">\([c_{11},c_{12},\dots,c_{1m}]\)</span>在该条件下使得 <span class="math inline">\(Var(Z_2)\)</span>的值最大；<spanclass="math inline">\([c_{31},c_{32},\dots,c_{3m}]\)</span> 垂直于 <spanclass="math inline">\(\boldsymbol{c_{1·}}\)</span> ， <spanclass="math inline">\(\boldsymbol{c_{2·}}\)</span>……可推得到全部主成分，每个主成分是满足与所有特征向量正交情况下的信息量最大的单位向量。</p><p><strong>直观解释（几何）</strong></p><p>一般情况， <span class="math inline">\(m\)</span> 个变量组成 <spanclass="math inline">\(m\)</span> 维空间， <spanclass="math inline">\(n\)</span> 个样品点就是 <spanclass="math inline">\(m\)</span> 维空间的 <spanclass="math inline">\(n\)</span> 个点。对于 <spanclass="math inline">\(m\)</span> 维正态随机向量来说,找主成分的问题就是找<span class="math inline">\(m\)</span>维空间中椭球的主轴问题<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="高惠璇. 应用多元统计分析[M]. 第2版. 第310页.">[6]</span></a></sup>。</p><p>初始数据集合中的样本由(正交)坐标系中的点来表示，每一个轴代表一个变量。对原坐标系中的数据进行主成分分析等价于对坐标系进行旋转变换，将数据投影到新坐标系的坐标轴上，此时每一个轴代表一个主成分。将新坐标系中的点在每个主成分轴上投影，得到对应的投影点。投影点的平方和则称为该主成分的方差，方差最大的轴称为第一主成分，依次类推第二主成分的选取，且保证与已选坐标轴正交<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/339038035">[5]</span></a></sup>。</p><h2 id="矩阵变换的理解">矩阵变换的理解</h2><p>对于矩阵变换有两个理解，第一个是来自3Blue1Brown的解释。</p><h3 id="理解一基变换">理解一：基变换</h3><p><span class="math display">\[\begin{bmatrix}i_1 &amp; j_1 &amp; k_1\\i_2 &amp; j_2 &amp; k_2\\i_3 &amp; j_3 &amp; k_3\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}=x\begin{bmatrix}i_1\\i_2\\i_3\end{bmatrix}+y\begin{bmatrix}j_1\\j_2\\j_3\end{bmatrix}+z\begin{bmatrix}k_1\\k_2\\k_3\end{bmatrix}\]</span></p><p><span class="math inline">\(\small[i_1,i_2,i_3]&#39;,[j_1,j_2,j_3]&#39;,[k_1,k_2,k_3]&#39;\)</span>就是新的基，变换 <span class="math inline">\(\small\boldsymbol{AX}\)</span> 的结果就是将点 <spanclass="math inline">\(\boldsymbol{X}\)</span>经过坐标基的旋转伸缩变换后，点在<strong>原坐标</strong>中的表示形式。</p><h3 id="理解二新坐标轴投影">理解二：新坐标轴投影</h3><p><span class="math display">\[\begin{bmatrix}i_1 &amp; j_1 &amp; k_1\\i_2 &amp; j_2 &amp; k_2\\i_3 &amp; j_3 &amp; k_3\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}=\begin{bmatrix}\begin{bmatrix} i_1 &amp;j_1&amp;k_1\end{bmatrix}\boldsymbol{X}\\\begin{bmatrix} i_2 &amp;j_2&amp;k_2\end{bmatrix}\boldsymbol{X}\\\begin{bmatrix} i_3 &amp;j_3&amp;k_3\end{bmatrix}\boldsymbol{X}\\\end{bmatrix},\boldsymbol{X}=\begin{bmatrix}x\\y\\z\end{bmatrix}.\]</span></p><p>可以理解为点 <span class="math inline">\(\boldsymbol{X}\)</span>在各个方向向量上的投影（在乘以长度）的结果。<spanclass="math inline">\([i,j,k]\)</span>就是变换后坐标系的原坐标轴，逆变换后在原空间的表示结果。</p><h2 id="协方差矩阵与特征值理解">协方差矩阵与特征值理解</h2><h3 id="理解一旋转">理解一：旋转</h3><p>通过线性代数知识有，对于任意一对称矩阵 <spanclass="math inline">\(\boldsymbol{\Sigma}\)</span>存在一个特征值分解(eigenvalue decomposition, EVD)： <spanclass="math display">\[\boldsymbol{\Sigma}=\boldsymbol{U}\boldsymbol{\Lambda}\boldsymbol{U}^T\]</span> 其中，<spanclass="math inline">\(\boldsymbol{U}\)</span>的每一列为标准相互正交的特征向量，<spanclass="math inline">\(\boldsymbol{\lambda}\)</span>对角线上的元素是从大到小排列的特征值，非对角线上的元素均为 <spanclass="math inline">\(0\)</span> 。可以看出 <spanclass="math inline">\(\boldsymbol{\Lambda}\)</span> 与 <spanclass="math inline">\(\boldsymbol{\Sigma}\)</span>是同一个向量在不同坐标系中的表示。</p><p>也可以写作 <spanclass="math display">\[\boldsymbol{\Sigma}=\left(\boldsymbol{U}\boldsymbol{\Lambda}^{1/2}\right)\left(\boldsymbol{U}\boldsymbol{\Lambda}^{1/2}\right)^T=\boldsymbol{A}\boldsymbol{A}^T\]</span>因子分析中用的就是上式。</p><p>可以理解到，<strong>协方差矩阵的特征向量控制旋转(rotation)，特征值控制尺度(scale)</strong>，特征值的大小代表了信息量（原始特征）多少<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/37609917">[2]</span></a></sup>。</p><h3 id="理解二投影">理解二：投影</h3><p>记协方差矩阵与中心化后的样本矩阵有以下关系<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/435001757">[8]</span></a></sup>：</p><p><spanclass="math display">\[\boldsymbol{\Sigma}=\boldsymbol{A}^T\boldsymbol{A}\]</span></p><p>其特征向量与特征特征值满足</p><p><spanclass="math display">\[\boldsymbol{A}^T\boldsymbol{A}\boldsymbol{\beta}=\lambda\boldsymbol{\beta}\]</span></p><p>左右同时左乘 <spanclass="math inline">\(\small\boldsymbol{\beta}^T\)</span> 得到</p><p><spanclass="math display">\[\boldsymbol{\beta}^T\boldsymbol{A}^T\boldsymbol{A}\boldsymbol{\beta}=\boldsymbol{\beta}^T\lambda\boldsymbol{\beta}\]</span></p><p><span class="math inline">\(\small \boldsymbol{\beta}\)</span>为单位向量，化简如下：</p><p><spanclass="math display">\[\left(\boldsymbol{A}\boldsymbol{\beta}\right)^T\left(\boldsymbol{A}\boldsymbol{\beta}\right)=\lambda\]</span></p><p><span class="math inline">\(\small \boldsymbol{A}\)</span>的每行是个样本点在这里 <span class="math inline">\(\small\boldsymbol{a_i}·\boldsymbol{\beta}\)</span> 是 <spanclass="math inline">\(\small \boldsymbol{a_i}\)</span> 在 <spanclass="math inline">\(\boldsymbol{\beta}\)</span> 方向上的投影，故 <spanclass="math inline">\(\small\boldsymbol{A}\boldsymbol{\beta}\)</span>可理解为样本空间中的样本点投影到轴 <spanclass="math inline">\(\small\boldsymbol{\beta}\)</span> 上的结果， <spanclass="math inline">\(\small\left(\boldsymbol{A}\boldsymbol{\beta}\right)^T\left(\boldsymbol{A}\boldsymbol{\beta}\right)\)</span>则是投影平方和。故 <span class="math inline">\(\lambda\)</span>最大，表示投影后方差最大即信息量最大。</p><p><imgsrc="https://pic.imgdb.cn/item/622201105baa1a80ab9a2b94.png" /></p><h2 id="主成分分析的滥用">主成分分析的滥用</h2><p>参考<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="王学明. 应用多元统计分析[M].">[7]</span></a></sup>，国内以 <span class="math inline">\(\small\lambda_i/\sum\limits_{i=1}^r\lambda_i\)</span>作为权重对主成分加权得到的结果作为评价的综合评价的方法是对主成分分析思想的误用（如高惠璇老师的书中内容）。</p><p>主成分分析得到的主成分 <span class="math inline">\(\small\boldsymbol{Z}_1,\boldsymbol{Z}_2,\dotsb,\boldsymbol{Z}_r\)</span>仅使得其表示的信息量趋大，其不满足正负向性，不具有作为综合评价的条件；其次，主成分的线性组合会瓦解主成分分析在信息上的优势；主成分意义模糊，其线性组合一般没有意义。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第231页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/37609917<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://baike.baidu.com/item/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/829840<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/342659017<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/339038035<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>高惠璇. 应用多元统计分析[M].第2版. 第310页.<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>王学明. 应用多元统计分析[M].<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/435001757<a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主成分分析 </tag>
            
            <tag> 相关系数矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类分析</title>
      <link href="/2022/02/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>聚类分析（Cluster Analysis）<br />又称为群分析，是对多个样本(或指标)进行定量分类的一种多元统计分析。对样本进行分析称为<strong>Q型聚类分析</strong>，对指标进行分类称为<strong>R型聚类分析</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第216页.">[1]</span></a></sup>。聚类与分类的不同在于，聚类所要求划分的类是未知的。</p><p>聚类是将数据分类到不同的类或者簇这样的一个过程，所以同一个簇中的对象有很大的相似性，而不同簇间的对象有很大的相异性<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/3450227">[2]</span></a></sup>。组内相似性越大，组间差距越大，说明聚类效果越好。</p><p>聚类效果的好坏依赖于两个因素：1.<strong>衡量距离的方法（distancemeasurement）</strong>2.<strong>聚类算法（algorithm）</strong><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/37856153">[3]</span></a></sup></p><h1 id="相似性衡量">相似性衡量</h1><p>相似性衡量（similarity measurement）<br />可近似为距离的计算（distance measurement）<br />距离，是抽象化的相似程度度量，不同的数据类型有着不同的距离计算方法，我们需要用数量化的方法刻画事物之间的相似程度。</p><h2 id="样本间距离度量">1. 样本间距离度量</h2><p>对于 <span class="math inline">\(m\)</span>个指标描述的样本可以看成是 <spanclass="math inline">\(\bold{R}^m\)</span>空间中的一个点，自然用距离衡量样本的相似度。</p><h3 id="数值变量">1.1 数值变量</h3><p>在做距离计算前，还需要对数据做<strong>标准化</strong>处理 <spanclass="math inline">\(x_i^*=\frac{x_i-mean_x}{S_x}\)</span>，以防止量纲的不同导致空间拉伸距离失真。</p><p><strong>闵氏(Minkowski)距离</strong>： <spanclass="math display">\[dis_q(\boldsymbol{x},\boldsymbol{y})=[\sum_{k=1}^{m}|x_k-y_k|^q]^{\frac{1}{q}}\]</span></p><p>以下均为闵氏(Minkowski)距离的子式</p><ul><li><p>曼哈顿(Manhattan)距离：<span class="math inline">\(q=1\)</span>时 <spanclass="math display">\[dis_q(\boldsymbol{x},\boldsymbol{y})=\sum_{k=1}^{m}|x_k-y_k|\]</span></p></li><li><p>欧几里得(Euclid)距离：<span class="math inline">\(q=2\)</span> 时（<strong>坐标轴正交旋后转保持不变</strong>） <spanclass="math display">\[dis_q(\boldsymbol{x},\boldsymbol{y})=\sqrt{\sum_{k=1}^{m}|x_k-y_k|^2}\]</span></p></li><li><p>切比雪夫(Chebyshev)距离：<spanclass="math inline">\(q\to+\infty\)</span> 时 <spanclass="math display">\[dis(\boldsymbol{x},\boldsymbol{y})=\max_{1\leqslantk\leqslant m}|x_k-y_k|\]</span></p></li></ul><p>对于不同的指标有不同的权重，还可以对上述公式的距离加权。将上述式子中<span class="math inline">\(|x_k-y_k|\)</span> 替换为 <spanclass="math inline">\(w_k|x_k-y_k|\)</span>(第一个和第三个式子会使加权与结果非线性)。此外使用闵氏(Minkowski)距离时，变量的多重相关性(Multicollinearity)会导致信息重叠，片面强调某些变量的重要性。因为上述缺点，一种改进的距离是马氏距离<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第216页.">[1]</span></a></sup>。</p><ul><li>马氏(Mahalanobis)距离： <spanclass="math display">\[dis(\boldsymbol{x},\boldsymbol{y})=\sqrt{(\boldsymbol{x}-\boldsymbol{y})^{T}\boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{y})}\]</span>其中：<span class="math inline">\(\boldsymbol{x},\boldsymbol{y}\)</span>来自总体 <span class="math inline">\(Z\)</span> 的样本观测值；<spanclass="math inline">\(\boldsymbol{\Sigma}\)</span> 为 <spanclass="math inline">\(Z\)</span> 的协方差矩阵。</li></ul><p><strong>马氏距离对一切线性变换是不变的</strong>，故而不受量纲影响。</p><p>根据聚类分析目的或者指标的不同，还可以使用夹角余弦等方法度量相似度（数据挖掘拓展）。</p><h3 id="二元变量">1.2 二元变量</h3><p>构造二元变量为0-1虚拟变量 |Name|指标1|指标2|指标3|指标4|指标5|指标6||:-:|:-:|:-:|:-:|:-:|:-:|:-:| |Eirc|1|0|1|1|0|0| |Freddie|1|0|0|1|1|1||Dramwig|0|1|1|1|1|0|</p><p>构造列联表</p><table><thead><tr class="header"><th style="text-align: center;">X</th><th style="text-align: center;">1</th><th style="text-align: center;">0</th><th style="text-align: center;">sum</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">a</td><td style="text-align: center;">b</td><td style="text-align: center;">a+b</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">c</td><td style="text-align: center;">d</td><td style="text-align: center;">c+d</td></tr><tr class="odd"><td style="text-align: center;">sum</td><td style="text-align: center;">a+c</td><td style="text-align: center;">b+d</td><td style="text-align: center;">a+b+c+d</td></tr></tbody></table><p>构造 <spanclass="math display">\[dis(X,Y)=\frac{b+c}{a+b+c}\]</span></p><h3 id="分类变量">1.3 分类变量</h3><ul><li>简单匹配：<spanclass="math inline">\(dis(X,Y)=\frac{p-m}{p}\)</span>p为类别数，m为配对数</li><li>二元化：<spanclass="math inline">\(Categories:\{C_1,C_2,C_3\}\)</span> <spanclass="math inline">\(\to\)</span> <spanclass="math inline">\(C_1:\{0,1\}\)</span> ; <spanclass="math inline">\(C_2:\{0,1\}\)</span> ; <spanclass="math inline">\(C_3:\{0,1\}\)</span>,</li></ul><h3 id="有序变量">1.4 有序变量</h3><ol type="1"><li>记序列为<span class="math inline">\(rank\to[1\dots N]\)</span></li><li>z-scores来标准化 <span class="math inline">\(r_i/N\)</span> 得 <spanclass="math inline">\(r\in [0,1]\)</span></li><li>计算马氏(Minkowski)距离</li></ol><h2 id="类与类间距度量">2. 类与类间距度量</h2><p>记两个类分别为 <span class="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span>，有以下方法度量类间距。</p><ul><li><p>最短距离法（Nearest Neighbor or Single Linkage Method）： <spanclass="math display">\[D(G_1,G_2)=\min_{\tiny{\boldsymbol{x_i}\inG_1,\boldsymbol{y_j}\in G_2}}{dis(\boldsymbol{x_i},\boldsymbol{y_j})}\]</span></p></li><li><p>最长距离法（Farthest Neighbor or Complete Linkage Method）：<span class="math display">\[D(G_1,G_2)=\max_{\tiny{\boldsymbol{x_i}\inG_1,\boldsymbol{y_j}\in G_2}}{dis(\boldsymbol{x_i},\boldsymbol{y_j})}\]</span></p></li><li><p>重心法（Centetoid Method） <spanclass="math display">\[D(G_1,G_2)=dis(\boldsymbol{\bar{x}},\boldsymbol{\bar{y}})\]</span></p></li><li><p>类平均法（Group AverageMethod）(被<strong>认为是最常用也最好用的方法</strong>其单调性良好，空间扩张/浓缩的程度适中)<spanclass="math display">\[D(G_1,G_2)=\frac{1}{n_1n_2}\sum_{\boldsymbol{x_i}\inG_1}\sum_{\boldsymbol{y_j}\inG_2}dis(\boldsymbol{x_i},\boldsymbol{y_j})\]</span></p></li><li><p>离差平方和法（Sum of Squares Method）又称 Ward 方法</p></li></ul><p>记 <span class="math display">\[D_1=\sum_{\boldsymbol{x_i}\inG_1}(\boldsymbol{x_i-\boldsymbol{\bar{x}}})^{T}(\boldsymbol{x_i-\boldsymbol{\bar{x}}}),D_2=\sum_{\boldsymbol{y_j}\inG_2}(\boldsymbol{y_j-\boldsymbol{\bar{y}}})^{T}(\boldsymbol{y_j-\boldsymbol{\bar{y}}})\]</span></p><p><span class="math display">\[D_{12}=\sum_{\boldsymbol{z_k}\in G_1\cupG_2}(\boldsymbol{z_k-\boldsymbol{\bar{z}}})^{T}(\boldsymbol{z_k-\boldsymbol{\bar{z}}})\]</span></p><p>定义 <spanclass="math display">\[D(G_1,G_2)=D_{12}-D_1-D_2\]</span></p><p>含义：<span class="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> 内点很聚集 <spanclass="math inline">\(D_1\)</span>、<spanclass="math inline">\(D_2\)</span> 就会很小，即自聚为一类；<spanclass="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> 相聚很远则 <spanclass="math inline">\(D_{12}\)</span> 很大，即 <spanclass="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> 充分分离。</p><h2 id="指标间距离度量">3. 指标间距离度量</h2><ul><li>相关系数</li></ul><p><spanclass="math display">\[r_{jk}=\frac{\sum\limits_{i=1}^{n}(x_{ij}-\bar{x}_j)(x_{ik}-\bar{x}_k)}{[\sum\limits_{i=1}^{n}(x_{ij}-\bar{x}_j)^2\sum\limits_{i=1}^{n}(x_{ik}-\bar{x}_k)^2]^{\frac{1}{2}}}\]</span></p><ul><li>夹角余弦</li></ul><p><spanclass="math display">\[r_{jk}=\frac{\sum\limits_{i=1}^{n}x_{ij}x_{ik}}{(\sum\limits_{i=1}^{n}x_{ij}^2\sum\limits_{i=1}^{n}x_{ik}^2)^{\frac{1}{2}}}\]</span></p><h1 id="聚类算法">聚类算法</h1><p>聚类算法多种多样，搭配上不同的相似性衡量算法对于聚类结果有巨大的差异。一下只给出了几种最根本的聚类算法，其他算法大都是在此基础上的优化与改进。<ahref="https://www.zhihu.com/question/34554321/answer/64372216">这个回答</a>可以窥视向外的拓展。</p><h2 id="k-均值聚类k-means">K-均值聚类(k-means)</h2><h3 id="步骤">步骤</h3><p>迭代算法如下： 1. 随机得到 K 个初始质心，每一个质心代表一个类 2.扫描所有样本点，把每个点划归到到离它最近的质心的簇类中 3.重新计算每个类的质心。 4. 重复 2. 和 3. 5.直到分类/质心不在发生变化时结束</p><figure><img src="https://s2.loli.net/2022/02/13/wtx935INsrcuWZA.png"alt="迭代" /><figcaption aria-hidden="true">迭代</figcaption></figure><h3 id="spss">SPSS</h3><p>SPSS-分析-分类-K均值聚类</p><h3 id="缺陷">缺陷</h3><ol type="1"><li>每次计算需要给定簇数目K</li><li>对孤立点（异常点）敏感，（会产生孤立点为单独一类的情况）</li><li>对于初始值敏感</li><li>k-means不能解决非凸（non-convex）数据（不规则形状聚类）</li></ol><h2 id="层次系统聚类hierarchical">层次(系统)聚类(Hierarchical)</h2><h3 id="步骤-1">步骤</h3><ol type="1"><li>迭代步骤<ol type="1"><li>把每个样本作为单独一个类，计算类与类之间的距离，用邻近度矩阵记录</li><li>将邻接矩阵中最小的距离连接的类归为一类</li><li>根据新的类，更新邻近度矩阵（若以类中样本间最短距离为类距离则不需要更新）</li><li>重复2. 3.</li><li>到只只剩下一个类的时候，停止</li></ol></li><li>画出<strong>聚类谱系图</strong>（SPSS自带）</li><li>画出<strong>聚合系数折线图</strong><ol type="1"><li>对于每个聚合类别，计算每个类 <spanclass="math inline">\(C_k\)</span> 的畸变程度：<spanclass="math inline">\(\sum\limits_{\tiny\boldsymbol{x}_i\inC_k}|\boldsymbol{x}_i-\boldsymbol{\bar{x}}|^2\)</span></li><li>计算所有类的总畸变程度，即聚合系数：<spanclass="math inline">\(J=\sum\limits_{k=1}^{K}\sum\limits_{\tiny\boldsymbol{x}_i\inC_k}|\boldsymbol{x}_i-\boldsymbol{\bar{x}}|^2\)</span></li><li>以聚合类别数 <span class="math inline">\(K\)</span>为横坐标，以聚合系数 <span class="math inline">\(J\)</span>为纵坐标</li></ol></li><li>通过肘部法则（Elbow Method）判断最优聚合数量，得到聚类结果</li></ol><p><img src="https://s2.loli.net/2022/02/13/1RztJXYsvk2j735.png" /></p><p>以上是凝聚(agglomerative)途径，即自下而上方法，还可以使用分裂(divisive)的途径。</p><p>自下而上法就是一开始每个个体（object）都是一个类，然后根据linkage寻找同类，最后形成一个“类”；自上而下法就是反过来，一开始所有个体都属于一个“类”，然后根据linkage排除异己，最后每个个体都成为一个“类”<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/34554321/answer/64372216">[4]</span></a></sup>。</p><h3 id="spss-1">SPSS</h3><p>SPSS-分析-分类-系统聚类</p><h2 id="基于密度的dbscan算法">基于密度的DBSCAN算法</h2><p>DBSCAN(Density-based spatial clustering of applications withnoise)<br />是一种基于密度的聚类方法，该方法能在具有噪声的空间数据库中发现任意形状的簇，可将密度足够大的相邻区域连接，能有效处理异常数据。</p><p><img src="https://s2.loli.net/2022/02/13/xIaSo6GKqC71tJr.png" /></p><h3 id="基本概念">基本概念</h3><ul><li>核心点：在该点半径 <span class="math inline">\(Eps\)</span>内含的点数不少于 <span class="math inline">\(MinPts\)</span></li><li>边界点：在该点半径 <span class="math inline">\(Eps\)</span>内点的数量小于 <spanclass="math inline">\(MinPts\)</span>，但是落在核心点的半径 <spanclass="math inline">\(Eps\)</span> 邻域内</li><li>噪音点：既不是核心点也不是边界点的点，即不在核心点的半径 <spanclass="math inline">\(Eps\)</span> 邻域内的点</li></ul><p><ahref="https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/">DBSCAN密度聚类可视化</a></p><figure><img src="https://s2.loli.net/2022/02/13/JF8HMDxkIcdKlwf.png"alt="密度聚类" /><figcaption aria-hidden="true">密度聚类</figcaption></figure><h3 id="缺点">缺点</h3><ul><li>对输入参数 <code>Eps</code> 和 <code>Minpts</code>敏感，确定参数困难，不同参数相差很大</li><li>时间复杂度高，处理大量数据时慢</li></ul><h2 id="根据网格单元的聚类">根据网格单元的聚类</h2><p>其原理是将数据空间划分为网格单元，将数据对象映射到网格单元中，并计算每个单元的密度。根据预设阈值来判断每个网格单元是不是高密度单元，由邻近的稠密单元组成“类”<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/37856153">[3]</span></a></sup>。</p><p><imgsrc="https://pic3.zhimg.com/e76863bafda37b0313d39f5338540488_r.jpg?source=1940ef5c" /></p><h3 id="步骤-2">步骤</h3><p>1.将数据空间划分为网格单元 2.依照设置的阈值，判定网格单元是否稠密3.合并相邻稠密的网格单元为一类</p><h3 id="特点">特点</h3><ul><li>优点<ul><li>效率快速度快</li><li>直观易于理解</li></ul></li><li>缺点<ul><li>拟合较为粗糙，分类不精确，无法处理不规则分布的数据</li><li>对输入参数敏感，难以确定方格宽以及稠密阈值，方格宽以及稠密阈值对结果影响很大</li></ul></li></ul><h2 id="基于概率的聚类">基于概率的聚类</h2><p>Model-based methods<br />这一类方法主要是指基于概率模型的方法和基于神经网络模型的方法，尤其以基于概率模型的方法居多。这里的概率模型主要指概率生成模型（generativeModel），同一”类“的数据属于同一种概率分布<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/34554321/answer/64372216">[4]</span></a></sup>。</p><p><imgsrc="https://pic3.zhimg.com/2bf5b20d2e44e3db4c55efde8209558c_r.jpg?source=1940ef5c" /></p><h1 id="数据简化">数据简化</h1><ul><li><strong>变换（Data Transformation）</strong>：<ul><li>离散傅里叶变换（Discrete FourierTransformation）可以提取数据的频域（frequency domain）信息</li><li>离散小波变换（Discrete WaveletTransformation）除了频域之外，还可以提取到时域（temporaldomain）信息<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/34554321/answer/64372216">[4]</span></a></sup></li></ul></li><li><strong>降维（Dimensionality Reduction）</strong>：<ul><li>线性方法<ul><li>PCA（Principle Component Analysis）</li><li>SVD（Singular Value Decomposition）</li><li>MDS（Multi-Dimensional Scaling）PCA拓展</li></ul></li><li>非线性降维的算法<ul><li>流形学习（Manifold Learning）<ul><li>ISOMAP、</li><li>LLE（Locally Linear Embedding）、</li><li>MVU（Maximum variance unfolding）、</li><li>Laplacian eigenmaps、Hessian eigenmaps、</li><li>Kernel PCA、</li><li>Probabilistic PCA</li></ul></li></ul></li></ul></li><li><strong>抽样（Sampling）</strong>：<ul><li>随机抽样</li></ul></li></ul><h1 id="三大步骤的综合">三大步骤的综合</h1><p>对于聚类分析三大步骤：</p><ol type="1"><li>相似性衡量：距离、相似系数、核函数、DTW（dynamic time warping）</li><li>聚类算法：Hierarchical methods、Partition-basedmethods、Density-based methods、Grid-based methods、Model-basedmethods</li><li>数据简化：变换、降维、抽样</li></ol><p>其中每个二级分类下含有多种方法。三个步骤每个选择一个方法可以组合出庞大数量的聚类模型。</p><p>例如：<strong>谱聚类（SpectralClustering）</strong>，就是先用Laplacianeigenmaps对数据降维（简单地说，就是先将数据转换成邻接矩阵或相似性矩阵，再转换成Laplacian矩阵，再对Laplacian矩阵进行特征分解，把最小的K个特征向量排列在一起），然后再使用k-means完成聚类。谱聚类是个很好的方法，效果通常比k-means好，计算复杂度还低，这都要归功于降维的作用<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/34554321/answer/64372216">[4]</span></a></sup>。</p><h1 id="参考">参考</h1><ul><li>这里非常感谢知乎答主<ahref="https://www.zhihu.com/people/guo-xiao-xian-24"><spanclass="citation"data-cites="郭小天">@郭小天</span></a>的分享给了我很大启发</li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第216页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/3450227<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/37856153<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://www.zhihu.com/question/34554321/answer/64372216<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类距离 </tag>
            
            <tag> K-均值聚类 </tag>
            
            <tag> 层次聚类 </tag>
            
            <tag> DBSCAN算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分类模型</title>
      <link href="/2022/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>判别分析是在已知研究对象分成若干类型并已经取得各种类型的一批已知样本的观测数据，在此基础上根据某些准则建立判别式，然后对未知类型的样品进行判别分析。</p><h1 id="回归">0-1回归</h1><p>即采用逻辑回归(logistic regressio)<br />把观测数据作为因变量对虚拟变量(0,1)进行回归，将y看作事件0发生的概率。</p><h2 id="模型构造">模型构造</h2><h3 id="构造线性概率模型">构造线性概率模型</h3><p><span class="math display">\[y_{i}=\beta_{0}+\beta_{1} x_{1i}+\beta_{2} x_{2 i}+\cdots+\beta_{k} x_{k i}+\mu_{i}\]</span></p><p>㝍成向量乘积形式: <spanclass="math inline">\(y_{i}=\boldsymbol{x}_{i}^{\prime}\boldsymbol{\beta}+u_{i}(i=1,2, \cdots, n)\)</span></p><h3 id="构造两点分布">构造两点分布</h3><p><span class="math display">\[\left\{\begin{array}{l}P(y=1 \mid \boldsymbol{x})=F(\boldsymbol{x}, \boldsymbol{\beta}) \\P(y=0 \mid \boldsymbol{x})=1-F(\boldsymbol{x}, \boldsymbol{\beta})\end{array} \text { 注: 一般 } F(\boldsymbol{x},\boldsymbol{\beta})=S\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)\right.\]</span></p><h3 id="构造连接函数">构造连接函数</h3><p>要使 <spanclass="math inline">\(F(\boldsymbol{x},\boldsymbol{\beta})\)</span>为值域 <span class="math inline">\([0,1]\)</span>上的函数。构造以下函数：</p><ol type="1"><li><spanclass="math inline">\(F(\boldsymbol{x},\boldsymbol{\beta})\)</span>取正态分布累计密度函数<span class="math inline">\((cdf)\)</span> <spanclass="math display">\[\begin{array}{c}F(\boldsymbol{x},\boldsymbol{\beta})=\Phi\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)=\int_{-\infty}^{\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}} \frac{1}{\sqrt{2 \pi}} e^{-\frac{t^{2}}{2}} d t \\\color{Red} (\text { probit 回归 })\end{array}\]</span></li><li><spanclass="math inline">\(F(\boldsymbol{x},\boldsymbol{\beta})\)</span>取<span class="math inline">\(Sigmoid\)</span>函数 <spanclass="math display">\[\begin{aligned}F(\boldsymbol{x}, \boldsymbol{\beta})=&amp;S\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right)=\frac{\exp\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right)}{1+\exp\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right)} \\&amp; \color{Red} (\text{ logistic回归  })\end{aligned}\]</span></li></ol><h3 id="参数求解">参数求解</h3><p>对于非线性模型采用极大似然估计法(MLE)估计： <spanclass="math display">\[f\left(y_{i} \mid \boldsymbol{x}_{i},\boldsymbol{\beta}\right)=\left\{\begin{array}{ll}S\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right) &amp; ,y_{i}=1 \\1-S\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right) &amp; ,y_{i}=0\end{array}\right.\]</span> 即 <span class="math display">\[f\left(y_{i}\mid \boldsymbol{x}_{i},\boldsymbol{\beta}\right)=\left[S\left(\boldsymbol{x}_{i}^{\prime}\boldsymbol{\beta}\right)\right]^{y_{i}}\left[1-S\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)\right]^{1-y_{i}}\]</span> 取对数 <spanclass="math display">\[\ln f\left(y_{i} \mid \boldsymbol{x}_{i},\boldsymbol{\beta}\right)=y_{i} \ln\left[S\left(\boldsymbol{x}_{i}^{\prime}\boldsymbol{\beta}\right)\right]+\left(1-y_{i}\right) \ln\left[1-S\left(\boldsymbol{x}_{i}^{\prime}\boldsymbol{\beta}\right)\right]\]</span> 得到样本对数似然函数 <spanclass="math display">\[\left.\ln L(\boldsymbol{\beta} \mid\boldsymbol{y}, \boldsymbol{x})=\sum_{i=1}^{n} y_{i} \ln\left[S\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)\right]+\sum_{i=1}^{n}\left(1-y_{i}\right) \ln\left[1-S\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)\right]\right.\]</span>求这个函数的最大化。</p><h3 id="求准确率">求准确率</h3><p>把数据分为<strong>训练组</strong>和<strong>测试组</strong>，一般取80%和20%，多次随机抽选训练组和测试组，对模型求一个平均的准确率(交叉验证)。</p><p><img src="https://s2.loli.net/2022/02/12/YVulZUi73kohRfN.png" /></p><h2 id="思考">思考</h2><p>对于这个模型 <span class="math inline">\(\hat{y}\)</span>理解为为事件“<span class="math inline">\(y=1\)</span>”发生的概率</p><p><span class="math display">\[\hat{y}_{i}=P\left(y_{i}=1 \mid\boldsymbol{x}\right)=S\left(\boldsymbol{x}_{i}^{\prime}\hat{\boldsymbol{\beta}}\right)=\frac{\exp\left(\boldsymbol{x}_{i}^{\prime}\hat{\boldsymbol{\beta}}\right)}{1+\exp\left(\boldsymbol{x}_{i}^{\prime}\hat{\boldsymbol{\beta}}\right)}=\frac{e^{\widehat{\beta}_{0}+\widehat{\beta}_{1}x_{1 i}+\widehat{\beta}_{2} x_{2 i}+\cdots+\widehat{\beta}_{k} x_{ki}}}{1+e^{\widehat{\beta}_{0}+\widehat{\beta}_{1} x_{1i}+\widehat{\beta}_{2} x_{2 i}+\cdots+\widehat{\beta}_{k} x_{ki}}}\]</span></p><p>对于 <span class="math inline">\(S\left(\boldsymbol{x}_{i}^{\prime}\hat{\boldsymbol{\beta}}\right)=\frac{1}{2}\)</span> 即</p><p><span class="math display">\[{\widehat{\beta}_{0}+\widehat{\beta}_{1}x_{1 i}+\widehat{\beta}_{2} x_{2 i}+\cdots+\widehat{\beta}_{k} x_{ki}}=0\]</span></p><p>可以看作一个超平面（ <span class="math inline">\(k=2\)</span>时是直线）。该分类的本质就是找到一个“曲线”把 '<spanclass="math inline">\(y=0\)</span>' 和 '<spanclass="math inline">\(y=1\)</span>' 分割到曲线的两侧。</p><h1 id="fisher线性判别分析">Fisher线性判别分析</h1><p>线性判别式分析(Linear Discriminant Analysis, LDA)<br />也叫做Fisher线性判别(Fisher Linear Discriminant ,FLD)</p><p>基本思想：选取适当的投影方向<strong>将高维数据投影到低维空间上</strong>使得投影后各样本类<strong>内离差</strong>平方和尽可能小，而使各样本类间的离差平方和尽可能大<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.jianshu.com/p/cd5ac0b95c03">[2]</span></a></sup>。即，使得在子空间上有最佳的可分离性。</p><figure><img src="https://s2.loli.net/2022/02/12/Eusi4l2NkGBMZj1.png"alt="LDA.png" /><figcaption aria-hidden="true">LDA.png</figcaption></figure><h2 id="一维压缩的fisher判别模型">一维压缩的Fisher判别模型</h2><p>Fisher判别可以将 <span class="math inline">\(C\)</span> 维指标压缩到<span class="math inline">\([1,C-1]\)</span>纬空间。这里只解释将样本压缩到一维的情况。</p><p>设样本数据集为 <spanclass="math inline">\(\{\boldsymbol{D_1},\boldsymbol{D_2}\}\)</span>(二维指标)， <span class="math inline">\(\boldsymbol{X_i}\)</span> 是第<span class="math inline">\(i\)</span> 类样本的集合 ，<spanclass="math inline">\(X_i\)</span> 是第 <spanclass="math inline">\(i\)</span> 类样本的集合，第 <spanclass="math inline">\(i\)</span> 个集合样本是数目是 <spanclass="math inline">\(N_i\)</span> ，<spanclass="math inline">\(x=(d_1,d_2)\)</span>。最佳的向量称为 <spanclass="math inline">\(\boldsymbol{w}\)</span><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/137968371">[4]</span></a></sup>。</p><p>记 <span class="math inline">\(\mu_i\)</span> 为第i类样本质心，为<span class="math display">\[\mu_{i}=\frac{1}{N_{i}} \sum_{x \in\boldsymbol{X_{i}}} x\]</span></p><p><span class="math inline">\(x\)</span> 到 <spanclass="math inline">\(\boldsymbol{w}\)</span> 投影后的样本点均值为</p><p><span class="math display">\[\tilde{\mu}_{i}=\frac{1}{N_{i}} \sum_{x\in  \boldsymbol{X}_{i}} y=\frac{1}{N_{i}} \sum_{x\in  \boldsymbol{X}_{i}} \boldsymbol{w}^{T} x=\boldsymbol{w}^{T}\mu_{i}\]</span></p><p><strong>类间方差最大化</strong>，那么就是要让 <spanclass="math inline">\(J(\boldsymbol{w})\)</span> 最大</p><p><spanclass="math display">\[J(\boldsymbol{w})=\left|\tilde{\mu}_{1}-\tilde{\mu}_{2}\right|=\left|\boldsymbol{w}^{T}\left(\mu_{1}-\mu_{2}\right)\right|\]</span></p><p>但是只满足这一个条件并不行，两个类达到了类间方差最大化的条件，但是可能轴上的投影两个类重合的部分太多，无法进行有效的区分。</p><p><strong>类内方差最小化</strong></p><p>对于类内方差，使用另外一个值<strong>散列值（scatter）</strong>，计算方法如果下，其实就是投影值与中心之间的方差和。目的就是使这个值最小。</p><p><span class="math display">\[\tilde{s_{i}}^{2}=\sum_{y \in\boldsymbol{Y}_{i}}\left(y-\tilde{\mu}_{i}\right)^{2},(y=\boldsymbol{w}^Tx)\]</span></p><p>最后，我们结合这两个条件</p><p><spanclass="math display">\[J(\boldsymbol{w})=\frac{\left|\tilde{\mu_{1}}-\tilde{\mu_{2}}\right|}{\tilde{s_{1}}^{2}+\tilde{s_{2}}^{2}}\]</span></p><p>我们要做的就是让 <spanclass="math inline">\(J(\boldsymbol{w})\)</span> 最大。<ahref="https://blog.csdn.net/antkillerfarm/article/details/80880221">推导过程</a></p><p>结论：</p><p><span class="math display">\[S_{i}=\sum_{x \in\omega_{i}}\left(x-\mu_{i}\right)\left(x-\mu_{i}\right)^{T}\]</span></p><p><span class="math display">\[S_{W}=S_{1}+S_{2}\]</span></p><p><spanclass="math display">\[\boldsymbol{w}=S_{W}^{-1}\left(\mu_{1}-\mu_{2}\right)\]</span></p><h2 id="思考-1">思考</h2><p><imgsrc="https://img-blog.csdnimg.cn/20190516120230815.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpbmFwcGxlTWk=,size_16,color_FFFFFF,t_70" /></p><p><strong>主成分分析(PCA)</strong>:是找到方差尽可能大的维度，使得信息尽可能都保存，不考虑样本的可分离性，不具备预测功能。</p><p><strong>线性判别分析(LAD)</strong>:是找到一个低维的空间，投影后，使得可分离性最佳(保留信息趋少)，投影后可进行判别以及对新的样本进行预测<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/PinappleMi/article/details/90261680">[3]</span></a></sup>。</p><p>相较于压缩至一维空间，压缩到二维平面或超平面上常常更能分离出不同的样本。<img src="https://s2.loli.net/2022/02/12/6gjoFQa8Hy5NWR9.png" /></p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>清风数学建模<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.jianshu.com/p/cd5ac0b95c03<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://blog.csdn.net/PinappleMi/article/details/90261680<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/137968371<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1回归 </tag>
            
            <tag> Fisher线性判别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回归分析</title>
      <link href="/2022/02/08/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/08/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="多元线性回归">多元线性回归</h1><h2 id="模型结构">模型结构</h2><p>多元线性回归是研究一个应变量依赖多个自变量的变化关系，并用线性关系刻画的模型。如下：</p><p><span class="math display">\[\left\{\begin{matrix}y = \beta_0 + \beta_1 x_1 + \cdots + \beta_mx_m + \varepsilon\\\varepsilon \sim N(0,\sigma ^2)\end{matrix}\right.\]</span></p><p>其中：<spanclass="math inline">\(\beta_0,\beta_1,\dotsb,\beta_m\)</span>为回归系数；<span class="math inline">\(x_0,x_1,\dotsb,x_m\)</span>为变量；<span class="math inline">\(\varepsilon\)</span>是误差随机项。</p><p>对于 <span class="math inline">\(n\)</span> 组观测，满足 <spanclass="math inline">\(y_i=\beta_{0} + \beta_1 x_{i1} + \cdots +\beta_mx_{im} + \varepsilon_i\)</span> ,记</p><p><span class="math display">\[\boldsymbol{Y}=\left[\begin{array}{l}y_{1} \\y_{2} \\\vdots \\y_{n}\end{array}\right] \quad, \quad \boldsymbol{X}=\left[\begin{array}{cccc}1 &amp; x_{11} &amp; \ldots &amp; x_{1m} \\1 &amp; x_{21} &amp; \ldots &amp; x_{2m} \\\vdots &amp; \vdots &amp; &amp; \vdots \\1 &amp; x_{n1} &amp; \ldots &amp; x_{nm}\end{array}\right] \quad, \quad\boldsymbol{\beta}=\left[\begin{array}{c}\beta_{0} \\\beta_{1} \\\vdots \\\beta_{k}\end{array}\right] \quad, \quad\boldsymbol{\varepsilon}=\left[\begin{array}{c}\varepsilon_{1} \\\varepsilon_{2} \\\vdots \\\varepsilon_{n}\end{array}\right]\]</span></p><p>这时模型可以写作:</p><p><span class="math display">\[\boldsymbol{Y}=\boldsymbol{X}\boldsymbol{\beta}+\boldsymbol{\varepsilon}\]</span></p><h2 id="参数估计">参数估计</h2><p>模型中的参数 <spanclass="math inline">\(\beta_0,\beta_1,\dotsb,\beta_m\)</span>用最小二乘法估计，得到估计值 <spanclass="math inline">\(\hat{\beta}_{i}\)</span> 。</p><p>需要最小化的函数是：</p><p><span class="math display">\[SSE = Q\left(\beta_{0}, \beta_{1},\ldots,\beta_{p}\right)=\sum_{i=1}^{n}(y_i-\hat{y_i})^2=\sum_{i=1}^{n}\left(y_{i}-\beta_{0}-\beta_{1}x_{i 1}-\ldots-\beta_{p} x_{i p}\right)^{2}\]</span></p><p>为此，令 <span class="math display">\[\frac{\partial Q}{\partial\beta _j} =0,(j=0,1,\dots ,m)\]</span></p><p>解得(详细过程参考<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/48541799">[3]</span></a></sup>或<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第150页.">[1]</span></a></sup>)： <spanclass="math display">\[\boldsymbol{\hat{\beta}}=\left(\boldsymbol{X}^{T}\boldsymbol{X}\right)^{-1} \boldsymbol{X}^{T}\boldsymbol{Y}\]</span></p><p>记 <spanclass="math inline">\(\boldsymbol{\hat{Y}}=\boldsymbol{X}\boldsymbol{\hat{\beta}}\)</span>，<spanclass="math inline">\(\boldsymbol{e}=\boldsymbol{Y}-\boldsymbol{\hat{Y}}\)</span>为残差，而 <span class="math inline">\(SSE=\sum e_i^2\)</span>为残差平方和<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第150页.">[1]</span></a></sup>。</p><h2 id="显著性检验">显著性检验</h2><h3 id="方程显著性检验">方程显著性检验</h3><p>检验这个回归方程本身是否有效。我们给出下列原假设和备择假设： <spanclass="math display">\[ H_0: \beta_j=0 , j=1,2,\dots,m\\H_1: \beta_1,\dots,\beta_m 不全为 0\]</span> 当假设 <spanclass="math inline">\(H_0\)</span> 成立时，满足： <spanclass="math display">\[F=\frac{SSR/m}{SSE/(n-m-1)} \simF(m,n-m-1)\]</span></p><p>式中, <spanclass="math inline">\(SSR=\sum_{i=1}^{n}\left(\hat{y}_{i}-\bar{y}\right)^{2}\)</span>是回归平方和； <spanclass="math inline">\(SSE=\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}\)</span>是残差平方和。再给定的 显著性水平 <spanclass="math inline">\(\alpha\)</span> 下，对于上 <spanclass="math inline">\(\alpha\)</span> 分位数 <spanclass="math inline">\(F_{\alpha}(k, n-k-1)\)</span> ， 检验的拒绝域为<span class="math inline">\(F&gt;F_{\alpha}(k, n-k-1)\)</span>接受域可以为：<span class="math inline">\(F_{1-\alpha/2}(k,n-k-1)&lt;F&lt;F_{\alpha/2}(k, n-k-1)\)</span>。</p><blockquote><p>上式，书上是这样写的，但是好像写错了。 (22.2.8)</p></blockquote><p>注：<span class="math inline">\(H_0\)</span> 仅说明 <spanclass="math inline">\(y\)</span> 与 <spanclass="math inline">\(x_1,x_2,\dots,x_m\)</span>的线性关系不明显，可能存在非线性关系(取对数)。</p><p>对于预测型回归需要检查拟合优度(<spanclass="math inline">\(R^2\)</span>)；解释型回归更多的关注模型整体显著性以及自变量的统计显著性和经济意义显著性即可。</p><p><spanclass="math display">\[R^2=\frac{SSR}{SST}=\frac{\sum_{i=1}^{n}(\hat{y_i}-\bar{y})^2}{\sum_{i=1}^{n}(y_i-\bar{y})^2}\]</span><span class="math inline">\(R\)</span> 称为复相关系数，<spanclass="math inline">\(R^2\)</span> 越大，<spanclass="math inline">\(y\)</span> 与 <spanclass="math inline">\(x_1,x_2,\dots,x_m\)</span> 相关关系越密切，通常<span class="math inline">\(R\)</span> 大于 <spanclass="math inline">\(0.8\)</span>才认为相关性成立<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第150页.">[1]</span></a></sup>,这是一个看拟合的好不好的一个综合指标。</p><h3 id="系数显著性检验">系数显著性检验</h3><p>经过上述验证得到 <span class="math inline">\(H_0\)</span>，被拒绝，<span class="math inline">\(\beta_j\)</span> 不全为 <spanclass="math inline">\(0\)</span> ,但不排除存在 <spanclass="math inline">\(\beta_j\)</span> 为 <spanclass="math inline">\(0\)</span> 。所以还要进行以下 <spanclass="math inline">\(m+1\)</span> 个检验。 <spanclass="math display">\[H_0^{(j)}：\beta_{j}=0 ,j=0,1,\cdots,m\]</span></p><p>根据无偏性和<span class="math inline">\(cov(\hat\beta)=\sigma^2(X^{T}X)^{-1}\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/heirenmin/article/details/94443404">[2]</span></a></sup>，得到 <span class="math inline">\(\hat \beta_j\sim N(\beta_j, c_{jj}\sigma^2)\)</span> ,其中 <spanclass="math inline">\(c_{jj}\)</span> 表示 <spanclass="math inline">\((X^{T}X)^{-1}\)</span> 的对角线元素 <spanclass="math inline">\((j,j)\)</span> 。考虑构造<strong>t检验</strong><span class="math inline">\(\frac{X}{\sqrt{Y/N}}\)</span>。</p><p><span class="math display">\[t=\frac{\hat\beta_j}{\sqrt{c_{jj}}\sigma}=\frac{\hat{\beta_j}/\sqrt{c_{jj}}}{\sqrt{SSE/(n-m-1)}}\sim t(n-m-1)\]</span></p><p>在 <span class="math inline">\(1-\alpha\)</span> 的置信水平下， <spanclass="math inline">\(\beta_j\)</span>的置信区间为<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第150页.">[1]</span></a></sup>： <spanclass="math display">\[[\hat{\beta_j}-t_{\frac{\alpha}{2}}(n-m-1)s\sqrt{c_{jj}},\hat{\beta_j}+t_{\frac{\alpha}{2}}(n-m-1)s\sqrt{c_{jj}}]\]</span>其中 <span class="math inline">\(s=\sqrt{\frac{SSE}{n-m-1}}\)</span>；或者当 <spanclass="math inline">\(|t_j|&lt;t_{\frac{\alpha}{2}}(n-m-1)\)</span>判断接受 <span class="math inline">\(H_0^{(j)}\)</span> ,否则拒绝。</p><h2 id="检验异方差">检验异方差</h2><p>残差的方差齐(Equalvariance),即LINE原则。即残差的大小不随预测值水平的变化而变化，通常在分析残差的时候，可以通过绘制普通残差或者标准化残差与预测值的散点图进行判断。残差的分布随着变量的取值的增大而呈现扩散趋势产生异方差<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/161483493">[5]</span></a></sup>。</p><p>异方差是指各个扰动项的方差不相同，那么方差较大的扰动项破坏模型稳定性的程度就较大<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="清风数学建模视频">[4]</span></a></sup>；因变量的变异程度会随着自身数值或者其他变量的变化而变化，从而不满足残差方差齐性的条件<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/161483493">[5]</span></a></sup>。</p><p><img src="https://s2.loli.net/2022/02/09/ryLoOf9UKcPJqWg.png" /></p><h3 id="多种检验方法"><ahref="https://blog.csdn.net/weixin_46649908/article/details/117927359">多种检验方法</a></h3><h3 id="解决方法">解决方法</h3><ol type="1"><li>构建加权最小二乘法模型</li></ol><p>判断导致残差不满足方差齐性的指标，对其加权。</p><ol start="2" type="1"><li><p>使用“OLS + 稳健标准误”</p></li><li><p>广义最小二乘法 GLS</p></li></ol><h2 id="检验多重共线性">检验多重共线性</h2><p>方差膨胀因子(Variance Inflation Factor)VIF</p><p>假设 <span class="math inline">\(m\)</span> 个自变量中，第 <spanclass="math inline">\(j\)</span> 个自变量的 <spanclass="math inline">\(VIF=\frac{1}{1-R_{1-m/j}^2}\)</span></p><p><span class="math inline">\(R_{1-m/j}^2\)</span> 是将第 <spanclass="math inline">\(j\)</span> 个自变量作为因变量，对余下 <spanclass="math inline">\(m-1\)</span> 个自变量回归得到的拟合优度，<spanclass="math inline">\(VIF_j\)</span> 越大（也就是 <spanclass="math inline">\(R_{1-m/j}^2\)</span>越大），说明当前变量和其他变量关联度越大<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="清风数学建模视频">[4]</span></a></sup>。记模型：</p><p><spanclass="math display">\[VIF=max(VIF_1,VIF_2,\dots,VIF_m)\]</span></p><p>若，<span class="math inline">\(VIF &gt; 10\)</span>,则表示回归模型存在严重多重共线性。</p><p>注：多重共线性不影响回归方程的解释变量能力与预测能力，只会影响被多重共线性影响的变量的显著性（系数）。解决办法是增大样本或剔除共线性变量。</p><figure><img src="https://s2.loli.net/2022/02/08/tOTeL4yjENYF6ld.png"alt="用散点图观察相关性" /><figcaption aria-hidden="true">用散点图观察相关性</figcaption></figure><p>有时候逐步回归（Lasso回归）是个快捷不动脑子的做法。此外，<strong>主成分回归</strong>也可用来解决多重共线性的问题。</p><h2 id="spss实现多元线性回归">SPSS实现多元线性回归</h2><p><ahref="https://zhuanlan.zhihu.com/p/143049922">SPSS实现多元线性回归</a></p><h1 id="岭回归和lasso回归">岭回归和Lasso回归</h1><p>岭回归 (Ridge regression)<br />Lasso(Least absolute shrinkage and selection operator)回归<br />是一种压缩估计。它通过构造一个惩罚函数得到一个较为精炼的模型，使得它压缩一些回归系数。以损失部分信息、降低精度为代价获得回归系数更为符合实际、更可靠的回归方法，对病态数据的拟合要强于最小二乘法。</p><p><span class="math display">\[\left\{\begin{matrix}多元线性：\boldsymbol{\hat{\beta }} =argmin_{\hat{\beta }}\sum_{i=1}^{n}(y_i-\boldsymbol{x_i}^T \boldsymbol{\hat{\beta} } )^2，其中\boldsymbol{\hat{\beta}}=[\hat{\beta}_1,\hat{\beta}_2,\dots ]\\岭回归：\boldsymbol{\hat{\beta } }=argmin_{\hat{\beta }} [\sum_{i=1}^{n}(y_i-\boldsymbol{x_i}^T \boldsymbol{\hat{\beta}}  )^2 +\lambda \sum_{i=1}^n \hat{\beta_i}^2]，\lambda&gt;0\\Lasso回归：\boldsymbol{\hat{\beta }} =argmin_{\hat{\beta }} [\sum_{i=1}^{n}(y_i-\boldsymbol{x_i}^T \boldsymbol{\hat{\beta} } )^2 +\lambda \sum_{i=1}^n |\hat{\beta_i}|]\end{matrix}\right.\]</span></p><p>其中新增的最后一项<span class="math inline">\(\sum_{i=1}^n\hat{\beta_i}^2\)</span>称为惩罚函数。</p><p>对于岭回归有解为：</p><p><spanclass="math display">\[\boldsymbol{\widehat{\beta}}=\left(\boldsymbol{X}^{T}\boldsymbol{X}+\lambda \boldsymbol{I}\right)^{-1} \boldsymbol{X}^{T}\boldsymbol{y}\]</span></p><p>易知：<span class="math inline">\(\lambda\)</span> 趋近 <spanclass="math inline">\(0\)</span> 时，系数和多元线性回归相同；<spanclass="math inline">\(\lambda\)</span> 趋近无穷时，系数趋近 <spanclass="math inline">\(0\)</span> 。</p><p>Lasso回归相比岭回归，能将不重要的回归系数压缩至 <spanclass="math inline">\(0\)</span> ，可以进行降纬，但是没有显式解。</p><p><img src="https://s2.loli.net/2022/02/09/XOaLo1vwhMDCgbn.jpg" /></p><h1 id="多元二项式回归">多元二项式回归</h1><p>Matlab 的统计工具箱提供了多元二项式回归命令 <code>rstool</code></p><div class="hljs code-wrapper"><pre><code class="hljs matlab">rstool(X,Y,model,alpha)</code></pre></div><p>其中 <code>alpha</code> 为显著性水平（默认为 <spanclass="math inline">\(0.05\)</span>）, <code>model</code>有以下四个模型（默认为线性模型）</p><ol type="1"><li><span class="math inline">\(\operatorname{linear}( 线性 ):y=\beta_{0}+\beta_{1} x_{1}+\cdots+\beta_{m} x_{m}\)</span></li><li><span class="math inline">\(purequadratic (纯二次) :y=\beta_{0}+\beta_{1} x_{1}+\cdots+\beta_{m} x_{m}+\sum\limits_{\tinyj=1}^{\tiny m} \beta_{j j} x_{j}^{2}\)</span></li><li><span class="math inline">\(interaction(交叉) :y=\beta_{0}+\beta_{1} x_{1}+\cdots+\beta_{m} x_{m}+\sum\limits_{\tiny1\leqslant j&lt;k \leqslant m} \beta_{j k} x_{j} x_{k}\)</span></li><li><span class="math inline">\(quadratic(完全二次) :y=\beta_{0}+\beta_{1} x_{1}+\cdots+\beta_{m} x_{m}+\sum\limits_{\tiny 1\leqslant j \leqslant k \leqslant m} \beta_{j k} x_{j}x_{k}\)</span></li></ol><h1 id="非线性回归">非线性回归</h1><p>这里的“线性”是相对于模型参数 <spanclass="math inline">\(\beta_0,\beta_1,\dotsb,\beta_m\)</span>而言的。</p><p>对于此类问题，应先给出 <span class="math inline">\(y\)</span> 与<span class="math inline">\(x_1,x_2,\dots,x_n\)</span> 关于 <spanclass="math inline">\(\beta_0,\beta_1,\dotsb,\beta_m\)</span>的非线性表达式。</p><p>再使用 Matlab 的 <code>nlpredci</code> 计算回归系数。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第150页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://blog.csdn.net/heirenmin/article/details/94443404<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/48541799<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>清风数学建模视频<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/161483493<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元线性回归 </tag>
            
            <tag> 多元二项式回归 </tag>
            
            <tag> 非线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插值算法</title>
      <link href="/2022/02/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"/>
      <url>/2022/02/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.6，其中一些理解可能已被笔者证伪或废弃。</p>          </div><p><strong>定义</strong>：给定一组离散点列，要求一条曲线将点依次连接，称之为插值<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="《数学建模算法与运用》">[1]</span></a></sup>。</p><p>利用已知的点建立合适的插值函数 <spanclass="math inline">\(f(x)\)</span> ,未知点 <spanclass="math inline">\(x_i\)</span> 由插值函数 <spanclass="math inline">\(f(x)\)</span> 可以求得 <spanclass="math inline">\((x_i,f(x_i))\)</span>近似代替未知点<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/64855561">[3]</span></a></sup>。</p><p><strong>作用</strong>：利用插值曲线可以对数据进行填充——用少量模拟产生一些靠谱的新数据。</p><h1 id="分段插值">分段插值</h1><h2 id="分段线性插值">分段线性插值</h2><p>这是最简单也最基础的插值方法，折现统计图的连接方式就是用的分段线性插值。使用函数表时一般直接用该方法。</p><figure><img src="https://s2.loli.net/2022/02/06/7mO13pyTznUFW26.png"alt="某折线统计图" /><figcaption aria-hidden="true">某折线统计图</figcaption></figure><h2 id="分段二次插值">分段二次插值</h2><p>取结点 <span class="math inline">\(x_i\)</span> 以及其左右的三个节点<span class="math inline">\(x_{i-1},x_{i},x_{i+1}\)</span> 进行在区间<span class="math inline">\([x_{i-1},x_{i+1}]\)</span>的二次函数插值，即</p><p><span class="math display">\[f(x) \approxL_{2}(x)=\sum_{k=i-1}^{i+1}\left[y_{k} \prod_{j=i-1 \atop j \neqk}^{i+1}\frac{\left(x-x_{j}\right)}{\left(x_{k}-x_{i}\right)}\right]\]</span></p><p>其意义是用分段抛物线代替 <span class="math inline">\(y=f(x)\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="清风数学建模">[2]</span></a></sup>。这个方法能保证函数的连续型与一定看起来的平滑性，但是<strong>不保证函数光滑</strong>，即不保证函数可导。</p><p>分段二维插值可以很好的避免多项式插值带来的龙格效应，同时简单易于理解又能看起来平滑，是很常用的方法。</p><h1 id="多项式插值">多项式插值</h1><p>多项式插值的本质是对于 <span class="math inline">\(n+1\)</span>个互不相同的节点 <span class="math inline">\((x_i,y_i)(i=0,1,2,\dots,n)\)</span> 求得一个唯一的多项式： <spanclass="math display">\[L_{n}(x)=a_{0}+a_{1} x+a_{2} x^{2}+\ldots+a_{n}x^{n}\]</span> 使得 <span class="math inline">\(L_n(x_i)=y_i\)</span>,即 <span class="math display">\[\left[\begin{array}{cccc}1 &amp; x_{0} &amp; \cdots &amp; x_{0}^{n} \\1 &amp; x_{1} &amp; \cdots &amp; x_{1}^{n} \\\vdots &amp; \vdots &amp; \cdots &amp; \vdots \\1 &amp; x_{n} &amp; \cdots &amp; x_{n}^{n}\end{array}\right] \left[\begin{array}{c}a_{0} \\a_{1} \\\vdots \\a_{n}\end{array}\right] =\left[\begin{array}{c}y_{0} \\y_{1} \\\vdots \\y_{n}\end{array}\right]\]</span></p><p>对于上述范德蒙行列式，易得，<spanclass="math inline">\([a_1,a_2,\dotsb]\)</span> 有且仅有一组解。</p><h2 id="拉格朗日插值法">拉格朗日插值法</h2><p>上多项式组易解得</p><p><spanclass="math display">\[L(x)=y_1\frac{(x-x_2)(x-x_3)...(x-x_n)}{(x_1-x_2)(x_1-x_3)...(x_1-x_n)}+y_2\frac{(x-x_1)(x-x_3)...(x-x_n)}{(x_2-x_1)(x_2-x_3)...(x_2-x_n)}...+y_{n}\frac{(x-x_1)(x-x_2)...(x-x_{n-1})}{(x_{n}-x_1)(x_{n}-x_2)...(x_{n}-x_{n-1})}\]</span>即 <span class="math display">\[L(x)=\sum_{i=1}^{n}y_i \prod_{j=1,j\neq  i}^n \frac{x-x_j}{x_i-x_j} \]</span> 为拉格朗日插值法。</p><p><strong>注</strong>：拉格朗日插值公式在理论分析理解上很容易理解，但是若插值节点发生改变时，插值公式随之就要重新计算生成，在实际计算中会占用大量的计算量。牛顿法的出现正是克服这个问题<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/64855561">[3]</span></a></sup>。</p><h2 id="牛顿插值法">牛顿插值法</h2><p><span class="math display">\[\begin{aligned}f(x)=&amp; f\left(x_{0}\right)+f\left[x_{0},x_{1}\right]\left(x-x_{0}\right) \\&amp;+f\left[x_{0}, x_{1},x_{2}\right]\left(x-x_{0}\right)\left(x-x_{1}\right)+\cdots \\&amp;+f\left[x_{0}, x_{1}, \cdots, x_{n-2},x_{n-1}\right]\left(x-x_{0}\right)\left(x-x_{1}\right)\cdots\left(x-x_{n-3}\right)\left(x-x_{n-2}\right) \\&amp;+f\left[x_{0}, x_{1}, \cdots, x_{n-1},x_{n}\right]\left(x-x_{0}\right)\left(x-x_{1}\right)\cdots\left(x-x_{n-2}\right)\left(x-x_{n-1}\right)\end{aligned}\]</span></p><h3 id="商差">商差</h3><ul><li>一阶差商</li></ul><p><span class="math display">\[f\left[x_{i},x_{j}\right]=\frac{f\left(x_{i}\right)-f\left(x_{j}\right)}{x_{i}-x_{j}}\quad\left(i \neq j, x_{i} \neq x_{j}\right)\]</span></p><ul><li>二阶差商</li></ul><p><span class="math display">\[f\left[x_{i}, x_{j},x_{k}\right]=\frac{f\left[x_{i}, x_{j}\right]-f\left[x_{j},x_{k}\right]}{x_{i}-x_{k}} \quad(i \neq k)\]</span></p><ul><li>n阶差商</li></ul><p><span class="math display">\[f\left[x_{0}, x_{1}, \Lambdax_{n}\right]=\frac{f\left[x_{0}, x_{1}, \Lambda,x_{n-1}\right]-f\left[x_{1}, x_{2}, \Lambdax_{n}\right]}{x_{0}-x_{n}}\]</span></p><p>由以上定义我们的到<strong>差商表</strong>如下：</p><p><span class="math display">\[\begin{array}{cccrcc}x_{i} &amp; y_{i} &amp; \text { 一阶差商 } &amp; \text { 二阶差商 }&amp; \cdots \cdots &amp; n \text { 阶差商 } \\&amp; &amp; &amp; &amp; \\x_{0} &amp; f\left(x_{0}\right) &amp; &amp; &amp; \\x_{1} &amp; f\left(x_{1}\right) &amp; f\left[x_{0}, x_{1}\right] &amp;&amp; \\x_{2} &amp; f\left(x_{2}\right) &amp; f\left[x_{1}, x_{2}\right] &amp;f\left[x_{0}, x_{1}, x_{2}\right] &amp; \\&amp; \cdots \cdots &amp; \cdots \cdots &amp; \cdots \cdots &amp; \\x_{n-1} &amp; f\left(x_{n-1}\right) &amp; \cdots \cdots &amp; \cdots\cdots \\x_{n} &amp; f\left(x_{n}\right) &amp; f\left[x_{n-1}, x_{n}\right] &amp;f\left[x_{n-2}, x_{n-1}, x_{n}\right] &amp;\dots  &amp;f\left[x_{n}\ldots, x_{n}\right] \\\end{array}\]</span> 我们可以得到下面公式： <spanclass="math display">\[\begin{array}{l}f(x)=f\left(x_{\theta}\right)+f\left[x,x_{\theta}\right]\left(x-x_{\theta}\right),\\f\left[x, x_{0}\right]=f\left[x_{0}, x_{1}\right]+f\left[x, x_{0},x_{1}\right]\left(x-x_{1}\right),\\f\left[x, x_{0}, x_{1}\right]=f\left[x_{0}, x_{1},x_{2}\right]+f\left[x, x_{0}, x_{1}, x_{2}\right]\left(x-x_{2}\right),\\\cdots \\f\left[x, x_{\theta}, \cdots, x_{m-1}\right]=f\left[x_{\theta}, x_{1},\cdots, x_{n}\right]+J\left[x, x_{\theta}, \cdots,x_{n}\right]\left(x-x_{n}\right)\end{array}\]</span> 可得到牛顿插值法。</p><h2 id="拉格朗日插值与牛顿插值">拉格朗日插值与牛顿插值</h2><p>牛顿插值法和拉格朗日插值法两者都是多项式插值法，本质上，两者的结果相同，只不过表示的形式不同。牛顿插值法的计算过程具有继承性有易于变动的特点。</p><h2 id="龙格现象">龙格现象</h2><p>当次数渐高，很容易在多项式插值的边界处产生巨大波动，称为龙格现象。</p><p><ahref="https://www.zhihu.com/question/39329749">这里</a>是龙格现象产生原因</p><figure><img src="https://s2.loli.net/2022/02/06/6uklOIA1qyXJ5UZ.png"alt="龙格现象展示" /><figcaption aria-hidden="true"><ahref="https://www.51wendang.com/doc/ea665b984958ca1de13ba4ab">龙格现象展示</a></figcaption></figure><h1 id="埃尔米特hermite插值">埃尔米特(Hermite)插值</h1><p>不但要求在节点处上的函数值相等，而且还要求对应的导数值也相等，甚至要求高阶导数也相等，满足这种要求的插值多项式就是“Hermite插值多项式”<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/Rayme629/article/details/113174004">[4]</span></a></sup>。</p><p>直接使用Hermite插值得到的多项式次数较高，也存在着“龙格现象（Rungephenomenon）”。因此，在实际应用中，往往使用分段三次Hermite插值多项式（PCHIP），来提高“模拟数据的准确性”<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/Rayme629/article/details/113174004">[4]</span></a></sup>。</p><h2 id="原理">原理</h2><p>假定已知函数 <span class="math inline">\(f(x)\)</span> 在揷值区间<span class="math inline">\([p, q]\)</span> 上的 <spanclass="math inline">\(n+1\)</span> 个互不相同的节点 <spanclass="math inline">\(x_{i}(i=0,1, \ldots, n)\)</span> 处满足 <spanclass="math inline">\(f\left(x_{i}\right)=f_{i}\)</span> 及 <spanclass="math inline">\(f^{\prime}\left(x_{i}\right)=f_{i}^{\prime}(i=0,1,2,\ldots, n)\)</span> , 如果函数 <span class="math inline">\(G(x)\)</span>的存在满足下列条件: 1. <span class="math inline">\(G(x)\)</span>在每个小区间上的多项式次数为 3 ; 2. <span class="math inline">\(G(x) \inC^{1}[a, b]\)</span> ; 3. <spanclass="math inline">\(G\left(x_{i}\right)=f\left(x_{i}\right), \quadG^{\prime}\left(x_{i}\right)=f^{\prime}\left(x_{i}\right), \quad i=(0,1,\ldots, n)\)</span> 就称 <span class="math inline">\(G(x)\)</span> 是<span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(n+1\)</span> 个节点 <spanclass="math inline">\(x_{i}\)</span> 上的分段三次埃尔米特插值多项式。<span class="math display">\[\begin{aligned}G(x)=&amp; h_{k} y_{k}(x)+h_{k+1} y_{k+1}(x)+H_{k}(x)y_{k}^{\prime}+H_{k+1}(x) y_{k+1}^{\prime} \\=&amp;\left(1+2\frac{x-x_{k}}{x_{k+1}-x_{k}}\right)\left(\frac{x-x_{k+1}}{x_{k}-x_{k+1}}\right)^{2}y_{k}+\left(1+2\frac{x-x_{k+1}}{x_{k}-x_{k+1}}\right)\left(\frac{x-x_{k}}{x_{k+1}-x_{k}}\right)^{2}y_{k+1} \\&amp;+\left(x-x_{k}\right)\left(\frac{x-x_{k+1}}{x_{k}-x_{k+1}}\right)^{2}y_{k}^{\prime}+\left(x-x_{k+1}\right)\left(\frac{x-x_{k}}{x_{k+1}-x_{k}}\right)^{2}y_{k+1}^{\prime}\end{aligned}\]</span></p><h3 id="推广">推广</h3><p>Hermite 揷值多项式为: <span class="math display">\[H(x)=\sum_{i=0}^{n} h_{i}\left[\left(x_{i}-x\right)\left(2 a_{i}y_{i}-y_{i}^{\prime}\right)+y_{i}\right]\]</span> 其中: <spanclass="math display">\[h_{i}=\prod_{j=0 \atop j \neqi}^{n}\left(\frac{x-x_{j}}{x_{i}-x_{j}}\right)^{2}, \quada_{i}=\sum_{j=0 \atop j \neq i}^{n} \frac{1}{x_{i}-x_{j}}\]</span></p><h2 id="代码">代码</h2><h3 id="手写函数">手写函数</h3><p>设n个节点的数据以数组<code>x0</code>（已知点的横坐标），<code>y0</code>（函数值），<code>y1</code>（导数值）输入（注意Matlat 的数组下标从 <span class="math inline">\(1\)</span> 开始），<spanclass="math inline">\(m\)</span> 个插值点以数组 <code>x</code>输入，输出数组 <code>y</code> 为 <span class="math inline">\(m\)</span>个插值。编 <div class="hljs code-wrapper"><pre><code class="hljs m">function y<span class="hljs-built_in">=</span>hermite(x0,y0,y1,x);n<span class="hljs-built_in">=</span>length(x0);m<span class="hljs-built_in">=</span>length(x);for k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:m    yy<span class="hljs-built_in">=</span><span class="hljs-number">0.0</span>;    for i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:n        h<span class="hljs-built_in">=</span><span class="hljs-number">1.0</span>;        a<span class="hljs-built_in">=</span><span class="hljs-number">0.0</span>;        for j<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:n            <span class="hljs-built_in">if</span> j~<span class="hljs-built_in">=</span>i                h<span class="hljs-built_in">=</span>h*((x(k)-x0(j))/(x0(i)-x0(j)))^<span class="hljs-number">2</span>;                a<span class="hljs-built_in">=</span><span class="hljs-number">1</span>/(x0(i)-x0(j))+a;            end        end        yy<span class="hljs-built_in">=</span>yy+h*((x0(i)-x(k))*(<span class="hljs-number">2</span>*a*y0(i)-y1(i))+y0(i));    end    y(k)<span class="hljs-built_in">=</span>yy;end</code></pre></div> ### 调用Matlab封装函数 <div class="hljs code-wrapper"><pre><code class="hljs m">x <span class="hljs-built_in">=</span> -<span class="hljs-number">3</span>:<span class="hljs-number">3</span>; y <span class="hljs-built_in">=</span> [-<span class="hljs-number">1</span> -<span class="hljs-number">1</span> -<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]; xq1 <span class="hljs-built_in">=</span> -<span class="hljs-number">3</span>:.<span class="hljs-number">01</span>:<span class="hljs-number">3</span>;p <span class="hljs-built_in">=</span> pchip(x,y,xq1);s <span class="hljs-built_in">=</span> spline(x,y,xq1);m <span class="hljs-built_in">=</span> makima(x,y,xq1);plot(x,y,<span class="hljs-string">&#x27;o&#x27;</span>,xq1,p,<span class="hljs-string">&#x27;-&#x27;</span>,xq1,s,<span class="hljs-string">&#x27;-.&#x27;</span>,xq1,m,<span class="hljs-string">&#x27;--&#x27;</span>)legend(<span class="hljs-string">&#x27;Sample Points&#x27;</span>,<span class="hljs-string">&#x27;pchip&#x27;</span>,<span class="hljs-string">&#x27;spline&#x27;</span>,<span class="hljs-string">&#x27;makima&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;SouthEast&#x27;</span>)</code></pre></div> <imgsrc="https://ww2.mathworks.cn/help/matlab/ref/datainterpolationcomparisonexample_01_zh_CN.png" />| <imgsrc="https://ww2.mathworks.cn/help/matlab/ref/datainterpolationcomparisonexample_02_zh_CN.png" />---|---</p><h1 id="样条插值">样条插值</h1><p>所谓样条（Spline）本来是工程设计中使用的一种绘图工具，它是富有弹性的细木条或细金属条。绘图员利用它把一些已知点连接成一条光滑曲线（称为样条曲线），并使连接点处有连续的曲率<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/Rayme629/article/details/113174004">[4]</span></a></sup>。</p><p>数学上将<strong>具有一定光滑性的分段多项式</strong>称为样条函数。</p><p>对于 <span class="math inline">\(\Delta : \quada=x_{0}&lt;x_{1}&lt;\cdots&lt;x_{n-1}&lt;x_{n}=b\)</span> 满足：</p><ol type="1"><li>在每个小区间 <span class="math inline">\(\left[x_{i},x_{i-1}\right](i=0,1, \cdots, n-1)\)</span> 上 <spanclass="math inline">\(s(x)\)</span> 是 <spanclass="math inline">\(k\)</span> 次多项式。</li><li><span class="math inline">\(s(x)\)</span> 在 <spanclass="math inline">\([a, b]\)</span> 上具有 <spanclass="math inline">\(k-1\)</span> 阶连续导数。即 <spanclass="math inline">\(S_{i}^{(j)}(x_{i+1})=S_{i+1}^{(j)}(x_{i+1})\)</span><span class="math inline">\((j=0,1,\dots,k-1)\)</span></li></ol><p>一般形式为：</p><p><span class="math display">\[s_{k}(x)=\sum_{i=0}^{k} \frac{\alpha_{i}x^{i}}{i !}+\sum_{j=1}^{n-1} \frac{\beta_{j}}{k!}\left(x-x_{j}\right)_{+}^{k}\]</span></p><p>在实际中最常用的是二次样条函数和<strong>三次样条函数</strong>。</p><p>三次样条生成的曲线更加光滑，相较Hermite更适合曲线(三角函数)。</p><h2 id="三次样条插值代码">三次样条插值代码</h2><div class="hljs code-wrapper"><pre><code class="hljs m">x <span class="hljs-built_in">=</span> ‐pi:pi;y <span class="hljs-built_in">=</span> sin(x);new_x <span class="hljs-built_in">=</span> ‐pi:<span class="hljs-number">0.1</span>:pi;p1 <span class="hljs-built_in">=</span> pchip(x,y,new_x); <span class="hljs-comment">%分段三次埃尔米特插值</span>p2 <span class="hljs-built_in">=</span> spline(x,y,new_x); <span class="hljs-comment">%三次样条插值</span>pp <span class="hljs-built_in">=</span> csape(x0,y0_ext,conds); <span class="hljs-comment">%另一个三次样条插值？</span>plot(x,y,<span class="hljs-string">&#x27;o&#x27;</span>,new_x,p1,<span class="hljs-string">&#x27;r‐&#x27;</span>,new_x,p2,<span class="hljs-string">&#x27;b‐&#x27;</span>)legend(<span class="hljs-string">&#x27;样本点&#x27;</span>,<span class="hljs-string">&#x27;三次埃尔米特插值&#x27;</span>,<span class="hljs-string">&#x27;三次样条插值&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;SouthEast&#x27;</span>) <span class="hljs-comment">%标注显示在东南方向</span></code></pre></div><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《数学建模算法与运用》<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>清风数学建模<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/64855561<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/Rayme629/article/details/113174004<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://www.jianshu.com/p/6dfca5f6b249<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://ww2.mathworks.cn/help/matlab/ref/pchip.html<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分段插值 </tag>
            
            <tag> 多项式插值 </tag>
            
            <tag> 埃尔米特插值 </tag>
            
            <tag> 样条插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022—SWJTU寒假选拔赛第三场复盘</title>
      <link href="/2022/02/02/14/"/>
      <url>/2022/02/02/14/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一个迟到几周的复盘，现在大年初一才来补题(😓)</p><h1 id="链接">链接</h1><div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894"><b>2022—SWJTU寒假选拔赛第三场</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/m0_56007815/article/details/122655578?spm=1001.2014.3001.5501"><b>前辈写的题解</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><figure><img src="https://s2.loli.net/2022/02/02/ZaWudk8AX1nLYgm.png"alt="RANK(E题是一道AC题被删的补偿)" /><figcaptionaria-hidden="true">RANK(E题是一道AC题被删的补偿)</figcaption></figure><h2 id="a-a"><a href="https://vjudge.net/contest/477408#problem/A">A-A√</a></h2><p>要想让 <span class="math inline">\(S(x + 1) &lt; s(x)\)</span>只能可能发生在进位的时候,因此每逢尾数为 <spanclass="math inline">\(9\)</span> 时就会对答案产生贡献。</p><p>其实通过样例就可以得到解为<spanclass="math inline">\((n+1)/10\)</span></p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();        cout&lt;&lt;(n+<span class="hljs-number">1</span>)/<span class="hljs-number">10</span>&lt;&lt;endl;    &#125;&#125;</code></pre></div><h2 id="b-b"><a href="https://vjudge.net/contest/477408#problem/B">B-B√</a></h2><p>题目重述；给出 <span class="math inline">\(1\)</span> 个长度为 <spanclass="math inline">\(n\)</span> 的序列，以及 <spanclass="math inline">\(1\)</span> 个正整数 <spanclass="math inline">\(m\)</span>。问这个原序列中是否存在非空子序列，使其元素之和能被<span class="math inline">\(m\)</span> 整除。</p><p>看到数据范围数据范围：<spanclass="math inline">\(1&lt;=n&lt;=10^6,2&lt;=m&lt;=1000,1&lt;=n&lt;=10\)</span>。 自然不可能用 <spanclass="math inline">\(O(nm)\)</span>，时间复杂度仅仅与<spanclass="math inline">\(m\)</span>有关。</p><ul><li><p>考虑 <span class="math inline">\(n&gt;m\)</span>的情况：我们对整个数列做前缀和，然后再对 <spanclass="math inline">\(m\)</span> 取模。根据抽屉原理，因为 <spanclass="math inline">\(n&gt;m\)</span>，所以在 <spanclass="math inline">\(n\)</span> 个前缀和中必有两个对 <spanclass="math inline">\(m\)</span>取模于是相等，它们中间那段就是答案。</p></li><li><p>而 n⩽m 的情况，n⩽103，不会超时,直接 <spanclass="math inline">\(O(nm)\)</span> 的背包。</p></li></ul><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> x*f;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100010</span><span class="hljs-keyword">int</span> n, m, i, j, k; <span class="hljs-keyword">int</span> dp[N], f[N], x; <span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; n=<span class="hljs-built_in">read</span>(); m=<span class="hljs-built_in">read</span>();  <span class="hljs-keyword">if</span>(n&gt;m) <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES&quot;</span>), <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;  x=<span class="hljs-built_in">read</span>();  <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; ++j) f[j]=dp[j];  <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; ++j)   dp[(j+x)%m]+=f[j];   dp[x%m]++; <span class="hljs-comment">//只有当前x的子集</span> &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, (dp[<span class="hljs-number">0</span>] ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>));  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> int_;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getchar</span>(), f = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(; c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>; c=<span class="hljs-built_in">getchar</span>())  <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>) f = -f; <span class="hljs-keyword">for</span>(; <span class="hljs-string">&#x27;0&#x27;</span>&lt;=c&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>; c=<span class="hljs-built_in">getchar</span>())  a = (a&lt;&lt;<span class="hljs-number">3</span>)+(a&lt;&lt;<span class="hljs-number">1</span>)+(c^<span class="hljs-number">48</span>); <span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123; <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">9</span>) <span class="hljs-built_in">writeint</span>(x/<span class="hljs-number">10</span>); <span class="hljs-built_in">putchar</span>((x%<span class="hljs-number">10</span>)^<span class="hljs-number">48</span>);&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXM = <span class="hljs-number">1000</span>;<span class="hljs-keyword">int</span> gcd[MAXM];<span class="hljs-keyword">bool</span> dp[MAXM+<span class="hljs-number">5</span>];<span class="hljs-keyword">int</span> cnt[MAXM], dis[MAXM];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>(); <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i)  ++ cnt[<span class="hljs-built_in">read</span>()%m]; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;m; ++i)  <span class="hljs-keyword">if</span>(m%i == <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;m/i; ++j)    gcd[i*j] = i; dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">bool</span> ans = cnt[<span class="hljs-number">0</span>]; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>; a&lt;m&amp;&amp;!ans; ++a)&#123;  <span class="hljs-keyword">int</span> d = gcd[a];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;d; ++i)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*m/d<span class="hljs-number">-1</span>; ~j; --j)&#123;   <span class="hljs-keyword">int</span> now = (i+j*a)%m;   dis[now] = dis[(now+a)%m]+<span class="hljs-number">1</span>;   <span class="hljs-keyword">if</span>(dp[now]) dis[now] = !now;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;d; ++i)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;m/d; ++j)&#123;   <span class="hljs-keyword">int</span> now = (i+j*a)%m;   <span class="hljs-keyword">if</span>(dp[now])&#123;    <span class="hljs-keyword">int</span> t = dis[(now+a)%m];    t = <span class="hljs-built_in">min</span>(t,cnt[a]);    <span class="hljs-keyword">for</span>(; t; --t,++j)&#123;     now = (now+a)%m;     dp[now] = <span class="hljs-literal">true</span>;     <span class="hljs-keyword">if</span>(now == <span class="hljs-number">0</span>)      ans = <span class="hljs-literal">true</span>;    &#125;   &#125;  &#125; &#125; <span class="hljs-built_in">puts</span>(ans ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="c-c"><a href="https://vjudge.net/contest/477408#problem/C">C-C√</a></h2><p>最简单的签到题，直接过</p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)            sum+=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">if</span>(sum&gt;=n)             cout&lt;&lt;sum-n&lt;&lt;endl;        <span class="hljs-keyword">else</span>             cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;    &#125;&#125;</code></pre></div><h2 id="原d题">原D题 √</h2><p>本来是二维dp题目，硬生生被我做成了字符串（公共子串）匹配，再在得到的二维数组上对公共子串长度记录，再dp（但是我觉得思路更清晰？迷幻）。</p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> f[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>][<span class="hljs-number">13</span>];<span class="hljs-comment">//priority_queue &lt;int&gt; q;</span><span class="hljs-comment">//priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</span><span class="hljs-comment">//priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> r=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">char</span> s[<span class="hljs-number">1010</span>];    <span class="hljs-keyword">char</span> t[<span class="hljs-number">1001</span>];    cin&gt;&gt;s+<span class="hljs-number">1</span>;    cin&gt;&gt;t+<span class="hljs-number">1</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)            <span class="hljs-keyword">if</span>(s[i]==t[j])                a[i][j]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span>)                d[i][j]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span>                d[i][j]=d[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;        &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)            <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">1</span>,r)&#123;                f[i][j][k]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][k],f[i][j<span class="hljs-number">-1</span>][k]);                f[i][j][k]=<span class="hljs-built_in">max</span>(f[i][j][k],f[i-d[i][j]][j-d[i][j]][k<span class="hljs-number">-1</span>]+d[i][j]);                ans=<span class="hljs-built_in">max</span>(ans,f[i][j][k]);            &#125;    cout&lt;&lt;ans;&#125;</code></pre></div><h2 id="d-e"><ahref="https://vjudge.net/contest/477408#problem/D">D-E</a></h2><p>组合数学，详解见题解</p><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; LL fac[N],inv[N];<span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(LL a, LL k, LL p)</span>  <span class="hljs-comment">// 求a^k mod p</span></span><span class="hljs-function"></span>&#123;    LL res = <span class="hljs-number">1</span> % p;    <span class="hljs-keyword">while</span> (k)    &#123;        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * a % p;        a = a * a % p;        k &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    inv[<span class="hljs-number">0</span>] = fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) fac[i] = (i * fac[i - <span class="hljs-number">1</span>]) % mod,inv[i] = <span class="hljs-built_in">qmi</span>(fac[i],mod - <span class="hljs-number">2</span>,mod);&#125; <span class="hljs-function">LL <span class="hljs-title">c</span><span class="hljs-params">(LL a,LL b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> fac[a] * inv[b] % mod * inv[a - b] % mod;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    LL n,k;    cin &gt;&gt; n &gt;&gt; k;    k = <span class="hljs-built_in">min</span>(k,n - <span class="hljs-number">1</span>);    <span class="hljs-built_in">fc</span>(N);    LL res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= k;i ++)    res = (res + <span class="hljs-built_in">c</span>(n,i) * <span class="hljs-built_in">c</span>(n - <span class="hljs-number">1</span>,i) % mod) % mod;    cout &lt;&lt; res &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-comment">//cin &gt;&gt; T;</span>    <span class="hljs-keyword">while</span>(T --)    <span class="hljs-built_in">solve</span>();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="e-f"><ahref="https://vjudge.net/contest/477408#problem/E">E-F</a></h2><p>看到这道题我先想到了树形dp、点分治。然而这是个图。</p><p><strong>正确思路</strong>:我们已经确定了起点和终点,那么我们只需要枚举 起点到 <spanclass="math inline">\(i\)</span> 的距离 + 终点到 <spanclass="math inline">\(j\)</span> 的距离 + <spanclass="math inline">\(i,j\)</span>之间的距离判断其是否大于等于最短距离,如果满足那么这个 <spanclass="math inline">\(i,j\)</span> 组合就是合法的加边结果。</p><p><strong>流程</strong>：我们对起点和终点分别跑两次最短路,枚举要加边的两个端点,判断其是否满足条件,计算其对答案的贡献即可。</p><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> vis[N][N];vector&lt;<span class="hljs-keyword">int</span>&gt; g[N];<span class="hljs-keyword">int</span> dist_s[N],<span class="hljs-keyword">dist_t</span>[N]; <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,s,t;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;    <span class="hljs-keyword">while</span>(m --)    &#123;        <span class="hljs-keyword">int</span> a,b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);        g[a].<span class="hljs-built_in">push_back</span>(b);        g[b].<span class="hljs-built_in">push_back</span>(a);        vis[a][b] = vis[b][a] = <span class="hljs-number">1</span>;    &#125;        <span class="hljs-built_in">memset</span>(dist_s,- <span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span> dist_s);    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">dist_t</span>,- <span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span> <span class="hljs-keyword">dist_t</span>);        queue&lt;<span class="hljs-keyword">int</span>&gt; q;    q.<span class="hljs-built_in">push</span>(s);    dist_s[s] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())    &#123;        <span class="hljs-keyword">auto</span> u = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; g[u].<span class="hljs-built_in">size</span>();i ++)        &#123;            <span class="hljs-keyword">int</span> v = g[u][i];            <span class="hljs-keyword">if</span>(dist_s[v] == <span class="hljs-number">-1</span>) dist_s[v] = dist_s[u] + <span class="hljs-number">1</span>,q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;        q.<span class="hljs-built_in">push</span>(t);    <span class="hljs-keyword">dist_t</span>[t] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())    &#123;        <span class="hljs-keyword">auto</span> u = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; g[u].<span class="hljs-built_in">size</span>();i ++)        &#123;            <span class="hljs-keyword">int</span> v = g[u][i];            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">dist_t</span>[v] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">dist_t</span>[v] = <span class="hljs-keyword">dist_t</span>[u] + <span class="hljs-number">1</span>,q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;     LL res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt;= n;j ++)      <span class="hljs-keyword">if</span>(!vis[i][j] &amp;&amp; dist_s[i] + <span class="hljs-number">1</span> + <span class="hljs-keyword">dist_t</span>[j] &gt;= dist_s[t] &amp;&amp; <span class="hljs-keyword">dist_t</span>[i] + <span class="hljs-number">1</span> + dist_s[j] &gt;= dist_s[t])       res ++;    cout &lt;&lt; res &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(T --) <span class="hljs-built_in">solve</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="f-g"><ahref="https://vjudge.net/contest/477408#problem/F">F-G</a></h2><p>线段树</p><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;vector &lt;pair &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt;in[maxn],out[maxn];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NODE</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum,num;&#125; p[maxn*<span class="hljs-number">4</span>];<span class="hljs-keyword">int</span> n,m,k;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> cur)</span></span><span class="hljs-function"></span>&#123;    p[cur].l=l;    p[cur].r=r;    p[cur].num=p[cur].sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l==r)        <span class="hljs-keyword">return</span> ;    <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-built_in">build</span>(l,mid,cur*<span class="hljs-number">2</span>);    <span class="hljs-built_in">build</span>(mid+<span class="hljs-number">1</span>,r,cur*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    p[k].num=p[k*<span class="hljs-number">2</span>].num+p[k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].num;    p[k].sum=p[k*<span class="hljs-number">2</span>].sum+p[k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> pri,<span class="hljs-keyword">int</span> cur)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=p[cur].l,r=p[cur].r;    <span class="hljs-keyword">if</span>(l==r)    &#123;        p[cur].num+=num;        p[cur].sum+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)num*pri;        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(pri&lt;=mid)        <span class="hljs-built_in">update</span>(num,pri,<span class="hljs-number">2</span>*cur);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">update</span>(num,pri,<span class="hljs-number">2</span>*cur+<span class="hljs-number">1</span>);    <span class="hljs-built_in">pushup</span>(cur);&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> cur)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=p[cur].l,r=p[cur].r;    <span class="hljs-keyword">if</span>(l==r)        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)l*<span class="hljs-built_in">min</span>(p[cur].num,(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)num);    <span class="hljs-keyword">if</span>(num&lt;=p[cur*<span class="hljs-number">2</span>].num)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(num,cur*<span class="hljs-number">2</span>);    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> p[cur*<span class="hljs-number">2</span>].sum+<span class="hljs-built_in">query</span>(num-p[cur*<span class="hljs-number">2</span>].num,cur*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l,r,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)    &#123;        in[i].<span class="hljs-built_in">clear</span>();        out[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x,&amp;y);        in[l].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(x,y));        out[r].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(x,y));    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,maxn,<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;in[i].<span class="hljs-built_in">size</span>(); j++)            <span class="hljs-built_in">update</span>(in[i][j].first,in[i][j].second,<span class="hljs-number">1</span>);        ans+=<span class="hljs-built_in">query</span>(k,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;out[i].<span class="hljs-built_in">size</span>(); j++)            <span class="hljs-built_in">update</span>(-out[i][j].first,out[i][j].second,<span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="原h题">原H题</h2><p>写了一个二分答案，wa后被告知题目要被删。</p><h2 id="g-i"><a href="https://vjudge.net/contest/477408#problem/G">G-I√</a></h2><p>一个奇葩的题目。你只需要构造出一个满足题意的树就行。</p><p>无法构造时： <span class="math inline">\(d&gt;2h\)</span>时必定不成立 <span class="math inline">\(d= 1\)</span> 时,节点数只能是<span class="math inline">\(2\)</span>。</p><p>先构建成一条满足条件的链,然后不够的再往上加点即可。有一些细节问题，所以我调了很久才A(哭)。</p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n,d,h;<span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    n=<span class="hljs-built_in">read</span>();d=<span class="hljs-built_in">read</span>();h=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">if</span>((!(<span class="hljs-number">2</span>*h&gt;=d&amp;&amp;d&gt;=h&amp;&amp;n&gt;=d+<span class="hljs-number">1</span>))||(d==<span class="hljs-number">1</span>&amp;&amp;n&gt;<span class="hljs-number">2</span>))&#123;        cout&lt;&lt;<span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,h)        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++cnt&lt;&lt;endl;    <span class="hljs-keyword">if</span>(h!=d)&#123;        cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++cnt&lt;&lt;endl;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">2</span>,d-h)            cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++cnt&lt;&lt;endl;    &#125;    <span class="hljs-keyword">int</span> o=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(cnt==n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(h==d&amp;&amp;h&gt;<span class="hljs-number">1</span>)o=<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(h==d&amp;&amp;h==<span class="hljs-number">1</span>)&#123;        cout&lt;&lt;<span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">while</span>(cnt!=n)&#123;        cout&lt;&lt;o&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++cnt&lt;&lt;endl;    &#125;        &#125;</code></pre></div><h2 id="h-j"><a href="https://vjudge.net/contest/477408#problem/H">H-J√</a></h2><p>在学长的点拨下做出来的题。</p><p>数据范围超空间，所以不能用数组作桶，用map。要用 <spanclass="math inline">\(O(n)\)</span>的做法，要用所以不能存位置，要map存奇数偶数的个数,还要开LL：<code>map&lt;int,ll&gt;m[2]</code>。导致我写了好几遍。</p><p>基本思路：两个相同的数的亦或为<spanclass="math inline">\(0\)</span>，<spanclass="math inline">\(0\)</span>和任意另外一个数的亦或都为另一个数。</p><p>所以对于题目要救“区间从<spanclass="math inline">\(1/2\)</span>的位置分割为两部分，两部分的元素异或和相同”，记两段的亦或分别为<code>l</code>，<code>r</code>当且仅当<code>a^l^r=a</code>时满足题意，可得<spanclass="math inline">\(O(n)\)</span>的算法（从左到右扫一遍）。</p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span>map&lt;<span class="hljs-keyword">int</span>,ll&gt; m[<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> e;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    ll ans=<span class="hljs-number">0</span>;    m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]++;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        e=e^<span class="hljs-built_in">read</span>();        ans+=m[i%<span class="hljs-number">2</span>][e];<span class="hljs-comment">//cout&lt;&lt;e&lt;&lt;&quot;:&quot;&lt;&lt;m[e][i%2]&lt;&lt;&quot; &quot;;</span>        m[i%<span class="hljs-number">2</span>][e]++;    &#125;    cout&lt;&lt;ans;&#125;</code></pre></div><h2 id="i-k"><ahref="https://vjudge.net/contest/477408#problem/I">I-K</a></h2><p>我想了线性dp但我就是没想出来(哭)</p><p>让你求解整个序列上的极值问题,然后判断其是否无后效性和是否存在最优子结构就能够知道是不是个dp,这题整个序列上的极值显然是可以由其子序列转移而来的,具体证明就不多赘述,直接开始dp。</p><p><strong>状态表示</strong>：<code>f[i]</code> 表示前 <code>i</code>个数字中取 <span class="math inline">\(\frac{n}{2}\)</span>(向下取整)个数并且这些数两两不相邻,其最大的和。</p><p><strong>状态转移</strong>：</p><p>由于是 <span class="math inline">\(\frac{n}{2}\)</span>(向下取整)存在奇偶数不同的情况,因此我们对其分类讨论</p><p>若是奇数并且选了第 <span class="math inline">\(i\)</span> 个数则<code>f[i] = f[i-2] + a[i]</code> ,因为选了第 <spanclass="math inline">\(i\)</span> 个数后,第 <spanclass="math inline">\(i-1\)</span> 个数就不能被选中了,只能从<code>f[i-2]</code>转移而来</p><p>若没有选第 <span class="math inline">\(i\)</span> 个数则 <code>f[i] =f[i-1]</code></p><p>若是偶数并且选了第 <span class="math inline">\(i\)</span> 个数则同理,<code>f[i] = f[i-2] + a[i]</code> ,</p><p>若没有选第 <span class="math inline">\(i\)</span>个数,我们只能将奇数位置上的数全选上才能有 <spanclass="math inline">\(⌊n/2⌋\)</span> (向下取整)个数字,不然的话若还是<code>f[i-1]</code> ,此时 <span class="math inline">\(i-1\)</span>为奇数除二下取整会比原来少一个就不符合题目的条件了。</p><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;LL a[N],f[N],s[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> n;cin &gt;&gt; n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);s[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i += <span class="hljs-number">2</span>) s[i] = s[i - <span class="hljs-number">2</span>] + a[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++)&#123;<span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-comment">//奇数</span>&#123;f[i] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">2</span>] + a[i],f[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">//偶数</span>&#123;f[i] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">2</span>] + a[i],s[i - <span class="hljs-number">1</span>]);&#125;&#125;cout &lt;&lt; f[n] &lt;&lt; endl; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T --)<span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022—SWJTU寒假选拔赛第二场复盘</title>
      <link href="/2022/01/17/13/"/>
      <url>/2022/01/17/13/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="链接">链接</h1><div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894"><b>2022—SWJTU寒假选拔赛第二场</b></a></p>          </div><div class="note note-info">            <p><ahref="https://zhuanlan.zhihu.com/p/459020192"><b>某后台老板的赛后快乐分享</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/m0_56007815/article/details/122555017"><b>题解</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><figure><img src="https://s2.loli.net/2022/01/19/mrJYjLkT4XZVovt.png"alt="RANk.png" /><figcaption aria-hidden="true">RANk.png</figcaption></figure><h1 id="a-傻子楼梯">A-傻子楼梯 ?</h1><div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/A">题目链接</a><span class="label label-warning">Attempted</span></p>          </div><p></b></font></p><p>队列模拟即可</p><p>要转变方向当且仅当不同方向的人已抵达电梯,且该方向的下一个人还未到达电梯</p><p>然而从赛场到现在我一直wa在test7上，现在也不知道怎么错的。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的错误代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    queue&lt;<span class="hljs-keyword">int</span>&gt; e[<span class="hljs-number">2</span>];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-keyword">int</span> t=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();        e[q].<span class="hljs-built_in">push</span>(t);    &#125;    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>,q=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(e[q^<span class="hljs-number">1</span>].<span class="hljs-built_in">front</span>()&lt;e[q].<span class="hljs-built_in">front</span>()) q^=<span class="hljs-number">1</span>;    t=e[q].<span class="hljs-built_in">front</span>()+<span class="hljs-number">10</span>;e[q].<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">//cout&lt;&lt;t&lt;&lt;&quot;:&quot;&lt;&lt;q&lt;&lt;&quot; &quot;;</span>    <span class="hljs-keyword">while</span>(!e[<span class="hljs-number">1</span>].<span class="hljs-built_in">empty</span>()||!e[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-keyword">if</span>(e[q].<span class="hljs-built_in">empty</span>()||e[q^<span class="hljs-number">1</span>].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-comment">//cout&lt;&lt;&quot;!&quot;;</span>            <span class="hljs-keyword">if</span>(e[q].<span class="hljs-built_in">empty</span>())&#123;                q^=<span class="hljs-number">1</span>;                t=<span class="hljs-built_in">max</span>(t,e[q].<span class="hljs-built_in">front</span>())+<span class="hljs-number">10</span>;                e[q].<span class="hljs-built_in">pop</span>();            &#125;<span class="hljs-keyword">else</span>&#123;                t=e[q].<span class="hljs-built_in">front</span>()+<span class="hljs-number">10</span>;                e[q].<span class="hljs-built_in">pop</span>();            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[q].<span class="hljs-built_in">front</span>()&lt;t) &#123;            t=<span class="hljs-built_in">max</span>(t,e[q].<span class="hljs-built_in">front</span>()+<span class="hljs-number">10</span>);            e[q].<span class="hljs-built_in">pop</span>();        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(e[q^<span class="hljs-number">1</span>].<span class="hljs-built_in">front</span>()&lt;e[q].<span class="hljs-built_in">front</span>()) q^=<span class="hljs-number">1</span>;            t=<span class="hljs-built_in">max</span>(t,e[q].<span class="hljs-built_in">front</span>())+<span class="hljs-number">10</span>;            e[q].<span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-comment">//cout&lt;&lt;t&lt;&lt;&quot;:&quot;&lt;&lt;q&lt;&lt;&quot; &quot;;</span>    &#125;    cout&lt;&lt;t;   &#125;<span class="hljs-comment">/*</span><span class="hljs-comment">5</span><span class="hljs-comment">1 1 </span><span class="hljs-comment">7 0 </span><span class="hljs-comment">8 0 </span><span class="hljs-comment">10 0</span><span class="hljs-comment">12 1</span><span class="hljs-comment">*/</span></code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;queue&lt;<span class="hljs-keyword">int</span>&gt; q0,q1;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span>(n --)    &#123;        <span class="hljs-keyword">int</span> a,b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) q0.<span class="hljs-built_in">push</span>(a);        <span class="hljs-keyword">else</span> q1.<span class="hljs-built_in">push</span>(a);    &#125;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q0.<span class="hljs-built_in">size</span>() &amp;&amp; q1.<span class="hljs-built_in">size</span>())    &#123;           <span class="hljs-keyword">auto</span> up = q0.<span class="hljs-built_in">front</span>(),down = q1.<span class="hljs-built_in">front</span>();        <span class="hljs-comment">//printf(&quot;up = %d,down = %d\n&quot;,up,down);</span>        <span class="hljs-keyword">if</span>(up &lt; down)        &#123;            ans += <span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>(q0.<span class="hljs-built_in">front</span>() &lt; ans &amp;&amp; q0.<span class="hljs-built_in">size</span>())            &#123;                ans = <span class="hljs-built_in">max</span>(ans,q0.<span class="hljs-built_in">front</span>() + <span class="hljs-number">10</span>);                <span class="hljs-comment">//printf(&quot;q0.ans = %d\n&quot;,ans);</span>                q0.<span class="hljs-built_in">pop</span>();            &#125;        &#125;        <span class="hljs-keyword">else</span>         &#123;           ans += <span class="hljs-number">10</span>;           <span class="hljs-keyword">while</span>(ans &gt; q1.<span class="hljs-built_in">front</span>() &amp;&amp; q1.<span class="hljs-built_in">size</span>())           &#123;               ans = <span class="hljs-built_in">max</span>(ans,q1.<span class="hljs-built_in">front</span>() + <span class="hljs-number">10</span>);               <span class="hljs-comment">//printf(&quot;q1.ans = %d\n&quot;,ans);</span>               q1.<span class="hljs-built_in">pop</span>();           &#125;        &#125;    &#125;    ans += <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q0.<span class="hljs-built_in">size</span>())    &#123;        res = q0.<span class="hljs-built_in">front</span>() + <span class="hljs-number">10</span>;        q0.<span class="hljs-built_in">pop</span>();    &#125;    <span class="hljs-keyword">while</span>(q1.<span class="hljs-built_in">size</span>())    &#123;        res = q1.<span class="hljs-built_in">front</span>() + <span class="hljs-number">10</span>;        q1.<span class="hljs-built_in">pop</span>();    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">max</span>(res,ans));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h1 id="b-cold爱吃小蛋糕">B-cold爱吃小蛋糕√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/B">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p><span class="math inline">\(Cold\)</span>可以无限次吃蛋糕，每次吃掉蛋糕的重量是一个正整数且任意，只要并且不会超过原本蛋糕重量的一半。因为可以无限次合并蛋糕。所以，可以贪心的考虑将所有蛋糕合并，然后次多次将蛋糕吃到<span class="math inline">\(K\)</span>的重量，然后再最后吃一口最重的就是最优解。</p><p>也就是，会浪费 <span class="math inline">\(\frac{K}{2}\)</span>上取整重量的蛋糕。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();    ll sum=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();        sum+=x;    &#125;    <span class="hljs-keyword">if</span>(sum&lt;k)&#123;        cout&lt;&lt;<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    cout&lt;&lt;sum-<span class="hljs-built_in">min</span>((k+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>,(k+<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>);<span class="hljs-comment">//这个min不需要 （k+1）/2 表示吃剩的 </span>&#125;</code></pre></div>    </div></div><h1 id="c-郑老板玩方块">C-郑老板玩方块√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/C">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p><strong>题目重述</strong>：判断给出的八个坐标能否构成正方体</p><p>最开始看到这个大模拟我是非常不想做的，但是看了其他题不是很有把握以及榜单上很多人这道题就写完了(神仙速度)然后就花了不少时间(30min?)把这个搞了出来。</p><p>因为只有500组数据，时间很宽裕，我就用了个O(T<em>8</em>8*8)的暴力：对于每个点，计算其他七个点与它的距离(直接不用开方)，用距离进行个冒泡排序，再判断该点与该点最近的三个点构成的向量长度是否相等，是否垂直。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">9</span>][<span class="hljs-number">4</span>],b[<span class="hljs-number">9</span>][<span class="hljs-number">4</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">double</span> di;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">8</span>;i++)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)            a[i][j]=<span class="hljs-built_in">read</span>();            &#125;    <span class="hljs-keyword">int</span> f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">8</span>;i++)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)&#123;            b[j][<span class="hljs-number">1</span>]=a[j][<span class="hljs-number">1</span>]-a[i][<span class="hljs-number">1</span>];            b[j][<span class="hljs-number">2</span>]=a[j][<span class="hljs-number">2</span>]-a[i][<span class="hljs-number">2</span>];            b[j][<span class="hljs-number">3</span>]=a[j][<span class="hljs-number">3</span>]-a[i][<span class="hljs-number">3</span>];            b[j][<span class="hljs-number">0</span>]=b[j][<span class="hljs-number">1</span>]*b[j][<span class="hljs-number">1</span>]+b[j][<span class="hljs-number">2</span>]*b[j][<span class="hljs-number">2</span>]+b[j][<span class="hljs-number">3</span>]*b[j][<span class="hljs-number">3</span>];        &#125;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)            <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)&#123;                <span class="hljs-keyword">if</span>(b[k][<span class="hljs-number">0</span>]&lt;b[k+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<span class="hljs-keyword">continue</span>;                <span class="hljs-built_in">FOR</span>(w,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)                    <span class="hljs-built_in">swap</span>(b[k][w],b[k+<span class="hljs-number">1</span>][w]);            &#125;        <span class="hljs-keyword">if</span>(b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>&amp;&amp;b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]==b[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]&amp;&amp;b[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]==b[<span class="hljs-number">4</span>][<span class="hljs-number">0</span>]&amp;&amp;            b[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]*b[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]+b[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]*b[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]+b[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]*b[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]==<span class="hljs-number">0</span>&amp;&amp;            b[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]+b[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]+b[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]==<span class="hljs-number">0</span>&amp;&amp;            b[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]+b[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]+b[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]==<span class="hljs-number">0</span>        )            f++;    &#125;    <span class="hljs-keyword">if</span>(f==<span class="hljs-number">8</span>)cout&lt;&lt;<span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">solve</span>();    &#125;&#125;</code></pre></div>    </div></div><h1 id="d-风神瞳">D-风神瞳√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/D">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p>这是一个最短路模板+无穷背包模板的题目。</p><p>首先，用Dij或SPFA跑出出发点 <code>S=1</code>到每个点的最短距离，对于每个非出发点节点相当于背包的物品：花费时间为<code>dis[i]*2</code>、收益为<code>a[i]</code>。每个“物品”有无限个，然后无线背包dp就行。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">3200</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXM = <span class="hljs-number">3200</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node1</span>&#123;</span>    <span class="hljs-keyword">int</span> to,nxt,val;&#125;edge[MAXM];<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>,head[MAXN];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node2</span>&#123;</span>    <span class="hljs-keyword">int</span> to,val;    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> node2 &amp;x)<span class="hljs-keyword">const</span>    &#123;        <span class="hljs-keyword">return</span> val&gt;x.val;<span class="hljs-comment">//这里注意符号要为&#x27;&gt;&#x27;</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)</span></span>&#123;    edge[++cnt].to=v;    edge[cnt].val=w;    edge[cnt].nxt=head[u];    head[u]=cnt;&#125;<span class="hljs-keyword">int</span> vis[MAXN],dis[MAXN];priority_queue&lt;node2&gt; q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">1</span>;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));dis[s]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));    q.<span class="hljs-built_in">push</span>((node2)&#123;s,<span class="hljs-number">0</span>&#125;);    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-keyword">int</span> u=q.<span class="hljs-built_in">top</span>().to;q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;        vis[u]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i;i=edge[i].nxt)&#123;<span class="hljs-comment">//cout&lt;&lt;&quot;!&quot;;</span>            <span class="hljs-keyword">int</span> v=edge[i].to;            <span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+edge[i].val)&#123;                dis[v]=dis[u]+edge[i].val;<span class="hljs-comment">// cout&lt;&lt;u&lt;&lt;&quot;-&gt;&quot;&lt;&lt;v&lt;&lt;&quot;:&quot;&lt;&lt;dis[v]&lt;&lt;endl;</span>                q.<span class="hljs-built_in">push</span>((node2)&#123;v,dis[v]&#125;);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x,y;    <span class="hljs-keyword">int</span> T;    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();    T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> a[MAXN]=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">2</span>,n)        a[i]=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        x=<span class="hljs-built_in">read</span>();y=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">1</span>);        <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">dij</span>();    <span class="hljs-keyword">int</span> f[<span class="hljs-number">3010</span>];    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,T)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">2</span>,n)&#123;            <span class="hljs-keyword">if</span>(i&lt;dis[j]*<span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;            f[i]=<span class="hljs-built_in">max</span>(f[i],f[i-(dis[j]&lt;&lt;<span class="hljs-number">1</span>)]+a[j]);        &#125;        cout&lt;&lt;f[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    &#125;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h1 id="e-cold不会字符串">E-cold不会字符串</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/E">题目链接</a></p>          </div> </b></font></p><p>我一直没想到做法是因为我把题目：“如果给你一个P串，是否能构造出来一个T串使得cold的代码不通过”看为了“如果给你一个T串，是否能构造出来一个P串使得cold的代码不通过”，话说如果这样改能有低于<spanclass="math inline">\(O(n^2)\)</span>的做法吗。</p><p>题目的意思是已知这么一段错误的代码然后给我们一个匹配串，问能否构造一个串使得这个算法得到的答案是错误的。</p><p>很明显这段代码错误的原因在于指针 没有回溯。那么怎样的串我们可以把它hack 掉呢</p><p>倘若 <code>next[i]&gt;0</code> 的一定会被 hack,学过KMP的同学知道,KMP就是求解前后缀匹配情况即数组回溯进行匹配的,但改错误代码其没有回溯,因此产生了错误。那么知道了这点以后,甚至可以不用求<code>next</code> 数组了,直接判断串中是否有与 <code>s[1]</code>相同的,有相同的必然是<code>next&gt;1</code>了。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">char</span> s[<span class="hljs-number">100000</span> + <span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123; <span class="hljs-keyword">int</span> n ; cin &gt;&gt; n; cin &gt;&gt; s + <span class="hljs-number">1</span>; <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n;i ++) &#123;  <span class="hljs-keyword">if</span>(s[i] == s[<span class="hljs-number">1</span>]) flag = <span class="hljs-number">0</span>; &#125; <span class="hljs-keyword">if</span>(flag) cout&lt;&lt;<span class="hljs-string">&quot;Correct&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Wrong Answer&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h1 id="f-你一定会种树吧2.0">F-你一定会种树吧2.0</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/F">题目链接</a></p>          </div> </b></font></p><p>我知道这是个线段树，但我没时间去改模板了。也确实不想写。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> il inline</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;long, long&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb(x) push_back(x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,x,y) for(auto i=(x);i&lt;=(y);++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i,x,y) for(auto i=(x);i&gt;=(y);--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem(num) memset(num,0,sizeof num)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowbit(x) ((x)&amp;-(x))</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>; <span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">int</span> l, r;<span class="hljs-keyword">int</span> mx;<span class="hljs-keyword">int</span> flag;&#125; sgt[maxn&lt;&lt;<span class="hljs-number">2</span>]; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> bitset&lt;<span class="hljs-number">32</span>&gt;(x).<span class="hljs-built_in">count</span>() == <span class="hljs-number">0</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;sgt[x].mx = <span class="hljs-built_in">max</span>(sgt[x&lt;&lt;<span class="hljs-number">1</span>].mx, sgt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mx);sgt[x].flag = sgt[x&lt;&lt;<span class="hljs-number">1</span>].flag | sgt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].flag;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">if</span>(l == r) &#123;sgt[x] = &#123;l, r, a[l], a[l]&#125;;<span class="hljs-keyword">return</span>;&#125;sgt[x] = &#123;l,r&#125;;<span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>, l, mid); <span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<span class="hljs-built_in">push_up</span>(x);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">if</span>(sgt[x].l == p &amp;&amp; sgt[x].r == p) &#123;sgt[x].mx = v;sgt[x].flag = v;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> mid = sgt[x].l + sgt[x].r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">update</span>(x&lt;&lt;<span class="hljs-number">1</span>,p,v); <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,p,v);<span class="hljs-built_in">push_up</span>(x);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">if</span>(!((~v)&amp;sgt[x].flag)) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(sgt[x].l == sgt[x].r) &#123;sgt[x].mx &amp;= v;sgt[x].flag &amp;= v;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> mid = sgt[x].l + sgt[x].r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">modify</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,r,v);<span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">modify</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,v);<span class="hljs-built_in">push_up</span>(x);&#125;  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> l ,<span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">if</span>(sgt[x].l&gt;=l&amp;&amp;sgt[x].r&lt;=r) <span class="hljs-keyword">return</span> sgt[x].mx;<span class="hljs-keyword">int</span> mid = sgt[x].l + sgt[x].r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (r &lt;= mid)<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x &lt;&lt; <span class="hljs-number">1</span>, l, r);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; mid)<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);    <span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">query</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,r));res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">query</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r));<span class="hljs-keyword">return</span> res;    &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;cin &gt;&gt; n;cin &gt;&gt; m;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;cin&gt;&gt;a[i];&#125;<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);string op;<span class="hljs-keyword">int</span> l, r, x, v;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;cin&gt;&gt;op;<span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<span class="hljs-comment">//cout&lt;&lt;1&lt;&lt;endl;</span>cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,l,r,v);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;U&#x27;</span>)&#123;cin&gt;&gt;x&gt;&gt;v;<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,x,v);&#125; <span class="hljs-keyword">else</span> &#123;cin&gt;&gt;l&gt;&gt;r;cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,l,r)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">NULL</span>);std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">NULL</span>);<span class="hljs-keyword">int</span> _ = <span class="hljs-number">1</span>;<span class="hljs-comment">//cin &gt;&gt; _;</span><span class="hljs-keyword">while</span> (_--) &#123;<span class="hljs-built_in">solve</span>();&#125;&#125;</code></pre></div>    </div></div><h1 id="g-郑老板爱玩博弈论">G-郑老板爱玩博弈论√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/G">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p>这道题属于是，一看题面长度吓死人，仔细看后可以算，算出来后直觉离谱的题。因为答案就输出一个<code>0.0000</code></p><p>老板对于每个选择都是 <spanclass="math inline">\(\frac{1}{20}\)</span>的概率，我直接写了个程序跑出来，无论学生取什么数字，期望得分都是 <spanclass="math inline">\(0\)</span>,</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">FOR</span>(a,<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)&#123;        <span class="hljs-keyword">double</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-built_in">FOR</span>(x,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)&#123;            <span class="hljs-keyword">if</span>(a&gt;x)ans+=(x-a+<span class="hljs-number">10</span>)/<span class="hljs-number">20</span>;            <span class="hljs-keyword">if</span>(a&lt;x)ans+=(x-a<span class="hljs-number">-10</span>)/<span class="hljs-number">20</span>;        &#125;        <span class="hljs-comment">//cout&lt;&lt;a&lt;&lt;&quot;:&quot;&lt;&lt;ans&lt;&lt;&quot; &quot;;</span>    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4f&quot;</span>,<span class="hljs-number">0</span>);&#125;</code></pre></div>    </div></div><h1 id="h-琴">H-琴</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/H">题目链接</a><span class="label label-warning">Attempted</span></p>          </div> </b></font></p><p><ahref="https://blog.csdn.net/weixin_43627118/article/details/104024380?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164247770616780255231125%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164247770616780255231125&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104024380.first_rank_v2_pc_rank_v29&amp;utm_term=%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97&amp;spm=1018.2226.3001.4187">数学- 数论 - 整除分块</a></p><p><span class="math inline">\(O(T\sqrt{n})\)</span></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T;    cin &gt;&gt; T;    <span class="hljs-keyword">while</span>(T --)    &#123;        LL res = <span class="hljs-number">0x3f3f3f3f</span>;        LL n,m;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);        <span class="hljs-keyword">if</span>(m % n == <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &gt; m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n - m);        <span class="hljs-keyword">else</span>         &#123;            <span class="hljs-keyword">for</span>(LL l = <span class="hljs-number">1</span>,r;l &lt;= n;l = r + <span class="hljs-number">1</span>)            &#123;                r = <span class="hljs-built_in">min</span>(n,(m - <span class="hljs-number">1</span>) / ((m - <span class="hljs-number">1</span>) / l));                res = <span class="hljs-built_in">min</span>(res,((m - <span class="hljs-number">1</span>) / l )* l);            &#125;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n - m + res);        &#125;           &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h1 id="i-简单数学2.0">I-简单数学2.0</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/I">题目链接</a></p>          </div> </b></font></p><p>考虑离线莫队。题目相当于找出每段区间里每个数字的所有因子，找到其出现次数最多的因子的个数。但是 ai 最大可达到 <span class="math inline">\(1e^6\)</span>,因子数量太多。仔细想想会发现我们并不需要求出所有因子，只需要求出所有质因子即可，又因为一个数的质因子个数非常少（最多不超过7 个，记为 <spanclass="math inline">\(k\)</span>），因此我们可以预处理所有数的质因子后把问题近似为求区间众数。维护每个质因子出现的次数和出现i 次的质因子的数量，即可离线后使用莫队求解本题。 由于 n 和 q为同一数量级，总时间复杂度为 <spanclass="math inline">\(O(kn\sqrt{n})\)</span></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">10</span>, B=<span class="hljs-number">220</span>, X=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>; vector&lt;<span class="hljs-keyword">int</span>&gt; V[X];<span class="hljs-keyword">int</span> numofp[X], num[N];<span class="hljs-keyword">int</span> maxp;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> a[N];<span class="hljs-keyword">bool</span> visp[X];vector&lt;<span class="hljs-keyword">int</span>&gt; vis; <span class="hljs-comment">//prime</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getprime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-keyword">if</span>(V[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> x=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>; j*j&lt;=x; ++j)&#123;<span class="hljs-keyword">if</span>(x%j==<span class="hljs-number">0</span>)&#123;V[i].<span class="hljs-built_in">push_back</span>(j);<span class="hljs-keyword">while</span>(x%j==<span class="hljs-number">0</span>)&#123;x/=j;&#125;&#125;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) V[i].<span class="hljs-built_in">push_back</span>(x);&#125; <span class="hljs-comment">//modui</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Query</span>&#123;</span><span class="hljs-keyword">int</span> l, r, ans, id;<span class="hljs-built_in">Query</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> r=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> id=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(l),<span class="hljs-built_in">r</span>(r),<span class="hljs-built_in">id</span>(id)&#123;&#125;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Query&amp;t)<span class="hljs-keyword">const</span>&#123;<span class="hljs-keyword">int</span> a=l/B, b=t.l/B;<span class="hljs-keyword">if</span>(a!=b) <span class="hljs-keyword">return</span> a&lt;b;<span class="hljs-keyword">return</span> r&lt;t.r;&#125;&#125;q[N]; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span></span>&#123;<span class="hljs-comment">//printf(&quot;%d\n&quot;, a[w]);</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;p:V[a[w]])&#123;<span class="hljs-comment">//printf(&quot;+ %d\n&quot;, p);</span>num[numofp[p]]--;numofp[p]++;num[numofp[p]]++;maxp=<span class="hljs-built_in">max</span>(maxp,numofp[p]);<span class="hljs-comment">//printf(&quot;maxp=%d\n&quot;, maxp);</span>&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;p:V[a[w]])&#123;num[numofp[p]]--;numofp[p]--;num[numofp[p]]++;<span class="hljs-keyword">if</span>(num[maxp]==<span class="hljs-number">0</span>) maxp--;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Getans</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> maxp;&#125; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Query&amp;q1, <span class="hljs-keyword">const</span> Query&amp;q2)</span></span>&#123;<span class="hljs-keyword">return</span> q1.id&lt;q2.id;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T; cin&gt;&gt;T;<span class="hljs-comment">//init V[]</span><span class="hljs-comment">//getprime();</span><span class="hljs-comment">//solve</span><span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-comment">//input n, q, a[], query[]</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);num[<span class="hljs-number">0</span>]=X;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a+i);<span class="hljs-built_in">getprime</span>(a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>, l, r; i&lt;=m; ++i)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);q[i]=<span class="hljs-built_in">Query</span>(l,r,i);&#125;q[<span class="hljs-number">0</span>]=<span class="hljs-built_in">Query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//prime factor of a[]</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;j:V[a[i]])&#123;<span class="hljs-keyword">if</span>(!visp[j])&#123;visp[j]=<span class="hljs-literal">true</span>;vis.<span class="hljs-built_in">push_back</span>(j);&#125;&#125;&#125;<span class="hljs-comment">//block, sort</span><span class="hljs-built_in">sort</span>(q,q+m+<span class="hljs-number">1</span>);<span class="hljs-comment">//solve</span><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=m; ++i)&#123;<span class="hljs-comment">//printf(&quot;l=%d r=%d\n&quot;, l, r);</span><span class="hljs-keyword">while</span>(l&lt;q[i].l) <span class="hljs-built_in">Del</span>(l++); <span class="hljs-keyword">while</span>(l&gt;q[i].l) <span class="hljs-built_in">Add</span>(--l);<span class="hljs-keyword">while</span>(r&lt;q[i].r) <span class="hljs-built_in">Add</span>(++r);<span class="hljs-keyword">while</span>(r&gt;q[i].r) <span class="hljs-built_in">Del</span>(r--);q[i].ans=<span class="hljs-built_in">Getans</span>();&#125;<span class="hljs-comment">//print</span><span class="hljs-built_in">sort</span>(q,q+m+<span class="hljs-number">1</span>,cmp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, q[i].ans);&#125;<span class="hljs-comment">//init</span>maxp=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;V[i].<span class="hljs-built_in">clear</span>();num[i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;i:vis)&#123;visp[i]=<span class="hljs-literal">false</span>;numofp[i]=<span class="hljs-number">0</span>;&#125;vis.<span class="hljs-built_in">clear</span>();&#125;&#125;</code></pre></div>    </div></div><h1 id="j-简单水题">J-简单水题√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/J">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p>看到棋盘格和从左上角走到右下角，只能向右边或者向下行走首先想到递推。</p><p>因为每个格子上只能是<span class="math inline">\(1\)</span>或<spanclass="math inline">\(0\)</span>,想到可以用路径和表示路过了多少个“<spanclass="math inline">\(1\)</span>”和“<spanclass="math inline">\(0\)</span>”,为了记录到达每个格子的各种已经路过数量的方案数，对每个格子<span class="math inline">\((i,j)\)</span> 还得开个 <spanclass="math inline">\(i+j-1\)</span>来储存各种可能的方案数量。即要开个<code>dp[n][m][n+m]</code>的三维数组，再在二维上对每个格子dp。</p><p>然后我用<spanclass="math inline">\(dp[510][510][1050]\)</span>写了出来。然后提交直接ME。于是想了想，压缩了第一纬度空间。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>];<span class="hljs-keyword">int</span> b[<span class="hljs-number">2</span>][<span class="hljs-number">510</span>][<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> m=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> p=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)            a[i][j]=<span class="hljs-built_in">read</span>();    b[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>&amp;&amp;j==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">0</span>,i+j)&#123;                b[i%<span class="hljs-number">2</span>][j][k]=(b[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>][j][k-a[i][j]]+b[i%<span class="hljs-number">2</span>][(j<span class="hljs-number">-1</span>)][k-a[i][j]])%M;            &#125;        &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,q,n+m<span class="hljs-number">-1</span>-p)        ans=(ans+b[n%<span class="hljs-number">2</span>][m][i])%M;    cout&lt;&lt;ans;&#125;</code></pre></div>    </div></div><h1 id="k-学不会的知识">K-学不会的知识*</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/K">题目链接</a></p>          </div> </b></font></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; M;<span class="hljs-keyword">int</span> mp[N];<span class="hljs-keyword">int</span> n, k;LL a[N];vector&lt;LL&gt; V; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span></span>&#123;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;i:M)&#123;        mp[i.second] = <span class="hljs-number">0</span>;    &#125;    M.<span class="hljs-built_in">clear</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)    &#123;        <span class="hljs-keyword">int</span> val = a[i];        <span class="hljs-keyword">if</span> (mp[val])&#123;            cnt++;            M.<span class="hljs-built_in">erase</span>(mp[val]);            mp[val] = i;            M[i] = val;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(M.<span class="hljs-built_in">size</span>()&lt;m)&#123;            mp[val] = i;            M[i] = val;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">auto</span> t = M.<span class="hljs-built_in">begin</span>();            <span class="hljs-keyword">int</span> v = t-&gt;second;            M.<span class="hljs-built_in">erase</span>(t);            mp[v] = <span class="hljs-number">0</span>;            mp[val] = i;            M[i] = val;        &#125;    &#125;    <span class="hljs-keyword">return</span> cnt &gt;= k;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lisan</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">sort</span>(V.<span class="hljs-built_in">begin</span>(), V.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;        a[i] = <span class="hljs-built_in">lower_bound</span>(V.<span class="hljs-built_in">begin</span>(), V.<span class="hljs-built_in">end</span>(), a[i]) - V.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>;    &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, a + i);        V.<span class="hljs-built_in">push_back</span>(a[i]);    &#125;    <span class="hljs-built_in">lisan</span>();    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n, mid;    <span class="hljs-keyword">while</span>(l&lt;r<span class="hljs-number">-1</span>)&#123;        mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))            r = mid;        <span class="hljs-keyword">else</span>            l = mid + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> ans;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(l))        ans = l;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(r)) ans=r;    <span class="hljs-keyword">else</span> ans=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(ans&gt;<span class="hljs-number">0</span>)&#123;    cout &lt;&lt; ans &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;cbddl&quot;</span>&lt;&lt;endl;&#125;    &#125;</code></pre></div>    </div></div><h1 id="l-写不完了">L-写不完了 *</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/L">题目链接</a></p>          </div> </b></font></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> head[maxm],nt[maxm&lt;&lt;<span class="hljs-number">1</span>],to[maxm&lt;&lt;<span class="hljs-number">1</span>],idx[maxm&lt;&lt;<span class="hljs-number">1</span>],cnt;<span class="hljs-keyword">int</span> d[maxm];<span class="hljs-keyword">int</span> a[maxm];<span class="hljs-keyword">int</span> e[maxm];<span class="hljs-keyword">int</span> n,q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span>&#123;    cnt++;nt[cnt]=head[x];head[x]=cnt;to[cnt]=y;idx[cnt]=z;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span></span>&#123;    d[x]=a[x];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=nt[i])&#123;        <span class="hljs-keyword">int</span> v=to[i],w=e[idx[i]];        <span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs1</span>(v,x);        d[x]=<span class="hljs-built_in">min</span>(d[x],d[v]+w);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=nt[i])&#123;        <span class="hljs-keyword">int</span> v=to[i],w=e[idx[i]];        <span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;        d[v]=<span class="hljs-built_in">min</span>(d[v],d[x]+w);        <span class="hljs-built_in">dfs2</span>(v,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ans^=d[i];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">int</span> x,y,z;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);        <span class="hljs-built_in">add</span>(x,y,i);        <span class="hljs-built_in">add</span>(y,x,i);        e[i]=z;    &#125;    <span class="hljs-keyword">while</span>(q--)&#123;        <span class="hljs-keyword">int</span> op;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">int</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);            a[x]=y;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">int</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);            e[x]=y;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">cal</span>();        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">solve</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优劣解距离法</title>
      <link href="/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E6%B3%95/"/>
      <url>/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.28，其中一些理解可能已被笔者推翻或废弃。</p>          </div><h1 id="优劣解距离法topsis">优劣解距离法(TOPSIS)</h1><p>TOPSIS法(Technique for Order Preference by Similarity to IdealSolution)<br />可翻译为逼近理想解排序法，国内常简称为优劣解距离法。是根据有限个评价对象与理想化目标的接近程度进行排序的方法，是在现有的对象中进行相对优劣的评价。</p><p>TOPSIS 法是一种常用的综合评价方法，其能充分利用原始数据的信息，<br />其结果能精确地反映各评价方案之间的差距。</p><figure><img src="https://s2.loli.net/2022/02/28/jRuf16qiWHEZbGm.png"alt="不同压缩因子压缩熵权法的TOPSIS" /><figcaptionaria-hidden="true">不同压缩因子压缩熵权法的TOPSIS</figcaption></figure><h2 id="基本思想">基本思想</h2><p>构造计算评分公式：<spanclass="math inline">\(\frac{x-min}{max-min}\)</span></p><p>该公式能够良好的对一个指标下的数据进行评分，反应了单个数据在数据范围区间所处的位置。</p><p><strong>拓展</strong>：将其中 <spanclass="math inline">\(x-min\)</span> 理解为“x与最小点的距离”；<spanclass="math inline">\(max-x\)</span>理解为“x于最大值点的距离”即可得到多指标评价公式</p><h2 id="模型步骤">模型步骤</h2><h3 id="数据处理">数据处理</h3><p>对所有的指标构成进行说明</p><p>对于 <span class="math inline">\(m\)</span> 个评价指标横向排列，<spanclass="math inline">\(n\)</span> 个评价对象纵向排列的矩阵，记为 <spanclass="math display">\[X_{nm}=\left[\begin{array}{cccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n 1} &amp; x_{n 2} &amp; \cdots &amp; x_{n m}\end{array}\right]\]</span></p><h3 id="指标正向化">指标正向化</h3><p><strong>描述</strong>：统一指标类型，将为极小型、中间型、区间型等指标转换为极大值指标</p><p><strong>注</strong>：最好不要出现负数(无法求熵权)</p><ol type="1"><li>极小型指标转换为极大型指标的公式</li></ol><p><spanclass="math display">\[\bar{x}_{i}=max-x_i或\bar{x}_{i}=\frac{1}{x_i}\]</span><strong>其中</strong>：<spanclass="math inline">\(\bar{x}_{i}\)</span>代表转化后的结果</p><ol start="2" type="1"><li>中间型指标转化为极大型指标</li></ol><p><span class="math display">\[\bar{x}_{i}=1-\frac{\left|x_{i}-x_{\text{best }}\right|}{\max \left(\left|X-x_{\text {best}}\right|\right)}\]</span> <strong>其中</strong>：<spanclass="math inline">\(x_{best}\)</span> 指代的是最好的值</p><ol start="3" type="1"><li>区间型指标转化为极大型指标</li></ol><p><span class="math display">\[\overline{x_{i}}=\left\{\begin{array}{c}1-\frac{a-x_{i}}{M}, x_{i}&gt;a \\1, \quad a&lt;x_{i}&lt;b \\1-\frac{x_{i}-b}{M}, x_{i}&gt;b\end{array}\right.\]</span> <strong>其中</strong>：<span class="math inline">\(M=\max\{a-\min (X), \max (X)-b\}\)</span>即偏离最优区间最远的值; <spanclass="math inline">\(a\)</span>为下界，<spanclass="math inline">\(b\)</span>为上界</p><h3 id="标准化处理">标准化处理</h3><p><strong>描述</strong>：消去不同指标量纲的影响</p><p>记标准化矩阵为<span class="math inline">\(Z_{nm}\)</span>,有<spanclass="math inline">\(Z_{i j}=\frac{x_{i j}}{\sqrt{\sum_{i=1}^{n} x_{ij}^{2}}}\)</span></p><h3 id="计算得分">计算得分</h3><p>定义 <span class="math display">\[\begin{aligned}Z^{+} &amp;=\left(Z_{1}^{+}, Z_{2}^{+}, \cdots, Z_{m}^{+}\right) \\&amp;=\left(\max \left\{z_{11}, z_{21}, \cdots, z_{n 1}\right\}, \max\left\{z_{12}, z_{22}, \cdots, z_{n 2}\right\}, \cdots, \max \left\{z_{1m}, z_{2 m}, \cdots, z_{n m}\right\}\right) \\Z^{-} &amp;=\left(Z_{1}^{-}, Z_{2}^{-}, \cdots, Z_{m}^{-}\right) \\&amp;=\left(\min \left\{z_{11}, z_{21}, \cdots, z_{n 1}\right\}, \min\left\{z_{12}, z_{22}, \cdots, z_{n 2}\right\}, \cdots, \min \left\{z_{1m}, z_{2 m}, \cdots, z_{n m}\right\}\right)\end{aligned}\]</span></p><p>定义第 <span class="math inline">\(i(i=1,2, \cdots, n)\)</span>个评价对象与最大值的距离 <spanclass="math inline">\(D_{i}^{+}=\sqrt{\sum_{j=1}^{m}\widetilde{w}_{j}\left(Z_{j}^{+}-z_{ij}\right)^{2}}\)</span><br />定义第 <span class="math inline">\(i(i=1,2, \cdots, n)\)</span>个评价对象与最小值的距离 <spanclass="math inline">\(D_{i}^{-}=\sqrt{\sum_{j=1}^{m}\widetilde{w}_{j}\left(Z_{j}^{-}-z_{ij}\right)^{2}}\)</span><br />其中 <span class="math inline">\(\widetilde{w}_{j}\)</span>为加权的指标权重，权重默认为1(因为除法，权重单位量对结果无影响)，可以用层次分析法或熵权法确定权重。</p><p>第 <span class="math inline">\(i(i=1,2, \cdots, n)\)</span>个评价对象未归一化得分<spanclass="math inline">\(S_{i}=\frac{D_{i}^{-}}{D_{i}^{+}+D_{i}^{-}}\)</span></p><h3 id="结果处理">*结果处理</h3><p>为了比较不同评价模型得到的结果曲线，常常对结果处理。让结果更容易解释，或更好比较。(归一化、标准化)</p><p><spanclass="math display">\[\widetilde{S_{i}}=\frac{S_{i}}{\sum_{i=1}^{n}S_{i}}\]</span></p><h2 id="更多理解">更多理解</h2><p>对于形如上文 <span class="math inline">\(Z\)</span>的矩阵，可以将<span class="math inline">\(m\)</span>个评价指标看作<spanclass="math inline">\(m\)</span>个坐标轴。对于这<spanclass="math inline">\(m\)</span>个坐标轴的张成空间 <spanclass="math inline">\(V\)</span>，每一条横轴（即待评价单元）就可表示为该空间上的一点 <spanclass="math inline">\(P(x_{i1},x_{i2},...,x_{im})\)</span>。</p><p><span class="math inline">\(Z^{+}(Z_{1}^{+}, Z_{2}^{+}, \cdots,Z_{m}^{+})\)</span> , <span class="math inline">\(Z^{-}(Z_{1}^{-},Z_{2}^{-}, \cdots, Z_{m}^{-})\)</span> 为包含所有评价点集的最小“<spanclass="math inline">\(m\)</span>维体”的主对称轴上的两端点。</p><p>对于 <spanclass="math inline">\(S_{i}=\frac{D_{i}^{-}}{D_{i}^{+}+D_{i}^{-}}=\frac{1}{1+k}\)</span>, <span class="math inline">\(k\)</span> 的含义为点到 <spanclass="math inline">\(Z^+\)</span> 与 <spanclass="math inline">\(Z^-\)</span> 的距离比值。形如 <spanclass="math inline">\(k=\frac{D^+}{D^-}=\frac{dis(X,Z^+)}{dis(X,Z^-)}\)</span>的式子表示的曲线为<span class="math inline">\(m\)</span>纬的球体。</p><p>以下为2个评价指标时，以 <span class="math inline">\(Z^+(3,2)\)</span>, <span class="math inline">\(Z^-(0,0)\)</span> 为端点，<spanclass="math inline">\(k=\{2^{-4},2^{-3},...,2^4\}\)</span>时的函数图像。同一曲线上的点表示的评价结果相同。</p><figure><img src="https://s2.loli.net/2022/01/18/pqFAbi5Ek4SonVa.png"alt="二维评价张成空间" /><figcaption aria-hidden="true">二维评价张成空间</figcaption></figure><p>如图，可以看出TOPSIS评价对空间进行了扭曲（把<spanclass="math inline">\(m\)</span>空间非线性压缩为一维评价系）。保留了样本间间距，但损失了原始统计信息。</p><blockquote><p>通过下文解释，所以TOPSIS是高纬的归一化(Normalization)?但下文中说，归一化也是线性放缩。(22.1.18)</p></blockquote><h1 id="熵权法">熵权法</h1><p>熵权法构建系数利用了信息论的知识。简单的说，数据的变异程度（方差）越大，就说明这个指标蕴含的信息量越大，也就越重要。例如：一个指标都是相同的数值，那么这个指标的变异程度（方差）就超级小，也没对最终的判断做出贡献，所以这个指标的权重就可以赋为0。</p><h2 id="模型思想">模型思想</h2><p>记信息量为<span class="math inline">\(I(p)\)</span>，概率为<spanclass="math inline">\(p\)</span>，有<spanclass="math inline">\(I(1)=0\)</span>、<spanclass="math inline">\(I(0^+)=+\infty\)</span>，可以得到一个<spanclass="math inline">\(I\)</span>与<spanclass="math inline">\(p\)</span>呈反比的函数图像。</p><p>构造<span class="math inline">\(I(x)=- \ln{p(x)}\)</span>保证<spanclass="math inline">\(0 \leqslant p(x) \leqslant 1\)</span>。<spanclass="math inline">\(x\)</span>表示事情发送的情况，<spanclass="math inline">\(p(x)\)</span>表示事情发生的概率。</p><p>可定义事件<spanclass="math inline">\(X={x_1,x_2,...,x_n}\)</span>(<spanclass="math inline">\(x_i\)</span>为发生情况)的信息熵为： <spanclass="math display">\[H(X)=\sum_{i=1}^{n}\left[p\left(x_{i}\right)I\left(x_{i}\right)\right]=-\sum_{i=1}^{n}\left[p\left(x_{i}\right) \ln\left(p\left(x_{i}\right)\right)\right]\]</span>信息熵的本质是对信息量的期望值。</p><p><strong>注</strong>：可证当<spanclass="math inline">\(p(x_1)=p(x_2)=...=p(x_n)=\frac{1}{n}\)</span>时<spanclass="math inline">\(H(x)\)</span>取得最大值为<spanclass="math inline">\(\ln n\)</span>。</p><h2 id="基本步骤">基本步骤</h2><ol type="1"><li>矩阵正向化和标准化 <spanclass="math display">\[Z=\left[\begin{array}{cccc}z_{11} &amp; z_{12} &amp; \cdots &amp; z_{1 m} \\z_{21} &amp; z_{22} &amp; \cdots &amp; z_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n 1} &amp; z_{n 2} &amp; \cdots &amp; z_{n m}\end{array}\right]\]</span></li><li>对已经正向化和标准化的矩阵，若有负数需再次归一化(另一种标准化) <spanclass="math display">\[\tilde{z}_{i j}=\frac{x_{i j}-\min \left\{x_{1j}, x_{2 j}, \cdots, x_{n j}\right\}}{\max \left\{x_{1 j}, x_{2 j},\cdots, x_{n j}\right\}-\min \left\{x_{1 j}, x_{2 j}, \cdots, x_{nj}\right\}}\]</span></li><li>计算概率矩阵 <span class="math display">\[p_{i j}=\frac{\tilde{z}_{ij}}{\sum_{i=1}^{n} \tilde{z}_{i j}}\]</span></li><li>计算熵值。之所以除以了一个 <spanclass="math inline">\(ln(n)\)</span> 是为了归一化 <spanclass="math display">\[e=-\frac{1}{\ln (n)} \times \sum_{i=1}^{n} p_{i}\ln \left(p_{i}\right)\]</span></li><li>构建权重。首先用<spanclass="math inline">\(1-e_j\)</span>得到信息的效用值，之后因为权重只和为<spanclass="math inline">\(1\)</span>，在对权重进行归一化即可得到<spanclass="math inline">\(w_j\)</span>权重 <spanclass="math display">\[d_j=1-e_j\]</span> <spanclass="math display">\[w_j=\frac{d_j}{\sum_{j=1}^m d_j}\]</span></li></ol><blockquote><p>熵权法仅仅能反应指标信息量的大小，并不能反应指标的重要程度，所以使用熵权法加权的评价模型得到的结果往往比未加权的结果变化幅度更大，增减趋势更明显。但似乎并不能得到一个客观的评分？(22.1.21)</p></blockquote><figure><img src="https://pic.imgdb.cn/item/621c62d12ab3f51d911ebe63.png"alt="越往右越趋近正常的熵权法权重" /><figcaption aria-hidden="true">越往右越趋近正常的熵权法权重</figcaption></figure><h1 id="归一化与标准化">*归一化与标准化</h1><p>它们都是指特征工程中的特征线性缩放过程</p><p><strong>作用</strong>：</p><ol type="1"><li>使不同量纲的特征处于同一数值量级，减少方差大的特征的影响，使模型更准确。</li><li>加快学习算法的收敛速度。</li></ol><p><strong>缩放过程可以分为以下几种</strong>：</p><ol type="1"><li>缩放到均值为0，方差为1（Standardization——StandardScaler()）</li><li>缩放到0和1之间（Standardization——MinMaxScaler()）</li><li>缩放到-1和1之间（Standardization——MaxAbsScaler()）</li><li>缩放到0和1之间，保留原始数据的分布（Normalization——Normalizer()）</li></ol><p>1就是常说的z-score归一化，2是min-max归一化。</p><h2 id="归一化normalization">归一化（Normalization）</h2><h3 id="平均归一化mean-normalization">1.平均归一化（MeanNormalization）</h3><p>这种归一化需防止在线学习或在线推理中，新进样本突破原始min或max数据</p><p><span class="math display">\[\frac{X_{i}-\mu }{X_{\max }-X_{\min}}\]</span></p><p><strong>其中</strong>：<spanclass="math inline">\(X_{min}\)</span>表示对应矩阵中最小的数;<spanclass="math inline">\(X_{max}\)</span>表示对应矩阵中最大的数</p><h3 id="minmax归一化rescaling">2.minmax归一化（Rescaling）</h3><p>这种归一化需防止在线学习或在线推理中，新进样本突破原始min或max数据<span class="math display">\[\frac{X_{i}-X_{\min }}{X_{\max }-X_{\min}}\]</span></p><h3 id="非线性归一化non-linear-normlization">3.非线性归一化（Non-LinearNormlization）</h3><p><span class="math display">\[\begin{array}{c}\lg x \\\log _{2} x \\\frac{2}{\pi} \arctan x\end{array}\]</span> 这种归一化需考虑数据分布，进行适当的非线性函数选取。</p><h2 id="标准化standardization">标准化（Standardization）</h2><h3 id="z-score标准化">1.Z-Score标准化</h3><p><span class="math display">\[\frac{X_{i}-\mu}{\sigma}\]</span>这种标准化需要要求原数据近似高斯分布。</p><p><strong>其中</strong>：<spanclass="math inline">\(\mu\)</span>表示矩阵均值;<spanclass="math inline">\(\sigma\)</span>表示矩阵标准差</p><h2 id="中心化centralization">中心化（Centralization）</h2><p>对于中心化，有的地方成为Mean-Subtraction，表示均值-减去（有点日本话的感觉），有的地方称之为Zero-Mean即零均值化，还有的为Zero-Centered这个只可意会很难翻译。但总而言之，他们都是下面这个形式：<span class="math display">\[x_i-\mu\]</span></p><h2 id="区别和用途">区别和用途</h2><p>归一化和标准化的相同点都是对某个特征（column）进行缩放（scaling）而不是对某个样本的特征向量（row）进行缩放。对特征向量进行缩放是毫无意义的。</p><p>归一化和标准化都保持数据分布不变的情况下（两者本质上都只是对数据进行线性变化），对数据进行处理，但是从公式上面还是能够明显看出来，归一化的处理只是和最大值最小值相关，归一化后样本会失去原始的信息；标准化却是和数据的分布相关（均值，方差）。归一化更好保留了样本间间距；标准化的统计意义更强，是数据缩放的首选。</p><table><colgroup><col style="width: 57%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th style="text-align: center;">归一化</th><thstyle="text-align: left;"><font size=1>将一列数据“拍扁”到某个固定区间(常为[0,1]),和最大/小值有关</font></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>标准化</strong></td><tdstyle="text-align: left;"><font size=1><strong>将数据变换为均值0,标准差为1的分布(并非一定正态),缩放和每个点都有关(通过均值+方差体现)</strong></font></td></tr><tr class="even"><td style="text-align: center;"><strong>中心化</strong></td><tdstyle="text-align: left;"><font size=1><strong>变量减去均值，可避免异常值和极端值的影响，本质为口个平移过程，平移后数据中心是原点0</strong></font></td></tr></tbody></table><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.cnblogs.com/xiashiwendao/p/12130992.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://baike.baidu.com/item/TOPSIS%E6%B3%95/3094166?fr=aladdin<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://blog.csdn.net/limiyudianzi/article/details/103410150<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>bilibili:数学建模学习交流<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://www.zhihu.com/question/20467170<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/364338617<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TOPSIS </tag>
            
            <tag> 熵权法 </tag>
            
            <tag> 归一化与标准化 </tag>
            
            <tag> 综合评价 </tag>
            
            <tag> 客观赋权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层次分析法</title>
      <link href="/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.1，其中一些理解可能已被笔者推翻或废弃。</p>          </div><h1 id="层次分析法ahp">层次分析法(AHP)</h1><p>层次分析法(Analytic Hierarchy Process,AHP)<br />这是一种定性和定量相结合的、系统的、层次化的分析方法。这种方法是在对复杂决策问题的本质上，利用较少的定量信息使<strong>决策的思维过程数学化</strong>，从而为多目标、多准则或无结构特性的决策问题提供简便的决策方法。<strong>是对难以定量的复杂系统进行决策的模型</strong>。</p><p>层次分析法的根本是<strong>打分法</strong>：<u>确定指标</u>，<u>不同方案指标打分</u>，<u>为指标确定权重</u>。用于处理数据未知的评价。</p><p>层次分析法将问题分解为组成因素，并按照因素间关联、影响以及隶属关系将因素按不同的层次聚集组合，形成一个多层次的分析结构模型。从而最终使问题归结为最低层(供决策的方案、措施等)相对于最高层(总目标)的相对重要权值的确定或相对优劣次序的排定。</p><h2 id="基本步骤">基本步骤</h2><h3 id="建立层次模型">建立层次模型</h3><p>思考以下问题：</p><ol type="1"><li>我的的评价目标是什么？</li><li>达到目标有哪些方案？</li><li>★对方案的评价准则或指标是什么？（最好参考引用文献）</li></ol><p>将<u>决策的目标</u>、<u>决策准则</u>(考虑的因素)和<u>决策对象</u>绘制为层次结构图。</p><ol type="1"><li>最高层(目标层)：决策的目的、要解决的问题；</li><li>中间层(准则层或指标层)：考虑的因素、决策的准则；</li><li>最低层(方案层)：决策时的备选方案；</li></ol><p>或仅绘制评价体系(树状图或表格)如下(要包含<strong>多级指标</strong>)：</p><figure><img src="https://s2.loli.net/2022/01/18/oVnIQh5DpORcuqX.png"alt="评价模型" /><figcaption aria-hidden="true">评价模型</figcaption></figure><h3 id="构造判断矩阵">构造判断矩阵</h3><p>(成对比较矩阵)</p><p>在确定权重时，只给出定性的结果(就是我认为景色占80%，费用10%等等)，常常不被别人接受，因此采用一致矩阵法，即：</p><ul><li>不把所有因素放在一起比较，而是两两比较</li><li>对此时采用相对尺度，尽可能减少诸因素导致的相互比较的困难，提高准确性</li></ul><p>成对比较矩阵是表示本层所有因素针对上一层某一个因素(准侧或目标)的相对重要性的比较。成对比较矩阵的元素<span class="math inline">\(a_{ij}\)</span> 表示的是第 <spanclass="math inline">\(i\)</span> 个因素相对于第 <spanclass="math inline">\(j\)</span>个因素的比较结果，这个值使用的是Santy的1-9标度方法给出。</p><p>定义且满足</p><p><spanclass="math display">\[a_{ij}=i相对j的重要度=\frac{i的重要程度}{j的重要程度}=a_{ik}a_{kj}\]</span></p><p><img src="https://s2.loli.net/2022/01/18/f5gYz8SqUmTbahn.png" /></p><h3 id="一致性检验">一致性检验</h3><p><span class="math inline">\(\left[\begin{array}{cccc} a_{11} &amp;a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22} &amp; \cdots&amp; a_{2 n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{n1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}\end{array}\right]\)</span>为一致矩阵的充要条件<spanclass="math inline">\(\left\{\begin{array}{l} a_{i j}&gt;0 \\a_{11}=a_{22}=\cdots=a_{n n}=1 \\ {\left[a_{i 1},..., a_{in}\right]=k_{i}\left[a_{11},..., a_{1 n}\right]}\end{array}\right.\)</span></p><p>对于</p><p>一致阵：则我们自然会取对应于最大特征根 <spanclass="math inline">\(n\)</span> 的归一化特征向量 <spanclass="math inline">\(\{w_1,w_2,\cdots,w_n\}\)</span> ，且 <spanclass="math inline">\(\sum_{i=1}^{n}{w_i=1}\)</span> ， <spanclass="math inline">\(w_i\)</span> 表示下层第 <spanclass="math inline">\(i\)</span>个因素对上层某个因素影响程度的权值。</p><p>非一致阵：用其最大特征根对应的归一化特征向量作为权向量 <spanclass="math inline">\(W=\{w_1,w_2,\cdots,w_n\}\)</span> ，则 <spanclass="math inline">\(AW=\lambda W\)</span>，这样确定权向量的方法称为特征根法；</p><p>定理：</p><ol type="1"><li><span class="math inline">\(n\)</span> 阶一致阵的唯一非零特征根为<span class="math inline">\(n\)</span></li><li><span class="math inline">\(n\)</span> 阶互反阵 <spanclass="math inline">\(A\left(a_{i j}&gt;0, a_{i j}=\frac{1}{a_{j i}},a_{i i}=1\right)\)</span> 最大特征根 <span class="math inline">\(\lambda\geq n\)</span> ，当且仅当 <spanclass="math inline">\(\lambda=n\)</span> 时， <spanclass="math inline">\(A\)</span> 为一致矩阵。</li></ol><p><span class="math inline">\(\lambda\)</span> 连续的依赖于 <spanclass="math inline">\(a_{ij}\)</span> ，则 <spanclass="math inline">\(\lambda\)</span> 比 <spanclass="math inline">\(n\)</span> 大的越多， <spanclass="math inline">\(A\)</span>的不一致性越严重。用最大特征值对应的特征向量作为影响程度的权向量，其不一致程度越大，引起的判断误差越大。</p><p><strong>第一步：计算一致性指标CI</strong></p><p><span class="math display">\[CI=\frac{\lambda -n}{n-1}\]</span></p><ol type="1"><li><span class="math inline">\(CI=0\)</span> ,有完全的一致性；</li><li><span class="math inline">\(CI\)</span> 接近 <spanclass="math inline">\(0\)</span> ，有满意的一致性</li><li><span class="math inline">\(CI\)</span> 越大，不一致越严重；</li></ol><p><strong>第二步：查找对应的平均随机一致性指标RI</strong></p><table><colgroup><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /></colgroup><thead><tr class="header"><th style="text-align: center;">n</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">8</th><th style="text-align: center;">9</th><th style="text-align: center;">10</th><th style="text-align: center;">11</th><th style="text-align: center;">12</th><th style="text-align: center;">13</th><th style="text-align: center;">14</th><th style="text-align: center;">15</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">RI</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0.52</td><td style="text-align: center;">0.89</td><td style="text-align: center;">1.12</td><td style="text-align: center;">1.26</td><td style="text-align: center;">1.36</td><td style="text-align: center;">1.41</td><td style="text-align: center;">1.46</td><td style="text-align: center;">1.49</td><td style="text-align: center;">1.52</td><td style="text-align: center;">1.54</td><td style="text-align: center;">1.56</td><td style="text-align: center;">1.58</td><td style="text-align: center;">1.59</td></tr></tbody></table><p><span class="math inline">\(RI\)</span>为统计结果，详细计算方法参考<ahref="https://zhuanlan.zhihu.com/p/38207837">这里</a></p><p><strong>第三步：计算一致性比例CR</strong></p><p><span class="math display">\[CR=\frac{CI}{RI}\]</span></p><p>如果 <span class="math inline">\(CR &lt; 0.1\)</span>,则可认为判断矩阵的一致性可以接受；否则需要对判断矩阵进行修正。</p><h3 id="求得权重">求得权重</h3><ol type="1"><li>算术平均法求权重 <span class="math display">\[\omega_{i}=\frac{1}{n}\sum_{j=1}^{n} \frac{a_{i j}}{\sum_{k=1}^{n} a_{k j}}\]</span></li><li>几何平均法求权重 <spanclass="math display">\[\omega_{i}=\frac{\left(\prod_{j=1}^{n} a_{ij}\right)^{\frac{1}{n}}}{\sum_{k=1}^{n}\left(\prod_{j=1}^{n} a_{kj}\right)^{\frac{1}{n}}}\]</span></li><li>特征值法求权</li></ol><p>特别的：若特征值为n，对应特征向量为<spanclass="math inline">\(k\left[\frac{1}{a_{11}}, \frac{1}{a_{12}}, \cdots,\frac{1}{a_{1 n}}\right]^{T}\)</span>，且特征向量刚好为矩阵第一列。</p><p>假如我们的判断矩阵一致性可以接受，那么我们可以仿照一致矩阵权重的求法。</p><ol type="1"><li>求出矩阵A的最大特征值以及其对应的特征向量<br /></li><li>对求出的特征向量进行归一化即可得到我们的权重( <spanclass="math inline">\(\sum_{i=1}^{n}{w_i=1}\)</span> )</li></ol><h3 id="填表得结果">填表得结果</h3><figure><img src="https://s2.loli.net/2022/01/18/BgNZY8JkrPjMKtq.png"alt="表格" /><figcaption aria-hidden="true">表格</figcaption></figure><p>然后相应的加权计算得分即可得到结果。</p><h2 id="一点补充">一点补充</h2><h3 id="详细做法补充">详细做法补充</h3><ol type="1"><li>对于评价指标：<ol type="1"><li>单层评价指标：构造所有指标的两两判断矩阵，得到权值</li><li>多层评价指标：<ol type="1"><li>构造一级指标的两两判断矩阵，得到权值</li><li>构造每个一级指标下的二级指标的两两判断矩阵（每个一级指标一个矩阵），得到权值</li><li>构造每个二级指标下……<br />……</li></ol></li></ol></li><li>对于方案：<ol type="1"><li>对于每个最低级指标构造所有方案的两两判断矩阵，得到权值</li></ol></li></ol><p>示例：</p><p><span class="math display">\[\left\{\begin{array}{l}   一级指标1\left\{\begin{array}{l}      二级指标1 :a_{11},a_{12},a_{13}\\      二级指标2 :a_{21},a_{22},a_{23}\\   \end{array}\right.\\ \\   一级指标2\left\{\begin{array}{l}      二级指标3 :a_{31},a_{32},a_{33}\\      二级指标4 :a_{41},a_{42},a_{43}\\      二级指标5 :a_{51},a_{52},a_{53}\\   \end{array}\right.\\ \\   一级指标3 : a_{61},a_{62},a_{63}\end{array}\right.\\\]</span></p><h3 id="特征向量含义思考">特征向量含义思考</h3><p>对于矩阵 <span class="math inline">\(A=\left[\begin{array}{cccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22}&amp; \cdots &amp; a_{2 n} \\ \vdots &amp; \vdots &amp; \ddots &amp;\vdots \\ a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}\end{array}\right]\)</span> ， <spanclass="math inline">\(W=\left[\begin{array}{c} w_{1}\\ w_{2}\\ \vdots\\w_{n} \end{array}\right]\)</span> ，满足 <spanclass="math inline">\(AW=\lambda A\)</span> 。</p><p>矩阵的本质是变换，把 <span class="math inline">\(A\)</span> 看作对<span class="math inline">\(m\)</span> 纬空间单位球体进行 <spanclass="math inline">\(A\)</span> 变换,取 <spanclass="math inline">\(\lambda\)</span> 最大时的特征向量 <spanclass="math inline">\(W\)</span>,即表示为变换后的球体上与变换前方向相同的点中距离原点 <spanclass="math inline">\(O\)</span> 最远的点（距离原点距离为 <spanclass="math inline">\(\lambda\)</span> ）所表示的方向向量 。记 <spanclass="math inline">\(W\)</span> 为可以代表整个变换 <spanclass="math inline">\(A\)</span> 的线性变换。</p><blockquote><p>特别的对于对称矩阵 <span class="math inline">\(A\)</span> ，变换<span class="math inline">\(A\)</span>一定是将球变为椭球，这也是不同特征值对应特征向量一定正交的原因，相同特征值<span class="math inline">\(\lambda\)</span> 若有多个特征向量 <spanclass="math inline">\(e_1,e_2,...\)</span>，特征向量的张成空间都是该特征值<span class="math inline">\(\lambda\)</span> 的特征向量。<spanclass="math inline">\(\lambda\)</span> 的特征向量。<br />但是，对于非特殊矩阵，几何意义不明确，另外对于正互反矩阵、一致性矩阵的变换性质，笔者并不清楚，所以也仅仅能近似的类比理解到这里了。(22.1.18)</p></blockquote><h2 id="一些问题">一些问题</h2><ol type="1"><li>评价的决策层不能太多，太多的话n会很大,判断矩阵和一致矩阵差异可能会很大。</li><li>平均随机一致性指标RI的表格中n最多是15。</li></ol><p>所以<strong>当n过大可以分层归纳为多级指标</strong>再构造多个判断矩阵。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>bilibili:数学建模学习交流<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/38207837<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合评价 </tag>
            
            <tag> 层次分析法 </tag>
            
            <tag> 决策方法 </tag>
            
            <tag> 主观赋权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊综合评价</title>
      <link href="/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/"/>
      <url>/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.1，其中一些理解可能已被笔者推翻或废弃。</p>          </div><h1 id="模糊综合评价fuzzy-sets">模糊综合评价(fuzzy sets)</h1><p>模糊综合评价(Fuzzy Comprehension EvaluationMethod)又为模糊集合理论(fuzzy sets)对于难以明确分类，边界不明显的评价指标可才用模糊综合评价，模型关键在于构造的<strong>隶属函数</strong>的准确性和合理性。</p><h2 id="基本步骤">基本步骤</h2><h3 id="建立综合评价的因素集">建立综合评价的因素集</h3><p>模糊综合评价指标的构建。<br />因素集是以影响评价对象的各种因素为元素所组成的一个普通集合，通常用 <spanclass="math inline">\(U\)</span> 表示， <spanclass="math inline">\(U=(u_1,u_2,\cdots,u_m)\)</span>，其中元素 <spanclass="math inline">\(u_i\)</span> 代表影响评价对象的第 <spanclass="math inline">\(i\)</span>个因素。这些因素，通常都具有不同程度的模糊性。</p><h3 id="建立综合评价的评价集">建立综合评价的评价集</h3><p>评价集是评价者对评价对象可能做出的各种结果所组成的集合，通常用 <spanclass="math inline">\(V\)</span> 表示， <spanclass="math inline">\(V=(v_1,v _2,\cdots,v_m)\)</span> ，其中元素 <spanclass="math inline">\(v_i\)</span> 代表第 <spanclass="math inline">\(i\)</span> 种评价结果</p><h3 id="构造隶属函数获得评价矩阵">构造隶属函数，获得评价矩阵</h3><p>构造合理美观的隶属函数 <spanclass="math inline">\(Fuzz(x)\)</span>。</p><p>若因素集U中第i个元素对评价集V中第1个元素的隶属度为 <spanclass="math inline">\(r_{i1}\)</span> ，则对第 <spanclass="math inline">\(i\)</span>个元素单因素使用隶属函数评价的结果用模糊集合表示为：<spanclass="math inline">\(R_i=(r_{i1},r_{i2},\cdots,r_{in})\)</span>。以<span class="math inline">\(m\)</span> 个单因素评价集构成 <spanclass="math inline">\(R_{mn}=[R1,R2,\cdots,Rm]^T\)</span>，称为模糊综合评价矩阵。</p><h3 id="确定因素权向量">确定因素权向量</h3><p>评价工作中，各因素的重要程度有所不同，为此，给各因素 <spanclass="math inline">\(u_i\)</span>一个权重 <spanclass="math inline">\(w_i\)</span> ，各因素的权重集合的模糊集，用 <spanclass="math inline">\(W\)</span> 表示: <spanclass="math inline">\(W=(w_1,w_2,\cdots,w_m)\)</span>。</p><h3 id="建立综合评价模型">建立综合评价模型</h3><p>确定单因素评判矩阵 <span class="math inline">\(R\)</span>和因素权向量 <span class="math inline">\(W\)</span> 之后，通过模糊变化将<span class="math inline">\(U\)</span>上的模糊向量 <spanclass="math inline">\(A\)</span> 变为 <spanclass="math inline">\(V\)</span> 上的模糊向量 <spanclass="math inline">\(B\)</span>，即 <spanclass="math display">\[B=W_{1m}\cdotR_{mn}=(b_1,b_2,\cdots,b_n)\]</span></p><p>绘出结果 <span class="math inline">\(B\)</span> 图像，如 <imgsrc="https://pic3.zhimg.com/80/v2-368fd890e8f6524b341b070804782bd2_1440w.jpg" /></p><h2 id="一些思考">一些思考</h2><p>对于模糊评价，相较于作为一个“综合评价”，我更愿意把模糊综合评价看作为类似于层次分析法的<strong>带有主观意愿的评价</strong>（体现在隶属函数的构造上）；对于模糊集合理论（模糊数学），更愿意看作一种<strong>思想</strong>（隶属程度的思想）。</p><blockquote><p>在2021亚太杯C题的第三四题中我用模糊数学思想，对于“是否属于城市印象范围”构造了这样的“模糊隶属函数”。<spanclass="math inline">\(Fuz_1(x)=\frac{ℯ^{-(k(x-b))}}{ℯ^{-(k(x-b))}+1}\)</span>、<spanclass="math inline">\(Fuz_2(x)=ℯ^{\frac{(x-a)^2}{q}}\)</span>得到了以下的结果。 (22.2.1)</p></blockquote><figure><img src="https://s2.loli.net/2022/02/01/mO67ZcKR2L34Bau.png"alt="一些城市相关评价指标评分（隶属）图像" /><figcaptionaria-hidden="true">一些城市相关评价指标评分（隶属）图像</figcaption></figure><h1 id="参考">参考</h1><p>[^1]https://baike.baidu.com/item/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%B3%95/2162444[^2] https://zhuanlan.zhihu.com/p/32666445</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主观赋权 </tag>
            
            <tag> 模糊综合评价 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰色关联分析</title>
      <link href="/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.28，其中一些理解可能已被笔者推翻或废弃。</p>          </div><h1 id="灰色关联分析gra">灰色关联分析(GRA)</h1><p>灰色关联度分析（Grey Relation Analysis）<br />可以在一个灰色系统中，衡量某个项目受其他的因素影响的相对强弱。</p><p>两个系统之间的因素，随时间或不同对象而变化的关联性大小的量度，称为关联度。两个因素变化即同步变化程度较高，即可谓二者关联程度较高；反之，则较低。因此，灰色关联分析方法，根据因素之间发展趋势的相似相异程度，为衡量因素间关联程度提供了量化的度量。</p><p>灰色关联分析的<strong>基本思想</strong>是根据<strong>序列曲线几何形状的相似程度</strong>来判断其联系是否紧密。曲线越接近，相应序列之间的关联度就越大，反之就越小。</p><h2 id="基本步骤">基本步骤</h2><h3 id="确定分析序列">确定分析序列</h3><ol type="1"><li><strong>母序列(又称参考序列、母指标)</strong></li></ol><p>能反映系统行为特征的数据序列，类似于因变量 <spanclass="math inline">\(Y\)</span> ，记为</p><p><span class="math display">\[Y=[y_1,y_2,...,y_m]^T\]</span></p><ol start="2" type="1"><li><strong>子序列(又称比较序列、子指标)</strong></li></ol><p>影响系统行为的因素组成的数据序列，类似于因变量 <spanclass="math inline">\(X\)</span> ，记为</p><p><span class="math display">\[X_{nm}=\left[\begin{array}{cccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n 1} &amp; x_{n 2} &amp; \cdots &amp; x_{n m}\end{array}\right]\]</span></p><p><strong>其中</strong>：<span class="math inline">\(n\)</span>为年份数量，<span class="math inline">\(m\)</span> 为要素的个数</p><h3 id="数据预处理">数据预处理</h3><p>由于不同要素具有不同量纲和数据范围范围，因此我们需要对它们进行归一化(常用均值化)去量纲，将它们统一到近似的范围内，然后重点关注其变化和趋势。</p><p><spanclass="math display">\[\widetilde{y}_{k}=\frac{y_{k}}{\bar{y_i}}, \quad\bar{y_i}=\frac{1}{n} \sum_{k=1}^{n} y_{k}\]</span></p><p><spanclass="math display">\[\widetilde{x}_{ki}=\frac{x_{ki}}{\bar{x_{\_i}}},\quad \bar{x_{\_i}}=\frac{1}{n} \sum_{k=1}^{n} x_{ki},(i=1,2,...m)\]</span></p><p>注：下文继续用 <span class="math inline">\(X\)</span> 代指预处理后的<span class="math inline">\(\widetilde{X}\)</span> ， <spanclass="math inline">\(Y\)</span> 代指 <spanclass="math inline">\(\widetilde{Y}\)</span>。</p><h3 id="计算灰色关联系数">计算灰色关联系数</h3><p>计算子序列中各个指标与母序列的关联系数</p><p>记 <span class="math display">\[a=\min _{i}\min_{k}\left|x_{0}(k)-x_{i}(k)\right|, \quad b=\max _{i}\max_{k}\left|x_{0}(k)-x_{i}(k)\right|\]</span>为两极最小差和最大差。</p><p>构造 <span class="math display">\[z_{k,j}=\xi_j(k)=\frac{a+\rhob}{|x_{kj}-y_j|+\rho b}\]</span> 构成 <spanclass="math inline">\(Z\)</span>。</p><p><strong>其中</strong>：<spanclass="math inline">\(\rho\)</span>为分辨系数，一般取0.5</p><h3 id="计算关联度">计算关联度</h3><p><span class="math display">\[r_j=\frac{1}{n} \sum_{k=1}^{n} \xi_j(k)= \frac{1}{n} \sum_{k=1}^{n} z_{kj}\]</span></p><h2 id="基于关联度计算权重的综合评价">基于关联度计算权重的综合评价</h2><p>本质是构造虚拟母指标，以各个指标与母指标的灰色关联度 <spanclass="math inline">\(r_j\)</span>代表指标权重，再<strong>以此权重对每个观测值做简单加权</strong>得到结果为评价。</p><p>权重 <span class="math inline">\(w_j\)</span>反应的是指标与样本最大值的关联度，指标下的观测值在同截面数据中最大的数目越多，与母序列相似程度愈高，<span class="math inline">\(w_j\)</span>愈大。所以得到的综合评价结果仅仅是未加权结果的更平缓曲线(?)</p><blockquote><p>本方法疑是来源清风的数学建模视频，在互联网上流传。与灰色关联分析的决策方法相异，正确性存疑。(2.28)</p></blockquote><h3 id="正向化预处理">1. 正向化预处理</h3><p>记正向化后的数据为： <spanclass="math display">\[X_{nm}=\left[\begin{array}{cccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n 1} &amp; x_{n 2} &amp; \cdots &amp; x_{n m}\end{array}\right]\]</span></p><p><strong>其中</strong>：<span class="math inline">\(n\)</span>为年份数，<span class="math inline">\(m\)</span> 为指标数</p><h3 id="去除量纲">2. 去除量纲</h3><p>每个数 <span class="math inline">\(x_{ij}\)</span> 除以每一列的平均值<span class="math inline">\(\bar{x_{\_i}}\)</span> ,记作 <spanclass="math inline">\(Z\)</span> ，有</p><p><span class="math display">\[z_{ki}=\frac{x_{ki}}{\bar{x_{\_i}}},\quad \bar{x_{\_i}}=\frac{1}{n} \sum_{k=1}^{n} x_{ki},(i=1,2,...m)\]</span></p><p><span class="math display">\[Z_{nm}=\left[\begin{array}{cccc}z_{11} &amp; z_{12} &amp; \cdots &amp; z_{1 m} \\z_{21} &amp; z_{22} &amp; \cdots &amp; z_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n 1} &amp; z_{n 2} &amp; \cdots &amp; z_{n m}\end{array}\right]\]</span></p><h3 id="构造母序列">3. 构造母序列</h3><p>构造<strong>虚拟指标</strong>表示每个观测值的最优值 <spanclass="math inline">\(Y=[y_1,y_2,...,y_n]^T\)</span> 其中</p><p><spanclass="math display">\[y_i=max(z_{i1},z_{i2},...,z_{im})\]</span></p><h3 id="计算关联系数">4. 计算关联系数</h3><p>记差值矩阵为 <span class="math inline">\(K\)</span>，有 <spanclass="math display">\[K=\left[\begin{array}{cccc}k_{11} &amp; k_{12} &amp; \cdots &amp; k_{1 m} \\k_{21} &amp; k_{22} &amp; \cdots &amp; k_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\k_{k 1} &amp; k_{n 2} &amp; \cdots &amp; k_{n m}\end{array}\right]=\left[\begin{array}{cccc}|z_{11}-y_1| &amp; |z_{12}-y_1| &amp; \cdots &amp; |z_{1 m}-y_1| \\|z_{21}-y_2| &amp; |z_{22}-y_2| &amp; \cdots &amp; |z_{2 m}-y_2| \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\|z_{n 1}-y_n| &amp; |z_{n 2}-y_n| &amp; \cdots &amp; |z_{n m}-y_n|\end{array}\right]\]</span></p><p>记 <span class="math display">\[a=\min _{i}\min_{j}\left|k_{ij}\right|, \quad b=\max_{i} \max_{j}\left|k_{ij}\right|\]</span> 为两极最小差和最大差。</p><h3 id="计算指标关联度">5. 计算指标关联度</h3><p>记 <span class="math display">\[\xi_{ij}=\frac{a+\rhob}{|k_{ij}|+\rho b}\]</span></p><p><strong>其中</strong>：<spanclass="math inline">\(\rho\)</span>为分辨系数，一般取0.5</p><p><span class="math display">\[r_j=\frac{1}{n} \sum_{i=1}^{n}\xi_{ij}\]</span></p><p><strong>其中</strong>：<span class="math inline">\(r_j\)</span> 为第<span class="math inline">\(j\)</span> 个指标的灰色关联度</p><h3 id="计算指标权重">6. 计算指标权重</h3><p><span class="math display">\[w_j=\frac{r_j}{\sum_{k=1}^{m} r_k}(j=1,2,...,m)\]</span></p><h3 id="计算得分">7. 计算得分</h3><p><span class="math display">\[S_i= \sum_{j=1}^{m} Z_{ij} \cdotr_j\]</span></p><h3 id="结果处理">8. 结果处理</h3><p><span class="math display">\[\tilde{S}_i=\frac{S_i}{\sum_{k=1}^{m}S_k} (i=1,2,\cdots,n)\]</span></p><h2 id="基于灰色关联分析的综合评价">基于灰色关联分析的综合评价</h2><h3 id="数据处理">1. 数据处理</h3><p>记横轴为指标，纵轴为样本编号的矩阵 <spanclass="math inline">\(X\)</span>经每个指标规范化（纵轴方向归一化/标准化）后为</p><p><span class="math display">\[Z_{nm}=\left[\begin{array}{cccc} z_{11}&amp; z_{12} &amp; \cdots &amp; z_{1 m} \\ z_{21} &amp; z_{22} &amp;\cdots &amp; z_{2 m} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n 1} &amp; z_{n 2} &amp; \cdots &amp; z_{n m}\end{array}\right]\\\]</span></p><h3 id="构造虚拟样本">2. 构造虚拟样本</h3><p>记虚拟母样本为 <span class="math inline">\(Y\)</span>，其每个元素取对应指标的最优值，</p><p><spanclass="math display">\[Y=\left[y_1,y_2,\dotsb,y_m\right]\]</span></p><p>其中</p><p><spanclass="math display">\[y_j=\max(z_{1j},z_{2j},\dotsb,z_{nj})\]</span></p><h3 id="计算关联系数-1">3. 计算关联系数</h3><p>记差值矩阵为 <span class="math inline">\(K\)</span> ，有</p><p><span class="math display">\[K=\left[\begin{array}{cccc}k_{11} &amp; k_{12} &amp; \cdots &amp; k_{1 m} \\k_{21} &amp; k_{22} &amp; \cdots &amp; k_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\k_{k 1} &amp; k_{n 2} &amp; \cdots &amp; k_{n m}\end{array}\right]=\left[\begin{array}{cccc}|z_{11}-y_1| &amp; |z_{12}-y_2| &amp; \cdots &amp; |z_{1 m}-y_m| \\|z_{21}-y_1| &amp; |z_{22}-y_2| &amp; \cdots &amp; |z_{2 m}-y_m| \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\|z_{n 1}-y_1| &amp; |z_{n 2}-y_2| &amp; \cdots &amp; |z_{n m}-y_m|\end{array}\right]\\\]</span></p><p>记</p><p><span class="math display">\[a=\min _{i} \min_{j}\left|k_{ij}\right|,\quad b=\max_{i} \max _{k}\left|k_{ij}\right|\\\]</span></p><h3 id="计算指标关联度-1">4.计算指标关联度</h3><p>取 <span class="math inline">\(\rho=0.5\)</span> ，记</p><p><span class="math display">\[\xi_{ij}=\frac{a+\rho b}{|k_{ij}|+\rhob}\\\]</span></p><p>得到第 <span class="math inline">\(i\)</span>个样本的灰色关联度，即评价结果为 <spanclass="math inline">\(r_i\)</span> 为</p><p><span class="math display">\[r_i=\frac{1}{m} \sum_{j=1}^{m} \xi_{ij}\ \ 或 \ \ r_i= \sum_{j=1}^{m} w_j\xi_{ij}\]</span></p><p>其中 <span class="math inline">\(w_j\)</span> 为指标的权重，</p><p>以此作为各个观测值的评价结果。</p><h1 id="去量纲化方法">*去量纲化方法</h1><h2 id="初值化">初值化</h2><p>顾名思义，就是把这一个序列的数据统一除以最开始的值，由于同一个因素的序列的量级差别不大，所以通过除以初值就能将这些值都整理到1这个量级附近。</p><p><span class="math display">\[f(x(k))=\frac{x(k)}{x(1)}=y(k), \quadx(1) \neq 0\]</span></p><h2 id="均值化">均值化</h2><p>顾名思义，就是把这个序列的数据除以均值，由于数量级大的序列均值比较大，所以除掉以后就能归一化到1的量级附近。</p><p><span class="math display">\[f(x(k))=\frac{x(k)}{\bar{x}}=y(k), \quad\bar{x}=\frac{1}{n} \sum_{k=1}^{n} x(k)\]</span></p><h2 id="百分比变换">百分比变换</h2><p><span class="math display">\[f(x(k))=\frac{x(k)}{\max _{k}x(k)}=y(k)\]</span></p><h2 id="倍数变换">倍数变换</h2><p><span class="math display">\[f(x(k))=\frac{x(k)}{\min _{k}x(k)}=y(k), \quad \min_{k} x(k) \neq 0\]</span></p><h2 id="归一化变换">归一化变换</h2><p><spanclass="math display">\[f(x(k))=\frac{x(k)}{x_{0}}=y(k)\]</span></p><h2 id="极差最大值变换">极差最大值变换</h2><p><span class="math display">\[f(x(k))=\frac{x(k)-\min _{k}x(k)}{\max_{k} x(k)}=y(k)\]</span></p><h2 id="区间值变换">区间值变换</h2><p><span class="math display">\[f(x(k))=\frac{x(k)-\min _{k}x(k)}{\max_{k} x(k)-\min _{k} x(k)}=y(k)\]</span></p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://baike.baidu.com/item/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E6%B3%95/8602076?fr=aladdin<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/149479206<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/266959639<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合评价 </tag>
            
            <tag> 客观赋权 </tag>
            
            <tag> 灰色关联分析 </tag>
            
            <tag> 去量纲方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022—SWJTU寒假选拔赛第一场复盘</title>
      <link href="/2022/01/14/12/"/>
      <url>/2022/01/14/12/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="比赛链接">比赛链接</h1><div class="note note-info">            <p><ahref="https://vjudge.net/contest/476119"><b>2022—SWJTU寒假选拔赛第一场</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/m0_56007815/article/details/122506249?utm_source=app&amp;app_version=4.21.1&amp;utm_source=app"><b>题解</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><p><font size=0.1 face="微软雅黑"><b> | | Stat | # | Title | | :-----|----: | :----: | :-------: | | <span class="label label-success">Solved</span> | 21/90| A | 惠老板观星 || <span class="label label-success">Solved</span> | 26/54 | B | Asuka大战兔子 | | <span class="label label-warning">Attempted</span> | 2/44 |C |我不会debug| | <span class="label label-success">Solved</span> | 39/51 | D| 我要吃饭| | |2/6 | E|删删删| | <span class="label label-success">Solved</span> |12/27| F |大水题| | |0/17 |G| 你一定会种树吧|| <span class="label label-warning">Attempted</span> |3 / 17| H |货车| | |9/28 |I|超级打字大师| | |1/3 |J|简单数学| | <span class="label label-warning">Attempted</span> |5/23 |K |小游戏| | <span class="label label-success">Solved</span> |36/72| L|cold玩真人cs| | | |M |杰哥打怪| </b></font></p><figure><img src="https://s2.loli.net/2022/01/20/tXAVbOE2zMBfK8g.png"alt="RANK" /><figcaption aria-hidden="true">RANK</figcaption></figure><h2 id="a-惠老板观星">A-惠老板观星</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>惠老板最近迷上了星空摄影，为了更好的出片，惠老板需要在山地中找到四个位置。从空中看，这四个位置必须是一个正方形的四个顶点。在惠老板的理论中这四个点必须有三个点的高度相同。而另外一个点的高度要高于这三个点。惠老板去了蒙德的龙脊雪山。对于惠老板来说龙脊雪山可以看成由n*n个小平台组成的地区。每个平台都有其独立的整数高度。现在他想找出高度相同的三个观测点中最高的观测位置的高度。</p><p><strong>输入格式</strong></p><p>第一行一个整数表示<span class="math inline">\(n*n\)</span>的矩阵,<span class="math inline">\(2&lt;=n&lt;=3002&lt;=n&lt;=300\)</span></p><p>接下来n行每行个数表示当前位置的高度。<spanclass="math inline">\(1&lt;=ht[i,j]&lt;=10^91&lt;=ht[i,j]&lt;=10^9\)</span></p><p><strong>输出格式</strong></p><p>一个整数表示能找的的最高的观测位置（注意你需要输出的是那三个高度相同的点的高度而不是第四个最高顶点的高度）。若没有符合条件的观测位置则输出-1.</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">2</code></pre></div></td></tr></table><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span></code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="b-asuka大战兔子">B-Asuka大战兔子</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>Asuka养了在他的农场养了许多兔子，他的农场由无数个方格构成的，农场行数为x,列数为y。现在Asuka的农场中有许多兔子还有许多萝卜。兔子能够不断向上下左右四个方向移动从而到达农场各个位置，若移动之后的放个有萝卜那么兔子可以将其吃掉。注意，兔子不能移动到已经有兔子的方格中。若兔子的上下左右四块田地中有萝卜，那么它也能够吃到。Asuka为了阻止他的兔子吃萝卜，他决定用围栏将将农场中的兔子和萝卜分开。他有足够多的围栏，但是围栏只能建造在空田地中。Auska想问你他能不能将所有的兔子和萝卜都分开。如果能请输出任意一种方案。否则输出No.</p><p>Asuka有非常的多的栅栏，你可以不输出使用最少栅栏的方案。</p><p><strong>输入格式</strong></p><p>第一行两个整数x和y表示农场的行数和列数，1&lt;=x,y&lt;=5001&lt;=x,y&lt;=500。接下来是一个x*y的字符串C表示萝卜R表示兔子。而空田地表示为"."。</p><p><strong>输出格式</strong></p><p>若可以将所有兔子和围栏分开则第一行输出“Yes”接下来输出任意一种方案。栅栏用"#"表示。空田地表示为"."。 否则输出No.</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-selector-class">.C</span><span class="hljs-selector-class">.RR</span>C.<span class="hljs-selector-class">.RR</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-class">.R</span>.....</code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">Yes<span class="hljs-string">.C</span><span class="hljs-comment">#RR</span>C.<span class="hljs-comment">#RR</span><span class="hljs-string">.C</span><span class="hljs-comment">#.R</span><span class="hljs-string">..</span><span class="hljs-comment">#..</span></code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="c-我不会debug">C-我不会debug</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>cold正在进行c语言考试，他提交程序之后，老师会告诉cold他对于每个测试点的结果是正确的（P）还是错误的（F），他将会得到一个只由P和F组成的字符串。他想让你帮他调试程序，你可以花一分钟删除首个或者最后一个字母，或者花两分钟删除字符串中间任何一个字母，删除之后将剩下的两端拼接起来。现在，他想问你将该字符串变成一个只存在P的字符串需要多少时间。</p><p><strong>输入格式</strong></p><p>第一行一个整数n，表示字符串长度<spanclass="math inline">\((1&lt;=n&lt;=10^6)(1&lt;=n&lt;=10^6)\)</span></p><p>第二行一个由P和F组成的字符串。</p><p><strong>输出格式</strong></p><p>一个整数，你调试程序所需要的最小时间。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs">6FPPFPP</code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">3</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="d-我要吃饭">D-我要吃饭</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>dki在考完cet—6之后非常愤怒，表示自己啥也不会，并且这次分数大概率比上次random的还低，他准备点一顿外卖来犒劳自己。</p><p>他打开某团，有七种菜品可以选择，价格分别是7,27,41,49,63,78,108元。</p><p>dki有三张满减券，分别是：</p><p>1、当总价达到69元可减15元。</p><p>2、当总价达到89元可减30元。</p><p>3、当总价达到120元可减50元。</p><p>但是dki只能使用一张优惠券。当他先但是系统自动为他选择了最优的优惠券。例如他总过点了400元的晚餐，他总共需要付350元。</p><p>dki总共点了n个菜，每个菜的单价分别为a1,a2,a3...an。他想知道他总共需要付多少钱。</p><p><strong>输入格式</strong></p><p>本题包含多组测试样例</p><p>第一行一个整数t, 表示有t组测试样例。<spanclass="math inline">\(1&lt;=t&lt;=10^61&lt;=t&lt;=10^6\)</span></p><p>对于每组测试样例</p><p>第一行一个整数n表示总共点了n个菜<spanclass="math inline">\(1&lt;=t&lt;=10^61&lt;=t&lt;=10^6\)</span>。</p><p><strong>输出格式</strong></p><p>对于每组测试样例输出一个数字，表示dki所需要支付的总价</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><span class="hljs-number">6</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">7</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">3487807139</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="e-删删删">E-删删删</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>给你一颗有n个结点的树，你可以删除这个树上任意数量的结点，如果在树的剩余每个结点部分仍然有至少一个结点与它相连，那么我们边成这种删除方式是漂亮的。Hertz想问你总共有多少种删除方式是美丽的。由于方案可能非常多，他希望你再计算的时候对998244353取模。</p><p>如果删除的结点集合相同，那么认为是相同的方式。</p><p><strong>输入格式</strong></p><p>本题含有多组测试样例，第一行输入一个整数t，表示总共有t组测试样例。</p><p>对于每组测试样例</p><p>第一行一个整数n，1&lt;=t&lt;=10^51&lt;=t&lt;=10 5</p><p>接下来n-1行，每行两个整数 x,y <spanclass="math inline">\((1≤x,y≤n,x≠y)(1≤x,y≤n,x≠y)\)</span>。表示x和y之间有一条边。</p><p>数据保证<span class="math inline">\(∑n≤10^6∑n≤10^6\)</span></p><p><strong>输出格式</strong></p><p>共有t行每行一个整数。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span><span class="hljs-number">7</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><span class="hljs-symbol">5 </span><span class="hljs-number">2</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">37</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="f-大水题">F-大水题</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>vc++最近在玩简单的数学题，他想给你分享一道简单的数学题.</p><p>一个数等于他所有真因子之和那么我们可以称指为完美数，例如<spanclass="math inline">\(1+2+4+7+14=28\)</span>，<spanclass="math inline">\(1+2+4+8+16+31+62+124+248=496\)</span>。</p><p>vc++觉得这不好玩，所以他自己创造一个半完美数的定义，令 S 为自然数 X的所有真因子的集合。如果存在 S的子集，使得子集中的数字之和等于数字本身，则称该数字是半完美的。</p><p>显然，所有完美数都是半完美数。此外，还有一些不完美的数字，它们也属于金成的半完美数字。例如，24的真实因子集是<spanclass="math inline">\({1,2,3,4,6,8,12}\)</span>，我们可以选择一个子集<spanclass="math inline">\({2,4,6,12}\)</span>，满足<spanclass="math inline">\(24=2+4+6+12\)</span>。所以24可以称为半完美数。</p><p>vc++想知道他是否能找到一个整数 k，它是正整数 x 的倍数，使得 k是一个半完美数。</p><p>由于 vc++不擅长数学，他希望 k 不能太大<spanclass="math inline">\(（k≤2×10^{18}）（k≤2×10^18）\)</span>，并且子集的大小不大于 1000。他希望你给你选择的子集。</p><p><strong>输入格式</strong></p><p>本题含有多组测试样例，第一行输入一个整数t，表示总共有t组测试样例。<spanclass="math inline">\(1&lt;=t&lt;=40001&lt;=t&lt;=4000\)</span>.</p><p>接下来t行每行一个正整数x，$1&lt;=x&lt;=10<sup>91&lt;=x&lt;=10</sup>9$</p><p><strong>输出格式</strong></p><p>总共2t行</p><p>每组第一行输出两个正整数k和l，k为你所找到的整数<spanclass="math inline">\((k&lt;=10^{18})(k&lt;=10^18)\)</span>，l为你所选择的子集的大小<spanclass="math inline">\((l&lt;=1000)(l&lt;=1000)\)</span>。</p><p>第二行输出你所选择的子集中的所有元素。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs">2102</code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">60 </span><span class="hljs-number">3</span><span class="hljs-symbol">10 </span><span class="hljs-number">20</span> <span class="hljs-number">30</span><span class="hljs-symbol">24 </span><span class="hljs-number">4</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">12</span></code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="g-你一定会种树吧">G-你一定会种树吧</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>cyh有一个长度为n的可操作序列a1,a2,a3,.......an。现在他可以对序列进行如下操作</p><p>1、 1 l r 对区间[l,r]的所有数加上<spanclass="math inline">\(lowbit(a[i])\)</span></p><p>2、2 l r 询问区间[l,r]中的和。</p><p>cyh需要你给出每次询问值对998244353取模的结果。</p><p><strong>输入格式</strong></p><p>第一行一个整数t, 1&lt;=t&lt;=201&lt;=t&lt;=20,表示有t组测试样例。</p><p>对于每组测试样例，第一行一个整数n,1&lt;=n&lt;=10^51&lt;=n&lt;=10 5,表示序列的长度。</p><p>接下来一行有有n个整数，表示该序列。</p><p>第三行一个整数m，表示需要进行操作的数量。$(1≤m≤10<sup>5)(1≤m≤10</sup>5)$</p><p>接下来m行，每行三个正整数x, l, r.x代表操作类型，l，r代表操作的区间。<spanclass="math inline">\(1&lt;=x&lt;=2,1&lt;=l,r&lt;=n1&lt;=x&lt;=2,1&lt;=l,r&lt;=n\)</span></p><p><strong>输出格式</strong></p><p>对于每次询问输出对998244353取模的结果</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span><span class="hljs-number">5</span><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">152012</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="h-货车">H-货车</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>有nn个城市被mm条路连接，每条路都有一个最大承重能力kk，如果货车总重量pp大于kk，则货车不能通过该条路。</p><p>如果一辆货车能从城市xx一直开到yy，则称城市x,yx,y对于该货车而言是“互通的”。</p><p>现在每次询问给定一个数pp表示货车总重量，请问有多少对城市对于这辆货车是“互通的”？</p><p><strong>输入格式</strong></p><p><span class="math inline">\(T(1≤T≤10)\)</span>组样例。</p><p>每组样例第一行包含三个整数<span class="math inline">\(n,m,q(2\le n\le1e5,1\le m\le 2e5,1\le q\le2e5)n,m,q(2≤n≤1e5,1≤m≤2e5,1≤q≤2e5)\)</span>分别表示城市的数量，路的数量，以及询问的数量。</p><p>然后是mm行，每行包含三个整数<span class="math inline">\(x,y,k(1\lex,y\le n,1\le k\le1e9)x,y,k(1≤x,y≤n,1≤k≤1e9)\)</span>表示城市x,yx,y之间有一条直接相连的路，最大承重能力为kk。</p><p>最后qq行，每行一个整数<span class="math inline">\(p(1\le p\le1e9)p(1≤p≤1e9)\)</span>表示货车总重量。</p><p><strong>输出格式</strong></p><p>每组样例输出qq行，每行包含一个整数，表示询问答案。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-number">3</span><span class="hljs-number">2</span><span class="hljs-number">1</span><span class="hljs-number">4</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">310101</code></pre></div></td></tr></table><p></font></p>    </div></div><p>最开始用了个dfs，然后超时？之后才明白是（最小生成树）建边并查集，离线。</p><p>改了好久还是没调出来。</p><h2 id="i-超级打字大师">I-超级打字大师</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p>众所周知，双拼是一种非常高效的打字手段,因为使用双拼，<strong>您只需按两次键即可输入任何中文单词</strong>。<center><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">表拼音双拼拼音双拼<span class="hljs-built_in">q,</span> iuqf, enf<span class="hljs-built_in">w,</span> eiwg, engg<span class="hljs-built_in">r,</span> uanrj, anjeeh, angh<span class="hljs-built_in">t,</span> uetk, uai, ingk<span class="hljs-built_in">y,</span> unyl, uang, iangl<span class="hljs-built_in">u,</span> shuz, ouz<span class="hljs-built_in">i,</span> chix, ia, uax<span class="hljs-built_in">o,</span> uooc, aoc<span class="hljs-built_in">p,</span> iepv, zh, uivaab, inb<span class="hljs-built_in">d,</span> aidm, ianm<span class="hljs-built_in">s,</span> ong, iongsn, iaon</code></pre></div></center><p><span class="math inline">\(ColdCold\)</span>最近在研究双拼打字,现在想请你帮忙将给定的句子以双拼的方式输出。比如说, "ni hao shijie"那么你需要输出的是,"ni hc ui jp"。</p><p>Tips:</p><ul><li>对于长度为 11的拼音,为了满足双拼的语法要求,你应该输出两个相同的该字符。</li><li>对于长度为 22 的拼音,不作改动,直接输出该拼音</li><li>对于像 angang这样的拼音如果独立出现,你应该先输出他的第一个字母,然后在表-格中查找整个拼音以获得第二个键ex.("ang" 会变成"ah")。而rang则会输出rh</li><li>为简化起见，任何输入中都没有字符 vv</li></ul><p><strong>输入格式</strong></p><p>有多个测试用例。每行包含一个。数据保证测试用例个数不超过10001000个，</p><p>每一行都是由空格分隔的拼音序列。</p><p>数据保证测试用例个数不超过10001000个， 一个测试用例的拼音个数不超过500500 个，所有测试用例的拼音个数不超过 50005000 个。</p><p><strong>输出格式</strong></p><p>由空格分隔的双拼序列。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ji</span><span class="hljs-keyword"></span>zhe ti mian <span class="hljs-keyword">shen </span>me wan yi<span class="hljs-keyword">beng </span><span class="hljs-keyword">bu </span>zhu leyuan lai ni ye wan yuan <span class="hljs-keyword">shen</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs vim">ji<span class="hljs-keyword">ve</span> ti mm uf <span class="hljs-keyword">me</span> wj yibg bu <span class="hljs-keyword">vu</span> <span class="hljs-keyword">le</span>yr ld ni ye wj yr uf</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="j-简单数学">J-简单数学</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>郑老板非常喜欢数学题，今天他给了你下面一个方程。 <spanclass="math display">\[f(n) = \begin{cases} 1, &amp; n \in \{1\} \bigcup \operatorname{质数} \\p\,f(p^{k-2}), &amp; n = p^k ~ (p \in \operatorname{质数}; ~ k &gt; 1)\\ f(p_1^{e_1})\prod_{i=2}^r {p_i}^{e_i}, &amp; n = \prod_{i=1}^r {p_i}^ {e_i} ~ (p_1 &lt; p_2 &lt; \cdots &lt; p_r; ~ p_i \in\operatorname{质数}; ~ r \ge 2) \end{cases}\]</span></p><p>现在郑老板想问你<span class="math inline">\(\sum_{i=1}^nf(i)\)</span>的结果，你能告诉他吗？</p><p><strong>输入格式</strong></p><p>一行一个正整数n <span class="math inline">\((1 \le n \le {10}^{7})n(1≤n≤10^7)\)</span>.</p><p><strong>输出格式</strong></p><p>一个正整数，代表结果。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs">50</code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">370</code></pre></div></td></tr></table><h2 id="node">Node</h2><p>对于第一个样例, <span class="math inline">\(f(1) = 1f(1)=1, f(2) =1f(2)=1, f(3) = 1f(3)=1, f(4) = 2f(4)=2, f(5) = 1f(5)=1, f(6) = 3f(6)=3,f(7) = 1f(7)=1, f(8) = 2f(8)=2, f(9) = 3f(9)=3, f(10) =5f(10)=5\)</span>.</p><p>题目保证答案小于 2^{64}-12 64 −1. </font></p>    </div></div><h2 id="k-小游戏">K-小游戏</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>dqhl76最近在玩一个游戏，他会给你一个长度为n的序列，序列中的元素为ai。他需要你对序列中的元素进行n-1次合并操作，每次合并操作你可以选择序列中的了两个相邻的元素，将a[x]和a[x+1]合并成一个元素值为<spanclass="math inline">\((a[x]*a[x+1])mod1000003\)</span>并且得到<spanclass="math inline">\((a[x]-a[x+1])^2\)</span>分。你将一直持续这个游戏，知道序列只剩下一个元素为止。</p><p>现在dqhl76想问你你能获得的最大积分是多少。</p><p><strong>输入格式</strong></p><p>第一行一个整数n表示序列的长度<spanclass="math inline">\(1&lt;=n&lt;=3001&lt;=n&lt;=300\)</span></p><p>T接下来一行n个整数，<spanclass="math inline">\(a[1],a[2],a[3]....a[n]1&lt;=ai&lt;=10^61&lt;=ai&lt;=10^6\)</span></p><p><strong>输出格式</strong></p><p>一个整数，表示你能达到的最大积分。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">630</code></pre></div></td></tr></table><p></font></p>    </div></div><p>一道本应该AC的题目。</p><p>错误原因是 <code>w</code> 忘了开 LL。最重要的又看错了题，得分结果不用取 MOD ，只对 <code>a[i][j]</code>的合并结果取 MOD！！！</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    ll sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span>ll a[<span class="hljs-number">330</span>][<span class="hljs-number">330</span>];ll dp[<span class="hljs-number">330</span>][<span class="hljs-number">330</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        a[i][i]=<span class="hljs-built_in">read</span>();    &#125;    <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;         <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n-k)&#123;<span class="hljs-comment">//i - i+k</span>            <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>)&#123;                ll w=(dp[i][i+j]+dp[i+j+<span class="hljs-number">1</span>][i+k]+(a[i][i+j]-a[i+j+<span class="hljs-number">1</span>][i+k])*(a[i][i+j]-a[i+j+<span class="hljs-number">1</span>][i+k])); <span class="hljs-comment">// 错误1</span>                <span class="hljs-keyword">if</span>(dp[i][i+k]&lt;=w)&#123;                    dp[i][i+k]=w; <span class="hljs-comment">//%MOD 错误2</span>                    a[i][i+k]=(a[i][i+j]*a[i+j+<span class="hljs-number">1</span>][i+k])%<span class="hljs-number">1000003</span>;                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;dp[<span class="hljs-number">1</span>][n]; <span class="hljs-comment">//%MOD 错误2</span>&#125;</code></pre></div><h2 id="l-cold玩真人cs">L-cold玩真人cs</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>cold最近迷上了射击游戏。在游戏中cold是一名狙击手。对于cold来说他有一个射击范围。在这个范围内的敌人它可以一发毙命。而在这个范围之外的敌人他需要两发。例如cold的射击范围是[30,90]，他每一次射击都能消灭一个在这个距离范围内的敌人。而不在这个距离之中的敌人,例如位置在95那么他则需要两发子弹。</p><p>现在cold倍困在山顶，有n个敌人围住了他，cold的枪里有m发子弹，并且cold知道每个敌人离他的距离。</p><p><strong>输入格式</strong></p><p>第一行四个整数n,m,s,f。分别表示n个敌人，m发子弹，cold能对[s,f]范围内的敌人一发毙命。<spanclass="math inline">\(1≤n≤1,000,000; 1≤m≤1,000,000,000;1≤s≤f≤1,000,000,0001≤n≤1,000,000;1≤m≤1,000,000,000;1≤s≤f≤1,000,000,000\)</span></p><p>第二行n个整数，表示每个敌人距cold的距离。</p><p><strong>输出格式</strong></p><p>若cold能杀死全部的敌人则输出lzdak!否则输出cold能杀死敌人的数量。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">10</span><span class="hljs-symbol">2 </span><span class="hljs-number">9</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">lzdak!</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="m-杰哥打怪">M-杰哥打怪</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>现在森林中有 nn 个村庄，住着猎人与怪兽，有 mm条路连接这些村庄且经过每条路都需要花费时间 11 。</p><p>第ii 个村庄的怪兽的防御力为<spanclass="math inline">\(w_i\)</span>，当猎人的攻击力大于等于怪兽的防御力时，猎人能够猎杀到这个村庄的怪兽。</p><p>现在有qq次询问，每次询问包含两个整数分别为<spanclass="math inline">\(a_i,p_ia\)</span>第<spanclass="math inline">\(a_i\)</span>个村庄攻击力<spanclass="math inline">\(p_i\)</span>的猎人要去打猎（可以打自家村庄的怪兽），请问猎人最少花费多少时间能打到怪兽？</p><p>每次询问时独立的，你只需要打到一个怪兽</p><p><strong>输入格式</strong></p><p>第一行给定三个整数 <span class="math inline">\(n,m,q(1\le n,m\le1e5,1\le q\le 5e5)n,m,q(1≤n,m≤1e5,1≤q≤5e5)\)</span>分别表示村庄，路以及询问的数量。</p><p>第二行nn个整数，期中第ii个整数表示第ii个村庄怪兽的防御力为<spanclass="math inline">\(w_i(1\le w_i\le 1e2)\)</span></p><p>接下来mm行，每行包含两个整数<span class="math inline">\(u_i,v_i(1\leu_i,v_i\le n,u_i\not=v_i)\)</span> 表示村庄<spanclass="math inline">\(u_i,v_i\)</span>之间有一条路。</p><p>最后qq行，每行包含两个整数<span class="math inline">\(p_i,a_i(1\lep_i\le n,1\le a_i\le 1e2)\)</span>表示第<spanclass="math inline">\(p_i\)</span>个村庄攻击力为<spanclass="math inline">\(a_i\)</span>的猎人要去打怪兽。</p><p><strong>输出格式</strong></p><p>每组样例输出qq行，每行包含一个整数，表示询问答案。如果无法打到怪兽则输出-1</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs diff">0111<span class="hljs-deletion">-1</span></code></pre></div></td></tr></table><p></font></p>    </div></div><p>一道简单的 BFS ，但是没来得及了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年鉴 - 山河</title>
      <link href="/2021/12/31/11%E5%B9%B4%E6%8A%A5/"/>
      <url>/2021/12/31/11%E5%B9%B4%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="note note-primary">update: 2021-12 28.22:00 29.15:18 29.2:08 30.20:17 31.13:19 31.20:46</p><blockquote><p>从往昔雪冬到来年腊月，黄梅落满枝头，却似换了人间。</p></blockquote><blockquote><p>山河已故，游子安在哉？</p></blockquote><p>这是一个新的尝试，第一次写这种文体，但一切的开拓都来源于尝试，所以我也愿意以这种形式，记录下这一春秋，与忘不掉的2021年。<br />无论是时代还是个人，这都是风云变幻的一年。</p><p><br>         <div id="aplayer-IHcuykrf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"纸短情长","author":"空雨233","url":"http://music.163.com/song/media/outer/url?id=574381147.mp3","pic":"http://p2.music.126.net/dGhz5kbOZ8Uzeg1xFOeseg==/109951163364571995.jpg","lrc":""},{"title":"蚍蜉","author":"花粥","url":"http://music.163.com/song/media/outer/url?id=1465288939.mp3","pic":"http://p1.music.126.net/9zwep-NZlopJz0JL8IOkpg==/109951165165628584.jpg","lrc":""},{"title":"岁月神偷","author":"金玟岐","url":"http://music.163.com/song/media/outer/url?id=28285910.mp3","pic":"http://p2.music.126.net/gWNsPDBbQCQXVNvMdnAH8A==/18815942487303143.jpg","lrc":""},{"title":"伶仃谣","author":"河图","url":"http://music.163.com/song/media/outer/url?id=101120.mp3","pic":"http://p2.music.126.net/Jcv5rY1Pq6u9dPrPZYH0lQ==/58274116284443.jpg","lrc":""},{"title":"光亮","author":"周深","url":"http://music.163.com/song/media/outer/url?id=1892532629.mp3","pic":"http://p1.music.126.net/WxJ-SLlhxAxzoBNFI8t-lQ==/109951166589320177.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-IHcuykrf");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script></p><hr /><h1 id="学习生活">1 学习/生活</h1><blockquote><p>这是人生的主曲，万事的根基</p></blockquote><h2 id="学业">1.1 学业</h2><p>在这一年里，我跨越了高中和大学的距离，也跨过了传统的义务教育阶段。告别一段记忆，一阶段的学习，迈入大学的大门，开始新的旅程。从公顷到千亩的土地，这是张度的变化；从百米到千米，这是距离的纵深；从五楼到数十层，这是高度；从百里到千里，这是漫天星火。大学，是新的场景，是新学业的起点，这是一个平台，他不指导你成功，但助推你前行。</p><h2 id="学习方式">1.2 学习方式</h2><p>在这一年，翻越人生中的重要山峰——高考，高考落幕，意味着告别传统授课形势的转型——从传统授课走向自主性学习。在这里，你不能要求老师教会你；在这里，没有固定陪伴你的友人；在这里，没有人来推动你前行；在这里，你才是自己的领路人，行走在深山巨谷里——大家结伴前行是看相相互能力，山顶者的教诲是看见过去的自己——当然，这里也有旅者之间的情谊，有指引者的温暖。</p><blockquote><p>高山仰止的背后，是无限的努力，天纵奇才，亦有成仲永之时。</p></blockquote><p>在初入大学时，我仅仅是完成作业、上课听讲、来不及预习也不会复习。我做着我曾经不怎么会做的事情，缺丢掉了我过去的优势。自诩接受新知识能力强，堆积到最后亦难以精通。在高中，我的学习主要是靠自己：上课做作业、看自己的书，晚自习做题和研究知识的本质，我用我从不自信的记忆能力，熟练的记忆理解了数学物理等公式，与此同时也带来了我对此的长期记忆——与大多数人在不学习后丢掉知识相反的：不容易忘记的记忆。我的知识是相通、成体系、可互推的，所以部分的遗忘可以重新推导出来，这也造就了我高中的弧形成绩曲线：开学即巅峰，然后下滑，最后几次考试排名再上升。所以我不理解那些说曾经学的，就忘了的人。也希望我不会成为这样的人。</p><p>大学的转机是半期考试前一个月：为了面临的数学建模比赛，从0开始，实现了两周过完清风数学建模视频的奇迹，这让我开始养成了长时间在外自习的习惯，在半期考试前一周，我在刷完当天的现代与高数题后再看数学建模论文——让看论文成为我刷完题的动力，(刷起来确实挺快的)。经历了“昏天黑地”的亚太杯（中间穿插了一个早上的半期考试），到“独自完成”新秀杯（整个期间还有ACM月赛和新秀杯）——自习的习惯从此养成，直到现在。从三教到图书馆，从第一次发清晨/夜晚的朋友圈到成为常态，用了半学期，一湾湖水见证了我学习方式的转变。</p><h2 id="生活状态环境">1.3 生活状态/环境</h2><p>熟悉了大学的食堂、宿舍、教学楼生活；学会了教学楼自习桌的使用；习惯了图书馆的进出预约。每周事件基本确定，吃饭地点时间基本固定，养成了记账和日记安排的习惯，淡化了ToDo计划清单习惯。手机使用量、重要性下滑，电脑成为了主要生产工具和学习工具。玩游戏行为全部抹除，把不怎么玩游戏变成了不玩游戏。</p><p>刚开始是和室友一起行动，熟悉了一切后，便尽量自己行动。身边没有友人，便仅能踽踽独行；若没有独立能力，又谈何友人。花了长时间的添置整理物件——我的寝室里面的桌子布置终于基本完备，所有相关生活用品也一一归位。同时，习惯了自己洗衣服，虽有洗衣间但基本没用过，保持了基本的生活整洁，冬天每天泡脚的习惯。</p><blockquote><p>熟知了一切，便无需他人伴行；孤独的灵魂，必将走向自己的远方。</p></blockquote><p>走出了自己的路，找到了生活方式和节奏，不为闲人所左右，寒假降临，亦希望来年能继续保持。</p><h2 id="学习进度规划">1.4 学习进度/规划</h2><h3 id="学科">1.4.1 学科</h3><p>今年学习的新知识有：(以重要/圆满/满意排序)</p><ol type="1"><li>高等数学I</li><li>线性代数B</li><li>数学建模(自学)</li><li>程序设计(大部分竞赛都学过)</li></ol><h3 id="软件语言">1.4.2 软件/语言</h3><p>今年学习的新技能有：(以满意度排序)</p><ol type="1"><li>学会了Latex的使用，能独立查阅解决问题，并写出完整（数学建模）论文</li><li>学会了部分Matlab</li><li>补充了C++部分遗漏知识</li></ol><h3 id="规划">1.4.3 规划</h3><p>计划学习的新知识和技能。</p><h4 id="编程语言">1.4.3.1 编程语言</h4><h5 id="必学">必学</h5><ol type="1"><li>Matlab，至少把大书学完，能独立完成大的程序</li><li>Python，打算学很久了，但一直没有成果</li></ol><h5 id="候学">候学</h5><ol type="1"><li>Java</li><li>Javascript</li><li>HTML/css</li></ol><h4 id="课内知识点">1.4.3.2 课内知识点</h4><p>(以优先级排序)</p><ol type="1"><li>高等数学II</li><li>大学物理</li><li>概率论与数理统计</li><li>离散数学/拓扑学</li><li>运筹学</li></ol><h4 id="竞赛知识点">1.4.3.3 竞赛知识点</h4><h5 id="编程比赛">编程比赛</h5><ul><li>对学过的算法/数据结构的复习和写代码，不能只会理解不会写</li><li>对没有学的算法/数据结构学习和补遗</li><li>因为很多考题不考模板，所以要做更多题型</li></ul><p>走上这条路，就放不了手，最初的梦，还是要流淌下去……</p><h5 id="数学建模">数学建模</h5><ul><li>Matlab的学习</li><li>清风基础数学模型的复习和重要模型的加深</li><li>学习更多的模型，尽量走出C题的模型</li></ul><p>接触的一个新的方向……能解决问题，得到结果的事情还是吸引我呀。</p><h2 id="与集体的关系">1.5 与集体的关系</h2><blockquote><p>万家灯火，却没盏灯留我。——《茫》</p></blockquote><h3 id="大学所在的各个集体">1.5.1 大学所在的各个集体</h3><p><del>因为能力，</del>大概就是说了我高中有策划节目制作背景/海报的经历和一些竞赛经历。于是，我的面试通过率是100%（办公室通过率可是很低的），因为申请的组织的较多，导致了加入的组织太多了，不过也没有哪个组织让我后悔吧……只不过我只能优先满足一些。<del>（另外我给很多部门的印象莫名很强）</del></p><h4 id="大学本班">1.5.1.1 大学本班</h4><p>大学的班级算是很小的班级了，一个班只有20余人。但，这并不是真正意义上的传统班集体，更像是学院的一个管理单元……在这个班，没有归属感也没有集体组织力，所以这也并不是我在意的群体。</p><h4 id="数学建模-办公室">1.5.1.2 数学建模-办公室</h4><p>这算是大家相互之间最熟悉的一个群体了，（比较有意思的一个这样的集体大家是否熟悉很有巧合性，有人员、组织性质、活动、QQ群氛围等因素），加入这个集体算是是本学期做的最正确的事情之一了。此外，这个集体背后是数学建模比赛和背靠数学建模协会，有幸能认识许多共事的友人，也能接触到各个专业首位之人，还有引路的学长……（让我了解“学霸”们在干什么，<del>然后卷起来</del>）。一个开学前就瞄准好了的组织。</p><h4 id="acm">1.5.1.3 ACM</h4><p>其实本是ACM协会外联部的一员，但是部门着实没有什么存在感。在这里，主要是参加举办的比赛——已经被内定<del>为校队成员</del>了，在这里可以找到编程的队友们，也有可爱的学长（听说我们已经被研究透了<del>可怕</del>）</p><h4 id="惟悦工作室">1.5.1.4 惟悦工作室</h4><p>我的另外一个重要社团，主要内容是每周开会和制作图书馆公众号推文。主要是它给了我与图书馆的一个链接——我是图书馆管理成员的一员，这也是我能养成到图书馆的习惯的动力，来自对图书馆的归属感？除此之外它提供了一个可以使用的自习室，只是有时候（特别是考试周）有学姐在就不好去。这也是我开学前就瞄准好了的组织。</p><h4 id="云运-视觉部">1.5.1.5 云运-视觉部</h4><p>因为事情多，逃了很多培训的组织（然后被…了），不过大多数活动还是参加了，有一群有意思的学姐~不过下学期开始有事情了。</p><h4 id="学院团委-青宣部">1.5.1.6 学院团委-青宣部</h4><p>最开始给我提供了Ps、（Pr、Ae）培训的组织，让我成功至少能使用这些软件了（虽然我有基础），也算是收获了有用的技能，这个组织女生较多……这个被我开学前瞄准好的组织，不好不坏吧。</p><hr /><h1 id="成长改变">2 成长/改变</h1><blockquote><p>什么是成长？或许只不过是推翻昨日…</p></blockquote><h2 id="责任压力">2.1 责任/压力</h2><p>在今年，我迈上了十八岁，成为了一位有完整权力的成年人；在这一年，我跨出了义务教育，开始走向高等教育；在这一年里，我走入社会，接触浮尘。我拥有了更多的选择权、决策权，与此相对我有了更多的压力——无论是生活的压力、社会的压力、还是学业的压力都如潮水涌来。我的成长，意味着父母的衰老，意味着年岁象限的后移，意味着我将要接过更多的家庭的担子。金钱成为不得不考虑的事情、就业方向与前进也成为关注的趋势，在混沌中浮沉，逝去的梦想与年少将成为永恒的回忆？真的要这样吗？</p><h2 id="性格">2.2 性格</h2><p>从古风的“翩翩公子”、好奇与兴趣驱使的、追求多元化与创造力的少年，到渐渐有条理、目光更加专一、眼神逐渐凉意的一袭黑衣，反复只在梨花开遍一夜间。从<code>INTP</code>慢慢靠近<code>INTJ</code>其间都经历了些什么？是因为碎玉后的心凉还是无边夜幕下的压力？当你步伐渐稳、表达愈清晰，是否仍记昔日，是否心怀少年？</p><blockquote><p>你说，我又是否该恭喜你，弥补了曾经的缺陷，送去了当年的圆月。</p></blockquote><p>你最终还是无法如旧。你背弃了过去？</p><h2 id="追求">2.3 追求</h2><blockquote><p>追求个人意义与自我实现的最大化。</p></blockquote><p>这是一个新的定义。并不是追求个人利益的最大化，一切的根本追求的都是意义。我追求将脑海中的构思付诸于现实；我寻求创新与创意；我追寻我的兴趣与研究事物的本质。这些都是自我实现的体现，同时也是对个人意义的体现，个人意义包含了自我的满足感，创造的价值感，同时也包含对社会的贡献。</p><h2 id="自信">2.4 自信</h2><p>请问，风倾失去自信了吗？</p><p>答案是，是的。是的，在进入大学以来的，我的学习能力收到了我自己的怀疑，两次高数的小测，我都有不会写的情况出现，我渐渐怀疑起了我的“快速理解接受使用新知识”的能力。此外曾经在学习上的优势感，也受到了挑战，同时“卷”字，进入了大家的常用话语。卷字，似乎有那么一点“勤能补拙”的感觉，我不认为自己“拙”，所以我认为“卷”也没有包含这个意思，它代表的是勤奋、是追寻自己梦想的行动、是实现自我价值的必需品。</p><h2 id="人际关系">2.5 人际关系</h2><p>如1.5所诉，大多数集体是没有集体感的。冷漠，是我在大学里，对待大部分熟人和陌生人的第一印象。我对友人以外的人不会打招呼，基本没有与班上的除寝室外的其他说过话。寝室的关系也很微妙，我并不喜欢这个寝室。对外，在非本专业倒是结实了不少友人。</p><p>路人们与我并没有瓜葛，走好自己的路，犬吠声也就随他去了~</p><hr /><h1 id="过客友人">3 过客/友人</h1><h2 id="熟人">3.1 熟人</h2><p>在这一年里，来来往往皆是路人，熙熙攘攘皆为过客，大千世界扑面而来，无数匆匆路过身边的，有一眼之缘的——皆为熟人。</p><p>这便是我我对于熟人的定义。没来得及走入生活的人，点头之交的人，又或是是偶然同处于一个环境下一个集体中而认识的人——一切未曾走进而又认识过的人，就是熟人。这个一个很大范围的划分，意味着我与他们并没有形成联系，这是友人的滤过器，或许这也是是我冷血与生性凉薄的证明——我并不在意，过客的评价于我，并不入眼。这也是我的界限，我交往的边界，宁缺毋滥，毕竟真正能同行的人，又有几何？所有的利益、勾心、应酬，都在这里面，而我的心——还是留给心中之人吧。</p><blockquote><p>身后灯火万千，均无归处。</p></blockquote><h2 id="同行者">3.2 同行者</h2><p>无论是集体中，还是比赛中，还是能遇到一群有着相似目标，有着相似经历，又或是有着相同话语的一群人。与这群人的相处，没有压力——这便是“同行者”。</p><h2 id="挚友">3.3 挚友</h2><p>挚友唯两人而已，比较有意思的是，最终的相知都在时间段的后半部分——初中的后半部分、高中的后半部分（小学亦是如此，但已迷途中路，故不做联系），关于对他们的描述我并不想写在这里，人物传记/岁月路会有一席之地。</p><h2 id="碎珩">3.4 碎珩</h2><blockquote><p>相逢一场，恍若昨昔。今朝玉散，哭不成泣。</p></blockquote><p>关于与她的一切，部分有日记/随笔记载，亦有书信支撑（部分文笔因为手机更换而吞没在了数据里，再也找不到了）。过去可能永远不会相信，一个人是如何填满你的心。</p><blockquote><p>有了她，就像忽然有了软肋，也有了铠甲。</p></blockquote><p>而，心空了又是什么样的感受？人们总是深刻的记着残缺的事情……</p><p>在此不愿落笔，将来必会重叙。</p><blockquote><p>而她，走入过你的生活，留下了无数的痕迹。在那个春夏之际呀，成为永恒的回忆；至于她，永远的停留在了那一瞬间……</p></blockquote><hr /><h1 id="部分app年报数据">4 部分app年报数据</h1><h2 id="知乎">4.1 知乎</h2><ul><li>我的看世界视角为45°，严谨、理性、沉稳</li><li>2021年在知乎浏览了18113个问题，26468个回答，超过99.99%的知友<br />即平均每天浏览49.6个问题，72.5个回答</li><li>今年常常在早晨来到知乎</li><li>最感兴趣的领域【社科】【工程学】【科技】</li></ul><p>真是夸张的浏览量，也证明了知乎是我今年第一大内容浏览平台。对于工程系，我倒是没有相关印象。</p><h2 id="网易云qq音乐">4.2 网易云/QQ音乐</h2><ul><li>我的音乐灵魂是83岁，“灵魂深藏东方神秘力量”</li><li>年度歌词中【少年】出现194次</li><li>有5天在24:00以后听歌，11月05号在3:06还在听《思君难见》</li><li>年度歌单：伶仃谣33次、白衣7次</li><li>日本流行35%、轻音乐29%、中国音乐18%</li><li>与【竹箫竹】共享160个小时的音乐</li></ul><p>因为听歌过少，和很大量的歌曲在电脑Listen1收听，所以数据样本很小，不太准确。</p><h2 id="qq">4.3 QQ</h2><ul><li>年度热聊好友：Hikari、长苏、树叶、元熹</li><li>好友数量：2019年145个、2020年108个、2021年176个</li></ul><p>看见了别人的qq好友都是200起步，300、400+的也很正常，不经感慨。<br />也许只有我的qq好友数才会下降吧。</p><hr /><p>因为时间关系，（主要因为没有灵感）未能详尽，完整的完成这篇年鉴，便在此寥寥的结束了。</p><p>“颠覆的2021”既指这个时代——中美对抗、疫情反复、大政策的出台（双减等）等国际国内的风云变幻，亦指我的18岁这一年，无论是这一年的成长，还是这一年的经历，都是今生为今的最高点，将深刻影响我的未来以及我的过去。</p><blockquote><p>年与岁去，日与时驰。愿君无望当日，愿君还记少年，愿君未来可期。</p></blockquote><p>祝读至此者，扶摇青云。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 年报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2021/12/18/test/"/>
      <url>/2021/12/18/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><code>阿哲</code></p><p class="note note-primary">标签</p><p><span class="label label-primary">Label</span></p><hr />        <div id="aplayer-KesVIdcm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"蚍蜉","author":"花粥","url":"http://music.163.com/song/media/outer/url?id=1465288939.mp3","pic":"http://p1.music.126.net/9zwep-NZlopJz0JL8IOkpg==/109951165165628584.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-KesVIdcm");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><div id="aplayer-NBjKBjYX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><div class="hljs code-wrapper"><pre class="aplayer-lrc-content">[00:00.000] 风倾客栈</pre></div></div><script>var ap = new APlayer({element: document.getElementById("aplayer-NBjKBjYX"),narrow: false,autoplay: true,showlrc: 2,music: {title: "蚍蜉",author: "花粥",url: "http://music.163.com/song/media/outer/url?id=1465288939.mp3",pic: "http://p1.music.126.net/9zwep-NZlopJz0JL8IOkpg==/109951165165628584.jpg",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script>        <div id="aplayer-CbIaXCQK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <div class="hljs code-wrapper"><pre class="aplayer-lrc-content"></pre></div>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CbIaXCQK"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "With You",              author: "Cashew",              url: "https://music.163.com/song/media/outer/url?id=1836016368",              pic: "http://p2.music.126.net/5pjHUmGogDt3ODMtdRkpCA==/109951165875491071.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-mtiREdhE" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <div class="hljs code-wrapper"><pre class="aplayer-lrc-content"></pre></div>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-mtiREdhE"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "いつも何度でも",              author: "宗次郎 / 白鳥英美子",              url: "https://music.163.com/song/media/outer/url?id=4904688",              pic: "http://p1.music.126.net/OLR8pDUR87SV2mXR7YfZuQ==/683896232488507.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-fgiyhMSs" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <div class="hljs code-wrapper"><pre class="aplayer-lrc-content"></pre></div>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-fgiyhMSs"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "天使的翅膀",              author: "安琥",              url: "https://m801.music.126.net/20190807163909f479a88358835505df7bbe1357488869/jdyyaac/065d/555a/5359/1784a40f89b0c54e7b4ad3ed1592c313.m4a",              pic: "https://p1.music.126.net/TUGO1gz0hq_f00o4DN0ocg==/80264348833252.jpg?param=34y34",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>    <div id="aplayer-qhuXfYun" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="7119348534" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#333030" data-order="random"    ></div><p>test<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="参考资料1">[1]</span></a></sup></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        带 空 格的标题    </div>    <div class='spoiler-content'>        <p>内容</p>    </div></div><p><span class="math display">\[ \LaTeX{} \]</span></p><p><span class="math display">\[\int_{}^{}secxdx=\int_{}^{}\frac{dx}{cosx}=ln\left|secx+tanx\right|+C\]</span> <span class="math display">\[\int_{}^{}secxdx=\int_{}^{}\frac{dx}{cosx}=ln\left|secx+tanx\right|+C\]</span></p><figure><img src="fig.png" alt="fig" /><figcaption aria-hidden="true">fig</figcaption></figure>            <input type="checkbox" disabled checked="checked">text          <div>            <input type="checkbox" disabled >text          </div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a;    cin&gt;&gt;a;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料1<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花园</title>
      <link href="/2021/12/16/9%E8%8A%B1%E5%9B%AD/"/>
      <url>/2021/12/16/9%E8%8A%B1%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我的故事里，有一座金色的花园，它不太大，却也撑起了年少的天空。<span id="more"></span></p></blockquote><h2 id="小园记">小园记</h2><p>从小家人就告诉我，花坛很脏，我可不听——因为那可是我自己的家园。</p><p>从我记事开始，那座花坛就在那里，仿佛，也一直应该在那里。在我家楼下，是一个被三面楼房和一堵墙包围的大院子，而正中央椭圆形的绿化空间就是这座花坛，在这个花坛中，有种植的几颗树木，四座假山，几株花草和一些我不曾认识的灌木类植物。</p><p>大片大片的杂草总是随着季节的更替变换着不同的绿色，构成了花坛的主色调。与此同时新的杂草会挤占旧杂草的生存空间，杂草的演替伴随着我的年岁的长大不断更替着——直到我离开这片土地。</p><p>我依然记得，在假山与灌木形成的空间中与那时的玩伴搭建的基地——对纸条进行一点点修剪，再在潮湿的泥土上铺上报纸，这便是一切，噢，还有木棍和砖块做一点简单的“家具”。我们还在林间的空地设置捕鸟笼；在斜坡上挖掘坡道形成灌溉线路；在假山边挖坑添水移栽花草制作风景点；在大“路”中间做出完美不会被看穿的陷阱……这哪是是花坛，这分明就是一大片树林、一大片田野、还有远山下的烟雨小镇。这是我们的土地，这片土地上空是我们的蓝天。</p><p>我用儿时的脚掌丈量了整片土地，为土地，不厌其烦绘制了许多地图，地图上标识了各个地方出产的“矿物”，果实，物种。颇有执掌天下之感。但，随着绘制精度的增加，我与花园日渐生疏，我不在知道一些植物是什么时候长出来的，也不在清楚假山的矿物是否还充足。我仅记得，捕鸟笼下的米饭未有鸟儿光顾；完美的陷阱不小心被自己踩中。那些因为“爬山”被打，蚂蚁换了多少代的往事都已经褪去。</p><p>这片孕育了少年梦的花园，依然还是在那里，但似乎也早已不在了。这花园中的我已经逝去，失去了我的花园亦已破碎，岁月变迁，花园新的时代不属于我，花园的旧花草还认识多少个？</p><p>想必没有花草还认识我了吧。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 岁月录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 光点 </tag>
            
            <tag> 散文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题更换</title>
      <link href="/2021/12/14/8/"/>
      <url>/2021/12/14/8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为难以忍受的文章渲染问题，和难以修改的字号配文章宽度，终于还是换了个主题。还是纪念一下曾经的主页吧……</p><figure><img src="https://s3.bmp.ovh/imgs/2021/12/6b01bef3fe214858.png"alt="曾经的主页" /><figcaption aria-hidden="true">曾经的主页</figcaption></figure><p>新的主题配件很多，设置很全面，很多就不用去翻找修改底层代码了√</p><p>另外配上上次的插件，很多东西就可以正常显示了，（虽然一些标识符还是显示不了）</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近日小结</title>
      <link href="/2021/12/06/6/"/>
      <url>/2021/12/06/6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font face="宋体"><br />嘿，你好啊！:cat:<br />现在是7：16，或者你也可以当作半夜，很黑很黑的那种<br />毕竟现在是冬天，太阳出来还早呢，<br />嗯，没错，今天算是我人生中第一个不眠之夜了——应该说是通宵<br />通宵是为什么呢，想想最近发生了什么<br />没错！今天是新秀杯的最后一个早餐，<br />而我，终于在临近到早晨时<br />完成了论文——我已经下不了手了<br />对了，我今天终于吃了一次早餐， 那家包子店真好吃 </font></p><hr /><p><font face="宋体"><br />今天，是竞赛周的最后一天，或许应该叫“竞赛双周”<br />嗯，这两周全是竞赛：亚太杯、ACM新秀杯、数学建模新秀杯、CSP认证<br />或许这个月都可以算在内！<br />今天的开始，意味着，对于我来说——竞赛周的结束<br />但是，也意为这“考试周”的到来，因为比赛，我蹉跎了很多学习<br />我有好多好多的要再学一次<br />英语四级、期末考试都在路上<br />所以，从今天开始<br />应该有比半期考试前一周更应该投入的状态 </font></p><hr /><p><font face="宋体"><br />你知道的，我还是想说这次数学建模新秀杯<br />我再也不想遇到这样的队友了<br />我一个人承担了建模、编程、排版、和部分写作<br />这个写作是迫不得已的<br />他们完全不会写——而我也不是专业这方面的<br />悲剧的开始在第一天<br />第一天，我让他们先说想法就被说凭什么我给他们布置任务<br />之后，就是漫长的写代码——对于我，<br />而本来属于我们亚太杯的桌子，成了我的，然后就成了我们的<br />然后，就有了我写代码，有人在对面看线性代数<br />还有一个要来就只能很晚才能来<br />说实话，真的很生气<br />对于这两个没有认真对待这个事情的人<br />对于这两个不愿意去学习不懂的事物的人<br />气愤<br />在我愤愤不平的时候效率会大打折扣<br />但是我又能怎么办呢？<br />对于这些即将不再是队友的队友<br />我觉得我不会再和他们交流<br />倾，不是这样用的<br />因为没有风<br />只有一片死寂<br />哦对，我搬回去了<br />那个地方我很长时间应该不会去了 </font></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近日小结</title>
      <link href="/2021/11/30/5/"/>
      <url>/2021/11/30/5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font face="宋体"><br />昨天呐，结束了为期四天的亚太杯。真的很累啊，有两个晚上熬夜到了凌晨四点多。而且是在比赛后很长时间都没调整回来状态——那是什么样的？那是长时间高度维持紧张和尽量维持专注的感觉。嗯，是的，这样的感觉能够帮助我们获得紧迫感的压力带来的效率以及长时间的投入——那确实是长时间的投入。<br />四天来说，时间很紧张，任务量也挺大的。而且最画时间的是：找数据、建模、写和排版论文。找论文的坎坷是未曾设想的，而中国的互联网和数据管理……也是让人很难受。<br />不过好歹是大家都竭尽全力的完成了，算是得到了一个尽力的结果，这样的经历本身的价值就很能让我回味了，而且在比赛中我的各项能力也有明显提升。总的来说：很累，但很值得。</font></p><hr /><p><font face="宋体"><br />其实不止于此，在准备比赛和比赛期间还经历了半期考试、舞台剧拍摄的事情，时间很紧张也很充实。我愈发感到了时间的压力——我已经很久没有嫌下来了——大概是从原半期考试的前三周开始，我开始学习数学建模的基本模型；在原半期考试前后，搭建了这个blog和看论文，再到真的半期考试（也就是上周末）的前一周的每天刷、看历年半期考试题目；然后便是这次亚太杯和现在的新秀杯；眼看快来的还有编程新秀杯和CSP，时间重合度高、没有把握的英语四级、期末考试也即将来临——然后才是假期。<br />看到这里也可以看见未来很长一段时间也是充盈的，我还要找到更好的生活状态，千万不能像昨天那样了。昨天理发的一点点按摩好像是缓解了我高度集中的注意力的主要原因。<br /></font></p><hr /><p><font face="宋体"><br />新秀杯的队友相对于亚太杯队友差太多了，挺失望的，也挺后悔。这个比赛我可能要一个人做完了……而且题目题型区别很大，题量很小，但方法很重要，找不到方法就结果都没有。<br />另外，因为很多事情，我的正课落下了很多，还一直没有很好的时间去补和复习预习……<br />得找个出路…… </font></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>霜行</title>
      <link href="/2021/11/24/4/"/>
      <url>/2021/11/24/4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font face="宋体"><br />无数的心之所向<br />无论是忘没忘，还是忘不掉<br />潜意识的一直存在<br />在各种场合耦合的一瞬间的回忆<br />哦，不是回忆<br />是一种生自心尖的难言之感<br />它在告诉我，有的人曾经来过<br />它体会了温情的充盈<br />也感受了剥心抽骨之痛<br />也不对<br />那是慢慢的流逝<br />是留不住的寒霜<br />是留不下的泪行<br />留下的<br />满院清风<br />满盘萧瑟<br />勾起感想之时<br />是谁在瑟瑟中消逝<br />万般落幕之后<br />是谁往身体塞漫寒霜 </font></p><hr /><p>这里面省略很多字，但这些字都指向一个字<br />不知，"字"在何方<br />是否会一如过往</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新小记</title>
      <link href="/2021/11/20/3/"/>
      <url>/2021/11/20/3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对于<ahref="http://valine.js.org/"><font color = red >Valine</font></a>评论插件做出了以下调整：<font face = "宋体" size =3></p><ol type="1"><li>移除了被放弃的设置遗留代码</li><li>增加了大部分可用设置</li><li>改变了表情包（以后将继续调整）</li><li>拉取QQ头像（未证实）</li><li>强制拉取<ahref="http://cn.gravatar.com/"><font color = red >Gravatar</font></a>最新头像</li><li>更改默认头像为随机小机器人<br /><font size=1 color = #9f9f9f face = "宋体"> updata on 11.20</font></li></ol><p></font></p><p>更改了文章的标题背景略缩图: <font face = "宋体" size =3> -略缩图素材来源于网络，经<font color = red >PhotoShop</font>处理得到 -源文件已被不小心删除，只留下一个最高压缩版的<font color = red >jpg</font>，导致所有细节丢失和细小文字被抹除<br /><font size=1 color = #9f9f9f face = "宋体"> updata on 11.19</font></p><p></font></p><p><strong>此外：</strong><br />发现本博客内置的<font color = red >MarkDown</font>渲染有非常大的问题，博客端的文本显示是和本地编辑/在线网站预览不同的。代码渲染还没有实装，目前暂无解决办法。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规划小记</title>
      <link href="/2021/11/19/2/"/>
      <url>/2021/11/19/2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>昨天和今天一直在反复看这个博客主题的底层代码以及注释了解各个属性变量的作用。因为是用的别人的主题模板，还是想着把这个主题个人化……</p><p>一直在装修这个小博客，很多地方还是不够满意，这个还得慢慢调整。昨天的主要调整是把评论功能加上了以及成功去除了<spanclass="math inline">\(bug\)</span>，想来以后面对的肯定是很多，只是不要把网站弄坏了就好……</p><p>毕竟一直在看<code>HTML</code>和<code>css</code>的代码，进步还是很大的，确实标记语言比编程语言好理解些……但是看<code>css</code>的很多东西还是一片茫然（白茫茫的一片）。</p><h5id="对于分类我想要分为如下几个categories">对于分类，我想要分为如下几个<spanclass="math inline">\(categories\)</span>：<font face = "宋体" size =3></h5><ul><li><font color = pansy ><kbd>动态</font>：包括随笔、日志在内</li><li><font color = pansy ><kbd>算法</font>：各种语言的算法都可以投放</li><li><font color = pansy ><kbd>数据结构</font>：同上，各语言写的数据结构</li><li><font color = pansy ><kbd>数学模型</font>：这个主要是面对数学建模的<br />……</font></li></ul><h5id="对于标签目前的有一下">对于标签,目前的有一下：<font face = "宋体" size =3></h5><ul><li><kbd> 随笔 </kbd>：所有包含日常/吐槽/情感等的文字都可以打上这个标签</li><li><kbd> 日志 </kbd> 所有关于对博客的规划/调整等等</li><li><kbd> 算法大类 </kbd>：如 <kbd> 二分答案 </kbd> <kbd>模拟退火 </kbd><kbd>快速排序 </kbd> <kbd>A*寻路</kbd>在内的非启发类或启发类（智能）算法</li><li><kbd> 语言大类 </kbd>：如<kbd>C++ </kbd> <kbd>Matlab </kbd><kbd>Python </kbd> <kbd>Latex </kbd>等等标记或非标记语言</li><li><kbd> 模型大类 </kbd>：如 <kbd>灰色预测 </kbd> <kbd>聚类模型 </kbd><kbd>多元回归分析 </kbd> <kbd>奇异值分解SVG </kbd>等模型</li><li><kbd> 结构大类 </kbd>：如<kbd>平衡树 </kbd> <kbd>支配树 </kbd><kbd>树链剖分 </kbd> <kbd>支配树 </kbd> <kbd>左偏树 </kbd>等结构<br />……</font></li></ul><p>但是这样的分类和标记其实有很多问题，很多属于两者之间的很难判断应该属于什么，比如很多数学模型倾向与算法、很多日志和随笔分不开等等…这种情况一直是让我头疼的问题——而且生活中在很多地方都有这样的问题。</p><p>与此同时，<code><spanclass="math inline">\(MarkDown\)</span></code>的标记语法我也忘了很多了，现在要慢慢的学习和回忆。比如以下对于关系:<code><spanclass="math inline">\(Markdown\)</span></code>中支持基本的<code><spanclass="math inline">\(HTMl\)</span></code>语法 <div class="hljs code-wrapper"><pre><code class="hljs md"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span></span></code></pre></div> <code><kbd> A </kbd> | <b> A </b> | <i> A </i> | <em> A </em> | <sup> A </sup>| <sub> A </sub> | <code> A </code> </code> <br><br>另外，不能在花太多时间在这个上了，我还有很多其他的东西要准备……</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>故事的开始</title>
      <link href="/2021/11/17/1/"/>
      <url>/2021/11/17/1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="hello-world">Hello World</h1><p>这里是本站的第一篇网站<br />也是这个博客的开始</p><p>在这里想把岁月留住<br />埋下旧人之花，铭刻少年之梦</p><p>搭建这个博客遇到了不少困难，也绕过了不少弯路，磕磕绊绊走到这<br />还得感谢友人的帮助和陪伴<br />也算是完成了曾经的心愿——搭建个人网站</p><p>虽然这个小小的平台还是使用的别人的模板、别人的代码<br />但一路走来，我们都成长了，不是吗———<br />所谓，“井底之蛙不知大海宽广，却知晓天空之蓝”<br />毕竟，在故乡的明月下，谁的身影不是被渐渐拉长</p><p>哈哈，原谅我使用了这个动漫中的句子，放在这显得似乎也不是那么恰当<br />但是，你应该是明白我的意思的，<br />想必一百个哈姆雷特中也总会有我一个</p><p>还是说回来吧<br />这个博客的主要使命是「记录」——<br />由此发散<br />包括笔记、随笔在内的许多东西…<br />哦对，还想认识一些远方的人<br />不必相知，嗯，暂且就称为「过客」吧</p><p>所以，<br />来到这里的过客呀，<br />祝你幸福</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 动态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迎泽</title>
      <link href="/2020/11/25/10%E8%BF%8E%E6%B3%BD/"/>
      <url>/2020/11/25/10%E8%BF%8E%E6%B3%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>那秋夜中的湖水，永远的留在了那里，直到再也找不到它的影子…<span id="more"></span></p></blockquote><h2 id="迎泽影">迎泽影</h2><p>我梦见迎泽许多次，却仅到了一次。而那一次，便足以使我回味至今。</p><p>那是在国庆，我急于在北方这个略显萧瑟的城市寻找一个安心之所。萧瑟的不是这个城市，而是心；安心之所不是住处，而是寻找自己。毕竟，一个人同一群人，在陌生的城市里，在不习惯的空气中，显得格格不入。</p><p>那正是在被打击的日子里。同行的师友善意的提醒我们，不要太放在心上，好好去放松下吧。我不甘心，相信在繁华的都市中，我仍然能够找寻到一片净土，在那里，一定会告诉我许多我未曾知晓的秘密。</p><p>沿着小径，是夹岸的泛黄的叶柳，在夜色里略显幽僻，寂静的草深处，夏虫已然鸣出了丝丝秋意。沿着幽径行去，拨开纸条便是小亭，亭中有方石桌一，小石椅两，若有油灯一盏，月光一壶就更佳了。我并没有停留的念头，我只是脱离人群的一人，我只想看看园中的景色，更何况又没有能温酒的友人。</p><p>隔篁竹，水声熹微，在干燥的北地，有一公园相伴以是幸事，有流水助兴那就是惊喜了。溪流里波光粼粼，映着远处高楼的霓虹灯影，远处楼台上的灯火中，看不见月光，没有月光的晚上，本还是阴森森的，转过亭来，却恍然亮堂了起来。</p><p>这是一面湖水，在城市的中间，犹如一颗宝石。沿着堤行，路上三两个形单影只的身影，随着水流动到拱桥那边去了。背着手踱着，仿佛我独享了整个湖，湖面四周都是黑乎乎的，只有湖心处泛着光，上面的夜空里，有阴靉的薄云，一点星光也没有，地上，一人微熹，不知在想些什么。</p><p>像今天晚上，心思可以飞往各处，哪里都可以去，也可以哪里都不去。有湖停陪在身边，我不用害怕迷失，因为我也是其中的一部分了。</p><p>翻过小山拜访了楼台，在廊腰缦回中寻味，月色渐渐泻了出来，停在了阁楼的最高层。曲曲折折的小路，路旁萦绕着心心点点的花朵，就像是草木好奇的眼睛，她们仿佛就是与秋天过不去，故意在夏末才开放；她们又好像是天上的星星落在了草丛里，正如粒粒明珠。清风送香，向夜半的风把树阴吹斜，我便看见了同行的伙伴们，不在躲着他们的行去。“你们听见了吗？”他们莫名其妙还笑话我有文人气。我并没有听清楚他们在说什么，我只听见了花的香气。</p><p>花的香气是怎么样的呢，我已想不起来，不过梦回迎泽，那些影已经忘不掉了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 岁月录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 光点 </tag>
            
            <tag> 散文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
