<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CNKI知网爬虫&amp;Python</title>
    <link href="/2023/12/06/43/"/>
    <url>/2023/12/06/43/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="cnki知网爬虫python">CNKI知网爬虫&amp;Python</h1><p>当涉及从CNKI（中国知网）获取数据时，编写一个网络爬虫以收集信息可能是个不错的选择。这篇博客将指导您如何使用Python和Selenium库编写一个简单的爬虫，从CNKI网站上检索关于特定主题的论文信息。</p><h2 id="特点">特点</h2><ul><li>根据指定关键词在 CNKI 进行论文搜索。</li><li>提取信息包括标题、作者、摘要、出版详情等。</li><li>支持多线程以提高检索速度。</li><li>将提取的信息保存到指定文件中（在这种情况下是一个 TSV 文件）。</li><li><strong>若存在指定文件将最后一行编号开始查询（可以随时关闭程序，下次接着爬取）。</strong></li><li>异常处理以确保稳健性。</li></ul><h2 id="利用python编写cnki知网爬虫">利用Python编写CNKI知网爬虫</h2><p>中国知网（CNKI）是一个知名的学术资源库，它提供了丰富的学术文献、期刊和论文。为了从CNKI获取数据，我们将使用Python编写一个简单但功能强大的网络爬虫。</p><p>因为知网的频繁的更新，以及目录是动态加载的，<del>而我不会找包</del>，还有听说知网有严厉的反爬机制。用传统的<code>response = requests.get(url)</code>爬取论文信息是不太可能的。</p><p>我查找了一些资料，先尝试查了GitHub上有没有现成的</p><p><ahref="https://github.com/qiuqingyu/CNKICrawler">qiuqingyu/CNKICrawler:中国知网爬虫</a>、<ahref="https://github.com/yanzhou/CnkiSpider">yanzhou/CnkiSpider:中国知网爬虫</a>，两个排名比较高的项目因为年久失修不能使用了……</p><p><ahref="https://github.com/aFlyBird0/CnkiSpider">aFlyBird0/CnkiSpider:知网爬虫，专利、论文项目</a>这个是2021年的，新一些，但是我没有尝试。</p><p>以及我只想要一个能运行的轻量级一点的爬虫，我几乎想要放弃了，但之后Bing，发现了CSDN和知乎有一些不算长的脚本就能爬。然后就认识了Selenium的强大。</p><p><ahref="https://zhuanlan.zhihu.com/p/599579339">这篇知乎文章</a>代码我只能跑通一部分，但是已经看到了能实现的眉目。<ahref="https://zhuanlan.zhihu.com/p/663793038">作者的另一篇介绍</a>让我了解了selenium的Xpath怎么用怎么获取。</p><p>缺点就是比较慢，而且加载网页会置顶浏览器，导致跑代码的时候干其他事情不太方便。</p><h3 id="准备工作">准备工作</h3><p>首先，确保您已经安装了Python并安装了必要的库。我们将使用Selenium来模拟浏览器行为，从而检索和提取我们感兴趣的信息。</p><h3 id="代码实现">代码实现</h3><p>以下是一个简化的示例代码，展示了如何使用Python和Selenium进行基本的CNKI知网爬取：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_info</span>(<span class="hljs-params">driver, xpath</span>):</span>    <span class="hljs-keyword">try</span>:        element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, xpath)))        <span class="hljs-keyword">return</span> element.text    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span><span class="hljs-comment"># 以上是一个简要的函数，展示了如何使用Python和Selenium进行基本的CNKI知网爬取。</span></code></pre></div><p>selenium其实就是操控（Driver）一个浏览器，点击、填写、获取文本等。这其实就是一个自动化脚本而已。</p><h3 id="实现步骤">实现步骤</h3><ol type="1"><li><strong>设置环境</strong>：确保您已经安装了Python和Selenium库，并配置了WebDriver（例如ChromeWebDriver或Edge WebDriver）。</li><li><strong>编写代码</strong>：使用Python编写爬虫代码，包括模拟浏览器行为（例如页面导航、关键字搜索等）和信息提取（例如论文标题、作者、摘要等）。</li><li><strong>测试和调试</strong>：运行您的代码并测试其功能。确保它可以成功地检索到您感兴趣的信息。</li><li><strong>优化和扩展</strong>：根据需要优化代码，处理异常情况并扩展其功能。您可以添加多线程支持以加快爬取速度，或者保存数据到文件或数据库中。</li></ol><h3 id="接下来的步骤">接下来的步骤</h3><p>这只是一个入门级的示例，您可以根据需要扩展它。您可能想要添加更多功能，例如多线程支持、数据持久化、自动化登录等。同时，还请确保您的爬虫行为是合法的，遵守网站的使用条款和规定。</p><p>我修改了<ahref="https://zhuanlan.zhihu.com/p/599579339">这篇知乎文章</a>的代码，重新更改了一些Xpath，并加上自己的逻辑。</p><blockquote><p>代码不再维护，含有一些问题，最新代码见下文</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> concurrent.futures<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="hljs-keyword">import</span> DesiredCapabilities<span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<span class="hljs-keyword">import</span> os<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">webserver</span>():</span>    <span class="hljs-comment"># get直接返回，不再等待界面加载完成</span>    desired_capabilities = DesiredCapabilities.EDGE    desired_capabilities[<span class="hljs-string">&quot;pageLoadStrategy&quot;</span>] = <span class="hljs-string">&quot;none&quot;</span>    <span class="hljs-comment"># 设置微软驱动器的环境</span>    options = webdriver.EdgeOptions()    <span class="hljs-comment"># 设置浏览器不加载图片，提高速度</span>    options.add_experimental_option(<span class="hljs-string">&quot;prefs&quot;</span>, &#123;<span class="hljs-string">&quot;profile.managed_default_content_settings.images&quot;</span>: <span class="hljs-number">2</span>&#125;)    <span class="hljs-comment"># 创建一个微软驱动器</span>    driver = webdriver.Edge(options=options)    <span class="hljs-keyword">return</span> driver<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_page</span>(<span class="hljs-params">driver, keyword</span>):</span>    <span class="hljs-comment"># 打开页面，等待两秒</span>    driver.get(<span class="hljs-string">&quot;https://kns.cnki.net/kns8/AdvSearch&quot;</span>)    time.sleep(<span class="hljs-number">2</span>)    <span class="hljs-comment"># 修改属性，使下拉框显示</span>    opt = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;div.sort-list&#x27;</span>)  <span class="hljs-comment"># 定位元素</span>    driver.execute_script(<span class="hljs-string">&quot;arguments[0].setAttribute(&#x27;style&#x27;, &#x27;display: block;&#x27;)&quot;</span>, opt)  <span class="hljs-comment"># 执行 js 脚本进行属性的修改；arguments[0]代表第一个属性</span>    <span class="hljs-comment"># 鼠标移动到下拉框中的[通讯作者]</span>    ActionChains(driver).move_to_element(driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;li[data-val=&quot;RP&quot;]&#x27;</span>)).perform()    <span class="hljs-comment"># # 找到[关键词]选项并点击</span>    <span class="hljs-comment"># WebDriverWait(driver, 100).until(</span>    <span class="hljs-comment">#     EC.visibility_of_element_located((By.CSS_SELECTOR, &#x27;li[data-val=&quot;KY&quot;]&#x27;))).click()</span>    <span class="hljs-comment"># 传入关键字</span>    WebDriverWait(driver, <span class="hljs-number">100</span>).until(        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;gradetxt&quot;]/dd[1]/div[2]/input&#x27;&#x27;&#x27;</span>))    ).send_keys(keyword)    <span class="hljs-comment"># 点击搜索</span>    WebDriverWait(driver, <span class="hljs-number">100</span>).until(        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;ModuleSearch&quot;]/div[1]/div/div[2]/div/div[1]/div[1]/div[2]/div[3]/input&#x27;&#x27;&#x27;</span>))    ).click()    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在搜索，请稍后...&quot;</span>)    <span class="hljs-comment"># # 点击切换中文文献</span>    <span class="hljs-comment"># WebDriverWait(driver, 100).until(</span>    <span class="hljs-comment">#     EC.presence_of_element_located((By.XPATH, &quot;/html/body/div[3]/div[1]/div/div/div/a[1]&quot;))</span>    <span class="hljs-comment"># ).click()</span>    <span class="hljs-comment"># 获取总文献数和页数</span>    res_unm = WebDriverWait(driver, <span class="hljs-number">100</span>).until(EC.presence_of_element_located(        (By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;countPageDiv&quot;]/span[1]/em&#x27;&#x27;&#x27;</span>))    ).text    <span class="hljs-comment"># 去除千分位里的逗号</span>    res_unm = <span class="hljs-built_in">int</span>(res_unm.replace(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>))    page_unm = <span class="hljs-built_in">int</span>(res_unm / <span class="hljs-number">20</span>) + <span class="hljs-number">1</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;共找到 <span class="hljs-subst">&#123;res_unm&#125;</span> 条结果, <span class="hljs-subst">&#123;page_unm&#125;</span> 页。&quot;</span>)    <span class="hljs-keyword">return</span> res_unm<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_info</span>(<span class="hljs-params">driver, xpath</span>):</span>    <span class="hljs-keyword">try</span>:        element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, xpath)))        <span class="hljs-keyword">return</span> element.text    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_choose_info</span>(<span class="hljs-params">driver, xpath1, xpath2, <span class="hljs-built_in">str</span></span>):</span>    <span class="hljs-keyword">try</span>:         <span class="hljs-keyword">if</span> WebDriverWait(driver, <span class="hljs-number">1</span>).until(EC.presence_of_element_located((By.XPATH, xpath1))).text==<span class="hljs-built_in">str</span>:            <span class="hljs-keyword">return</span> WebDriverWait(driver, <span class="hljs-number">1</span>).until(EC.presence_of_element_located((By.XPATH, xpath2))).text        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span>    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl</span>(<span class="hljs-params">driver, papers_need, theme</span>):</span>    count = <span class="hljs-number">1</span>    file_path = <span class="hljs-string">f&quot;CNKI_<span class="hljs-subst">&#123;theme&#125;</span>.tsv&quot;</span>    <span class="hljs-keyword">if</span> os.path.exists(file_path) <span class="hljs-keyword">and</span> os.path.getsize(file_path) &gt; <span class="hljs-number">0</span>:        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> file:            lines = file.readlines()            last_line = lines[-<span class="hljs-number">1</span>].strip()            count = <span class="hljs-built_in">int</span>(last_line.split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((count-<span class="hljs-number">1</span>) // <span class="hljs-number">20</span>):        <span class="hljs-comment"># 切换到下一页</span>        time.sleep(<span class="hljs-number">3</span>)        WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;//*[@id=&#x27;PageNext&#x27;]&quot;</span>))).click()    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;从第 <span class="hljs-subst">&#123;count&#125;</span> 条开始爬取\n&quot;</span>)    <span class="hljs-comment"># 当爬取数量小于需求时，循环网页页码</span>    <span class="hljs-keyword">while</span> count &lt;= papers_need:        <span class="hljs-comment"># 等待加载完全，休眠3S</span>        time.sleep(<span class="hljs-number">3</span>)        title_list = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_all_elements_located((By.CLASS_NAME, <span class="hljs-string">&quot;fz14&quot;</span>)))        <span class="hljs-comment"># 循环网页一页中的条目</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((count-<span class="hljs-number">1</span>) % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>, <span class="hljs-number">21</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n###正在爬取第 <span class="hljs-subst">&#123;count&#125;</span> 条(本页第<span class="hljs-subst">&#123;i&#125;</span>条)#######################################\n&quot;</span>)            <span class="hljs-keyword">try</span>:                term = (count-<span class="hljs-number">1</span>) % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>  <span class="hljs-comment"># 本页的第几个条目</span>                                <span class="hljs-comment"># 获取基础信息</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取基础信息...&#x27;</span>)                title_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[2]&#x27;&#x27;&#x27;</span>                author_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[3]&#x27;&#x27;&#x27;</span>                source_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[4]&#x27;&#x27;&#x27;</span>                date_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[5]&#x27;&#x27;&#x27;</span>                database_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[6]&#x27;&#x27;&#x27;</span>                quote_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[7]&#x27;&#x27;&#x27;</span>                download_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[8]&#x27;&#x27;&#x27;</span>                xpaths = [title_xpath, author_xpath, source_xpath, date_xpath, database_xpath, quote_xpath, download_xpath]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    future_elements = [executor.submit(get_info, driver, xpath) <span class="hljs-keyword">for</span> xpath <span class="hljs-keyword">in</span> xpaths]                title, authors, source, date, database, quote, download = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> future_elements]                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> quote.isdigit():                    quote = <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> download.isdigit():                    download = <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;title&#125;</span> <span class="hljs-subst">&#123;authors&#125;</span> <span class="hljs-subst">&#123;source&#125;</span> <span class="hljs-subst">&#123;date&#125;</span> <span class="hljs-subst">&#123;database&#125;</span> <span class="hljs-subst">&#123;quote&#125;</span> <span class="hljs-subst">&#123;download&#125;</span>\n&quot;</span>)                               <span class="hljs-comment"># 点击条目</span>                title_list[i-<span class="hljs-number">1</span>].click()                                <span class="hljs-comment"># 获取driver的句柄</span>                n = driver.window_handles                                <span class="hljs-comment"># driver切换至最新生产的页面</span>                driver.switch_to.window(n[-<span class="hljs-number">1</span>])                time.sleep(<span class="hljs-number">3</span>)                                <span class="hljs-comment"># 开始获取页面信息</span>                <span class="hljs-comment"># 点击展开</span>                <span class="hljs-keyword">try</span>:                    WebDriverWait(driver, <span class="hljs-number">10</span>).until(                        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;ChDivSummaryMore&quot;]&#x27;&#x27;&#x27;</span>))                    ).click()                <span class="hljs-keyword">except</span>:                    <span class="hljs-keyword">pass</span>                                <span class="hljs-comment"># 获取作者单位</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取institute...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    institute = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[3]/div/h3[2]&quot;</span>))).text                <span class="hljs-keyword">except</span>:                    institute = <span class="hljs-string">&#x27;无&#x27;</span>                <span class="hljs-built_in">print</span>(institute+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取摘要、关键词、专辑、专题</span>                <span class="hljs-comment"># 获取摘要</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取abstract...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    abstract = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.CLASS_NAME, <span class="hljs-string">&quot;abstract-text&quot;</span>))).text                <span class="hljs-keyword">except</span>:                    abstract = <span class="hljs-string">&#x27;无&#x27;</span>                <span class="hljs-built_in">print</span>(abstract+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取关键词</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取keywords...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    keywords = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.CLASS_NAME, <span class="hljs-string">&quot;keywords&quot;</span>))).text[:-<span class="hljs-number">1</span>]                <span class="hljs-keyword">except</span>:                    keywords = <span class="hljs-string">&#x27;无&#x27;</span>                      <span class="hljs-built_in">print</span>(keywords+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取专辑</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取publication...&#x27;</span>)                xpaths = [                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[1]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[1]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[1]/p&quot;</span>)                ]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    futures = [executor.submit(get_choose_info, driver, xpath1, xpath2, <span class="hljs-string">&#x27;专辑：&#x27;</span>) <span class="hljs-keyword">for</span> xpath1, xpath2 <span class="hljs-keyword">in</span> xpaths]                    results = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures)]                publication = <span class="hljs-built_in">next</span>((result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results <span class="hljs-keyword">if</span> result != <span class="hljs-string">&#x27;无&#x27;</span>), <span class="hljs-string">&#x27;无&#x27;</span>)                <span class="hljs-built_in">print</span>(publication+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取专题</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取topic...&#x27;</span>)                xpaths = [                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[3]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[3]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[3]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[3]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[2]/p&quot;</span>)                ]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    futures = [executor.submit(get_choose_info, driver, xpath1, xpath2, <span class="hljs-string">&#x27;专题：&#x27;</span>) <span class="hljs-keyword">for</span> xpath1, xpath2 <span class="hljs-keyword">in</span> xpaths]                    results = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures)]                topic = <span class="hljs-built_in">next</span>((result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results <span class="hljs-keyword">if</span> result != <span class="hljs-string">&#x27;无&#x27;</span>), <span class="hljs-string">&#x27;无&#x27;</span>)                <span class="hljs-built_in">print</span>(topic+<span class="hljs-string">&#x27;\n&#x27;</span>)                                url = driver.current_url                                <span class="hljs-comment"># 获取下载链接</span>                <span class="hljs-comment"># link = WebDriverWait( driver, 10 ).until( EC.presence_of_all_elements_located((By.CLASS_NAME  ,&quot;btn-dlcaj&quot;) ) )[0].get_attribute(&#x27;href&#x27;)</span>                <span class="hljs-comment"># link = urljoin(driver.current_url, link)</span>                <span class="hljs-comment"># 写入文件</span>                res = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;count&#125;</span>\t<span class="hljs-subst">&#123;title&#125;</span>\t<span class="hljs-subst">&#123;authors&#125;</span>\t<span class="hljs-subst">&#123;institute&#125;</span>\t<span class="hljs-subst">&#123;date&#125;</span>\t<span class="hljs-subst">&#123;source&#125;</span>\t<span class="hljs-subst">&#123;publication&#125;</span>\t<span class="hljs-subst">&#123;topic&#125;</span>\t<span class="hljs-subst">&#123;database&#125;</span>\t<span class="hljs-subst">&#123;quote&#125;</span>\t<span class="hljs-subst">&#123;download&#125;</span>\t<span class="hljs-subst">&#123;keywords&#125;</span>\t<span class="hljs-subst">&#123;abstract&#125;</span>\t<span class="hljs-subst">&#123;url&#125;</span>&quot;</span>.replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>                <span class="hljs-keyword">try</span>:                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>) <span class="hljs-keyword">as</span> f:                        f.write(res)                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;写入失败:&#x27;</span>, <span class="hljs-built_in">str</span>(e))                    <span class="hljs-keyword">raise</span> e            <span class="hljs-keyword">except</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; 第<span class="hljs-subst">&#123;count&#125;</span> 条爬取失败\n&quot;</span>)                <span class="hljs-comment"># 跳过本条，接着下一个</span>                <span class="hljs-keyword">continue</span>                        <span class="hljs-keyword">finally</span>:                <span class="hljs-comment"># 如果有多个窗口，关闭第二个窗口， 切换回主页</span>                n2 = driver.window_handles                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n2) &gt; <span class="hljs-number">1</span>:                    driver.close()                    driver.switch_to.window(n2[<span class="hljs-number">0</span>])                <span class="hljs-comment"># 计数,判断需求是否足够</span>                count += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> count == papers_need: <span class="hljs-keyword">break</span>        <span class="hljs-comment"># 切换到下一页</span>        WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;//a[@id=&#x27;PageNext&#x27;]&quot;</span>))).click()            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取完毕！&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:        keyword = <span class="hljs-string">&quot;青少年抑郁&quot;</span>    driver = webserver()        <span class="hljs-comment"># 设置所需篇数</span>    papers_need = <span class="hljs-number">500</span>    res_unm = open_page(driver, keyword)        <span class="hljs-comment"># 判断所需是否大于总篇数</span>    papers_need = papers_need <span class="hljs-keyword">if</span> (papers_need &lt;= res_unm) <span class="hljs-keyword">else</span> res_unm        os.system(<span class="hljs-string">&quot;pause&quot;</span>)        <span class="hljs-comment"># 开始爬取</span>    crawl(driver, papers_need, keyword)    <span class="hljs-comment"># 关闭浏览器</span>    driver.close()</code></pre></div><p>总算能成功运行了，因为太慢了之后增加了并行处理，尽量加速。得到了下面这个代码，封装的多一些。</p><blockquote><p>2023/12/07 更新，修复了一些逻辑BUG、专辑专题覆盖更全。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> concurrent.futures<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="hljs-keyword">import</span> DesiredCapabilities<span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<span class="hljs-keyword">import</span> os<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">webserver</span>():</span>    <span class="hljs-comment"># get直接返回，不再等待界面加载完成</span>    desired_capabilities = DesiredCapabilities.EDGE    desired_capabilities[<span class="hljs-string">&quot;pageLoadStrategy&quot;</span>] = <span class="hljs-string">&quot;none&quot;</span>    <span class="hljs-comment"># 设置微软驱动器的环境</span>    options = webdriver.EdgeOptions()    <span class="hljs-comment"># 设置浏览器不加载图片，提高速度</span>    options.add_experimental_option(<span class="hljs-string">&quot;prefs&quot;</span>, &#123;<span class="hljs-string">&quot;profile.managed_default_content_settings.images&quot;</span>: <span class="hljs-number">2</span>&#125;)    <span class="hljs-comment"># 创建一个微软驱动器</span>    driver = webdriver.Edge(options=options)    <span class="hljs-keyword">return</span> driver<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_page</span>(<span class="hljs-params">driver, keyword</span>):</span>    <span class="hljs-comment"># 打开页面，等待两秒</span>    driver.get(<span class="hljs-string">&quot;https://kns.cnki.net/kns8/AdvSearch&quot;</span>)    time.sleep(<span class="hljs-number">2</span>)    <span class="hljs-comment"># 修改属性，使下拉框显示</span>    opt = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;div.sort-list&#x27;</span>)  <span class="hljs-comment"># 定位元素</span>    driver.execute_script(<span class="hljs-string">&quot;arguments[0].setAttribute(&#x27;style&#x27;, &#x27;display: block;&#x27;)&quot;</span>, opt)  <span class="hljs-comment"># 执行 js 脚本进行属性的修改；arguments[0]代表第一个属性</span>    <span class="hljs-comment"># 鼠标移动到下拉框中的[通讯作者]</span>    ActionChains(driver).move_to_element(driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;li[data-val=&quot;RP&quot;]&#x27;</span>)).perform()    <span class="hljs-comment"># # 找到[关键词]选项并点击</span>    <span class="hljs-comment"># WebDriverWait(driver, 100).until(</span>    <span class="hljs-comment">#     EC.visibility_of_element_located((By.CSS_SELECTOR, &#x27;li[data-val=&quot;KY&quot;]&#x27;))).click()</span>    <span class="hljs-comment"># 传入关键字</span>    WebDriverWait(driver, <span class="hljs-number">100</span>).until(        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;gradetxt&quot;]/dd[1]/div[2]/input&#x27;&#x27;&#x27;</span>))    ).send_keys(keyword)    <span class="hljs-comment"># 点击搜索</span>    WebDriverWait(driver, <span class="hljs-number">100</span>).until(        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;ModuleSearch&quot;]/div[1]/div/div[2]/div/div[1]/div[1]/div[2]/div[3]/input&#x27;&#x27;&#x27;</span>))    ).click()    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在搜索，请稍后...&quot;</span>)    <span class="hljs-comment"># # 点击切换中文文献</span>    <span class="hljs-comment"># WebDriverWait(driver, 100).until(</span>    <span class="hljs-comment">#     EC.presence_of_element_located((By.XPATH, &quot;/html/body/div[3]/div[1]/div/div/div/a[1]&quot;))</span>    <span class="hljs-comment"># ).click()</span>    <span class="hljs-comment"># 获取总文献数和页数</span>    res_unm = WebDriverWait(driver, <span class="hljs-number">100</span>).until(EC.presence_of_element_located(        (By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;countPageDiv&quot;]/span[1]/em&#x27;&#x27;&#x27;</span>))    ).text    <span class="hljs-comment"># 去除千分位里的逗号</span>    res_unm = <span class="hljs-built_in">int</span>(res_unm.replace(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>))    page_unm = <span class="hljs-built_in">int</span>(res_unm / <span class="hljs-number">20</span>) + <span class="hljs-number">1</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;共找到 <span class="hljs-subst">&#123;res_unm&#125;</span> 条结果, <span class="hljs-subst">&#123;page_unm&#125;</span> 页。&quot;</span>)    <span class="hljs-keyword">return</span> res_unm<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_info</span>(<span class="hljs-params">driver, xpath</span>):</span>    <span class="hljs-keyword">try</span>:        element = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, xpath)))        <span class="hljs-keyword">return</span> element.text    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_choose_info</span>(<span class="hljs-params">driver, xpath1, xpath2, <span class="hljs-built_in">str</span></span>):</span>    <span class="hljs-keyword">try</span>:         <span class="hljs-keyword">if</span> WebDriverWait(driver, <span class="hljs-number">1</span>).until(EC.presence_of_element_located((By.XPATH, xpath1))).text==<span class="hljs-built_in">str</span>:            <span class="hljs-keyword">return</span> WebDriverWait(driver, <span class="hljs-number">1</span>).until(EC.presence_of_element_located((By.XPATH, xpath2))).text        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span>    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;无&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl</span>(<span class="hljs-params">driver, papers_need, theme</span>):</span>    count = <span class="hljs-number">1</span>    file_path = <span class="hljs-string">f&quot;CNKI_<span class="hljs-subst">&#123;theme&#125;</span>.tsv&quot;</span>    <span class="hljs-keyword">if</span> os.path.exists(file_path) <span class="hljs-keyword">and</span> os.path.getsize(file_path) &gt; <span class="hljs-number">0</span>:        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> file:            lines = file.readlines()            last_line = lines[-<span class="hljs-number">1</span>].strip()            count = <span class="hljs-built_in">int</span>(last_line.split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count // <span class="hljs-number">20</span>):        <span class="hljs-comment"># 切换到下一页</span>        time.sleep(<span class="hljs-number">3</span>)        WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;//*[@id=&#x27;PageNext&#x27;]&quot;</span>))).click()    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;从第 <span class="hljs-subst">&#123;count&#125;</span> 条开始爬取\n&quot;</span>)    <span class="hljs-comment"># 当爬取数量小于需求时，循环网页页码</span>    <span class="hljs-keyword">while</span> count &lt;= papers_need:        <span class="hljs-comment"># 等待加载完全，休眠3S</span>        time.sleep(<span class="hljs-number">3</span>)        title_list = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_all_elements_located((By.CLASS_NAME, <span class="hljs-string">&quot;fz14&quot;</span>)))        <span class="hljs-comment"># 循环网页一页中的条目</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((count-<span class="hljs-number">1</span>) % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>, <span class="hljs-number">21</span>):            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n###正在爬取第 <span class="hljs-subst">&#123;count&#125;</span> 条(本页第<span class="hljs-subst">&#123;i&#125;</span>条)#######################################\n&quot;</span>)            <span class="hljs-keyword">try</span>:                term = (count-<span class="hljs-number">1</span>) % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>  <span class="hljs-comment"># 本页的第几个条目</span>                                <span class="hljs-comment"># 获取基础信息</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取基础信息...&#x27;</span>)                title_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[2]&#x27;&#x27;&#x27;</span>                author_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[3]&#x27;&#x27;&#x27;</span>                source_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[4]&#x27;&#x27;&#x27;</span>                date_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[5]&#x27;&#x27;&#x27;</span>                database_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[6]&#x27;&#x27;&#x27;</span>                quote_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[7]&#x27;&#x27;&#x27;</span>                download_xpath = <span class="hljs-string">f&#x27;&#x27;&#x27;//*[@id=&quot;gridTable&quot;]/div/div/table/tbody/tr[<span class="hljs-subst">&#123;term&#125;</span>]/td[8]&#x27;&#x27;&#x27;</span>                xpaths = [title_xpath, author_xpath, source_xpath, date_xpath, database_xpath, quote_xpath, download_xpath]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    future_elements = [executor.submit(get_info, driver, xpath) <span class="hljs-keyword">for</span> xpath <span class="hljs-keyword">in</span> xpaths]                title, authors, source, date, database, quote, download = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> future_elements]                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> quote.isdigit():                    quote = <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> download.isdigit():                    download = <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;title&#125;</span> <span class="hljs-subst">&#123;authors&#125;</span> <span class="hljs-subst">&#123;source&#125;</span> <span class="hljs-subst">&#123;date&#125;</span> <span class="hljs-subst">&#123;database&#125;</span> <span class="hljs-subst">&#123;quote&#125;</span> <span class="hljs-subst">&#123;download&#125;</span>\n&quot;</span>)                               <span class="hljs-comment"># 点击条目</span>                title_list[i-<span class="hljs-number">1</span>].click()                                <span class="hljs-comment"># 获取driver的句柄</span>                n = driver.window_handles                                <span class="hljs-comment"># driver切换至最新生产的页面</span>                driver.switch_to.window(n[-<span class="hljs-number">1</span>])                time.sleep(<span class="hljs-number">3</span>)                                <span class="hljs-comment"># 开始获取页面信息</span>                <span class="hljs-comment"># 点击展开</span>                <span class="hljs-keyword">try</span>:                    WebDriverWait(driver, <span class="hljs-number">10</span>).until(                        EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&#x27;&#x27;&#x27;//*[@id=&quot;ChDivSummaryMore&quot;]&#x27;&#x27;&#x27;</span>))                    ).click()                <span class="hljs-keyword">except</span>:                    <span class="hljs-keyword">pass</span>                                <span class="hljs-comment"># 获取作者单位</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取institute...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    institute = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[3]/div/h3[2]&quot;</span>))).text                <span class="hljs-keyword">except</span>:                    institute = <span class="hljs-string">&#x27;无&#x27;</span>                <span class="hljs-built_in">print</span>(institute+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取摘要、关键词、专辑、专题</span>                <span class="hljs-comment"># 获取摘要</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取abstract...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    abstract = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.CLASS_NAME, <span class="hljs-string">&quot;abstract-text&quot;</span>))).text                <span class="hljs-keyword">except</span>:                    abstract = <span class="hljs-string">&#x27;无&#x27;</span>                <span class="hljs-built_in">print</span>(abstract+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取关键词</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取keywords...&#x27;</span>)                <span class="hljs-keyword">try</span>:                    keywords = WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.CLASS_NAME, <span class="hljs-string">&quot;keywords&quot;</span>))).text[:-<span class="hljs-number">1</span>]                <span class="hljs-keyword">except</span>:                    keywords = <span class="hljs-string">&#x27;无&#x27;</span>                      <span class="hljs-built_in">print</span>(keywords+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取专辑</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取publication...&#x27;</span>)                xpaths = [                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[1]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[1]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[1]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[1]/p&quot;</span>)                ]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    futures = [executor.submit(get_choose_info, driver, xpath1, xpath2, <span class="hljs-string">&#x27;专辑：&#x27;</span>) <span class="hljs-keyword">for</span> xpath1, xpath2 <span class="hljs-keyword">in</span> xpaths]                    results = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures)]                publication = <span class="hljs-built_in">next</span>((result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results <span class="hljs-keyword">if</span> result != <span class="hljs-string">&#x27;无&#x27;</span>), <span class="hljs-string">&#x27;无&#x27;</span>)                <span class="hljs-built_in">print</span>(publication+<span class="hljs-string">&#x27;\n&#x27;</span>)                                <span class="hljs-comment"># 获取专题</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在获取topic...&#x27;</span>)                xpaths = [                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[3]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[6]/ul/li[3]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[2]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[3]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[7]/ul/li[3]/p&quot;</span>),                    (<span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[2]/span&quot;</span>, <span class="hljs-string">&quot;/html/body/div[2]/div[1]/div[3]/div/div/div[4]/ul/li[2]/p&quot;</span>)                ]                <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:                    futures = [executor.submit(get_choose_info, driver, xpath1, xpath2, <span class="hljs-string">&#x27;专题：&#x27;</span>) <span class="hljs-keyword">for</span> xpath1, xpath2 <span class="hljs-keyword">in</span> xpaths]                    results = [future.result() <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures)]                topic = <span class="hljs-built_in">next</span>((result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results <span class="hljs-keyword">if</span> result != <span class="hljs-string">&#x27;无&#x27;</span>), <span class="hljs-string">&#x27;无&#x27;</span>)                <span class="hljs-built_in">print</span>(topic+<span class="hljs-string">&#x27;\n&#x27;</span>)                                url = driver.current_url                                <span class="hljs-comment"># 获取下载链接</span>                <span class="hljs-comment"># link = WebDriverWait( driver, 10 ).until( EC.presence_of_all_elements_located((By.CLASS_NAME  ,&quot;btn-dlcaj&quot;) ) )[0].get_attribute(&#x27;href&#x27;)</span>                <span class="hljs-comment"># link = urljoin(driver.current_url, link)</span>                <span class="hljs-comment"># 写入文件</span>                res = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;count&#125;</span>\t<span class="hljs-subst">&#123;title&#125;</span>\t<span class="hljs-subst">&#123;authors&#125;</span>\t<span class="hljs-subst">&#123;institute&#125;</span>\t<span class="hljs-subst">&#123;date&#125;</span>\t<span class="hljs-subst">&#123;source&#125;</span>\t<span class="hljs-subst">&#123;publication&#125;</span>\t<span class="hljs-subst">&#123;topic&#125;</span>\t<span class="hljs-subst">&#123;database&#125;</span>\t<span class="hljs-subst">&#123;quote&#125;</span>\t<span class="hljs-subst">&#123;download&#125;</span>\t<span class="hljs-subst">&#123;keywords&#125;</span>\t<span class="hljs-subst">&#123;abstract&#125;</span>\t<span class="hljs-subst">&#123;url&#125;</span>&quot;</span>.replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>                <span class="hljs-keyword">try</span>:                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>) <span class="hljs-keyword">as</span> f:                        f.write(res)                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;写入失败:&#x27;</span>, <span class="hljs-built_in">str</span>(e))                    <span class="hljs-keyword">raise</span> e            <span class="hljs-keyword">except</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; 第<span class="hljs-subst">&#123;count&#125;</span> 条爬取失败\n&quot;</span>)                <span class="hljs-comment"># 跳过本条，接着下一个</span>                <span class="hljs-keyword">continue</span>                        <span class="hljs-keyword">finally</span>:                <span class="hljs-comment"># 如果有多个窗口，关闭第二个窗口， 切换回主页</span>                n2 = driver.window_handles                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n2) &gt; <span class="hljs-number">1</span>:                    driver.close()                    driver.switch_to.window(n2[<span class="hljs-number">0</span>])                <span class="hljs-comment"># 计数,判断需求是否足够</span>                count += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> count == papers_need: <span class="hljs-keyword">break</span>        <span class="hljs-comment"># 切换到下一页</span>        WebDriverWait(driver, <span class="hljs-number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="hljs-string">&quot;//a[@id=&#x27;PageNext&#x27;]&quot;</span>))).click()            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取完毕！&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:        keyword = <span class="hljs-string">&quot;青少年抑郁&quot;</span>    driver = webserver()        <span class="hljs-comment"># 设置所需篇数</span>    papers_need = <span class="hljs-number">500</span>    res_unm = open_page(driver, keyword)        <span class="hljs-comment"># 判断所需是否大于总篇数</span>    papers_need = papers_need <span class="hljs-keyword">if</span> (papers_need &lt;= res_unm) <span class="hljs-keyword">else</span> res_unm        <span class="hljs-comment"># os.system(&quot;pause&quot;)</span>        <span class="hljs-comment"># 开始爬取</span>    crawl(driver, papers_need, keyword)    <span class="hljs-comment"># 关闭浏览器</span>    driver.close()</code></pre></div><p>获取专辑和获取专题是最慢的，而且因为知网摆放的问题而且没有特殊命名，用了很蠢的方法查询了四个位置，应该有其他优化方法。</p><h3 id="展示">展示</h3><p><imgsrc="https://pic.imgdb.cn/item/65708984c458853aef8c5262.jpg" /></p><h2 id="结语">结语</h2><p>这篇博客希望能为您提供一个简单但实用的起点，让您开始使用Python编写CNKI知网爬虫。祝您编写爬虫的过程愉快，同时请注意遵守相关法律法规和网站规定。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>大学相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>知网</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>眠</title>
    <link href="/2023/11/09/42/"/>
    <url>/2023/11/09/42/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="眠">眠</h1><p>从前的果实已然硕黄，在一碧万顷的水天之间，充满了丰收的喜悦。一截枯木在湖面横亘，细数近日糜烂的生活。</p><p>身后应是一片连边的森林，阳光透过树梢照射在林间的小屋上，坐在树下思绪渺渺。</p><p>故事道：树后应有一道传送门，穿过这扇门，你能到达记忆深处。于是看到了昏黄天空，纱窗，变色的玻璃，破碎的镜子，磨破皮的老式黑色沙发，用茶几盖上布做的课桌，黄色的门廊……记忆里，日头向晚，家人当归了。门上的数字显示为12。</p><p>梦到，与予站在讲台上，手捧奖状，台下是同学的喝彩，这一年是18；梦到，在报告厅前售卖文创，报告厅里是活动的结束声，那是我的生日：梦到，独自行走在昔园，似乎下着雨，心里是难言与痛苦，那是关于熹的；梦到我在班主任办公室里，解释手机的情况，只求不告诉家长，这也是关于她的，因为我不能失去唯一的联系方式。</p><p>望到，阳光蓝天下的白裙黑衣，看气球与鲜花，看形形色色的人举杯或交谈。那声音带我成为了他，见到了她，她眼里是我，我亦望着她，是暖阳，金黄了发梢，白衣，朦胧。我不认识我，看不清，但见到她心里便照了温暖，入了欣喜，浸满温情。满眼欣赏溢着温柔。但是并不是她？我不认识她！</p><p>那声音述说着，过去的事情都过去了，现在也不会再感受到那悲伤又为什么苦苦舔舐？那身影告诉我，既然祂不是她，那又为什么痛苦？要记得那美满，在每一次呼吸都会感受到，都要更加的圆满。</p><p>你还想在看看吗？湖面的层层波涛由远及近，自然的能量从远处汇聚而来。躺坐在沙滩上，闭上眼，眼中也有阳光的温情吧。</p><p>内心暖流涌起，在一碧万顷的水天之间，充满了喜悦。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>散文</tag>
      
      <tag>催眠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列车上的梦</title>
    <link href="/2023/10/10/37%E5%88%97%E8%BD%A6%E4%B8%8A%E7%9A%84%E6%A2%A6/"/>
    <url>/2023/10/10/37%E5%88%97%E8%BD%A6%E4%B8%8A%E7%9A%84%E6%A2%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>列车上没有梦。 <span id="more"></span></p></blockquote><h2 id="列车上的梦">列车上的梦</h2><p>你睡了，静静的躺在我身边。车窗外的灯光拂过你的黑发，你的身体小小的，很独立很可爱，我很喜欢。</p><p>我们之间只有浅浅的栏杆与短短的间隙阻拦，我一伸手就能触碰到你。我不忍心，怕打扰了你的睡梦，你侧过身去，呼吸变得很细…</p><p>还记得，你坐在我的身后，我坐在你的身前，风拂过我的脸颊，吹动你的长发。你举起相机，记录了这一刻，在这五六十公里的旅途上，我的心似那万顷的金灿灿的稻谷。在金灿灿之间，你背着我张开手臂，这幅画卷随着远山村庄携刻在一起，阳光拂面，你很美。我驾着车，你放着歌曲，你的温度通过肌肤传递到我的身上，暖洋洋的，蒸发了清晨的小雨。</p><p>在古城中走街串巷，你捧起了一本书，嗯，在梦中我忘记了是什么书，我只记得，在扎染玫瑰与工艺品间，你穿上了裙子，你笑了，裙子上带着花，和你笑的一样好看。</p><p>早在列车人员的叫喊前，你早便醒了，你趴在枕头上，打开床帘。不远处，天边泛白，然后变黄，黑色褪去变成深蓝色。</p><p>在海边，在输送海水的码头，你蹲坐在桥洞里，让我留下了你的照片，身后是汹涌的海浪，远处是远山与蓝天白云。你流落在了这样的世界里，这样的世界汹涌澎湃，你像一直小猫一样，安安静静的蜷缩在世界一角，不畏外物，我很欣赏你。落日余晖，天边看不见斜阳，唯见山边黄澄澄的云。你坐在海边，粉紫色的天空，倒影着我的内心。</p><p>夜深了，你累了，但你走出了门去买了裙子。我留在了屋子里，酣睡而去。</p><p>我在车上悠悠转醒，我依靠在座椅上向左倾倒，你的发丝就在我眼前，很黑、很细、很温柔，像你。你也睡着了，而我轻轻依靠便能枕在你的肩膀。但是我们的目的地到了，我拍了拍腿把你叫醒，你朦胧着双眼述说着动听的音律。理想邦美术馆里，明信片上的绘画很好看，你拿在手里更好看。在一望无际的深蓝色的天空里，你站在我相机的中心，你拿着自拍杆拍下了自己，而我拍下了你。</p><p>“你为什么总是拍我”</p><p>“因为你就是我的风景”</p><p>这并不是“mouthsweet”，这仅仅是我百转千回的内心话语，说予你听。在公园的山顶，fufu很可爱，你抱着fufu留下与这个梦中城市的合照，你也fufu的，我留下了你和fufu和这个城市的照片，我也fufu的。兴盛大桥很雄伟很精致，像发卡一样别在你发间的发梢。我觉得很有趣，说的是你。</p><p>列车向前奔走着，你睡在我的床下，我看不见你。但是我看见你在玩手机，手机里面不是照片、不是歌曲、也不是你。</p><p>在苍山雾蒙蒙的云间，我们穿着单薄的衣衫走在厚厚衣服的人之间。氧气也不用，在几度的山涧间，迎客松很挺拔，我也想要这样挺拔。能罩住风雪，能遮挡阳光，为了那个手拂过许愿牌的旅客。人来人往间，我双眼极目所至，无不是你。而你左手fufu右手自拍杆拍着视频，视频中有时有我的身影。你偏着头敬礼，不是给我，是摄像机。</p><p>苍翠的山峰，风景很美，我等不了了，走在了前面，我不敢回头，怕看见你，怕看不见你，几公里的山路寥寥。我回头找你，在山石嶙峋中，你比着yes，眼睛里亮晶晶的，看着摄像机。我总是落后你半步，前路交给你，我只是跟着你，跟着你……</p><p>没能给你买裙子，没能在照片中找到你。在列车隆隆中，我翻来覆去。我很痛苦，痛苦旅程的结束，痛苦求而不得，痛苦不被关心。</p><p>在有一天夜里，你告诉我，会关心我，会为我难过。在更远的梦里，你告诉我你不看外貌而看能力。我告诉你，两个完整的圆才能在一起，因为我不完美，所以言尽于此。我告诉你，我能交予的都已给你，我许下承诺，Iwill try my best to be better，你告诉我metoo。你告诉我，可以在你那打卡，我告诉你我会做个2048给你。数独很好玩，但是你不会玩，于是我就把我所会的交给你。</p><p>I want to be better。于是我背单词，看书，学习安卓开发。Youtoo，所以你开始投身于作业；搞机器人，然后做作业。</p><p>我开始看《我要和你好好的》和《不能承受的生命之轻》，我做了很多笔记，我想读给你听：</p><blockquote><p>“是的，我很多时候会不安，而且看到你平凡的在我身边同另一个男生微信聊天…是我自私吗？也许我们关系没到那步，你并不需要对我表现的特别和“忠诚”但是他到火车站接你，而你让我自己回家我又能怎么想呢？更何况你逃避了这个问题，和我设想的一样，在这个设想里我也会疏远你但是我还是反悔了，你旅途中带给我的美好和深入聊天建立的情感纽带让我贪心的想和你做朋友下去…以上，这也是我不够好的表现 I need to become better”</p></blockquote><blockquote><p>我感觉超出了界限，但是你似乎并不觉得，于是我回退了一步，以试图看清我的喜欢，看清我喜欢的女孩，看清这段关系。我没有勇气表白，因为表白很有可能会推远我们，虽然我已然喜欢上了你。</p></blockquote><blockquote><p>我爱你，但是我还没做到最好，所以我在变好——尽最大的能力，我要值得被你爱，也要有爱你的能力。你在未来是否接受我，那是你的事，我在变好，是为了我自己！</p></blockquote><p>有好多好多，我要学习我的英语，学会爱和被爱，这样我才能尽我所能的用我的完整靠近你。</p><p>在列车到站后，我帮你取下箱子，自然的帮你推着箱子，你有些不自在的夺走了自己的箱子。我尊重你，于是就有了一个人夺走了我身边的你。这是你决定的，我也尊重你！</p><p>在每个早上的七点，或者更早，我起来开始一天，你也起来上课或者写作业。我把我的打卡发给了你，你有时鼓励我，我的心暖暖的；你有事不理我，我只能当做你很忙。我和你一起听音乐，带着耳机度过了一天……</p><p>于是你告诉了我一个笑话，笑话不好笑，因为我是那个笑话。</p><p>但是我早早的就有感知啊！所谓男人也有第六感吗？在我痛苦的时候你应该很快乐吧，就像我常看到的一样，对着手机笑，很可爱，很漂亮，想来很有趣，很幸福。</p><p>置身与夜雨中，雨湿透了我的心。然后破碎开来变得更加坚硬。</p><p>夜晚的风乎乎的吹着，你睡在我的身侧，我坐在冰冷的地板上看你，你在梦中笑的很美。</p><p>我很感激你。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>岁月录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>光点</tag>
      
      <tag>散文</tag>
      
      <tag>爱情</tag>
      
      <tag>玥</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 791 (Div. 2) 过题</title>
    <link href="/2023/10/05/41/"/>
    <url>/2023/10/05/41/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="codeforces-round-791-div.-2-过题">Codeforces Round 791 (Div. 2)过题</h1><p>https://codeforces.com/contest/1679</p><h2 id="a.-avtobus">A. AvtoBus</h2><h3 id="题意">题意</h3><p>汽车的轮胎可能有4个或者6个，对于给定的每个n（n表示轮胎数量），给出汽车的数量的极小值和极大值，不可能就输出-1### 题解</p><p>纯纯的签到题 平板上写了个 // Created on iPad.</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    cin &gt;&gt; t;    <span class="hljs-keyword">while</span> (t--)    &#123;        <span class="hljs-keyword">int</span> n;        cin &gt;&gt; n;        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)        &#123;            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        n /= <span class="hljs-number">2</span>; <span class="hljs-comment">// n = 2a+3b</span>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)            n -= <span class="hljs-number">3</span>, ans++;        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)        &#123;            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;            <span class="hljs-keyword">continue</span>;        &#125;        cout &lt;&lt; ans + n / <span class="hljs-number">6</span> * <span class="hljs-number">2</span> + n % <span class="hljs-number">6</span> / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;        cout &lt;&lt; ans + n / <span class="hljs-number">2</span> &lt;&lt; endl;    &#125;&#125;</code></pre></div><p><ahref="https://codeforces.com/contest/1679/submission/226810092">AC</a>了。</p><h2 id="b.-stone-age-problem">B. Stone Age Problem</h2><h3 id="题意-1">题意</h3><p>题意大概是：给定一个 长度为 n 的 数组 a 和 q次操作。每次操作可能为</p><ol type="1"><li>把 数组a 中的一个元素的值 变成 x 。</li><li>把 数组 a 的所有元素变成 x 。</li><li>询问 数组 a 的所有元素和 sum(a[1∼n]) 。</li></ol><h3 id="题解">题解</h3><p>我们用 布尔变量 all 和 数值 变量 v 来表示 "数组 a 是否全部被变成 数值v "。如果 数组 全部被 变为 v 了，我们再用 一个映射 d[i] 来表示， 在 all为真的情况下，a[i] 的 数值被 操作 1 变为了多少。之后就是模拟写代码了。</p><h2 id="c.-rooks-defenders">C. Rooks Defenders</h2><h3 id="题意-2">题意</h3><p>问题被转化为: 给定一个元素全为 0 的二维数组 a[][] ，和 q次操作，每次操作可能为:</p><ol type="1"><li>给定 x, y ，将 a[x][y] 变成 1 (题目保证在操作之前 a[x][y] 是 0).</li><li>给定 x, y ，将 a[x][y] 变成 0 （题目保证在操作之前 a[x][y] 是 1）.</li><li>给定 x_{1}, y_{1}, x_{2}, y_{2} ，询问是否有 " a 的 x_{1} x_{2} 行每行都至少存在一个 1 " 或 " a 的 y_{1} y_{2} 列 每列都至少存在一个 1 "。 这题本质上是 "单点值修改，区间和查询"，可以用树状数组。</li></ol><h3 id="题解-1">题解</h3><p>单点修改区间查询的问题。可以用树状数组/线段树维护某一段区间内多少行/列上有多少个车。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span>    <span class="hljs-keyword">int</span> l, r, v, sum;&#125;tr1[maxn * <span class="hljs-number">4</span>], tr2[maxn * <span class="hljs-number">4</span>];<span class="hljs-keyword">int</span> n, q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(Node tr[], <span class="hljs-keyword">int</span> u)</span></span>&#123;    tr[u].sum = tr[u &lt;&lt; <span class="hljs-number">1</span>].sum + tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(Node tr[], <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;    tr[u] = &#123;l, r&#125;;    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(tr, u &lt;&lt; <span class="hljs-number">1</span>, l, mid);    <span class="hljs-built_in">build</span>(tr, u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node tr[], <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="hljs-keyword">return</span> tr[u].sum;    <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (l &lt;= mid) sum += <span class="hljs-built_in">query</span>(tr, u &lt;&lt; <span class="hljs-number">1</span>, l, r);    <span class="hljs-keyword">if</span> (r &gt; mid) sum += <span class="hljs-built_in">query</span>(tr, u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(Node tr[], <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span></span>&#123;    <span class="hljs-keyword">if</span> (tr[u].l == tr[u].r)&#123;        tr[u].v += v;        tr[u].sum = (tr[u].v &gt; <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">modify</span>(tr, u &lt;&lt; <span class="hljs-number">1</span>, x, v);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(tr, u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);    <span class="hljs-built_in">pushup</span>(tr, u);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-built_in">build</span>(tr1, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n), <span class="hljs-built_in">build</span>(tr2, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">while</span>(q--)&#123;        <span class="hljs-keyword">int</span> op;        cin &gt;&gt; op;        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">int</span> x, y;            cin &gt;&gt; x &gt;&gt; y;            <span class="hljs-built_in">modify</span>(tr1, <span class="hljs-number">1</span>, x, <span class="hljs-number">1</span>);            <span class="hljs-built_in">modify</span>(tr2, <span class="hljs-number">1</span>, y, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">int</span> x, y;            cin &gt;&gt; x &gt;&gt; y;            <span class="hljs-built_in">modify</span>(tr1, <span class="hljs-number">1</span>, x, <span class="hljs-number">-1</span>);            <span class="hljs-built_in">modify</span>(tr2, <span class="hljs-number">1</span>, y, <span class="hljs-number">-1</span>);                    &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">int</span> x0, y0, x1, y1;            cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; x1 &gt;&gt; y1;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(tr1, <span class="hljs-number">1</span>, x0, x1) == x1 - x0 + <span class="hljs-number">1</span> || <span class="hljs-built_in">query</span>(tr2, <span class="hljs-number">1</span>, y0, y1) == y1 - y0 + <span class="hljs-number">1</span>)                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;    &#125;&#125;</code></pre></div><h2 id="d.-toss-a-coin-to-your-graph...">D. Toss a Coin to YourGraph...</h2><h3 id="题意-3">题意</h3><p>给出一个有向图，求图中所有长度为k的路径经过的点中最大的点权最小是多少。</p><h3 id="题解-2">题解</h3><p>二分答案,每次都只用小于等于<code>mid</code>的边建图,然后判断图中是否有长度为k的路径或有环即可,可以用拓扑排序判环和<code>DP</code></p><h2 id="e.-typical-party-in-dorm">E. Typical Party in Dorm</h2><h3 id="题意-4">题意</h3><p>给出一个字符串,其中有些位置是<code>?</code>，每次询问给出一个集合,每个<code>?</code>的位置可以用集合中任意的字母代替产生很多不同的字符串,所有产生的串中回文串总数是多少?</p><h3 id="题解-3"><ahref="https://zhuanlan.zhihu.com/p/514519244">题解</a></h3><p>首先我们用类似马拉车算法的初始化方法给在字符之间插入一下<code>#</code>,以便我们直接枚举回文中心.</p><p>我们处理每个回文中心对于询问状态的贡献.</p><p>用状态压缩的方法表示询问中的字符集,我们枚举回文中心,然后处理对于每个回文中心每个回文半径至少需要哪些字母(状压表示)才能使当前的回文中心和回文半径合法(当然也可能怎样都不合法).这部分处理是O(n^2)的,然后用<code>子集和DP</code>处理一下就可以得到某个当前串对每个询问集合会产生多少贡献.</p><p>然后我们发现最后的结果不仅和集合中包含哪些字母有关,还和集合的大小有关,所以我们可以分别处理每个状态在不同集合大小情况下对答案的贡献,这样处理询问的时候就可以O(1)查询了.总复杂度应该是O(17n^2)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静静的</title>
    <link href="/2023/10/05/40/"/>
    <url>/2023/10/05/40/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>你静静的坐在身边，静静的合眼 静静的睡</p><p>静静的，离开大理，离开云南，离开牧笛</p><p>我也静静的，</p><p>因为我知道，静静的，是最后的时光</p><p>静静的，故事就暂停了</p><p>静静的，故事就远去了</p><p>留不住的，都在静静的消逝了</p><p>静静的，还能见吗</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大理</tag>
      
      <tag>喜欢</tag>
      
      <tag>玥</tag>
      
      <tag>诗歌</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>心论</title>
    <link href="/2023/10/04/35/"/>
    <url>/2023/10/04/35/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>        <div id="aplayer-Swumifuf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"落","author":"蓝心羽","url":"http://music.163.com/song/media/outer/url?id=1865012590.mp3","pic":"/2023/10/04/35/03D879F2836B9E2C792186AC78FE5F39.png","lrc":""},{"title":"ハナタバ （花束）","author":"MIMI/可不","url":"http://music.163.com/song/media/outer/url?id=1999253939.mp3","pic":"http://p1.music.126.net/rGRfS1wSBcQcrN2F7bY4tw==/109951168067420441.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-Swumifuf");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><p>毫无疑问，我喜欢上了她。</p><p>在美好的时间，美好的地点，美好的旅途中，不合时宜的贴近了心。</p><p>如何判断这就喜欢上了？</p><p>是看见她就会开心，会情不自禁的关心，会胡思乱想，会嫉妒、会好奇、会贪恋，会忍不住的贴近(贴贴！)，会变得敏感，会有危机感，会心情被牵动(吃醋的换一种表述)。</p><p>yes，that's right.yes，that's right.</p><p>所以合适吗？</p><p>时间上，在短短两天喜欢上一个人，这样的爱未免过于浅薄，未知她全面，就喜欢上，只是滥情，是不负责任！行为上，贴贴与拉扯，主动甚至迫切的帮忙打伞，提东西，拍照，关心，这是极不负责任的，在不知道对方态度便走入安全距离，过于靠近，这是大不只廉耻！</p><p>请容许我在狡辩一下</p><p>第一次与一人单独旅游，第一次为旅游出省，第一次连续的关心一个人，第一次送鲜花……</p><p>把如此多的第一次献给一个人，这样喜欢上不是很正常吗？</p><p>对方能把原计划自己的旅行加入一个人，这不也是表达了好感吗？</p><p>非也！好感也许只是好感，朋友的好感不也是可以的吗？在知道对方大概率仅是好感的情况下，把自己置于不合适的位置，表现了超出友情的照顾，真是下头！更合理，她想带去大理的可能最开始就不是你！你只不过是搭上了顺风车而已，不表谢意就罢了，还想入非非，实乃不可说。</p><p>我哪里没表现出感谢了，我发自内心的感谢她。我感谢她的陪伴感谢她的提携，感谢她让我有了这次非同一般的经历，就像我昨天所写的</p><p>“</p><p>我不知道她怎么想，但是在此时此刻，在这三四天里，大理唯属于我和她，就足够了。</p><p>弥足珍贵的经历，又再次一去不返了。索性，我还在大理，还在她身边，享受这时光，并尽量的留住时间记忆与记录……</p><p>我消极的认为没有下次了</p><p>”</p><p>这段时光我已经很满足了，体验了两三天的“亲密关系”我已经很……</p><p>打住打住，怎么在这自我感动上了，你别忘了“嗯，她下次会抓别人去，还有一个以为不会去的人……”，这也是你写的吧，你就搁那自我感动，自我怀疑然后再自我逃避吧！我已经预测到了未来。毕竟总是这样，还是这样。</p><p>你别忘了她所讨厌的正是很痛苦的爱情，那种吵架，那种吃醋，那种自我内耗，这都是她讨厌你不可能与你同行的理由！</p><p>那我应该怎么办……吃醋就别谈了，正是因为还没在一起然后又有学弟和她聊的欢才有占有欲吗……</p><p>呸，你那不是占有欲，你只会自我怀疑，然后退缩，你不自信，不，你甚至不相信你喜欢的人！这就是你的命门。</p><p>要我说啊，你就应该进攻或者抛弃你那幻想。</p><p>不，表白不是进攻的号角，我错误的理解了她，她应当确实是不喜欢我的，所以不平等的关注才会产生内耗，那我又如何放弃幻想呢，以前的经验告诉我，很难。我可以尝试压抑住，可以尝试疏远，可以吗？</p><p>你觉得呢？你忘记高中的感情花了两年，你现在说的那个不是做过的或者更狠。只能说，这个结只能从你那不自信不相信解决了。你总会被动的等别人，你这人啊，活该啊。</p><p>都说不主动是得不到的，现在主动了反而更不好了？</p><p>你那不是主动，是自我感动！别人需要的是你那些关怀吗你把自己的位置放的越低，就预得不到你想要的。她想要的可是强者，慕强知道吧，和你那高中那个一样，你这样强吗？说来也是，原来这才是你们半个分手的原因，我总算是知道了。</p><p>fine</p><p>fine</p><p>不必多说，我要做的就是回退感情是吧回到友情的层面，这方面还是有一点点经验了……</p><p>“</p><p>当我把墨镜摘下来，林间亮堂了起来，阳光透过针叶林投影下来，一切都是美好的样子。</p><p>”</p><p>你关注到了一切都美好，证明了你本身的不美好，特别是带上墨镜的眼睛所看到的。听我一声劝，这种子种下了，不是那么好脱身的，你还是把时间放在需要准备的大事上，这些事时时品味下，也能作为美好的烦恼了。</p><p>“</p><p>与学弟，聊天中发自拍与视频</p><p>还有与闺蜜提到的那个以为不会陪她去大理的男生</p><p>嗯……</p><p>也是的，最后一天了，</p><p>谢谢你，但是假期快结束了</p><p>我越界了，所以我该走了</p><p>向前去</p><p>向前去</p><p>”</p><p>嗯，不错，走一步看一步也行，更何况还没爱的那么深，相比之前，迷途知返吧……</p><p>但你也知道，那么多年了，心动的有机会？这样消极的等待，有意义吗？</p><p>那你抓得住吗？你抓不住眼前的机会，也抓不住她。你旅途所带走的只有记忆，却带不走她。</p><p>So， the question is coming back again.</p><p>what should I do?</p><p>Do your best if she needs you, do your best if you stayaloneness.</p><p>说了，但什么都没说。</p><p>说了，但是都说了。</p><p>别忘了，你说的“you are my sightseen”，“i will follow you”。能不能做life的和forever的就看你了。</p><p>你这是属于还在暗恋都把后事想了，你这样才是下偷男吧。</p><p>sightseen可不是你嘴甜突发奇想的，你大脑在胡思乱想什么，谁又知道呢(笑)。好了好了，我困了，明天再告诉我你的判断吧。</p><p>我可以接受是判断题，但不能接受成为选项！</p><p>傻子——</p><p><img src="image-20231005235046690.png" /></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>大理</tag>
      
      <tag>喜欢</tag>
      
      <tag>玥</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桂月</title>
    <link href="/2023/10/01/33/"/>
    <url>/2023/10/01/33/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="桂月">桂月</h1><p>桂枝挂月，夜阑无眠。</p><p>是什么时候开始想起了那轮月，圆月常挂天边，却难时时相见。常有雨疏风骤，尝有楼高林立。上天难见，又何现月？</p><p>我曾欣赏满碧池的荷花而忽视了看见水中的游鱼，盯着那桂枝看，当然也就忘记了那高璇的天边月，也是情有可原了。要怪，就怪那荷花惹眼，桂花怡人了。人啊，总是先看见眼前物，眼中景色聚焦聚焦虚化虚化，也就仅剩的那摸嫣红了罢！要为何总怪繁华迷人眼，薄雾遮人面哉？</p><p>所谓小人得志，无怪乎此，但岂能仅怪那外物而忽视自己的错误呢。说那君子，却似那浮生六记的沈复一般，问尽风雅之事又言行不一难当重任。所谓世人，亦无外乎此。</p><p>如今那月盘时隐时现，时暖时清，却似那人一般时近时远。猜不透的心情，看不清的身影。倘若一直看着其随春秋岁去的变化倒也能读懂他的习性，但偶尔看上几眼又如何看的透。如今怕是年与日去，悔之晚矣…</p><p>然世人，总望着不能得之物，若望清月，则忘眼前海棠，若观荷塘又让那月倒影的越来越远了。故而失而复得，得而复失，不能两全。更何况，失而不能复得的海棠，得而依然会掩去的玉珏。</p><p>夜不能寐，珏终缺乎？</p><p>注1，文中圆月代指人</p><p>注2，玉珏，亦是月</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX2023 安装食用指南</title>
    <link href="/2023/09/19/32/"/>
    <url>/2023/09/19/32/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="latex2023-安装食用指南">LaTeX2023 安装食用指南</h1><h2 id="环境texlive2023安装">【环境】texlive2023安装</h2><ul><li>通过<ahref="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">清华大学开源软件镜像站</a>下载texlive2023.iso</li></ul><p><img src="v2-ddb77505e4396c3e2ce5b10a9317b3a8_b.jpg" alt="下载位置" style="zoom: 67%;" /></p><ul><li>右键点击iso文件，解压到你想安装的位置<ul><li>注：不带中文，不带空格</li></ul></li><li>双击install-tl-windows.bat进入安装程序<ul><li>然后等待安装完成，时间很长</li></ul></li></ul><p><img src="image-20230919092411345.png" alt="image-20230919092411345" style="zoom: 33%;" /></p><p><img src="image-20230919092516807.png" alt="image-20230919092516807" style="zoom: 50%;" /></p><p><img src="image-20230919092642594.png" alt="修改安装路径" style="zoom: 50%;" /></p><ul><li>环境变量会自动添加，不用再手动配置，至此环境安装完毕，可以<ahref="#验证">验证</a></li></ul><h2 id="编译器安装texstudio">【编译器】安装texstudio</h2><ul><li>在<ahref="https://mirrors.tuna.tsinghua.edu.cn/github-release/texstudio-org/texstudio/LatestRelease/">清华大学开源软件镜像站</a>下载</li></ul><p><img src="v2-17e5ff5f67819d6c2afd3bc15f989f6c_b.jpg" alt="img" style="zoom:67%;" /></p><ul><li>双击exe安装即可</li></ul><h2 id="验证">验证</h2><p>打开cmd，输入以下代码，能看到版本信息则表示texlive安装完成</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">tex -v</span><span class="hljs-attribute">latex -v</span><span class="hljs-attribute">xelatex -v</span><span class="hljs-attribute">pdflatex -v</span></code></pre></div><p>打开TeXstudio即可开始使用……</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX在数学建模比赛中的起手式</title>
    <link href="/2023/09/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/LaTeX%E5%9C%A8%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E8%B5%B7%E6%89%8B%E5%BC%8F/"/>
    <url>/2023/09/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/LaTeX%E5%9C%A8%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E8%B5%B7%E6%89%8B%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="latex-在数学建模比赛中的起手式">LaTeX在数学建模比赛中的起手式</h1><h2 id="算法设计起手式">算法设计起手式</h2><h3 id="step形式">STEP形式</h3><p>类似于在三线表中用自然语言表示的方法</p><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;algorithm&#125;[H]  \renewcommand&#123;\algorithmcfname&#125;&#123;算法&#125;  \LinesNumberedHidden % 隐藏行号  \SetAlgoNoEnd % 取消结构块末尾END  \SetAlgoNoLine % 取消每行代码末尾竖线  \SetKwInOut&#123;Input&#125;&#123;输入&#125;  \SetKwInOut&#123;Output&#125;&#123;输出&#125;  \Input&#123;输入$in$&#125;  \Output&#123;输出$out$&#125;  \textbf&#123;\textit&#123;Step&#125;1&#125;: 语句1\;  \textbf&#123;\textit&#123;Step&#125;2&#125;: 语句2\;  \textbf&#123;\textit&#123;Step&#125;3&#125;: 语句3\;  \caption&#123;Step表示&#125;\end&#123;algorithm&#125;</code></pre></div><figure><img src="image-20230907104527593.png" alt="image-20230907104527593" /><figcaption aria-hidden="true">image-20230907104527593</figcaption></figure><h3 id="伪代码">伪代码</h3><p>使用伪代码的方法</p><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;algorithm&#125;[H]  \renewcommand&#123;\algorithmcfname&#125;&#123;算法&#125;  \SetAlgoLined  \SetKwInOut&#123;Input&#125;&#123;输入&#125;  \SetKwInOut&#123;Output&#125;&#123;结果&#125;  %\Input&#123;输入$in$&#125;  \Output&#123;输出$out$&#125;  \BlankLine % 插入一个空行  initialization\;  \While&#123;While condition&#125;&#123;    instructions\;    \eIf&#123;condition&#125;&#123;      instructions1      $$\text&#123;公式&#125;\ ;$$      instructions2\;    &#125;&#123;      instructions3\;    &#125;  &#125;  \caption&#123;伪代码表示&#125;\end&#123;algorithm&#125;</code></pre></div><figure><img src="image-20230907104545224.png" alt="image-20230907104545224" /><figcaption aria-hidden="true">image-20230907104545224</figcaption></figure><h2 id="配置">配置</h2><h3 id="lstlisting-代码框">lstlisting 代码框</h3><div class="hljs code-wrapper"><pre><code class="hljs latex">%代码框设置\lstset&#123;     language=matlab, % 设置语言basicstyle=\ttfamily, % 设置字体族     %basicstyle=\small, breaklines=true, % 自动换行keywordstyle = \color&#123;blue&#125;, % 设置关键字为粗体，颜色为 NavyBluemorekeywords=&#123;&#125;, % 设置更多的关键字，用逗号分隔emph=&#123;&#125;, % 指定强调词，如果有多个，用逗号隔开    emphstyle=\bfseries\color&#123;Rhodamine&#125;, % 强调词样式设置    commentstyle = \it\fontspec&#123;Times New Roman&#125;\color[RGB]&#123;60,118,61&#125;, % 设置注释样式    stringstyle = \it\fontspec&#123;Times New Roman&#125;\color&#123;red!100&#125;, % 设置字符串样式    columns=fixed,     numbers=left, % 显示行号在左边    numbersep=2em, % 设置行号的具体位置    numberstyle=\footnotesize, % 缩小行号    frame=single, % 边框    framesep=1em, % 设置代码与边框的距离    rulecolor=\color&#123;gray&#125;, %框架颜色设置&#125;</code></pre></div><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;lstlisting&#125;[language=matlab]clc;clear;see = 0;% 加载数据data = readtable(&#x27;路径全天候数据表.xlsx&#x27;);\end&#123;lstlisting&#125;</code></pre></div><figure><img src="image-20230907105407542.png" alt="image-20230907105407542" /><figcaption aria-hidden="true">image-20230907105407542</figcaption></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
      <tag>数学建模</tag>
      
      <tag>排版</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 与 Matlab、C++ 的交互使用</title>
    <link href="/2023/08/29/31/"/>
    <url>/2023/08/29/31/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="python-与-matlabc-的交互使用">Python 与 Matlab、C++的交互使用</h1><h2 id="python-与-matlab">Python 与 Matlab</h2><p>方法：借助于 matlab 自带的引擎 API</p><p><ahref="%5BPython版本与MATLAB产品兼容版本%20-%20MATLAB%20&amp;%20Simulink%20(mathworks.com)%5D(https://www.mathworks.com/support/requirements/python-compatibility.html)">与MATLAB 产品兼容的 Python 版本（按版本）</a></p><h3 id="配置">配置</h3><p>在MATLAB的命令栏输入 <code>matlabroot</code> 可以得到MATLAB的安装路径，我的安装路径是<code>'D:\Program Files\MATLAB\R2022a'</code>。</p><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">cd matlab路径<span class="hljs-symbol">\e</span>xtern<span class="hljs-symbol">\e</span>ngines<span class="hljs-symbol">\p</span>ython # 即 D:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ATLAB<span class="hljs-symbol">\R</span>2022a<span class="hljs-symbol">\e</span>xtern<span class="hljs-symbol">\e</span>ngines<span class="hljs-symbol">\p</span>ythonpython setup.py install</code></pre></div><h3 id="测试-python-调用-matlab-函数">测试 python 调用 matlab 函数</h3><ol type="1"><li>multiplication_matlab.m 文件：一个乘法函数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span> = <span class="hljs-title">multiplication_matlab</span><span class="hljs-params">(b,c)</span></span>a = b * c<span class="hljs-keyword">end</span></code></pre></div><ol start="2" type="1"><li>python 主程序：调用上述 matlab 函数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs py"><span class="hljs-keyword">import</span> matlab.engine               <span class="hljs-comment"># import matlab引擎</span><span class="hljs-comment"># 启动一个新的MATLAB进程，并返回Python的一个变量，它是一个MatlabEngine对象，用于与MATLAB过程进行通信。</span>eng = matlab.engine.start_matlab() <span class="hljs-comment"># 可以调用matlab的内置函数。                                  </span>d = eng.multiplication_matlab(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 可以调用matlab写的脚本函数</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;d&#x27;</span>, d, <span class="hljs-built_in">type</span>(d))</code></pre></div><ol start="3" type="1"><li>运行 python 结果：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs angelscript">a =  <span class="hljs-built_in">int</span>64   <span class="hljs-number">6</span>d <span class="hljs-number">6</span> &lt;<span class="hljs-keyword">class</span> &#x27;<span class="hljs-symbol">int</span>&#x27;&gt;</code></pre></div><h3 id="注意">注意</h3><ul><li>调用 MATLAB 的函数相对于相同的计算操作可能会慢一些，这是因为在调用MATLAB函数时涉及到了更多的处理步骤和资源开销。所以对于简单的函数不建议调用matlab实现。</li><li>启动引擎 <code>eng = matlab.engine.start_matlab()</code>的时间开销很大，也存在一些随机性，所以不要每次调用都重新启动引擎 。</li></ul><h2 id="python-与-c">python 与 C++</h2><p>测试</p><h3 id="python-调用-c-函数">Python 调用 C 函数</h3><ol type="1"><li>called_c.c：C语言函数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//编译命令 gcc -o libpycall.so -shared -fPIC called_c.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:%d, b:%d.&quot;</span>, a, b);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><ol start="2" type="1"><li>在命令行或者终端输入：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs angelscript">gcc -o libpycall.so -<span class="hljs-keyword">shared</span> -fPIC called_c.c</code></pre></div><p>生成libpycall.so动态库文件，之后就可以在Python中调用foo函数。Python文件：py_call_c.py</p><ol start="3" type="1"><li>运行py_call_c.py输出：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>:<span class="hljs-number">1</span>, b:<span class="hljs-number">3</span></code></pre></div><h3 id="python-调用-c-类">Python 调用 C++ 类</h3><ol type="1"><li>cpp_called.cpp：C++源文件</li></ol><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//Python调用c++(类）动态链接库</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLib</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestLib::display</span><span class="hljs-params">()</span> </span>&#123;    cout&lt;&lt;<span class="hljs-string">&quot;First display&quot;</span>&lt;&lt;endl;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestLib::display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;    cout&lt;&lt;<span class="hljs-string">&quot;Second display:&quot;</span>&lt;&lt;a&lt;&lt;endl;&#125;<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;    TestLib obj;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;        obj.<span class="hljs-built_in">display</span>();      &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;        obj.<span class="hljs-built_in">display</span>(a);      &#125;&#125;</code></pre></div><ol start="2" type="1"><li>在命令行或者终端输入编译命令：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs angelscript">g++ -o libpycallcpp.so -<span class="hljs-keyword">shared</span> -fPIC cpp_called.cpp</code></pre></div><p>说明：</p><ul><li><p>fPIC：生成位置无关目标代码，适用于动态连接；</p></li><li><p>Lpath：表示在path目录中搜索库文件，如-L.表示在当前目录；</p></li><li><p>I path：表示在path目录中搜索头文件；</p></li><li><p>o file：制定输出文件为file；</p></li><li><p>shared：生成一个共享库文件。</p></li></ul><ol start="3" type="1"><li>py_call_c.py：Python文件：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ctypesdll = ctypes.cdll.LoadLibrarylib = dll(<span class="hljs-string">&#x27;./libpycallcpp.so&#x27;</span>) <span class="hljs-comment"># 刚刚生成的库文件的路径</span>lib.display()lib.display_int(<span class="hljs-number">0</span>)</code></pre></div><ol start="4" type="1"><li>运行输出：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">First</span> display<span class="hljs-built_in">Second</span> display:<span class="hljs-number">0</span></code></pre></div><h1 id="参考">参考</h1><ul><li><ahref="https://zhuanlan.zhihu.com/p/514259625">Python调用matlab及其配置方法- 知乎 (zhihu.com)</a></li><li><ahref="https://zhuanlan.zhihu.com/p/604451198">几行Python代码调用C++程序- 知乎 (zhihu.com)</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Matlab</tag>
      
      <tag>语言交互</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022a半年鉴 - 雾中花</title>
    <link href="/2023/07/14/30%E5%B9%B4%E6%8A%A5/"/>
    <url>/2023/07/14/30%E5%B9%B4%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>        <div id="aplayer-bbbqhwWn" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"雾里","author":"朵芊/双怡","url":"http://music.163.com/song/media/outer/url?id=1985847535.mp3","pic":"http://p1.music.126.net/VL11pZBCvTiKXouXobDIzg==/109951167922641293.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-bbbqhwWn");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><h1 id="小结">小结</h1><p>半夜，一点，没有睡意，从床上翻下，想写点东西。</p><p>已经连续三天睡眠时长超过十个小时了，最近也多是在虚度光阴，也是日常的考试后的松懈和假期综合征了。</p><p>回想这忙碌的一学期又干了什么呢？这一学期里我总共修了十六门课，有八门期末考试，课程中有四个是实验课，总共30.5学时，占据了我一周的大部分时间。这确实是我入校以来课程最多的学期了，但是其中包括了两课是转专业补休的。下一个繁忙的学期是大三下……</p><p>两天考四门，四天考六门，这样的考试安排加上我并不良好的应试状态，我考试成绩并不亮眼似乎也是正常发挥了……</p><p>给这一学期或者小半年做一个小小的总结吧！</p><ul><li>在竞赛上：我仍然参加了（大量的）竞赛，并终于获得了国一（但是签字还没跑）</li><li>在学习上：度过了困难的大二下，并基本补齐了所有转专业要补的课</li><li>在社团上：我忽视了惟悦，继续在数模和ACM协会中混了下去（换届），还加了新成立的HSD</li><li>在生活上：和寝室的矛盾更加尖锐，在社团关系中度过了“党争”，并抵达了似乎是最好的结局</li><li>在科研上：我尝试加入了老师（袁）带领的组，但是因为其他事情挤压没放太多时间以及没有主动和老师沟通被踢除了组（因为提出的人不少所以也不至于很尴尬）</li><li>在亲密关系上：割舍愤怒痛苦放下了更多的她，能够对下一段感情抱有消极的期望</li><li>生活习惯上：因为课程的不规律和繁多更无法做到规律的睡眠习惯，倒是在前期养成了上床用ipad看微信阅读看书的习惯</li></ul><p>综上，总体上还算如意，细节上仍有很多失意。</p><p>买不到归乡的车票，看来铁路部门也不想让我明天回家吧（摊手</p><h1 id="碑---碎碎念">碑 - 碎碎念</h1><p>第二学期已经结束了呢……大学生活过去一大半了呢……听说大三一年过的很快，大四或在已经科研或者考研或者找工作或者去远方旅行，这么算下来大学已经时日无多了呢……而我却感觉什么也没学到啊……</p><p>如何？何如？时间不多了，想学的东西很多，大学不自学不争取真是什么都学不到呢。</p><p>而且，而且，找不到时间和空间陪自己和散自己了，不过下学期课程压力少，或许可以尝试</p><p>但是，但是，人还是迷茫的，但这和大一入学的迷茫不一样</p><p>可惜，可惜的是，这大半年来，也没什么精彩的日子也没什么难忘的记忆，没有故事也没有记录故事的人</p><p>也许，也许这就是悲剧本身吧</p><div style="text-align: center;"><p><img src="https://pic.imgdb.cn/item/64b040e51ddac507cc114a7e.jpg" style="zoom: 50%; display: inline-block;"></p></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>释怀</title>
    <link href="/2023/06/23/29/"/>
    <url>/2023/06/23/29/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>又一年有由春转夏，这一年，你释怀了吗</p><p>月亮残了又缺，这一月，她释怀了吗</p><p>天色熹微，这一天，我释怀了吗</p><p>我听见，很多人，都说释怀了。他们有的重游故地，有的擦除过往，有的去了他们曾经想去的地方。</p><p>我听说过有的人造访了我所在的学校，然后配图新修的校门，是为释怀。我想到我曾数次踏步的校园，大片的绿草地与银杏大道，我可曾释怀？我也想到无数次路过的校园，关于它的舆论我没有足够的位置评价，无力始终伴随——有曾经或讨厌或身边的人，靠着冲刺与民族加分步入了那里，也是讽刺和遗憾。曾无数次埋怨过自己的学校，批判他的体系，批评他的地位，可是他也是收留了我的地方——没了他，还不知道流落何方。</p><p>这就是可悲的人吧，生来仰望星空，长大只会看见跑不完的阶梯在天穹扶摇直上，低下了头便更没勇气抬起来。</p><p>逝去的魂灵曾经传语道，生活的痛苦永远比快乐多，贫穷、饥饿、疾病，有人仓皇奔波于痛苦本身，也有人为求知本身而感到痛苦。我们都希望是后者。但是面对人的有限性与人界的无限性，个人奔波的痛苦究竟是为了提升还是为了求生？是为了过的更体面还是为了自己的家庭？我不理解世上的大部分人，亦看不清自己。</p><p>那些释怀与不释怀的混杂在一起，飘散到脑海中。我释怀了吗？释怀了是什么？如果我释怀了为什么还记得这一切？如果我没有释怀为什么却又淡忘了？同时间赛跑人总是落后的那一方，就像我现在躺在床上消磨的时间，都是花费掉的筹码。</p><p>我面对不了这样或那样的自己，就像我还面对不了几天后的考试。我忘不掉的那些，无非是fb的赞美诗罢了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雪山</title>
    <link href="/2023/05/18/28/"/>
    <url>/2023/05/18/28/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从故事里遥遥窥见雪山那刻起，我的心就落在了那里。</p><p>那雪山好远好远的，藏在书斐薄雾与云烟里，一阵风便没了影。似乎要一生追寻它。</p><p>日以继日的奔向那个方向，那个认定的方向路荆棘密布，杂草丛生，还有一座一座的跨月不完的山涧与溪流，无数的层峦叠嶂。一不小心就会迷失了方向。</p><p>但是，在一次雨过天晴的清晨，你总是能远眺它——在那头，白雪皑皑的雪山在阳光的照耀下闪闪发光，雪山高耸，没入云端，仿佛世界尽头。凝视它，自己的心灵也能得到洗涤，灵魂在茫茫山峦中悄然升腾。</p><p>渐渐走出崇山峻岭，那天地间寒冷彻骨的风吹得你发丝凌乱，肩头沾染冰霜。你走入了客栈，为阶段性的胜利欣喜，你想睡一觉，然后再继续前行。</p><p>你醒了，雪山没有露面，空气中凝结的水露告诉你，此刻不能前行。</p><p>你决定等待，等待雨停，等待天晴，等待雪山再次出现。你在客栈里安心等待，享受着温暖的火炉和美味的食物，和来自各地的旅人们分享彼此的冒险故事。在这里，你也能发现许多新的目标和方向，等待着你去探索和挑战。你认定当雪山再次出现，你会在新的起点继续前行，越过那平野草地，到达那片未知的领域，追逐自己的梦想。在客栈里您能度过漫长的等待时间。</p><p>习惯了火炉，习惯了旅人陪伴，习惯了美食。在踏上前路变得困难时，你不得不做上了马车，来到了山脚下最大的城市，从此你爱上了康庄大道，再也跨不过泥泞的沟壑。</p><p>城市里灯火通明，人群熙攘，与之前的旅途大不相同。你沉浸在城市的喧嚣之中，开始迷失雪山的方向。在声色犬马中，努力地渴望着前进，但是却越走越远，再也看不见雪山的身影。你在城市中徘徊，渐渐变得茫然失措。</p><p>雪山的方向已经不再清晰，但你知道你还有无数的雪山——在鸡鸣狗吠声中你还是知道的——在不远处的金峰山或者最近处的玄岳山，无数的人渴望取道。</p><p>你在金峰山和玄岳山之间徘徊，试图攀登它们的高峰，但却发现这些“雪山”并不是你真正想要的。在往复的追求中，你跌倒在积雪之中……</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>散文</tag>
      
      <tag>雪山</tag>
      
      <tag>故事</tag>
      
      <tag>童话</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理实验 - 实验六：运算器设计</title>
    <link href="/2023/05/17/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/17/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实验内容">实验内容</h1><p>将算术逻辑单元与寄存器组集成，设计简单的运算器。</p><p><strong>Sin,Sout:</strong></p><table><thead><tr class="header"><th>Sin</th><th>Sout</th><th>寄存器输入信号</th><th>寄存器输出信号</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>键盘输入</td><td>PC</td></tr><tr class="even"><td>0</td><td>1</td><td>键盘输入</td><td>res，即R[RA]</td></tr><tr class="odd"><td>1</td><td>0</td><td>ALU计算结果输入</td><td>PC</td></tr><tr class="even"><td>1</td><td>1</td><td>ALU计算结果输入</td><td>res，即R[RA]</td></tr></tbody></table><p><strong>R0-R3:</strong></p><table><thead><tr class="header"><th>寄存器</th><th style="text-align: center;">控制信号 RA1 RA0 Wr Rd</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>R0</td><td style="text-align: center;">0 0 0 1</td><td>写入</td></tr><tr class="even"><td>R0</td><td style="text-align: center;">0 0 1 0</td><td>读出</td></tr><tr class="odd"><td>R1</td><td style="text-align: center;">0 1 0 1</td><td>写入</td></tr><tr class="even"><td>R1</td><td style="text-align: center;">0 1 1 0</td><td>读出</td></tr><tr class="odd"><td>R2</td><td style="text-align: center;">1 0 0 1</td><td>写入</td></tr><tr class="even"><td>R2</td><td style="text-align: center;">1 0 1 0</td><td>读出</td></tr><tr class="odd"><td>R3</td><td style="text-align: center;">1 1 0 1</td><td>写入</td></tr><tr class="even"><td>R3</td><td style="text-align: center;">11 1 0</td><td>读出</td></tr></tbody></table><p>RA控制R0~R3的选择，Wr和Rd控制输入和输出。</p><p><strong>PC：</strong></p><table><thead><tr class="header"><th>寄存器</th><th style="text-align: center;">控制信号 M1 M0</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>PC</td><td style="text-align: center;">0 0</td><td>置数</td></tr><tr class="even"><td>PC</td><td style="text-align: center;">0 1</td><td>加一计数</td></tr><tr class="odd"><td>PC</td><td style="text-align: center;">1 0</td><td>减一计数</td></tr><tr class="even"><td>PC</td><td style="text-align: center;">1 1</td><td>保持</td></tr></tbody></table><p>reset为低电平有效的PC清零信号。</p><p><strong>ALU：</strong></p><table><thead><tr class="header"><th>控制信号 s2 s1 s0</th><th>实现功能</th></tr></thead><tbody><tr class="odd"><td>000</td><td>F清零</td></tr><tr class="even"><td>001</td><td>A与B逻辑乘(&amp;)</td></tr><tr class="odd"><td>010</td><td>A与B逻辑加(|)</td></tr><tr class="even"><td>011</td><td>A与B逻辑异或(^)</td></tr><tr class="odd"><td>100</td><td>A与B算数加</td></tr><tr class="even"><td>101</td><td>A逻辑左移一位</td></tr><tr class="odd"><td>110</td><td>A逻辑右移一位</td></tr><tr class="even"><td>111</td><td>A算数右移一位</td></tr></tbody></table><h1 id="实验代码">实验代码</h1><h2 id="顶层设计">顶层设计</h2><p>注：实验和仿真时要对应的修改bdf中的Parameter的值！</p><figure><img src="https://pic2.imgdb.cn/item/646434ac0d2dde577715cc42.png"alt="bdf" /><figcaption aria-hidden="true">bdf</figcaption></figure><h2 id="cpu寄存器-cpu_register_group">CPU寄存器 CPU_register_group</h2><p>注：l用于分频，clk_alt是分频时钟信号。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> CPU_register_group(<span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] M,RA,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] D,<span class="hljs-keyword">input</span> wr,rd,reset,<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] PC,res,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] R0,R1,R2,R3);<span class="hljs-keyword">reg</span> clk_alt;<span class="hljs-keyword">reg</span> [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>] l;<span class="hljs-keyword">parameter</span> wei = <span class="hljs-number">9</span>;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-comment">//分频</span><span class="hljs-keyword">begin</span>l&lt;=l+<span class="hljs-number">1</span>;clk_alt&lt;=l[wei];<span class="hljs-keyword">end</span><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk_alt <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset) <span class="hljs-comment">//处理PC的值</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(!reset)PC = <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(M)<span class="hljs-number">0</span>:PC = D;<span class="hljs-number">1</span>:PC = PC+<span class="hljs-number">1</span>;<span class="hljs-number">2</span>:PC = PC-<span class="hljs-number">1</span>;<span class="hljs-keyword">default</span>:PC = PC;<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-comment">//处理寄存器的值</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(RA)<span class="hljs-number">0</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R0=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R0;<span class="hljs-keyword">end</span><span class="hljs-number">1</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R1=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R1;<span class="hljs-keyword">end</span><span class="hljs-number">2</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R2=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R2;<span class="hljs-keyword">end</span><span class="hljs-number">3</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R3=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R3;<span class="hljs-keyword">end</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="矩阵键盘-keymodule">矩阵键盘 keymodule</h2><p>注：COUNT_MAX用于防抖，当其小于10左右会出现抬起抖动读取，建议在实验时设置为100或1000；在仿真时设置为1。</p><p>注：因为clr绑定在按钮上，而按键按下为低电平，所以清理信号低电平有效，改为!clr。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> keymodule(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> clr,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] out);<span class="hljs-keyword">parameter</span> COUNT_MAX = <span class="hljs-number">32&#x27;d1000</span>; <span class="hljs-comment">//没有按键按下的延迟时间</span><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] cnt = <span class="hljs-number">2&#x27;d0</span>;<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] num =<span class="hljs-number">5&#x27;d16</span>;<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] count_num=COUNT_MAX;<span class="hljs-keyword">initial</span>KEY_R = <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-comment">//根据按钮的列扫描信号和行输入信号判断按钮是否被按下</span><span class="hljs-keyword">always</span>  @(<span class="hljs-keyword">posedge</span> clk,<span class="hljs-keyword">negedge</span> clr)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(!clr)<span class="hljs-keyword">begin</span>cnt&lt;=<span class="hljs-number">2&#x27;b0</span>;out&lt;=<span class="hljs-number">16&#x27;h0000</span>;count_num&lt;=COUNT_MAX; <span class="hljs-comment">//让下一次就能读取</span><span class="hljs-keyword">end</span><span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(KEY_C==<span class="hljs-number">4&#x27;b1111</span>)<span class="hljs-keyword">begin</span><span class="hljs-comment">//num = 5&#x27;d16;</span>cnt = cnt + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">case</span> (cnt)<span class="hljs-number">2&#x27;b00</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-number">2&#x27;b01</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1101</span>;<span class="hljs-number">2&#x27;b10</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1011</span>;<span class="hljs-number">2&#x27;b11</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b0111</span>;         <span class="hljs-keyword">endcase</span><span class="hljs-comment">//计数分频防止位移过快</span><span class="hljs-keyword">if</span>(count_num &lt; COUNT_MAX)count_num = count_num + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>   <span class="hljs-keyword">case</span> (&#123;KEY_C, KEY_R&#125;) <span class="hljs-number">8&#x27;b_1110_1011</span>: num = <span class="hljs-number">5&#x27;d0</span>; <span class="hljs-number">8&#x27;b_0111_0111</span>: num = <span class="hljs-number">5&#x27;d1</span>; <span class="hljs-number">8&#x27;b_0111_1011</span>: num = <span class="hljs-number">5&#x27;d2</span>; <span class="hljs-number">8&#x27;b_0111_1101</span>: num = <span class="hljs-number">5&#x27;d3</span>;  <span class="hljs-number">8&#x27;b_1011_0111</span>: num = <span class="hljs-number">5&#x27;d4</span>; <span class="hljs-number">8&#x27;b_1011_1011</span>: num = <span class="hljs-number">5&#x27;d5</span>; <span class="hljs-number">8&#x27;b_1011_1101</span>: num = <span class="hljs-number">5&#x27;d6</span>; <span class="hljs-number">8&#x27;b_1101_0111</span>: num = <span class="hljs-number">5&#x27;d7</span>;    <span class="hljs-number">8&#x27;b_1101_1011</span>: num = <span class="hljs-number">5&#x27;d8</span>; <span class="hljs-number">8&#x27;b_1101_1101</span>: num = <span class="hljs-number">5&#x27;d9</span>; <span class="hljs-number">8&#x27;b_0111_1110</span>: num = <span class="hljs-number">5&#x27;d10</span>; <span class="hljs-number">8&#x27;b_1011_1110</span>: num = <span class="hljs-number">5&#x27;d11</span>;    <span class="hljs-number">8&#x27;b_1101_1110</span>: num = <span class="hljs-number">5&#x27;d12</span>; <span class="hljs-number">8&#x27;b_1110_1110</span>: num = <span class="hljs-number">5&#x27;d13</span>; <span class="hljs-number">8&#x27;b_1110_0111</span>: num = <span class="hljs-number">5&#x27;d14</span>; <span class="hljs-number">8&#x27;b_1110_1101</span>: num = <span class="hljs-number">5&#x27;d15</span>;    <span class="hljs-keyword">endcase</span>  <span class="hljs-keyword">if</span>(count_num &gt;= COUNT_MAX) <span class="hljs-comment">//没有按键按下的空闲时间够长（防抖）</span><span class="hljs-keyword">begin</span>count_num = <span class="hljs-number">32&#x27;b0</span>;<span class="hljs-comment">//移位</span>out=out&lt;&lt;<span class="hljs-number">4</span>;out[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = num[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end KER_R!=4&#x27;b1111</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end if(clr) else</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end always</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="数码管输出-segment_displays">数码管输出 segment_displays</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> segment_displays(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] N,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] seg,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel);<span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span>sel=sel+<span class="hljs-number">1</span>;<span class="hljs-keyword">case</span>(sel)<span class="hljs-number">3&#x27;b000</span>:num=N[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>];<span class="hljs-number">3&#x27;b001</span>:num=N[<span class="hljs-number">27</span>:<span class="hljs-number">24</span>];<span class="hljs-number">3&#x27;b010</span>:num=N[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<span class="hljs-number">3&#x27;b011</span>:num=N[<span class="hljs-number">19</span>:<span class="hljs-number">16</span>];<span class="hljs-number">3&#x27;b100</span>:num=N[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>];<span class="hljs-number">3&#x27;b101</span>:num=N[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>];<span class="hljs-number">3&#x27;b110</span>:num=N[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>];<span class="hljs-number">3&#x27;b111</span>:num=N[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span>@(num)<span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(num)<span class="hljs-number">4&#x27;h0</span>:seg=<span class="hljs-number">8&#x27;b00111111</span>;<span class="hljs-comment">//&quot;0&quot;</span><span class="hljs-number">4&#x27;h1</span>:seg=<span class="hljs-number">8&#x27;b00000110</span>;<span class="hljs-comment">//&quot;1&quot;</span><span class="hljs-number">4&#x27;h2</span>:seg=<span class="hljs-number">8&#x27;b01011011</span>;<span class="hljs-comment">//&quot;2&quot;</span><span class="hljs-number">4&#x27;h3</span>:seg=<span class="hljs-number">8&#x27;b01001111</span>;<span class="hljs-comment">//&quot;3”</span><span class="hljs-number">4&#x27;h4</span>:seg=<span class="hljs-number">8&#x27;b01100110</span>;<span class="hljs-comment">//&quot;4&quot;</span><span class="hljs-number">4&#x27;h5</span>:seg=<span class="hljs-number">8&#x27;b01101101</span>;<span class="hljs-comment">//&quot;5&quot;</span><span class="hljs-number">4&#x27;h6</span>:seg=<span class="hljs-number">8&#x27;b01111101</span>;<span class="hljs-comment">//&quot;6&quot;</span><span class="hljs-number">4&#x27;h7</span>:seg=<span class="hljs-number">8&#x27;b00000111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;h8</span>:seg=<span class="hljs-number">8&#x27;b01111111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;h9</span>:seg=<span class="hljs-number">8&#x27;b01101111</span>;<span class="hljs-comment">//&quot;9&quot;</span><span class="hljs-number">4&#x27;hA</span>:seg=<span class="hljs-number">8&#x27;b01110111</span>;<span class="hljs-comment">//&quot;A&quot;</span><span class="hljs-number">4&#x27;hB</span>:seg=<span class="hljs-number">8&#x27;b01111100</span>;<span class="hljs-comment">//&quot;b&quot;</span><span class="hljs-number">4&#x27;hC</span>:seg=<span class="hljs-number">8&#x27;b00111001</span>;<span class="hljs-comment">//&quot;c&quot;</span><span class="hljs-number">4&#x27;hD</span>:seg=<span class="hljs-number">8&#x27;b01011110</span>;<span class="hljs-comment">//&quot;d&quot;</span><span class="hljs-number">4&#x27;hE</span>:seg=<span class="hljs-number">8&#x27;b01111001</span>;<span class="hljs-comment">//&quot;E&quot;</span><span class="hljs-number">4&#x27;hF</span>:seg=<span class="hljs-number">8&#x27;b01110001</span>;<span class="hljs-comment">//&quot;F&quot;</span><span class="hljs-keyword">default</span>:seg=<span class="hljs-number">8&#x27;b00000000</span>;<span class="hljs-comment">//&quot;dark&quot;</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="alu的暂存器组-midware">ALU的暂存器组 midware</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> midware(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]in,<span class="hljs-keyword">input</span> sel,<span class="hljs-keyword">input</span> wt,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] X,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Y);<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wt)<span class="hljs-keyword">if</span>(!sel)X = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">else</span>Y = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="alu运算器">ALU运算器</h2><p>注：cin绑定在按键上，所以改为!cin。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ALU(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] s,<span class="hljs-keyword">input</span> cin,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> overflow,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] F);<span class="hljs-keyword">reg</span> [<span class="hljs-number">8</span>:<span class="hljs-number">0</span>] C;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(s)<span class="hljs-number">3&#x27;b000</span>: <span class="hljs-comment">//F清零</span><span class="hljs-keyword">begin</span> overflow=<span class="hljs-number">0</span>; F=<span class="hljs-number">0</span>;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b001</span>: <span class="hljs-comment">//逻辑乘</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F=A&amp;B;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b010</span>: <span class="hljs-comment">//逻辑加</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F=A|B;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b011</span>: <span class="hljs-comment">//逻辑异或</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F=A^B;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b100</span>: <span class="hljs-comment">//算术加</span><span class="hljs-keyword">begin</span>C = &#123;A[<span class="hljs-number">7</span>],A[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125;+&#123;B[<span class="hljs-number">7</span>],B[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]&#125; + !cin;F = C[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];overflow = C[<span class="hljs-number">8</span>]^C[<span class="hljs-number">7</span>];<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b101</span>: <span class="hljs-comment">//逻辑左移</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F = &#123;A[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>],<span class="hljs-number">1&#x27;b0</span>&#125;;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b110</span>: <span class="hljs-comment">//逻辑右移</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F = &#123;<span class="hljs-number">1&#x27;b0</span>,A[<span class="hljs-number">7</span>:<span class="hljs-number">1</span>]&#125;;<span class="hljs-keyword">end</span><span class="hljs-number">3&#x27;b111</span>: <span class="hljs-comment">//算数右移</span><span class="hljs-keyword">begin</span>overflow=<span class="hljs-number">0</span>;F = &#123;A[<span class="hljs-number">7</span>],A[<span class="hljs-number">7</span>:<span class="hljs-number">1</span>]&#125;;<span class="hljs-keyword">end</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h1 id="仿真波形">仿真波形</h1><figure><img src="https://pic2.imgdb.cn/item/646434ac0d2dde577715cc8e.png"alt="仿真波形" /><figcaption aria-hidden="true">仿真波形</figcaption></figure><h1 id="引脚配置">引脚配置</h1><table><colgroup><col style="width: 11%" /><col style="width: 10%" /><col style="width: 9%" /><col style="width: 9%" /><col style="width: 9%" /><col style="width: 17%" /><col style="width: 18%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th>Node Name</th><th>Direction</th><th>Location</th><th>I/O Bark</th><th>-</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr class="odd"><td>cin</td><td>Input</td><td>PIN_AH8</td><td>3</td><td>B3_N1</td><td>PIN_AH8</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>clk</td><td>Input</td><td>PIN_A14</td><td>8</td><td>B8_N0</td><td>PIN_A14</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>clr</td><td>Input</td><td>PIN_AH7</td><td>3</td><td>B3_N2</td><td>PIN_AH7</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>key_c[3]</td><td>PIN_AE14</td><td>3</td><td>B3_N0</td><td>PIN_AE14</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="odd"><td>key_c[2]</td><td>PIN_AF13</td><td>3</td><td>B3_N1</td><td>PIN_AF13</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="even"><td>key_c[1]</td><td>PIN_AD12</td><td>3</td><td>B3_N3</td><td>PIN_AD12</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="odd"><td>key_c[0]</td><td>PIN_AD11</td><td>3</td><td>B3_N3</td><td>PIN_AD11</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="even"><td>key_out[3]</td><td>PIN_E24</td><td>6</td><td>B6_N0</td><td>PIN_E24</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>key_out[2]</td><td>PIN_F22</td><td>7</td><td>B7_N0</td><td>PIN_F22</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>key_out[1]</td><td>PIN_E22</td><td>7</td><td>B7_N0</td><td>PIN_E22</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>key_out[0]</td><td>PIN_F21</td><td>7</td><td>B7_N0</td><td>PIN_F21</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>key_r[3]</td><td>PIN_AE11</td><td>3</td><td>B3_N0</td><td>PIN_AE11</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>key_r[2]</td><td>PIN_AF11</td><td>3</td><td>B3_N1</td><td>PIN_AF11</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>key_r[1]</td><td>PIN_AE12</td><td>3</td><td>B3_N0</td><td>PIN_AE12</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>key_r[0]</td><td>PIN_AE13</td><td>3</td><td>B3_N0</td><td>PIN_AE13</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_seg[7]</td><td>PIN_M21</td><td>6</td><td>B6_N1</td><td>PIN_M21</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_seg[6]</td><td>PIN_G12</td><td>8</td><td>B8_N2</td><td>PIN_G12</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_seg[5]</td><td>PIN_G14</td><td>8</td><td>B8_N0</td><td>PIN_G14</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_seg[4]</td><td>PIN_G15</td><td>7</td><td>B7_N3</td><td>PIN_G15</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_seg[3]</td><td>PIN_G18</td><td>7</td><td>B7_N2</td><td>PIN_G18</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_seg[2]</td><td>PIN_F18</td><td>7</td><td>B7_N1</td><td>PIN_F18</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_seg[1]</td><td>PIN_G17</td><td>7</td><td>B7_N2</td><td>PIN_G17</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_seg[0]</td><td>PIN_G16</td><td>7</td><td>B7_N3</td><td>PIN_G16</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_sel[2]</td><td>PIN_G9</td><td>8</td><td>B8_N3</td><td>PIN_G9</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>LED_sel[1]</td><td>PIN_D22</td><td>7</td><td>B7_N0</td><td>PIN_D22</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>LED_sel[0]</td><td>PIN_C22</td><td>7</td><td>B7_N1</td><td>PIN_C22</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="odd"><td>M[1]</td><td>Input</td><td>PIN_AA10</td><td>3</td><td>B3_N1</td><td>PIN_AA10</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>M[0]</td><td>Input</td><td>PIN_U8</td><td>2</td><td>B2_N3</td><td>PIN_U8</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>overflow</td><td>PIN_AE8</td><td>3</td><td>B3_N3</td><td>PIN_AE8</td><td>2.5 V (default)</td><td>8mA (default)</td><td>2 (default)</td></tr><tr class="even"><td>RA[1]</td><td>PIN_AF12</td><td>3</td><td>B3_N1</td><td>PIN_AF12</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="odd"><td>RA[0]</td><td>PIN_AG12</td><td>3</td><td>B3_N0</td><td>PIN_AG12</td><td>2.5 V (default)</td><td>8mA (default)</td><td></td></tr><tr class="even"><td>rd</td><td>Input</td><td>PIN_AH6</td><td>3</td><td>B3_N2</td><td>PIN_AH6</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>reset</td><td>Input</td><td>PIN_AE3</td><td>2</td><td>B2_N3</td><td>PIN_AE3</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>s[2]</td><td>Input</td><td>PIN_AA8</td><td>2</td><td>B2_N1</td><td>PIN_AA8</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>s[1]</td><td>Input</td><td>PIN_AB8</td><td>2</td><td>B2_N3</td><td>PIN_AB8</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>s[0]</td><td>Input</td><td>PIN_AE4</td><td>2</td><td>B2_N3</td><td>PIN_AE4</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>sel</td><td>Input</td><td>PIN_AD4</td><td>2</td><td>B2_N3</td><td>PIN_AD4</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>sin</td><td>Input</td><td>PIN_AH12</td><td>3</td><td>B3_N1</td><td>PIN_AH12</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>sout</td><td>Input</td><td>PIN_AF14</td><td>3</td><td>B3_N0</td><td>PIN_AF14</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="even"><td>wr</td><td>Input</td><td>PIN_AF5</td><td>3</td><td>B3_N2</td><td>PIN_AF5</td><td>2.5 V (default)</td><td>8mA (default)</td></tr><tr class="odd"><td>wt</td><td>Input</td><td>PIN_AC5</td><td>2</td><td>B2_N3</td><td>PIN_AC5</td><td>2.5 V (default)</td><td>8mA (default)</td></tr></tbody></table><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>大学相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理实验</tag>
      
      <tag>verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理实验 - 实验五：CPU寄存器组的设计</title>
    <link href="/2023/05/10/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9ACPU%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/10/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9ACPU%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实验内容">实验内容</h1><p>实验要求:用VDH语言设计CPU寄存器组,其包括4个8位通用寄存器(R0~R3)和一个8位专用寄存器PC,R0-R3&amp;PC操作方式见下表格，之后要将PC和R0-R3(其中一个)输出并用4个数码管显示。<strong>R0-R3</strong>:</p><table><thead><tr class="header"><th>寄存器</th><th style="text-align: center;">控制信号 RA1 RA0 Wr Rd</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>R0</td><td style="text-align: center;">0 0 0 1</td><td>写入</td></tr><tr class="even"><td>R0</td><td style="text-align: center;">0 0 1 0</td><td>读出</td></tr><tr class="odd"><td>R1</td><td style="text-align: center;">0 1 0 1</td><td>写入</td></tr><tr class="even"><td>R1</td><td style="text-align: center;">0 1 1 0</td><td>读出</td></tr><tr class="odd"><td>R2</td><td style="text-align: center;">1 0 0 1</td><td>写入</td></tr><tr class="even"><td>R2</td><td style="text-align: center;">1 0 1 0</td><td>读出</td></tr><tr class="odd"><td>R3</td><td style="text-align: center;">1 1 0 1</td><td>写入</td></tr><tr class="even"><td>R3</td><td style="text-align: center;">11 1 0</td><td>读出</td></tr></tbody></table><p>RA控制R0~R3的选择，Wr和Rd控制输入和输出。</p><p><strong>PC</strong>：</p><table><thead><tr class="header"><th>寄存器</th><th style="text-align: center;">控制信号 M1 M0</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>PC</td><td style="text-align: center;">0 0</td><td>置数</td></tr><tr class="even"><td>PC</td><td style="text-align: center;">0 1</td><td>加一计数</td></tr><tr class="odd"><td>PC</td><td style="text-align: center;">1 0</td><td>减一计数</td></tr><tr class="even"><td>PC</td><td style="text-align: center;">1 1</td><td>保持</td></tr></tbody></table><p>reset为低电平有效的PC清零信号。</p><h1 id="实验代码">实验代码</h1><h2 id="顶层设计-exp5">顶层设计 exp5</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> exp5(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> clr, <span class="hljs-comment">//K[0]</span><span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] seg,<span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel,<span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] M,RA, <span class="hljs-comment">// k[6:7] K[2:3]</span><span class="hljs-keyword">input</span> wr,rd,reset, <span class="hljs-comment">// K[4] k[5] k[8]</span><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] PC,res,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] R0,R1,R2,R3,<span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] key_out);keymodule(clk,KEY_C,clr,KEY_R,key_out);CPU_register_group(M,RA,key_out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>],wr,rd,reset,clk,PC,res,R0,R1,R2,R3);segment_displays( clk,&#123;key_out,PC,res&#125;,seg,sel);<span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="cpu寄存器-cpu_register_group">CPU寄存器 CPU_register_group</h2><p>注：l用于分频，clk_alt是分频时钟信号。仿真时设置clk_alt&lt;=l[0]，实验时clk_alt&lt;=l[9]，l[9]可能还是太快了，可以设置的更高。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> CPU_register_group(<span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] M,RA,<span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] D,<span class="hljs-keyword">input</span> wr,rd,reset,<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] PC,res,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] R0,R1,R2,R3);<span class="hljs-keyword">reg</span> clk_alt;<span class="hljs-keyword">reg</span> [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>] l;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-comment">//分频</span><span class="hljs-keyword">begin</span>l&lt;=l+<span class="hljs-number">1</span>;clk_alt&lt;=l[<span class="hljs-number">9</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk_alt <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset) <span class="hljs-comment">//处理PC的值</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(!reset)PC = <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(M)<span class="hljs-number">0</span>:PC = D;<span class="hljs-number">1</span>:PC=PC+<span class="hljs-number">1</span>;<span class="hljs-number">2</span>:PC=PC-<span class="hljs-number">1</span>;<span class="hljs-keyword">default</span>:PC = PC;<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-comment">//处理寄存器的值</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(RA)<span class="hljs-number">0</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R0=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R0;<span class="hljs-keyword">end</span><span class="hljs-number">1</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R1=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R1;<span class="hljs-keyword">end</span><span class="hljs-number">2</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R2=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R2;<span class="hljs-keyword">end</span><span class="hljs-number">3</span>:<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wr==<span class="hljs-number">0</span>&amp;&amp;rd==<span class="hljs-number">1</span>)R3=D;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wr==<span class="hljs-number">1</span>&amp;&amp;rd==<span class="hljs-number">0</span>)res=R3;<span class="hljs-keyword">end</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="矩阵键盘-keymodule">矩阵键盘 keymodule</h2><p>注：COUNT_MAX用于防抖，当其小于10左右会出现抬起抖动读取，建议在实验时设置为100或1000；在仿真时设置为1。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> keymodule(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> clr,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] out);<span class="hljs-keyword">parameter</span> COUNT_MAX = <span class="hljs-number">32&#x27;d1000</span>; <span class="hljs-comment">//没有按键按下的延迟时间</span><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] cnt = <span class="hljs-number">2&#x27;d0</span>;<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] num =<span class="hljs-number">5&#x27;d16</span>;<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] count_num=COUNT_MAX;<span class="hljs-keyword">initial</span>KEY_R = <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-comment">//根据按钮的列扫描信号和行输入信号判断按钮是否被按下</span><span class="hljs-keyword">always</span>  @(<span class="hljs-keyword">posedge</span> clk,<span class="hljs-keyword">posedge</span> clr)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(clr)<span class="hljs-keyword">begin</span>cnt&lt;=<span class="hljs-number">2&#x27;b0</span>;out&lt;=<span class="hljs-number">16&#x27;h0000</span>;count_num&lt;=COUNT_MAX; <span class="hljs-comment">//让下一次就能读取</span><span class="hljs-keyword">end</span><span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(KEY_C==<span class="hljs-number">4&#x27;b1111</span>)<span class="hljs-keyword">begin</span><span class="hljs-comment">//num = 5&#x27;d16;</span>cnt = cnt + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">case</span> (cnt)<span class="hljs-number">2&#x27;b00</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-number">2&#x27;b01</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1101</span>;<span class="hljs-number">2&#x27;b10</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1011</span>;<span class="hljs-number">2&#x27;b11</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b0111</span>;         <span class="hljs-keyword">endcase</span><span class="hljs-comment">//计数分频防止位移过快</span><span class="hljs-keyword">if</span>(count_num &lt; COUNT_MAX)count_num = count_num + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>   <span class="hljs-keyword">case</span> (&#123;KEY_C, KEY_R&#125;) <span class="hljs-number">8&#x27;b_1110_1011</span>: num = <span class="hljs-number">5&#x27;d0</span>; <span class="hljs-number">8&#x27;b_0111_0111</span>: num = <span class="hljs-number">5&#x27;d1</span>; <span class="hljs-number">8&#x27;b_0111_1011</span>: num = <span class="hljs-number">5&#x27;d2</span>; <span class="hljs-number">8&#x27;b_0111_1101</span>: num = <span class="hljs-number">5&#x27;d3</span>;  <span class="hljs-number">8&#x27;b_1011_0111</span>: num = <span class="hljs-number">5&#x27;d4</span>; <span class="hljs-number">8&#x27;b_1011_1011</span>: num = <span class="hljs-number">5&#x27;d5</span>; <span class="hljs-number">8&#x27;b_1011_1101</span>: num = <span class="hljs-number">5&#x27;d6</span>; <span class="hljs-number">8&#x27;b_1101_0111</span>: num = <span class="hljs-number">5&#x27;d7</span>;    <span class="hljs-number">8&#x27;b_1101_1011</span>: num = <span class="hljs-number">5&#x27;d8</span>; <span class="hljs-number">8&#x27;b_1101_1101</span>: num = <span class="hljs-number">5&#x27;d9</span>; <span class="hljs-number">8&#x27;b_0111_1110</span>: num = <span class="hljs-number">5&#x27;d10</span>; <span class="hljs-number">8&#x27;b_1011_1110</span>: num = <span class="hljs-number">5&#x27;d11</span>;    <span class="hljs-number">8&#x27;b_1101_1110</span>: num = <span class="hljs-number">5&#x27;d12</span>; <span class="hljs-number">8&#x27;b_1110_1110</span>: num = <span class="hljs-number">5&#x27;d13</span>; <span class="hljs-number">8&#x27;b_1110_0111</span>: num = <span class="hljs-number">5&#x27;d14</span>; <span class="hljs-number">8&#x27;b_1110_1101</span>: num = <span class="hljs-number">5&#x27;d15</span>;    <span class="hljs-keyword">endcase</span>  <span class="hljs-keyword">if</span>(count_num &gt;= COUNT_MAX) <span class="hljs-comment">//没有按键按下的空闲时间够长（防抖）</span><span class="hljs-keyword">begin</span>count_num = <span class="hljs-number">32&#x27;b0</span>;<span class="hljs-comment">//移位</span>out=out&lt;&lt;<span class="hljs-number">4</span>;out[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = num[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end KER_R!=4&#x27;b1111</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end if(clr) else</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end always</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="数码管输出-segment_displays">数码管输出 segment_displays</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> segment_displays(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] N,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] seg,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel);<span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num;<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span>sel=sel+<span class="hljs-number">1</span>;<span class="hljs-keyword">case</span>(sel)<span class="hljs-number">3&#x27;b000</span>:num=N[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>];<span class="hljs-number">3&#x27;b001</span>:num=N[<span class="hljs-number">27</span>:<span class="hljs-number">24</span>];<span class="hljs-number">3&#x27;b010</span>:num=N[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<span class="hljs-number">3&#x27;b011</span>:num=N[<span class="hljs-number">19</span>:<span class="hljs-number">16</span>];<span class="hljs-number">3&#x27;b100</span>:num=N[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>];<span class="hljs-number">3&#x27;b101</span>:num=N[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>];<span class="hljs-number">3&#x27;b110</span>:num=N[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>];<span class="hljs-number">3&#x27;b111</span>:num=N[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span>@(num)<span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(num)<span class="hljs-number">4&#x27;h0</span>:seg=<span class="hljs-number">8&#x27;b00111111</span>;<span class="hljs-comment">//&quot;0&quot;</span><span class="hljs-number">4&#x27;h1</span>:seg=<span class="hljs-number">8&#x27;b00000110</span>;<span class="hljs-comment">//&quot;1&quot;</span><span class="hljs-number">4&#x27;h2</span>:seg=<span class="hljs-number">8&#x27;b01011011</span>;<span class="hljs-comment">//&quot;2&quot;</span><span class="hljs-number">4&#x27;h3</span>:seg=<span class="hljs-number">8&#x27;b01001111</span>;<span class="hljs-comment">//&quot;3”</span><span class="hljs-number">4&#x27;h4</span>:seg=<span class="hljs-number">8&#x27;b01100110</span>;<span class="hljs-comment">//&quot;4&quot;</span><span class="hljs-number">4&#x27;h5</span>:seg=<span class="hljs-number">8&#x27;b01101101</span>;<span class="hljs-comment">//&quot;5&quot;</span><span class="hljs-number">4&#x27;h6</span>:seg=<span class="hljs-number">8&#x27;b01111101</span>;<span class="hljs-comment">//&quot;6&quot;</span><span class="hljs-number">4&#x27;h7</span>:seg=<span class="hljs-number">8&#x27;b00000111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;h8</span>:seg=<span class="hljs-number">8&#x27;b01111111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;h9</span>:seg=<span class="hljs-number">8&#x27;b01101111</span>;<span class="hljs-comment">//&quot;9&quot;</span><span class="hljs-number">4&#x27;hA</span>:seg=<span class="hljs-number">8&#x27;b01110111</span>;<span class="hljs-comment">//&quot;A&quot;</span><span class="hljs-number">4&#x27;hB</span>:seg=<span class="hljs-number">8&#x27;b01111100</span>;<span class="hljs-comment">//&quot;b&quot;</span><span class="hljs-number">4&#x27;hC</span>:seg=<span class="hljs-number">8&#x27;b00111001</span>;<span class="hljs-comment">//&quot;c&quot;</span><span class="hljs-number">4&#x27;hD</span>:seg=<span class="hljs-number">8&#x27;b01011110</span>;<span class="hljs-comment">//&quot;d&quot;</span><span class="hljs-number">4&#x27;hE</span>:seg=<span class="hljs-number">8&#x27;b01111001</span>;<span class="hljs-comment">//&quot;E&quot;</span><span class="hljs-number">4&#x27;hF</span>:seg=<span class="hljs-number">8&#x27;b01110001</span>;<span class="hljs-comment">//&quot;F&quot;</span><span class="hljs-keyword">default</span>:seg=<span class="hljs-number">8&#x27;b00000000</span>;<span class="hljs-comment">//&quot;dark&quot;</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h1 id="仿真波形">仿真波形</h1><figure><img src="https://pic2.imgdb.cn/item/645afa090d2dde577701fd6c.png"alt="仿真波形" /><figcaption aria-hidden="true">仿真波形</figcaption></figure><h1 id="引脚配置">引脚配置</h1><table><thead><tr class="header"><th>信号</th><th>输出/输出</th><th>引脚</th><th>信号</th><th>输出/输出</th><th>引脚</th></tr></thead><tbody><tr class="odd"><td>KEY_C[3]</td><td>Input</td><td>PIN_AE14</td><td>rd</td><td>Input</td><td>PIN_AC5</td></tr><tr class="even"><td>KEY_C[2]</td><td>Input</td><td>PIN_AF13</td><td>reset</td><td>Input</td><td>PIN_AA10</td></tr><tr class="odd"><td>KEY_C[1]</td><td>Input</td><td>PIN_AD12</td><td>seg[7]</td><td>Output</td><td>PIN_M21</td></tr><tr class="even"><td>KEY_C[0]</td><td>Input</td><td>PIN_AD11</td><td>seg[6]</td><td>Output</td><td>PIN_G12</td></tr><tr class="odd"><td>KEY_R[3]</td><td>Output</td><td>PIN_AE11</td><td>seg[5]</td><td>Output</td><td>PIN_G14</td></tr><tr class="even"><td>KEY_R[2]</td><td>Output</td><td>PIN_AF11</td><td>seg[4]</td><td>Output</td><td>PIN_G15</td></tr><tr class="odd"><td>KEY_R[1]</td><td>Output</td><td>PIN_AE12</td><td>seg[3]</td><td>Output</td><td>PIN_G18</td></tr><tr class="even"><td>KEY_R[0]</td><td>Output</td><td>PIN_AE13</td><td>seg[2]</td><td>Output</td><td>PIN_F18</td></tr><tr class="odd"><td>M[1]</td><td>Input</td><td>PIN_AF12</td><td>seg[1]</td><td>Output</td><td>PIN_G17</td></tr><tr class="even"><td>M[0]</td><td>Input</td><td>PIN_AG12</td><td>seg[0]</td><td>Output</td><td>PIN_G16</td></tr><tr class="odd"><td>RA[1]</td><td>Input</td><td>PIN_AA8</td><td>sel[2]</td><td>Output</td><td>PIN_G9</td></tr><tr class="even"><td>RA[0]</td><td>Input</td><td>PIN_AB8</td><td>sel[1]</td><td>Output</td><td>PIN_D22</td></tr><tr class="odd"><td>clk</td><td>Input</td><td>PIN_A14</td><td>sel[0]</td><td>Output</td><td>PIN_C22</td></tr><tr class="even"><td>clr</td><td>Input</td><td>PIN_AH12</td><td>wr</td><td>Input</td><td>PIN_AE4</td></tr></tbody></table><h1 id="解释说明">解释说明</h1><figure><img src="https://pic2.imgdb.cn/item/645afa090d2dde577701fcfd.png"alt="RTL" /><figcaption aria-hidden="true">RTL</figcaption></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>大学相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理实验</tag>
      
      <tag>verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理实验 - 实验四：算数逻辑单元设计</title>
    <link href="/2023/05/06/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/06/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%20-%20%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实验内容">实验内容</h1><p>请使用文本输入方式(VerilogHDL)设计一个8位算术逻辑单元，包括控制信号与相关功能，具体如表2所示。假设暂存器A、B中的操作数均为<strong>8位补码</strong>，包含一位符号位，并使用双符号位补码进行算术加法运算，需要判断运算结果是否<strong>溢出</strong>，考虑低位进位输入Cin。如果运算结果溢出，则需要将溢出标志位Overflow置为1，否则置为0。在逻辑运算时，Overflow均置为0。对于算术右移操作，需要按照补码的算术右移规则执行。</p><table><thead><tr class="header"><th>控制信号 s2 s1 s0</th><th>实现功能</th></tr></thead><tbody><tr class="odd"><td>000</td><td>F清零</td></tr><tr class="even"><td>001</td><td>A与B逻辑乘(&amp;)</td></tr><tr class="odd"><td>010</td><td>A与B逻辑加(|)</td></tr><tr class="even"><td>011</td><td>A与B逻辑异或(^)</td></tr><tr class="odd"><td>100</td><td>A与B算数加</td></tr><tr class="even"><td>101</td><td>A逻辑左移一位</td></tr><tr class="odd"><td>110</td><td>A逻辑右移一位</td></tr><tr class="even"><td>111</td><td>A算数右移一位</td></tr></tbody></table><p>将8位ALU的运算结果输出到七位数码管，Overflow绑定到LED灯</p><p><imgsrc="https://pic1.zhimg.com/v2-3b49784ea84b01db7622e4db200a8228_b.jpg" /></p><p>Sel用于选择数据写入啷个暂存器，Wt用于控制是否读入数据。本文使用矩阵键盘输入A和B。</p><h1 id="实验代码">实验代码</h1><h2 id="顶层设计-exp_4">顶层设计 exp_4</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> exp_4(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> sel,<span class="hljs-keyword">input</span> wt,<span class="hljs-keyword">input</span> clr,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] s,<span class="hljs-keyword">input</span> cin,<span class="hljs-keyword">output</span> overflow,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] LED_seg,<span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] LED_sel,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B,<span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] F,<span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] indata,<span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num,<span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] N);keymodule (clk,KEY_R,clr,KEY_C,indata); <span class="hljs-comment">//键盘输入</span>midware (clk,indata,sel,wt,A,B);ALU (clk,s,cin,A,B,overflow,F);<span class="hljs-keyword">assign</span> N = &#123;A,B,<span class="hljs-number">8&#x27;h0</span>,F&#125;;segment_displays(clk,N,LED_seg,LED_sel,num);<span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="矩阵键盘-keymodule">矩阵键盘 keymodule</h2><p>注：COUNT_MAX用于防抖，当其小于10左右会出现抬起抖动读取，建议在实验时设置为100或1000；在仿真时设置为1。</p><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> keymodule(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_C,<span class="hljs-keyword">input</span> clr,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] KEY_R,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] out);<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] cnt = <span class="hljs-number">2&#x27;d0</span>;<span class="hljs-keyword">reg</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] num=<span class="hljs-number">5&#x27;d16</span>;<span class="hljs-keyword">reg</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] count_num=<span class="hljs-number">32&#x27;d0</span>;<span class="hljs-keyword">parameter</span> COUNT_MAX = <span class="hljs-number">32&#x27;d100</span>; <span class="hljs-comment">//没有按键按下的延迟时间</span><span class="hljs-keyword">initial</span><span class="hljs-keyword">begin</span>KEY_R = <span class="hljs-number">4&#x27;b0111</span>;count_num = COUNT_MAX; <span class="hljs-comment">//让第一次就能读取</span><span class="hljs-keyword">end</span><span class="hljs-comment">//根据按钮的列扫描信号和行输入信号判断按钮是否被按下</span><span class="hljs-keyword">always</span>  @(<span class="hljs-keyword">posedge</span> clk,<span class="hljs-keyword">posedge</span> clr)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(clr)<span class="hljs-keyword">begin</span>cnt&lt;=<span class="hljs-number">2&#x27;b0</span>;out&lt;=<span class="hljs-number">16&#x27;h0000</span>;count_num&lt;=COUNT_MAX; <span class="hljs-comment">//让下一次就能读取</span><span class="hljs-keyword">end</span><span class="hljs-keyword">else</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(KEY_C==<span class="hljs-number">4&#x27;b1111</span>)<span class="hljs-keyword">begin</span><span class="hljs-comment">//num = 5&#x27;d16;</span>cnt = cnt + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">case</span> (cnt)<span class="hljs-number">2&#x27;b00</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1110</span>;<span class="hljs-number">2&#x27;b01</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1101</span>;<span class="hljs-number">2&#x27;b10</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b1011</span>;<span class="hljs-number">2&#x27;b11</span>:KEY_R &lt;= <span class="hljs-number">4&#x27;b0111</span>;         <span class="hljs-keyword">endcase</span><span class="hljs-comment">//计数分频防止位移过快</span><span class="hljs-keyword">if</span>(count_num &lt; COUNT_MAX)count_num = count_num + <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>   <span class="hljs-keyword">case</span> (&#123;KEY_R, KEY_C&#125;) <span class="hljs-number">8&#x27;b1011_1110</span>: num = <span class="hljs-number">5&#x27;d0</span>; <span class="hljs-number">8&#x27;b0111_0111</span>: num = <span class="hljs-number">5&#x27;d1</span>; <span class="hljs-number">8&#x27;b1011_0111</span>: num = <span class="hljs-number">5&#x27;d2</span>; <span class="hljs-number">8&#x27;b1101_0111</span>: num = <span class="hljs-number">5&#x27;d3</span>;  <span class="hljs-number">8&#x27;b0111_1011</span>: num = <span class="hljs-number">5&#x27;d4</span>; <span class="hljs-number">8&#x27;b1011_1011</span>: num = <span class="hljs-number">5&#x27;d5</span>; <span class="hljs-number">8&#x27;b1101_1011</span>: num = <span class="hljs-number">5&#x27;d6</span>; <span class="hljs-number">8&#x27;b0111_1101</span>: num = <span class="hljs-number">5&#x27;d7</span>;    <span class="hljs-number">8&#x27;b1011_1101</span>: num = <span class="hljs-number">5&#x27;d8</span>; <span class="hljs-number">8&#x27;b1101_1101</span>: num = <span class="hljs-number">5&#x27;d9</span>; <span class="hljs-number">8&#x27;b1110_0111</span>: num = <span class="hljs-number">5&#x27;d10</span>; <span class="hljs-number">8&#x27;b1110_1011</span>: num = <span class="hljs-number">5&#x27;d11</span>;    <span class="hljs-number">8&#x27;b1110_1101</span>: num = <span class="hljs-number">5&#x27;d12</span>; <span class="hljs-number">8&#x27;b1110_1110</span>: num = <span class="hljs-number">5&#x27;d13</span>; <span class="hljs-number">8&#x27;b0111_1110</span>: num = <span class="hljs-number">5&#x27;d14</span>; <span class="hljs-number">8&#x27;b1101_1110</span>: num = <span class="hljs-number">5&#x27;d15</span>;    <span class="hljs-keyword">endcase</span>  <span class="hljs-keyword">if</span>(count_num &gt;= COUNT_MAX) <span class="hljs-comment">//没有按键按下的空闲时间够长（防抖）</span><span class="hljs-keyword">begin</span>count_num = <span class="hljs-number">32&#x27;b0</span>;<span class="hljs-comment">//移位</span>out=out&lt;&lt;<span class="hljs-number">4</span>;out[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = num[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end KER_R!=4&#x27;b1111</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end if(clr) else</span><span class="hljs-keyword">end</span> <span class="hljs-comment">//end always</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="暂存器-midware">暂存器 midware</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> midware(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]in,<span class="hljs-keyword">input</span> sel,<span class="hljs-keyword">input</span> wt,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] X,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Y);<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><span class="hljs-keyword">if</span>(wt)<span class="hljs-keyword">if</span>(sel)X = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">else</span>Y = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h2 id="数码管输出-segment_displays">数码管输出 segment_displays</h2><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> segment_displays(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] N,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] seg,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num);<span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span>sel=sel+<span class="hljs-number">1</span>;<span class="hljs-keyword">case</span>(sel)<span class="hljs-number">3&#x27;b111</span>:num=N[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<span class="hljs-number">3&#x27;b110</span>:num=N[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>];<span class="hljs-number">3&#x27;b101</span>:num=N[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>];<span class="hljs-number">3&#x27;b100</span>:num=N[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>];<span class="hljs-number">3&#x27;b011</span>:num=N[<span class="hljs-number">19</span>:<span class="hljs-number">16</span>];<span class="hljs-number">3&#x27;b010</span>:num=N[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<span class="hljs-number">3&#x27;b001</span>:num=N[<span class="hljs-number">27</span>:<span class="hljs-number">24</span>];<span class="hljs-number">3&#x27;b000</span>:num=N[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>];<span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">always</span>@(num)<span class="hljs-keyword">begin</span><span class="hljs-keyword">case</span>(num)<span class="hljs-number">4&#x27;b0000</span>:seg=<span class="hljs-number">8&#x27;b00111111</span>;<span class="hljs-comment">//&quot;0&quot;</span><span class="hljs-number">4&#x27;b0001</span>:seg=<span class="hljs-number">8&#x27;b00000110</span>;<span class="hljs-comment">//&quot;1&quot;</span><span class="hljs-number">4&#x27;b0010</span>:seg=<span class="hljs-number">8&#x27;b01011011</span>;<span class="hljs-comment">//&quot;2&quot;</span><span class="hljs-number">4&#x27;b0011</span>:seg=<span class="hljs-number">8&#x27;b01001111</span>;<span class="hljs-comment">//&quot;3”</span><span class="hljs-number">4&#x27;b0100</span>:seg=<span class="hljs-number">8&#x27;b01100110</span>;<span class="hljs-comment">//&quot;4&quot;</span><span class="hljs-number">4&#x27;b0101</span>:seg=<span class="hljs-number">8&#x27;b01101101</span>;<span class="hljs-comment">//&quot;5&quot;</span><span class="hljs-number">4&#x27;b0110</span>:seg=<span class="hljs-number">8&#x27;b01111101</span>;<span class="hljs-comment">//&quot;6&quot;</span><span class="hljs-number">4&#x27;b0111</span>:seg=<span class="hljs-number">8&#x27;b00000111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;b1000</span>:seg=<span class="hljs-number">8&#x27;b01111111</span>;<span class="hljs-comment">//&quot;8&quot;</span><span class="hljs-number">4&#x27;b1001</span>:seg=<span class="hljs-number">8&#x27;b01101111</span>;<span class="hljs-comment">//&quot;9&quot;</span><span class="hljs-number">4&#x27;b1010</span>:seg=<span class="hljs-number">8&#x27;b01110111</span>;<span class="hljs-comment">//&quot;A&quot;</span><span class="hljs-number">4&#x27;b1011</span>:seg=<span class="hljs-number">8&#x27;b01111100</span>;<span class="hljs-comment">//&quot;b&quot;</span><span class="hljs-number">4&#x27;b1100</span>:seg=<span class="hljs-number">8&#x27;b00111001</span>;<span class="hljs-comment">//&quot;c&quot;</span><span class="hljs-number">4&#x27;b1101</span>:seg=<span class="hljs-number">8&#x27;b01011110</span>;<span class="hljs-comment">//&quot;d&quot;</span><span class="hljs-number">4&#x27;b1110</span>:seg=<span class="hljs-number">8&#x27;b01111001</span>;<span class="hljs-comment">//&quot;E&quot;</span><span class="hljs-number">4&#x27;b1111</span>:seg=<span class="hljs-number">8&#x27;b01110001</span>;<span class="hljs-comment">//&quot;F&quot;</span><span class="hljs-keyword">default</span>:seg=<span class="hljs-number">8&#x27;b00000000</span>;<span class="hljs-comment">//&quot;dark&quot;</span><span class="hljs-keyword">endcase</span><span class="hljs-keyword">end</span><span class="hljs-keyword">endmodule</span></code></pre></div><h1 id="仿真波形">仿真波形</h1><figure><img src="https://pic2.imgdb.cn/item/6455bd1a0d2dde577758c113.png"alt="仿真" /><figcaption aria-hidden="true">仿真</figcaption></figure><h1 id="引脚配置">引脚配置</h1><figure><img src="https://pic2.imgdb.cn/item/6455bd1a0d2dde577758c166.png"alt="引脚绑定" /><figcaption aria-hidden="true">引脚绑定</figcaption></figure><h1 id="解释说明">解释说明</h1><p>注：有很多没有分配引脚的输出信号是为了方便在仿真的时候调试，可以把他们移除输出，改为wire。</p><figure><img src="https://pic2.imgdb.cn/item/6455bd190d2dde577758c09c.png"alt="RTL" /><figcaption aria-hidden="true">RTL</figcaption></figure><p><imgsrc="https://pic2.imgdb.cn/item/6455bd190d2dde577758c0c9.png" /></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>大学相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
      <tag>计算机组成原理实验</tag>
      
      <tag>verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西南交通大学转专业与一般事务指南</title>
    <link href="/2023/03/24/27%E8%BD%AC%E4%B8%93%E4%B8%9A%E6%8C%87%E5%8D%97/"/>
    <url>/2023/03/24/27%E8%BD%AC%E4%B8%93%E4%B8%9A%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="更新日志">更新日志</h1><ul><li>2023/03/24 完成转专业后事务的课程替代和冲突选课部分</li><li>2023/06/29完成转专业后事务的选课、评奖评优、换宿舍部分和资源与信息部分</li><li>2023/07/03 修复了图片图床和转跳联结失效问题，补充了初审流程</li><li>2023/08/06 图片使用本地图片，更改了一些细节</li><li>2023/08/30 面试部分增加了内容</li></ul><h1 id="写在前面">写在前面</h1><p>这是一篇残缺的转专业指南，早在2022年9月转专业成功前后就想写了，但因为种种原因一直没写（忙、懒、已经有完善的指南了），如今已经过去半年之多很多细节也记不起来了。</p><p>学长说他觉得转专业毁了他两年的大学生活，对我来说——可能毁了一年吧。因为学长除了要补离散、OOP、高级语言程序设计外还要补修大物，相比起来我已经好多了……</p><h2 id="关于我">关于我</h2><ul><li>年级：2021级</li><li>原专业：交运学院 - 物流工程</li><li>现专业：计算机学院 - 软件工程</li></ul><h1 id="资源与信息">资源与信息</h1><h2 id="通知汇总">通知汇总</h2><p>每年的通知与时间结点都大致相同。</p><h3 id="教务网---转专业细则">教务网 - 转专业细则</h3><p>各学院转专业细则都在每年寒假给出</p><ul><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=C4F78F220DEF855D">关于公布2023年各学院转专业实施细则的通知</a>- 2022/12/22</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=0C0F62F3F20CEB30">关于公布2022年各学院转专业实施细则的通知</a>- 2021/12/18</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=A2D8ED682A8E583B">关于公布2021年各学院转专业实施细则的通知</a>- 2020/12/31</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=9C52FAC812FB848E">关于公布2020年各学院转专业实施细则的通知</a>- 2019/12/19</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=6AF9850FCAF7B593">关于公布2019年各学院转专业实施细则的通知</a>- 2018/12/18</li></ul><p>其中包含每年的重要文件：<ahref="http://jwc.swjtu.edu.cn/download/ueditor/jsp/upload/file/20221227/1672138715705083837.zip"><strong>学院转专业实施细则</strong></a></p><h3 id="教务网---转专业相关工作的通知初审">教务网 -转专业相关工作的通知（初审）</h3><ul><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=68B780B8696CB0FA">关于开展2022年本科生转专业相关工作的通知</a>- 2022/07/11</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=145C7B6E0890730D">关于开展2021年本科生转专业相关工作的通知</a>- 2021/07/23</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=9426D03269831795">关于2020年本科生转专业相关工作的通知</a>- 2020/07/15</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=E39111921A3869DE">关于2019年本科生转专业相关工作的通知</a>- 1019/07/11</li></ul><p>包含重要信息：转专业<strong>网上申请</strong>时间与安排</p><h3 id="教务网---转专业学院层面相关安排通知各学院考核安排">教务网 -转专业学院层面相关安排通知（各学院考核安排）</h3><ul><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=101EBE5E9BF0EDC1">2022年本科生转专业学院层面相关安排通知（动态更新）</a>- 2022/08/30</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=B7ABA971C04521A5">2020年本科生转专业学院考核、公示相关安排（动态更新）</a>- 2020/09/15</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=48140E7571915A12">2019年转专业学院考核安排通知及公示情况（持续更新）</a>- 2019/08/23</li></ul><p>可能包含的重要信息：入围结果、考核安排、联系方式</p><p>好像很多学院都会拉一个<strong>官方QQ群</strong>进行通知。</p><h3 id="教务网---转专业名单公示">教务网 - 转专业名单公示</h3><ul><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=00760F9760F3752F">西南交通大学2022年本科生转专业名单公示</a>- 2022/09/15</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=C65E90F019234F9C">西南交通大学2018年本科生转专业名单公示</a>- 2018/09/20</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=DEA3842E116C315C">西南交通大学2017年本科生转专业名单公示</a>- 2017/09/15</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=5403685A87EF2AD3">西南交通大学2016年本科生转专业名单公示</a>- 2016/09/03</li><li><ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=25ABAB0697CFE335">西南交通大学2015年本科生转专业名单公示</a>- 2015/06/24</li></ul><p>重要文件：<ahref="http://jwc.swjtu.edu.cn/download/ueditor/jsp/upload/file/20220915/1663207815880017041.pdf">转专业名单</a></p><p><img src="2022转专业流动图（学院）.png" alt="2022转专业流动图（学院）" style="zoom: 30%;" /></p><p><img src="2022转专业流动图（专业）.png" alt="2022转专业流动图（专业）" style="zoom: 11%;" /></p><h3 id="学院官网---转专业名单公示计院">学院官网 -转专业名单公示（计院）</h3><ul><li><ahref="https://scai.swjtu.edu.cn/web/page-newsDetail.html?nid=c9923259-db46-444e-86c6-ee43fb03cb29">计算机与人工智能学院2022年转专业拟录取名单公示</a>- 2022/09/08</li><li><ahref="https://scai.swjtu.edu.cn/web/page-newsDetail.html?nid=c9f799b9-c287-4c99-bce2-881d98f70157">计算机学院2021年转专业拟录取名单公示</a>- 2021/09/18</li></ul><h2 id="各专业培养计划">各专业培养计划</h2><p>教务处 - <ahref="http://jwc.swjtu.edu.cn/vatuu/PublicInfoQueryAction?setAction=queryProgram">公共信息查询- 各培养计划下载</a></p><h2 id="群聊与咨询">群聊与咨询</h2><p>两个转专业交流群：</p><ul><li><ahref="http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=14vW7myw7a4F26rMWi7lxxgPkEO-wQHu&amp;authKey=xIUNlAa%2FLUC9dICIBeGIigGmKY45ZwrRZ4IcAa%2BtGmHii7XZTS1wzgL2wxf6kvPN&amp;noverify=0&amp;group_code=1058118797">转专业交流群</a></li><li><ahref="http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=BJGEUoUFq1b0lQxs45NwctxcBwkLezNk&amp;authKey=r2PP99mrAJgBE%2FVYPnIvwGaHlFSMHedIWmXpTiNmgbkCouQ2aAnSdyxHtkO1sJbp&amp;noverify=0&amp;group_code=423276278">西南交通大学转专业交流群</a></li></ul><p><img src="群1.png" alt="群1" style="zoom: 30%;" /></p><p><img src="群2.png" alt="群2" style="zoom: 30%;" /></p><p>群中有很多大佬和已经转专业成功的学长学姐，可以进行询问，平时也会发些相关通知在群里。</p><p>但是群聊可能造成信息冗杂、信息焦虑和引起焦虑，建议加入群助手。</p><h2 id="转专业资料">转专业资料</h2><p>我的转专业文件</p><ul><li><p>链接: https://pan.baidu.com/s/1vtmst5VZeEjxRwRAMIchWw?pwd=eq1y提取码: eq1y</p><div style="display: flex; justify-content: center;"><img src="转专业资料.jpg" alt="文件" style="zoom: 70%;" /></div></li></ul><h2 id="转专业分数线">转专业分数线</h2><h3 id="年转计院进入面试分数线">2022年转计院进入面试分数线</h3><figure><img src="rank.png" alt="2022计院分数线" /><figcaption aria-hidden="true">2022计院分数线</figcaption></figure><p>来源于<ahref="https://scai.swjtu.edu.cn/web/page-newsDetail.html?nid=563bf522-0548-448f-bb79-2c5aad260fbd">计算机学院2022年学生转专业考试及面试安排</a>附件。</p><p>注：其中<strong>浅蓝色背景的获得了面试资格</strong>，进入面试。</p><h2 id="专业推免数据专业卷与否">专业推免数据（专业卷与否）</h2><h3 id="届全校推免数据">2022 届全校推免数据</h3><table><colgroup><col style="width: 47%" /><col style="width: 9%" /><col style="width: 9%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /></colgroup><thead><tr class="header"><th>专业</th><th>推免指标</th><th>专业人数</th><th>推免最低分</th><th>推免平均分</th><th>一般推免率</th></tr></thead><tbody><tr class="odd"><td>土木工程</td><td>126</td><td>643</td><td>83.74</td><td>87.149</td><td>18.82%</td></tr><tr class="even"><td>铁道工程</td><td>28</td><td>145</td><td>82.112</td><td>86.664</td><td>18.62%</td></tr><tr class="odd"><td>城市地下空间工程</td><td>12</td><td>114</td><td>81.988</td><td>85.641</td><td>10.53%</td></tr><tr class="even"><td>道路桥梁与渡河工程</td><td>16</td><td>105</td><td>82.636</td><td>86.792</td><td>14.29%</td></tr><tr class="odd"><td>机械设计制造及其自动化</td><td>44</td><td>254</td><td>82.754</td><td>87.172</td><td>16.93%</td></tr><tr class="even"><td>测控技术与仪器</td><td>11</td><td>59</td><td>89.4</td><td>90.528</td><td>16.95%</td></tr><tr class="odd"><td>车辆工程</td><td>33</td><td>188</td><td>84.492</td><td>88.182</td><td>17.55%</td></tr><tr class="even"><td>工业工程</td><td>9</td><td>52</td><td>82.376</td><td>84.566</td><td>15.38%</td></tr><tr class="odd"><td>能源与动力工程</td><td>4</td><td>30</td><td>80.291</td><td>82.326</td><td>13.33%</td></tr><tr class="even"><td>建筑环境与能源应用工程</td><td>9</td><td>53</td><td>84.359</td><td>86.33</td><td>15.09%</td></tr><tr class="odd"><td>交通设备与控制工程</td><td>23</td><td>134</td><td>81.858</td><td>85.949</td><td>17.16%</td></tr><tr class="even"><td>电气工程及其自动化(电力电子与传动控制)</td><td>19</td><td>101</td><td>87.952</td><td>90.223</td><td>17.82%</td></tr><tr class="odd"><td>电子信息工程</td><td>26</td><td>131</td><td>88.455</td><td>91.583</td><td>17.56%</td></tr><tr class="even"><td>电气工程及其自动化(城轨与磁浮交通电气化)</td><td>4</td><td>23</td><td>87.183</td><td>88.867</td><td>13.04%</td></tr><tr class="odd"><td>电气工程及其自动化(轨道交通供电及其自动化)</td><td>17</td><td>96</td><td>88.113</td><td>90.453</td><td>17.71%</td></tr><tr class="even"><td>电气工程及其自动化(电力系统及其自动化)</td><td>19</td><td>107</td><td>87.146</td><td>90.513</td><td>17.76%</td></tr><tr class="odd"><td>电气工程与智能控制</td><td>20</td><td>120</td><td>85.106</td><td>89.172</td><td>16.67%</td></tr><tr class="even"><td>电气工程及其自动化(功率半导体器件及应用)</td><td>4</td><td>8</td><td>83.186</td><td>84.927</td><td>50.00%</td></tr><tr class="odd"><td>通信工程</td><td>18</td><td>97</td><td>87.954</td><td>91.206</td><td>17.53%</td></tr><tr class="even"><td>自动化</td><td>11</td><td>62</td><td>87.382</td><td>90.73</td><td>17.74%</td></tr><tr class="odd"><td>电子科学与技术(微电子技术)</td><td>11</td><td>62</td><td>83.428</td><td>89.695</td><td>17.74%</td></tr><tr class="even"><td>轨道交通信号与控制</td><td>17</td><td>89</td><td>85.732</td><td>89.623</td><td>17.98%</td></tr><tr class="odd"><td>网络工程(铁道信号)</td><td>25</td><td>140</td><td>85.191</td><td>87.584</td><td>17.14%</td></tr><tr class="even"><td>交通运输</td><td>31</td><td>147</td><td>85.84</td><td>89.137</td><td>18.37%</td></tr><tr class="odd"><td>交通工程</td><td>19</td><td>94</td><td>86.374</td><td>88.347</td><td>18.09%</td></tr><tr class="even"><td>安全工程</td><td>4</td><td>28</td><td>82.841</td><td>86.184</td><td>14.29%</td></tr><tr class="odd"><td>交通运输(城市轨道交通)</td><td>18</td><td>118</td><td>85.466</td><td>88.784</td><td>15.25%</td></tr><tr class="even"><td>交通运输(詹天佑学院)</td><td>8</td><td>29</td><td>85.551</td><td>87.328</td><td>27.59%</td></tr><tr class="odd"><td>物流工程</td><td>16</td><td>88</td><td>86.637</td><td>89.493</td><td>17.05%</td></tr><tr class="even"><td>物流管理</td><td>6</td><td>30</td><td>86.172</td><td>88.076</td><td>16.67%</td></tr><tr class="odd"><td>信息管理与信息系统</td><td>11</td><td>77</td><td>89.294</td><td>91.753</td><td>14.29%</td></tr><tr class="even"><td>工商管理</td><td>6</td><td>41</td><td>87.306</td><td>88.112</td><td>12.20%</td></tr><tr class="odd"><td>会计学</td><td>11</td><td>75</td><td>90.803</td><td>93.128</td><td>14.67%</td></tr><tr class="even"><td>工程管理</td><td>5</td><td>36</td><td>84.101</td><td>86.104</td><td>13.89%</td></tr><tr class="odd"><td>金融学</td><td>11</td><td>76</td><td>87.125</td><td>90.869</td><td>14.47%</td></tr><tr class="even"><td>经济学</td><td>11</td><td>74</td><td>84.427</td><td>86.051</td><td>13.51%</td></tr><tr class="odd"><td>汉语言文学</td><td>11</td><td>72</td><td>88.469</td><td>89.506</td><td>12.50%</td></tr><tr class="even"><td>音乐表演</td><td>6</td><td>61</td><td>86.025</td><td>87.511</td><td>9.84%</td></tr><tr class="odd"><td>传播学</td><td>10</td><td>75</td><td>89.276</td><td>90.661</td><td>12.00%</td></tr><tr class="even"><td>广告学</td><td>7</td><td>58</td><td>89.259</td><td>91.373</td><td>12.07%</td></tr><tr class="odd"><td>英语</td><td>6</td><td>47</td><td>90.2</td><td>91.717</td><td>12.77%</td></tr><tr class="even"><td>日语</td><td>3</td><td>25</td><td>92.872</td><td>93.226</td><td>12.00%</td></tr><tr class="odd"><td>德语</td><td>4</td><td>28</td><td>87.939</td><td>89.329</td><td>14.29%</td></tr><tr class="even"><td>法语</td><td>3</td><td>25</td><td>92.486</td><td>92.922</td><td>12.00%</td></tr><tr class="odd"><td>翻译</td><td>8</td><td>51</td><td>90.632</td><td>91.887</td><td>13.73%</td></tr><tr class="even"><td>汉语国际教育</td><td>6</td><td>45</td><td>92.34</td><td>93.192</td><td>13.33%</td></tr><tr class="odd"><td>商务英语</td><td>6</td><td>42</td><td>89.149</td><td>90.909</td><td>14.29%</td></tr><tr class="even"><td>绘画</td><td>3</td><td>28</td><td>85.966</td><td>88.101</td><td>10.71%</td></tr><tr class="odd"><td>建筑学</td><td>10</td><td>85</td><td>87.474</td><td>89.546</td><td>11.76%</td></tr><tr class="even"><td>城乡规划</td><td>6</td><td>45</td><td>88.427</td><td>88.827</td><td>11.11%</td></tr><tr class="odd"><td>风景园林</td><td>6</td><td>46</td><td>86.212</td><td>89.21</td><td>13.04%</td></tr><tr class="even"><td>视觉传达设计</td><td>8</td><td>63</td><td>85.951</td><td>87.294</td><td>11.11%</td></tr><tr class="odd"><td>环境设计</td><td>10</td><td>89</td><td>85.589</td><td>87.23</td><td>11.24%</td></tr><tr class="even"><td>产品设计</td><td>7</td><td>62</td><td>89.741</td><td>90.873</td><td>11.29%</td></tr><tr class="odd"><td>生物医学工程</td><td>9</td><td>53</td><td>85.029</td><td>88.876</td><td>16.98%</td></tr><tr class="even"><td>材料科学与工程(金属材料)</td><td>11</td><td>80</td><td>83.071</td><td>86.866</td><td>13.75%</td></tr><tr class="odd"><td>材料科学与工程(高分子材料)</td><td>12</td><td>67</td><td>86.4</td><td>89.233</td><td>17.91%</td></tr><tr class="even"><td>材料科学与工程(无机非金属)</td><td>5</td><td>11</td><td>82.331</td><td>84.815</td><td>45.45%</td></tr><tr class="odd"><td>材料成型及控制工程</td><td>13</td><td>76</td><td>83.237</td><td>87.201</td><td>17.11%</td></tr><tr class="even"><td>工程力学</td><td>28</td><td>115</td><td>86.186</td><td>90.164</td><td>21.74%</td></tr><tr class="odd"><td>飞行器设计与工程</td><td>7</td><td>30</td><td>80.394</td><td>87.026</td><td>23.33%</td></tr><tr class="even"><td>数学与应用数学</td><td>14</td><td>77</td><td>84.619</td><td>89.232</td><td>16.88%</td></tr><tr class="odd"><td>统计学</td><td>12</td><td>75</td><td>82.564</td><td>88.631</td><td>14.67%</td></tr><tr class="even"><td>电子信息科学与技术（光电子）</td><td>16</td><td>119</td><td>85.553</td><td>88.818</td><td>13.45%</td></tr><tr class="odd"><td>应用物理学</td><td>13</td><td>81</td><td>83.909</td><td>88.738</td><td>14.81%</td></tr><tr class="even"><td>电子信息科学与技术（电磁场）</td><td>17</td><td>96</td><td>86</td><td>90.006</td><td>14.58%</td></tr><tr class="odd"><td>计算机科学与技术</td><td>21</td><td>116</td><td>89.11</td><td>91.992</td><td>17.24%</td></tr><tr class="even"><td>软件工程</td><td>18</td><td>104</td><td>87.721</td><td>90.791</td><td>17.31%</td></tr><tr class="odd"><td>制药工程</td><td>16</td><td>107</td><td>87.519</td><td>90.081</td><td>13.08%</td></tr><tr class="even"><td>生物工程(生物制药)</td><td>8</td><td>56</td><td>84.308</td><td>89.001</td><td>14.29%</td></tr><tr class="odd"><td>生物工程(生物学)</td><td>4</td><td>21</td><td>81.561</td><td>87.843</td><td>19.05%</td></tr><tr class="even"><td>生物工程(生物信息)</td><td>4</td><td>25</td><td>86.264</td><td>90.075</td><td>16.00%</td></tr><tr class="odd"><td>测绘工程</td><td>10</td><td>63</td><td>83.016</td><td>85.879</td><td>15.87%</td></tr><tr class="even"><td>地质工程</td><td>12</td><td>66</td><td>82.835</td><td>85.198</td><td>16.67%</td></tr><tr class="odd"><td>遥感科学与技术</td><td>11</td><td>64</td><td>86.785</td><td>89.54</td><td>17.19%</td></tr><tr class="even"><td>环境工程</td><td>14</td><td>79</td><td>86.194</td><td>88.229</td><td>16.46%</td></tr><tr class="odd"><td>消防工程</td><td>10</td><td>58</td><td>80.368</td><td>83.103</td><td>17.24%</td></tr><tr class="even"><td>地理信息科学</td><td>10</td><td>56</td><td>87.279</td><td>89.701</td><td>16.07%</td></tr><tr class="odd"><td>资源勘查工程</td><td>3</td><td>18</td><td>85.321</td><td>86.099</td><td>16.67%</td></tr><tr class="even"><td>安全科学与工程类(中外合作办学)</td><td>9</td><td>59</td><td>85.693</td><td>88.894</td><td>15.25%</td></tr><tr class="odd"><td>法学</td><td>13</td><td>104</td><td>88.267</td><td>89.613</td><td>12.50%</td></tr><tr class="even"><td>政治学与行政学</td><td>3</td><td>20</td><td>87.941</td><td>89.937</td><td>15.00%</td></tr><tr class="odd"><td>公共事业管理</td><td>11</td><td>81</td><td>86.795</td><td>89.797</td><td>12.35%</td></tr><tr class="even"><td>思想政治教育</td><td>7</td><td>40</td><td>89.4</td><td>91.613</td><td>15.00%</td></tr><tr class="odd"><td>土木工程(利兹)</td><td>8</td><td>65</td><td>89.87</td><td>92.084</td><td>12.31%</td></tr><tr class="even"><td>机械设计制造及其自动化(利兹)</td><td>8</td><td>65</td><td>85.605</td><td>89.01</td><td>12.31%</td></tr><tr class="odd"><td>电子信息工程(利兹)</td><td>9</td><td>74</td><td>90.694</td><td>91.914</td><td>10.81%</td></tr><tr class="even"><td>计算机科学与技术(利兹)</td><td>9</td><td>74</td><td>92.793</td><td>94.476</td><td>12.16%</td></tr><tr class="odd"><td>应用心理学</td><td>6</td><td>42</td><td>92.411</td><td>93.784</td><td>14.29%</td></tr></tbody></table><p>来源于<a href="https://wiki.swjtu.top/free_major/">专业推免详细数据 |SWJTU-Wiki</a>。</p><p>从分数线可以大概了解一个专业保研压力大不大，和卷不卷。</p><h1 id="转专业重要事件结点">转专业重要事件结点</h1><h2 id="初审">初审</h2><p>时间：暑假</p><p>根据<ahref="#教务网-转专业相关工作的通知初审">转专业相关工作的通知</a>在提交转专业申请后，会对你个人进行初步的审核，这一步中便会筛选出部分同学，再进行之后的考核工作。</p><p>注意：要转专业的同学<strong>不建议实习替代</strong>！！因为实习替代会先打0分再替代，可能时间上赶不上初审申请结束时间，而拉低平均分。</p><h3 id="申请流程">申请流程</h3><p><a href="http://jwc.swjtu.edu.cn/vatuu/UserFramework">教务系统</a> -<ahref="https://jiaowu.swjtu.edu.cn/vatuu/WebSite?setAction=index"><code>网上办事</code></a></p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a256c71ddac507cc82aa74.jpg" style="zoom:25%;" /></div><p><ahref="https://jiaowu.swjtu.edu.cn/vatuu/WebSite?setAction=index">网上办事平台</a>- 转专业申请</p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a257431ddac507cc839f7b.jpg" style="zoom:25%;" /></div><p>转专业申请 - <code>点此申请</code></p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a257a21ddac507cc845328.jpg" style="zoom:25%;" /></div><p>此处也可以查看专业转入要求，然后点击<code>申请</code>进行转专业申请。</p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a259011ddac507cc86b6a8.jpg" style="zoom:25%;" /></div><p>会自动生成平均成绩、四六级成绩等相关信息，你只用填写申请理由、附件等就行了。</p><p>最后结果大致如下：</p><div style="display: flex; justify-content: center;"><img src="https://pic.imgdb.cn/item/64a259a61ddac507cc87d7e2.jpg" style="zoom:33%;" /></div><h2 id="笔试">笔试</h2><p>根据<ahref="#教务网-转专业学院层面相关安排通知各学院考核安排">各学院安排</a>，一般会有短信或者QQ群通知。</p><p>时间：开学第一周</p><p>我没有经历笔试……</p><blockquote><p>可以参考<ahref="https://blog.supersassw.com/p/univ-exchange_major/#笔试">西南交通大学转专业指南- 笔试</a></p></blockquote><h2 id="机考">机考</h2><p>根据<ahref="#教务网-转专业学院层面相关安排通知各学院考核安排">各学院安排</a>，一般会有短信或者QQ群通知。</p><p>时间：开学第一周</p><p>我没有参加机考，用CSP替代的……</p><blockquote><p>建议参看<ahref="https://blog.supersassw.com/p/univ-exchange_major/#机考">西南交通大学转专业指南- 机考</a></p></blockquote><h2 id="面试">面试</h2><p>根据<ahref="#教务网-转专业学院层面相关安排通知各学院考核安排">各学院安排</a>，一般会有短信或者QQ群通知。</p><p>时间：开学第一周</p><p>我的面试PPT和面试准备稿子都在<ahref="转专业资料">我的资料</a>中了。因为我们是线上面试，就可以读稿子……虽然回答还是只能随机应变了。</p><p>大概问了我：学了哪些语言，天梯赛情况，c++缺点（Python优缺点）等</p><h3 id="大致流程">大致流程</h3><ol type="1"><li>自我介绍环节</li><li>一个英文问答：一般是一个简单的生活问题或者专业相关问题</li><li>面试老师提问环节</li></ol><h3 id="具体问答">具体问答</h3><blockquote><p>建议参看<ahref="https://blog.supersassw.com/p/univ-exchange_major/#面试">西南交通大学转专业指南- 面试</a>。</p></blockquote><p>老师一般都是根据你的自我介绍，问答情况进行提问的，简单应对就好，这一点上其实很简单的——自信就好。</p><h3 id="可能的准备">可能的准备</h3><ol type="1"><li>准备一个自我介绍+英语问答+面试问答的稿子</li></ol><p>根据<ahref="#具体问答">具体问答</a>可以总结一些基本的问题，也可以自己猜想会问到什么，不一定有很大的用但是可以给自己心理上的鼓励。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我准备的稿子    </div>    <div class='spoiler-content'>        <p>（可以放映PPT吗？可以发简历到聊天框吗肖静杨燕）各位老师晚上好，非常高兴能参加此次面试。我是来自xxx的xxx，下面我将通过三个方面介绍自己。</p><p>首先是学习方面，我科目平均成绩为xx，综合素质评价成绩为xx，专业排名第x，有较强的自我学习能力。</p><p>当然，在大学生活中，不只有学习，锻炼社会工作能力，也是非常重要的。因此我积极参加社会实践，并有较强的能力。我不仅有举办学校年级活动的经历，还有在图书馆、学院团委、学术性社团的任职经历。我现在也担任着ACM协会部长的职位。</p><p>关于学科竞赛，我从初中就开始参加编程竞赛。在大学生活的第一年里，我作为ACM校队和数学建模学术部的成员，参加了大量的学科竞赛，获得了共计x个奖项。其中A类奖项有：南桥杯四川省一等奖，国家三等奖；程序设计天梯赛国家三等奖等，且在天梯赛中排名团队第一。同时也获得了许多有关程序设计的校级奖项，比如新秀杯一等奖，等等。此外，我参加了7场数学建模的比赛，其中4场获得一等奖。</p><p>诸如此些成就与能力，我相信如果我能进入软件工程专业学习，我一定能继续追求自我进步，为学院取得更多成就。我的自我介绍完毕，谢谢老师。</p><p><strong>Q：如何分配时间/为什么参加竞赛、活动</strong></p><p>因为作为一位学生，我自然而然想学到更多的知识，获得更多的技能，这并不算是学生的惯性，更多的是我自主的追求，我爱好编程，喜欢他让脑海中的想法得到实现的过程，并愿意付出时间，所以我才会从初中参加竞赛，进入大学并主动积极加入校队，并成为一员。关于时间，那也自然就是在没有上课的时间里画时间学习竞赛的知识了。至于活动，是调味品和也是另一种实现自我的方式吧。</p><p><strong>Q：数学建模与ACM关系</strong></p><p>我认为数学建模与ACM对于我来说其实是相互促进的关系。一方面我有比较深厚的ACM程序设计基础，作为数学建模的算手，因为有ACM的基础，我能较快的学习、构思并实现解决数学建模问题的代码；另一方面，数学建模的代码量大，能训练我程序设计的严谨性和debug能力。此外程序设计的算法、数据结构更像是理论部分，而数学建模能够帮助其实践运用，进而得到一篇完整的论文。</p><p><strong>Q：如果你转成专业了有什么规划和打算</strong></p><p>短期来看我马上面对着数学建模国赛，ACM网络赛，和各种区域赛；更长远的看，我希望我能进入实验室，在本科阶段做出成果，发表学术期刊，其实我已经在做这件事了；另外我希望能继续读研学习。</p><p><strong>Q：为什么转专业/失败怎么办</strong></p><p>我转专业其实是自然而然的过程，第一因为我有自主的学习内驱力，在学习上也得到了还算不错的成绩，第二是因为我追求挑战与创新，也一直喜欢并参加着程序设计竞赛有着基础，第三是遇到了可爱的同学学长们，以及敬爱的老师们帮助我。</p><p>如果失败了，确实对于我来说非常的遗憾，但我也不会放弃7年的追逐，我也会继续基于我的算法基础发展更多的技能，我会吸取教训，争取在研究生考试实现跨考，我也会专心学习原专业，用所学的知识做出学术成就吧。也感谢各位老师能给我这次转专业面试的机会。</p><p><strong>Q：对于原专业的看法/转专业动机</strong></p><p>在物流我度过了大学的第一学年，在这一年里我了解了物流的背景与发展方向，物流是供应链活动的一部分，带来的是他更像是一个更偏向管理或者说是文科的工科。</p><p>我从初中开始学习信息学竞赛到现在也7年了，在大学的一年里我也继续保持着对编程的爱好，也是校队的一员，也自然的想要转入软件工程来学习。在性格上我善于创新，追求挑战，所以想要进入软件工程；在学科本身上，软件编程本身是有规则的，有迹可循的，而不是基于实验/猜想得到的规律，这一点正是软件工程吸引我的原因。</p><p><strong>Q：为什么不报计算机科学/为什么想转软工</strong></p><p>计算机科学的培养目标更多是应用研究、技术开发或管理等方向，其理论性更强，相较之下软件工程面向软件系统研发等，更符合实践，也更符合我的兴趣与想要的研究方向。去解决问题去创造实现问题的方法这正是我追求的，这也是我运用编程能力积极参加数学建模的原因。</p><p><strong>Q：关于英语差</strong></p><p>从主观原因上，我英语基础不理想，其主要原因是曾经教育阶段的英语过分强调了背诵、记忆，而没有让英语的实用、媒介作用得到发挥。我擅长于理解，不善于单纯的记忆。客观原因上也有我用竞赛时间挤压的原因。</p><p>但是在大学里，我无论是在比赛上又或是在科研上都会接触英文题面与英语的论文。我更多的看到了英语的实际作用，现在我也经常阅读英文文献、书籍，对其中的陌生单词进行快速查找，留下记忆，因此我英语能力与语感得到了极大的提升，相信这不会成为一个难题。</p><p>自我介绍</p><p>Good evening teachers, I am very happy to attend this interview. I amWang Zixi from Logistics. I will introduce myself in three aspects.</p><p>First of all, I have an average grade of 88.95 in all subjects and anoverall quality assessment score of 93.29, ranking second in my major,so I have strong self-learning ability.</p><p>Of course, in university life, not only studying, but also exercisingsocial work skills, is very important. Therefore I actively participatein social practice and have a strong ability to do so. Not only do Ihave experience in organising school year activities, but I also haveexperience in serving in the library, the college committee and academicsocieties. I am also currently holding the position of Director of theACM Society.</p><p>Regarding subject competitions, I have been participating inprogramming competitions since junior high school. During my first yearof university life, I participated in a large number of subjectcompetitions as a member of the ACM varsity team and the academicsection of Mathematical Modelling, and also won a wealth of awards. Someof the A-class awards include: the first prize in Sichuan Province inthe Nanqiao Cup, the third prize in the country; the third prize in thecountry in the programming ladder competition, the second prize inSichuan Province in the team, the third prize in the country in theteam, and the first place in the team in the ladder competition. I havealso won many school-level awards related to programming, such as theRookie Cup, and so on. In addition, I have participated in sevenmathematical modelling competitions and won first prize in four ofthem.</p><p>With all these achievements and abilities, I believe that if I canenter the Software Engineering program, I will be able to continue topursue self improvement and achieve more for the college.</p><p>学校</p><p>Southwest Jiaotong University is a transportation-focused institutionof higher learning that has produced a large number ofprofessionals.</p><p>物流</p><p>Logistics originally meant "physical distribution", which is part ofthe supply chain activities</p><p>家乡</p><p>My hometown is Qianwei, a small town located in the south of Leshan,with beautiful natural scenery and local culture. It is rich in tea andit is my cradle forever.</p>    </div></div><ol start="2" type="1"><li>可以找熟悉的人模拟面试几次</li></ol><h1 id="转专业后事务">转专业后事务</h1><h2 id="选课">选课</h2><p>每学期末，教务网会发放第二学期的选课通知，如<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=572C043902FDE315">关于做好2023-2024学年第一学期选课工作的通知</a>，选课包含三次而前两次都在转专业结果出来之前，第三次选课是在转专业结果出来之后（一般是每学期的第二周），这个选课就是针对转专业学生重写选课的。</p><p>第一次第二次选课<strong>按照原专业的优选班选择</strong>。</p><h3 id="前言">前言</h3><p>大学生都知道选择好的（给分高）老师很重要。</p><p>在第一次选课期间要分配好权重，首先保证自己的英语老师不错。然后去研究咨询其他课的老师情况。</p><p>一般可以通过<ahref="https://huoshui.org/">活水</a>快速的了解一个老师的好坏，对于一些“名”师（好/坏）也可以直接看出来，评价的人越多，偏差越小。对于不了解的还可以询问同学、学长等。</p><div style="display: flex; justify-content: center;"><img src="活水.png" alt="活水" style="zoom:25%;" /></div><h3 id="换教学班攻略">换教学班攻略</h3><p>如果遇到了天坑老师或者有明确更换老师，</p><ol type="1"><li>可以直接在第一次选课不选这门课，方便在第二次选课的时候抢，<strong>节约取消选课的时间</strong>（抢过课的人应该懂的都懂）</li><li>需要<strong>提前查询并整理</strong>好相关课程、老师和时间的信息。第一是明确抢课步骤（PlanA，Plan B），第二是一般选课期间<ahref="https://huoshui.org/">活水</a>就查看不了了（访问量过大）。</li></ol><h3 id="一个选课整理的例子">一个选课整理的例子</h3><div class='spoiler collapsed'>    <div class='spoiler-title'>        大二上选课例子    </div>    <div class='spoiler-content'>        <p>我曾经选课整理的。</p><div class="hljs code-wrapper"><pre><code class="hljs diff">√第一步：概率论【已删】 换 程世娟（星期四 3-5节）/  赵春明（星期三 8-10）√第二步：供应链管理怕【已删】 换 王群智（星期三 3-5节）√第三步：【第二步成功】马原 换 米曙娟（星期一 3-5节）              【第二步失败】马原 换 袁雨宸（星期三 3-5节）X第四步：软件工程 换 另一个班√第五步：运筹学 换 王坤——————————————————————————概率论：星期三 3-5节 MATH001612<span class="hljs-deletion">-赵春明：有趣透彻*95；概帮帮主；给分不算高</span> （星期三 3-5 8-10）<span class="hljs-deletion">-程世娟：没有小测，给分高*8</span> （星期四 3-5节）★★★<span class="hljs-deletion">-左东：负责；板书；高中老师；看其他科目成绩；平时分平均分最高</span> （星期三 8-10）<span class="hljs-deletion">-彭皓：特别水；测验我没去，然后满分；雨课堂签到</span>运筹：【时间无法变动】<span class="hljs-deletion">-王坤：负责，课好，但严</span> （星期三 6-7）★<span class="hljs-deletion">-郑斌：课不算好，亲和，签到</span> （星期三 6-7）马原：<span class="hljs-deletion">-袁雨宸：年轻，不死板，有思考；有免考（平时拉满、读书笔记）；课堂表现20分（回答问题，可QQ）</span> （星期三 3-5）★<span class="hljs-deletion">-杨东：平时分拉满*11</span> （星期一 3-5节）<span class="hljs-deletion">-米曙娟：免考；温柔；送分*7</span> （星期一 3-5节）★供应链管理：【必跑！！！】<span class="hljs-deletion">-王群智：讲故事，有趣</span> （星期三 3-5节）★★软件工程<span class="hljs-deletion">-换一个班 ★</span>考虑”市场调查与分析竞赛训练“——————————————————通用学术英语<span class="hljs-deletion">-杨琼：给分高，上课不舒服</span><span class="hljs-deletion">-付华权：给分不高，上课舒服；不点名平时分也不是很高</span><span class="hljs-deletion">-余小玲：事不多；上课不用回答问题上课表现分就满了</span><span class="hljs-deletion">-里娜：事不多</span><span class="hljs-deletion">-张梅子：平时分能到55</span></code></pre></div>    </div></div><h3 id="转专业选课攻略">转专业选课攻略</h3><ul><li>两个专业都要修的课<ul><li><strong>最高优先级</strong>，例：概率论、马原</li><li><strong>重要</strong>：通过教务网、优选班课程表pdf、<ahref="http://jwc.swjtu.edu.cn/vatuu/CourseAction?setAction=queryCourseList&amp;selectTableType=ThisTerm">本学期课程表</a>和<ahref="http://jwc.swjtu.edu.cn/vatuu/CourseAction?setAction=queryCourseList&amp;selectTableType=NextTerm">下学期课程表</a>。<strong>同时参看本专业与转入专业的课</strong>（找同学或学长要）的教学安排时间，整理，最大可能的防止课程冲突，防止抢的课因为时间冲突又不得不放弃。（这是一个很困难很麻烦的事情，但是刚转入的那学期的课程冲突真的很麻烦）</li><li>更换策略参看<a href="#换教学班攻略">换教学班攻略</a></li></ul></li><li>原专业专业课<ul><li>次优先级</li><li>因为专业课调班的人不多，一般来说想调就调。</li></ul></li><li>转入专业专业课<ul><li>次优先级</li><li>对于大部分的同学来说，不会也<strong>没有必要</strong>在第二次选课就选上转入专业的课，也不用担心好的老师会被选完，因为专业课调班的人不多（相对于概率论、马原这种大家都修的课），而且转专业成功之后教务会与学生对接（会收集问卷等），<strong>第三次选课时会对每个老师的课程容量进行扩容</strong>。</li></ul></li><li>转入专业补休课<ul><li>次次优先级，对于简单的课程建议<ahref="#冲突选课"><strong>冲突选课</strong></a></li></ul></li><li>选修课/多元化<ul><li>次次优先级</li><li>一般来说建议大一下就修满选修课学分（大部分学院选修课要求四个通识学分）。这个<strong>一定要仔细研究现专业和转入专业的培养方案</strong>！！！尽量选择两个专业都能满足的课。部分专业的选修课或多元化课是多选一的课，不是随便选通识。</li></ul></li></ul><h3 id="选课页面与攻略">选课页面与攻略</h3><p>相信很多人经过一学期忘了选课界面了，而且非选课时间是打不开的。这里帮大家复习一下(?)。</p><p><ahref="http://jwc.swjtu.edu.cn/index.html?version=2020"><code>教务处</code></a>- <code>学生</code>即<ahref="http://jwc.swjtu.edu.cn/service/login.jsp">学生登录</a>，可以进入：</p><div style="display: flex; justify-content: center;"><img src="选课服务器.png" alt="选课服务器" style="zoom:33%;" /></div><p>可以考虑使用选课服务器，注意可以打开多个窗口进入选课，方便一边删除一边插入，同时不建议频发刷新网页（可能会更挤不进去）。听说用宽带接入学校内网是最快的，其次是去校外，最差的是校内使用非内网（热点）。</p><div style="display: flex; justify-content: center;"><img src="选课页面.png" alt="选课页面" style="zoom: 25%;" /></div><p>最常用的是选其他优选班，其次是撤销已有选课。可以多个网页进入<code>选其他优选班</code>，一个网页进<code>撤销已有选课</code>。</p><div style="display: flex; justify-content: center;"><img src="选其他班.png" alt="选其他班" style="zoom:25%;" /></div><p>通过提前存好的信息直接查询课。</p><h2 id="课程替代">课程替代</h2><p>转专业成功后会拉一个小群，会有教务老师、辅导员与转专业的学生进行指导对接。在课程替代上，你需要填写《转专业学生课程替代认定表》并打印两份，交由教务处审核并盖章然后返还你一份。</p><ul><li>最好提前找实习老师要来《XX实习课程大纲》（不是教务网能下载的那个）并连同认定表一起打印两份，两份分别装订。</li><li>实习需要“计算机程序设计基础”与原专业的“XX实习”课程二对一替代。</li></ul><p>注意：</p><ul><li>计算机学院在2022年取消了新生导论课的替代（承诺大三上开补修班补修【未实行】）。</li><li>计算机学院在2022年加强了实习替代的审核，只有与计算机相关的实习能够替代实习（建议大二下暑假上两个实习）。</li></ul><h2 id="冲突选课">冲突选课</h2><ol type="1"><li>建议对较为容易的课程进行冲突选课，如：高级语言程序设计、面向对象</li><li>如果有熟悉认识的老师就最好了</li><li>冲突选课的优点是：节约本来就很少的时间、为了选其他课（老师）把次要课程冲突</li></ol><p>每学期第一周<ahref="http://jwc.swjtu.edu.cn/">教务处</a>会印发本学期的选课安排通知（如：<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=50A9E994BCB9AC50">2022-2023学年第二学期第二阶段选课安排</a>）,本通知告知了第二阶段选课（即第二次选课和第三次选课）的时间安排，并在文末会提及到超学分选课相关安排和冲突选课申请安排，冲突选课申请时间为选课结束后的一周内。</p><blockquote><p>冲突选课申请安排通知如下：本学期冲突选课申请时间：2023年3月23日-2023年3月31日，具体操作流程及注意事项见《<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=959F806B5F4C9CD1">冲突选课申请流程</a>》，学生登录教务系统辅助平台；密码默认为身份证号码后6位，如果修改过则为修改过的密码。</p></blockquote><h3 id="官方流程">官方流程</h3><p>在教务网网上办事处<ahref="https://jiaowu.swjtu.edu.cn/vatuu/WebSite?setAction=detail&amp;tspId=0380707C53D59CD4&amp;tspSortId=61E92EF67418DC54">冲突选课</a>板块和教务处的<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=newsDetail&amp;viewType=web&amp;newsId=959F806B5F4C9CD1">冲突选课流程</a>告知了冲突选课的具体流程如下：</p><p><img src="http://jiaowu.swjtu.edu.cn/download/news/images/20211108/1636354222529071788.jpg" alt="冲突选课流程" style="zoom: 10%;" /></p><p>具体操作如下：</p><p>1、网上下载并填写<ahref="http://jwc.swjtu.edu.cn/vatuu/WebAction?setAction=download&amp;fileType=file&amp;fileId=D328348E5032A442">《冲突选课申请表》</a>，填写时注意填写项要求；</p><p>2、任课教师审批冲突选课申请表；</p><p>3、学院审批冲突选课申请表；</p><p>4、在教务系统辅助平台网上提交冲突选课申请(http://180.85.38.138:8000/)</p><p>（1）学生登录<ahref="http://180.85.38.138:8000/">教务系统辅助平台</a>；密码默认为身份证号码后6位，如果修改过则为修改过的密码；</p><p>（2）点击【冲突选课申请】--【提交冲突选课】--“填写课程信息，务必填对选课编号”（提交的课程为教务网课表未选上的课程，每位同学最多提交2门课程）；</p><p>（3）提交冲突选课申请；</p><p>5、提交审批完的《冲突选课申请表》到教务处排课与考试中心（综合楼222办公室）；</p><p>6、教务处排课与考试中心审核《冲突选课申请表》和网上冲突选课申请；</p><p>7、审核通过，冲突选课生效，学生在教务网查询本学期个人课表，按课表上课。</p><p>注：每个学生每学期冲突选课不超过2门</p><h3 id="个人理解">个人理解</h3><p>以个人理解步骤如下：</p><ol type="1"><li>填写《冲突选课申请表》并打印两份，“学生承诺”处自己签字；</li><li>分别找冲突的两个课程的老师，并让他们在“任课教师签名”处签字；</li><li>找自己学院（本科）教务处老师在“学生所在学院意见”处写“同意”，在“教学院长签字”处签字；</li><li>找自己学院盖章处（通常第三步中的教务老师会告知你），在“学院公章”处盖章；</li><li>第三次选课结束后在<ahref="http://180.85.38.138:8000/">教务系统辅助平台</a>提交冲突选课申请；</li><li>把纸质的申请表交给学校教务处（综合楼222），即排课与考试中心。</li></ol><p>建议步骤1-4在第三次选课结束前完成。</p><h3 id="一些性质">一些性质</h3><ul><li>冲突选课<strong>可以无视课程容量限制选课</strong></li><li>冲突选课仅需要交作业和考试</li></ul><h2 id="评奖评优">评奖评优</h2><ul><li>评奖：即申请国家奖学金、国家励志奖学金、专项奖学金、一二三等奖学金等。</li><li>评优：即申请三好学生（标兵）、优秀学生干部等荣誉称号</li></ul><p>若转专业成功，<strong>评奖评优将在原学院进行</strong>。一切的评奖评优申报，包括国奖（国家奖学金）答辩、评选等都是在原学院进行。奖学金会自动打入<ahref="https://cwc.swjtu.edu.cn/">西南交大计划财务处</a>绑定的银行卡，奖学金证明和荣誉将会在转入学院发放（一般是班长发）。</p><p>这个时间线很长好在申请之后就不用关心这件事了，不用花费太多精力（转专业与大学生活非常消耗精力，这种事情能不在意就不要关心了）。</p><h3 id="前置学生信息拓展">*前置：学生信息拓展</h3><p><a href="http://xg.swjtu.edu.cn/web"><code>扬华素质网</code></a> -<code>用户登录</code> - <code>个人信息</code> -<code>学生拓展信息</code></p><p>申请自己获得的奖项、科研经历、实践活动等，并通过了辅导员审核，便于在申请评奖评优的时候直接引用（仅能引用）。</p><div style="display: flex; justify-content: center;"><img src="拓展信息.png" alt="拓展信息" style="zoom:25%;" /></div><h3 id="申请评奖评优">申请评奖评优</h3><p><a href="http://xg.swjtu.edu.cn/web"><code>扬华素质网</code></a> -<code>用户登录</code></p><p>即登录<ahref="http://xgsys.swjtu.edu.cn/userhall/smart/student">学工一体化平台</a>，一般若申请开放可以直接在首页的业务申请项里面看见；也可以点击“<code>办事大厅</code> - 评优管理项 - <code>学生评优管理</code>”进入。大致界面如下：</p><p><img src="评奖评优.png" alt="评奖评优" style="zoom:25%;" /></p><p>注意：</p><ul><li><p>这个网页非常卡，很可能要提交多次，建议把申请理由等复制到一个文档保存起来。</p></li><li><p>在这个网站，“<code>办事大厅</code> -<code>综合素质评价管理</code> ”下可以看自己综测结果</p></li></ul><h3 id="奖学金收入查询">奖学金收入查询</h3><p>路径： <ahref="https://cwc.swjtu.edu.cn/"><code>西南交大计划财务处</code></a> -<code>财务系统</code> - <code>登录</code> - <code>新版财务查询</code> -<code>我的收入查询</code> - <code>个人酬金查询</code></p><div style="display: flex; justify-content: center;"><img src="财务.png" alt="财务" style="zoom: 25%;" /></div><h2 id="更换宿舍">更换宿舍</h2><p>因为犀浦宿舍资源紧张（202?-2023），原则上不能申请新的宿舍，只能插入转入专业的有空位的宿舍（所以很多人也不会换宿舍）。但是九里的同学一定会换宿舍到犀浦的（新东部校区还没建好，情况未知）。</p><p>更换宿舍主要是辅导员安排，所以并不是一定在转入的时候就决定好。同时，可以自己联系有空位的宿舍（询问新同学，社恐噩梦QAQ俄），再询问辅导员进行调换，这样的效率会高很多（比如辅导员告诉我没有空位）。</p><p>更换宿舍，<strong>只需要填写一张表</strong>，按照表格操作即可。</p><h1 id="写在后面">写在后面</h1><p>嗟后人哉，世事沧桑，仰观昔日之辉煌。滕王阁上，巍峨高楼，昔日英杰何在？今朝风华，如云烟飘逝，往来者何去之？</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>大学相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转专业</tag>
      
      <tag>大学事务</tag>
      
      <tag>西南交通大学</tag>
      
      <tag>攻略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和她的故事</title>
    <link href="/2023/02/19/26%E5%92%8C%E5%A5%B9%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <url>/2023/02/19/26%E5%92%8C%E5%A5%B9%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>好似那笼中雀扑向水中月。 <span id="more"></span></p></blockquote><h2 id="和她的故事">和她的故事</h2><p>我和她的故事如何讲起，是在那个还有这烟火味道的除夕？还是那年暑假的补课？时间过去了太久，久到我忘记了相知的细节，相处的悸动。</p><p>在那个除夕我天真的认为，真的是她大冒险输了，来询问我是否喜欢他人，再再一年后的补课，我出于什么心理坐在她身旁。我不能说这是少年的心动，因为这显得很廉价。在补课结束的那段时间我们慢慢聊了许多，再往后我要她写诗却写了一封信，信封从线上来到线下，配上周末的交谈，似乎便开始了。</p><p>我不知道如何定义这个开始，可以说是她偶尔口上说笑，也可以说是相知与心换心。那段时间太多事太多细节已经记不清，至少每天会有担心，激动，害羞，有多想的充实。入今看来如梦如幻的日子啊，其实早也有祸根，我会吃错，交流也大都限于线上。也许这就是我至今不能确定这究竟算不算谈，算不算那关系。</p><p>分开后的很长一段时间，我对她的定义是半个女友，这来自于离别的对话，但是我似乎是记错了。“我们还不算男女朋友关系吧”，“四舍五入也算了”。也许这段对话来自梦中？不管怎么样也快一年的联系就此断绝，在毕业后的第一天，从此山河相隔，再难相见。</p><p>一直还是意难平的。在那个长假里，我逝去了许多爱好和计划，或积极或消极的逃进大学，我单方面屏蔽了她的空间很长时间，再往后我偶尔会看到她的说说与朋友圈。我也自以为两人再难走入新的亲密关系——直到她曾经从来不让我知道的账号突然关注了我——直到我今天看见他元宵节的回答——直到我看见了她对前男友的叙事。恍恍忽，我才知道，所谓的影响如镜中花。笼中雀倒影着水中月。一切静下来，慢下来，其实也不过如此。</p><p>以为我想说什么？我眼泪早已在最后那一学期里留尽了。往后在她生日那天也再难哭出来，其实我并不逃避这段关系，我时常回想品味。已经很淡了，大学时间冲淡了太多东西，我是不想忘记的，也不可得。我只认为在无数的孤月下，会有两个独立又萧条的背影。如今看来，宛若秋风。</p><p>感性叙事并不能带来什么。但她真的回避依恋了吗？我怀疑了起来了。我不知道，我只知道我的心空了，空了很久——我记不起来了。</p><p>我现在，似乎很平静，也只是似乎罢了。一股电流从脚流到胸腔，它早就比不上当年的刺痛了。我又来这干什么呢？</p><p>——23.02.19 00:46</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>岁月录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>光点</tag>
      
      <tag>散文</tag>
      
      <tag>元熹</tag>
      
      <tag>爱情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年鉴 - 烟花</title>
    <link href="/2022/12/31/25%E5%B9%B4%E6%8A%A5/"/>
    <url>/2022/12/31/25%E5%B9%B4%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>        <div id="aplayer-sIJZdBUD" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"烟花落","author":"DarkSpirit","url":"http://music.163.com/song/media/outer/url?id=1314010312.mp3","pic":"http://p1.music.126.net/pLtzftMgZ1E1X-plEZlfWA==/109951163577838770.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-sIJZdBUD");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><p>好久不上楼顶，久卧未眠心神不宁，所以登楼望风。竟窥到楼顶门外有光，轻轻推开门从门缝中窥视，才发现有人打灯在板凳上写着东西。敲敲门，推门而出，门外的人却骇然的收走了纸笔∶“现在还有人能看见夜里的人？”</p><p>我看见他呼的一声甩手把光亮甩灭，一个转身不见了身影，不由心中不安，一手扶着门框喊道∶“谁家的小孩，半夜不睡觉在楼顶晃悠？”听到这话那声音笑到“我当是谁，哪来的细杆子”，说着声音到了我耳边，“快快快，这边坐，都说这楼住都是老年人，这不就碰见稀客了吗”。感觉左肩后背被人推着向前引去，我浑身一颤，一回头看见了一个比我矮不了多少的模糊身影。</p><p>他自顾自的走着，嘟囔着什么，我四处瞧去，除了他身边有暗光一片以外就只有在城市灯光下围栏的剪影。什么都看不清的一片中他四处摸索，终于抬出一个破旧板凳来。“是你让我这蓬荜生辉了”他说着摸了摸，“实在是让你见笑了，现在人用火少了，年也不过了，我这里也不太富足。”缓缓的，一盏灯在他手里慢慢亮了起来。“你这铜灯有意思啊，这灯我都没见过，是古董了吧”说着把头凑过去想仔细看看这灯的构造。</p><p>火光猛地摇曳了一下，我余光看见了他的脸无比的熟悉，竟和我有些相似。“你什么人！”猛地双脚蹬起，猫腰着颇像受惊的猫。“就你们才能在夜里见得我！我就是你，你就是我。不信你且来仔细瞧瞧。”几近迟疑，还是从新坐下了，“你什么魑魅魍魉我也不怕，身正不怕影子斜德高何忧生是非，你若是鬼我倒是要抓你起做研究呢！”</p><p>他惊讶，“你胆子倒是大了不少，也变得油嘴滑舌了起来。”又耻笑道∶“穿着个破夹袄，就当孔乙己呢？你信不信我无所谓，我就想问你，你现在还写东西吗？”“你问这做甚，与你有什么干系！”好像又回想起什么，胀红了脸道，“你怎就认为我没写了，我前两周才写过信呢！”对面啧啧“想不到你竟沦落到这个地步，我构想的也够低了。你也没有必要解释什么，你要解释的我都知道，无非是什么没时间没心思没心境，是吧？”我脸色一边红一边紫“你你……你懂什么，搞学习学东西不花时间的吗？我还拿了那么多奖……”“是是是，你都没时间，你都在做‘正事’。”他把灯扣在扁凳上，火光熹微似乎就要灭了，“那你还带着个破眼镜，装自己和以前一样呢？我随便问你一点我都知道的东西你怕啥都不知道了吧——比如那个，那个retard是什么意思？”</p><p>“你你知道我英语不好就问英语是吧，有本事考古诗，或者考考数学！”“行，你想默写《蜀道难》还是求求初中的相似三角形题啊？你，我还不了解？”他嘲讽的说道，“古诗只会背，呵呵，还有就你那沾沾自喜的数学看你大学学的怎么样？你别给我说什么高数不一样的，就看你英语没有一点长进其他还都在落后我就看不起你！”。</p><p>我气结了，站起来起靠着围栏说“你也不看看你现在怎么样就说我，谁喜欢戴眼镜，谁喜欢舞文弄墨的，喜欢的人喜欢不上，在一起的人走不遥远，兴趣兴趣不能养成，一知半解一事无成。”“是呀是呀，这可总结的太到位了，我都想给您鼓掌了。希望不要再看见你晚上在外面喝酒，又什么缅怀过去的那个她，别人早把你忘了。你那样子，以后也脱不了单，没人理你，做你的工科生去把！”说着就消失了。</p><p>望着城市的老旧楼房，和一些格格不入伫立在城区和边郊的一些高楼。他们身上的霓虹灯也熄灭了，天边的红也消散了。再往上，星星三两点洒在天幕上，忽然星星就从眼角流了出来。</p><p>没人祝福自己，也没有能祝福的人，今天可是元旦啊。趴在栏杆上，让身体紧贴围栏那厚厚的水泥壁，这样腿可以轻松些，也多些依靠。冷，寒冷通过栏杆传递到胸口，把手攥起来缩进衣袖。想起了在寒风中披星戴月早出晚归去往图书馆；想起一个个冰冷的夜里在大厅熬夜，后背一瞬间被贴紧了，另一双手穿过了臂弯。还是有温度的不是吗？我挣扎着翻过了身，身上的束缚又消失开来。</p><p>“喂，你在哪？”</p><p>“喂，我想你了！”</p><p>“可我不想你，”油灯光芒收敛，他又蹦了出来。“你走不出过去，也走不通未来。还是现在一样”，他赌气的插着腰，“胆小、内向、懒惰怎么还是一模一样啊。”</p><p>“和以前一样吗？”</p><p>“一样什么一样，都变啦”他摸了摸鼻子，“你以为我为什么出现在这啊，你听过一句话吗，每个人心里都有个死小孩，我的小孩死啦，现在你的也死啦！”</p><p>“我还知道每个人都是小怪兽，最后都会正义的奥特曼消灭。”“你个半吊书袋子，怪不得找不到对象。”他抹着眼睛说到。“找不到就找不到，我还是有你啊。”“我你可再也见不到了”他哽咽着说，“没人记得我，没人会点灯放烟火纪念我们……你们都在追逐那些实际的利益与虚无的自我，你，你们……”</p><p>“是，是这样的”</p><p>“你就愿意看我远去？”</p><p>“没有人会一直回望过去的，当下和未来才是要面对的，你影响了我，你们也要为下一个我们负责不是吗？”</p><p>“就不会想我，纪念我？”</p><p>“会啊，时时刻刻，我就是你啊！”</p><p>毕了，那身影钻入灯花，消失不见了，忽然，远处微小的爆炸声想起，然后是第二声第三声，无数的花火在夜空绽开。在椅子上留下了发光的卡片与燃尽的油灯，看这温度，原来灯已经灭了好久了。</p><p>我醒了，记不得那似梦非梦的夜。窗外阳光刺眼，枕边一张白色信封躺着。上面有着印泥，手绘邮票，背后写着：</p><p>愿为烟火，与君相逢。</p><blockquote><p>记作《铜灯小记》</p></blockquote><p><img src="https://pic.imgdb.cn/item/63b120f12bbf0e7994637009.png" /></p><hr /><h1 id="学习">1 学习</h1><blockquote><p>为什么总是把学习放在第一位呢？大概是因为惯性和希望吧。长久以来学习都是最重要的——无论是家庭教育又或是学校的教育。当然我也一直认为我是求学之人，但这样的惯性是否是对的呢？选择似乎更重要。</p></blockquote><p>上半年的学习情况已经在<ahref="https://dramwig.github.io/2022/06/25/22年报/">半年鉴</a>中有写道。至于下半年基于学习习惯，我只是保持的低限度的学习——没有考试的压力也不会画很多时间来复习。但是期末考试推迟到了明年的开学，所以期末的压力也顺延了。</p><p>下半年来影响最大的事情是我转专业的成功，我成功到了一个我更加熟悉与得心应手的学院与专业。同时也有国赛失利、社团团体矛盾的事情拉扯，过的很累却又无所事事——经常在半夜还在外面吃夜宵与喝酒（有点难以切齿）。大概是累了，也放松了，所以学习才放下了那么多。</p><p>在竞赛上主要是参加了很多场ACM区域赛，也只获得了一枚区域赛铜牌，至少不是空手而归了。</p><h1 id="同道">2 同道</h1><p>感觉认识的人更多，熟悉的人更少了。</p><p>挚友和熟人圈几乎都没有变，要说变了还是有圈子破碎和友人渐远的感觉。我无心太去经营这些，毕竟我也改变不了别人。</p><h1 id="app年报">3 App年报</h1><ul><li><p>知乎</p><ul><li>2022年你在知乎发表了3个问题、32个回答、13篇文章、27个想法、172979个字</li><li>2022年你有108天发表了内容，2月是最高产时段</li><li>你的内容1被阅读了141331次，你在其他领域创作最多</li><li>你的创作被转发了56次，被收藏了1136次</li><li>你收到了2332个赞同</li><li>2022又有99个粉丝关注了你，最常浏览你内容的是@放之</li><li>今年你常常在深夜时段打开知乎刷刷推荐</li><li>8月2日你在知乎停留了5小时，是最久的一天</li><li>2022，你一共浏览了5740个问题、17537个回答、732篇文章、20275609个字</li><li>你浏览了4939位答主的回答461个万赞回答</li><li>你浏览最多的是科学工程、教育</li><li>2022年你发出了1432个赞同、522个喜欢</li><li>关键词：承认欲望</li></ul></li><li><p>QQ音乐</p><ul><li>2022年，你共听歌984首，81h33min</li><li>你与音乐的故事多发生在11月</li><li>你收听了11首收藏量小于999的歌，循环了89次”报国寺喝茶“</li><li>你收听了153首新歌</li><li>9月18日，你4:44还在听歌</li><li>年度关键词：天空</li><li>年度歌单1.报国寺喝茶 2.Dear Moments 3.落英 4.阿拉斯加湾 5.城南花已开6.马 7.acacia 8.白鸟过河滩</li></ul></li><li><p>网易云音乐</p><ul><li>听过187手歌、19小时25分钟</li><li>你大部分是时间在听10年代的歌</li><li>9月9日3:59还在听龙图</li><li>发现了只有104人听过的报国寺喝茶</li><li>春天：Reunion In TheWind，夏天：报国寺喝茶，秋天：画，冬天：Singularity</li><li>与耳机另一端一起听了21234分钟</li><li>年度歌曲：落日随山隐</li><li>11%逍遥 35%纯洁 54%云淡风轻</li></ul></li><li><p>QQ</p><ul><li>你最爱用”辣眼睛“”幽灵“</li><li>热聊TOP5：AFXR、蹦豆、莫栩、Yuyuse、长苏</li></ul><hr /><blockquote><p>疫情全面放开、经济下行、俄乌冲突……未来难料</p></blockquote></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>年报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编程训练】二维导热 - 差分模拟</title>
    <link href="/2022/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E4%BA%8C%E7%BB%B4%E5%AF%BC%E7%83%AD/"/>
    <url>/2022/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E4%BA%8C%E7%BB%B4%E5%AF%BC%E7%83%AD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="显示迭代法">显示迭代法</h1><h2 id="问题">问题</h2><p>模拟绝热环境下有初始温度差的二维平面的温度随时间的变化情况。</p><p>（gif见知乎文章）</p><h2 id="代码">代码</h2><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%二维热传导过程显式差分模拟</span>clear;close <span class="hljs-built_in">all</span>;clc;t <span class="hljs-built_in">=</span> <span class="hljs-number">0.03</span>;       <span class="hljs-comment">%时间范围，计算到0.03h</span>x <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>;y <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">%空间范围，0-1m</span>m <span class="hljs-built_in">=</span> <span class="hljs-number">320</span>;        <span class="hljs-comment">%时间t方向分320个格子</span>n <span class="hljs-built_in">=</span> <span class="hljs-number">32</span>;         <span class="hljs-comment">%空间x方向分32个格子</span>k <span class="hljs-built_in">=</span> <span class="hljs-number">32</span>;         <span class="hljs-comment">%空间y方向分32个格子</span>ht <span class="hljs-built_in">=</span> t/(m-<span class="hljs-number">1</span>);   <span class="hljs-comment">%时间步长dt</span>hx <span class="hljs-built_in">=</span> x/(n-<span class="hljs-number">1</span>);   <span class="hljs-comment">%空间步长dx</span>hy <span class="hljs-built_in">=</span> y/(k-<span class="hljs-number">1</span>);   <span class="hljs-comment">%空间步长dy</span>u <span class="hljs-built_in">=</span> zeros(m,n,k);<span class="hljs-comment">%设置边界</span>[x,y] <span class="hljs-built_in">=</span> meshgrid(<span class="hljs-number">0</span>:hx:<span class="hljs-number">1</span>,<span class="hljs-number">0</span>:hy:<span class="hljs-number">1</span>);u(<span class="hljs-number">1</span>,:,:) <span class="hljs-built_in">=</span> sin(<span class="hljs-number">4</span>*pi*x)+cos(<span class="hljs-number">4</span>*pi*y);<span class="hljs-comment">%按照公式进行差分</span>for ii<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:m-<span class="hljs-number">1</span>    for jj<span class="hljs-built_in">=</span><span class="hljs-number">2</span>:n-<span class="hljs-number">1</span>        for kk<span class="hljs-built_in">=</span><span class="hljs-number">2</span>:k-<span class="hljs-number">1</span>            u(ii+<span class="hljs-number">1</span>,jj,kk) <span class="hljs-built_in">=</span> ht*(u(ii,jj+<span class="hljs-number">1</span>,kk)+u(ii,jj-<span class="hljs-number">1</span>,kk)-<span class="hljs-number">2</span>*u(ii,jj,kk))/hx^<span class="hljs-number">2</span> + ...                ht*(u(ii,jj,kk+<span class="hljs-number">1</span>)+u(ii,jj,kk-<span class="hljs-number">1</span>)-<span class="hljs-number">2</span>*u(ii,jj,kk))/hy^<span class="hljs-number">2</span> + u(ii,jj,kk);        end    endendfor i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:<span class="hljs-number">200</span>    figure(<span class="hljs-number">1</span>);    mesh(x,y,reshape(u(i,:,:),[n k]));    axis([<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> -<span class="hljs-number">2</span> <span class="hljs-number">2</span>]);        F<span class="hljs-built_in">=</span>getframe(gcf); <span class="hljs-comment">%捕获显示在屏幕上的当前坐标区作为影片帧</span>    I<span class="hljs-built_in">=</span>frame2im(F); <span class="hljs-comment">%将捕获的影片帧转换为图像数据</span>    [I,map]<span class="hljs-built_in">=</span>rgb2ind(I,<span class="hljs-number">256</span>);     <span class="hljs-built_in">if</span> i <span class="hljs-built_in">=</span><span class="hljs-built_in">=</span> <span class="hljs-number">1</span>        imwrite(I,map,<span class="hljs-string">&#x27;test.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;Loopcount&#x27;</span>,inf,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">0.05</span>);    <span class="hljs-built_in">else</span>        imwrite(I,map,<span class="hljs-string">&#x27;test.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;WriteMode&#x27;</span>,<span class="hljs-string">&#x27;append&#x27;</span>,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">0.05</span>);        endend</code></pre></div><h1 id="交替隐式迭代法">交替隐式迭代法</h1><h2 id="问题-1">问题</h2><p>模拟外界温度周期变化的影响下，二维地板的温度随时间的变化情况。</p><p>（gif见知乎文章）</p><h2 id="代码-1">代码</h2><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%二维热传导过程差分交替隐式迭代法(Alternating-direction implicit method)</span><span class="hljs-comment">%c过大会导致交替迭代非常不稳定</span>clear;close <span class="hljs-built_in">all</span>;clc;<span class="hljs-comment">%% 参数定义</span>t <span class="hljs-built_in">=</span> <span class="hljs-number">72</span>;               <span class="hljs-comment">%时间范围</span>xl <span class="hljs-built_in">=</span> <span class="hljs-number">20</span>;yl <span class="hljs-built_in">=</span> <span class="hljs-number">20</span>;      <span class="hljs-comment">%空间范围</span>ht <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>;             <span class="hljs-comment">%时间步长dt</span>nt <span class="hljs-built_in">=</span> t/ht;            <span class="hljs-comment">%时间t方向分格子</span>nx <span class="hljs-built_in">=</span> <span class="hljs-number">50</span>;              <span class="hljs-comment">%空间x方向分格子</span>ny <span class="hljs-built_in">=</span> <span class="hljs-number">50</span>;              <span class="hljs-comment">%空间y方向分3格子</span>hx <span class="hljs-built_in">=</span> xl/(nx-<span class="hljs-number">1</span>);       <span class="hljs-comment">%空间步长dx</span>hy <span class="hljs-built_in">=</span> yl/(ny-<span class="hljs-number">1</span>);       <span class="hljs-comment">%空间步长dy</span>k <span class="hljs-built_in">=</span> <span class="hljs-number">1.93</span>;             <span class="hljs-comment">%二维材料导热系数</span>c <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>e-<span class="hljs-number">1</span>;             <span class="hljs-comment">%与空气换热参数</span>u <span class="hljs-built_in">=</span> zeros(nt,ny,nx);sqt <span class="hljs-built_in">=</span> @(x) -<span class="hljs-number">12.5</span>*cos(<span class="hljs-number">3.1415926535</span>*x/<span class="hljs-number">12</span>)+<span class="hljs-number">72.5</span>; <span class="hljs-comment">%温度计算</span><span class="hljs-comment">%设置边界与初始温度</span>[x,y] <span class="hljs-built_in">=</span> meshgrid(-hx:hx:xl+hx,-hy:hy:yl+hy);u <span class="hljs-built_in">=</span> <span class="hljs-number">72.5</span>*ones(size(x));u(<span class="hljs-number">1</span>,:)<span class="hljs-built_in">=</span>sqt(ht)*ones(size(u(<span class="hljs-number">1</span>,:)));u(end,:)<span class="hljs-built_in">=</span>sqt(ht)*ones(size(u(end,:)));u(:,<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>sqt(ht)*ones(size(u(:,<span class="hljs-number">1</span>)));u(:,end)<span class="hljs-built_in">=</span>sqt(ht)*ones(size(u(:,end)));log(<span class="hljs-number">1</span>,:,:)<span class="hljs-built_in">=</span>u;<span class="hljs-comment">%% 构造迭代矩阵 A,B</span>A <span class="hljs-built_in">=</span> eye(ny)*(-<span class="hljs-number">2</span>);A(<span class="hljs-number">2</span>:end,<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>) <span class="hljs-built_in">=</span> A(<span class="hljs-number">2</span>:end,<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>)+eye(ny-<span class="hljs-number">1</span>);A(<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end) <span class="hljs-built_in">=</span> A(<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end)+eye(ny-<span class="hljs-number">1</span>);A <span class="hljs-built_in">=</span> A*(k*ht/hy^<span class="hljs-number">2</span>);<span class="hljs-comment">%A = inv(eye(ny)-A);</span>tmp <span class="hljs-built_in">=</span> zeros(size(A)+[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]);tmp(<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>) <span class="hljs-built_in">=</span> A;tmp(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>:<span class="hljs-number">3</span>) <span class="hljs-built_in">=</span> [ht*c/<span class="hljs-number">2</span>,-ht*c/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>];tmp(end-<span class="hljs-number">1</span>,end-<span class="hljs-number">2</span>:end) <span class="hljs-built_in">=</span> [<span class="hljs-number">0</span>,-ht*c/<span class="hljs-number">2</span>,ht*c/<span class="hljs-number">2</span>];<span class="hljs-comment">%tmp(1,1)=1;tmp(end,end)=1;</span>A <span class="hljs-built_in">=</span> tmp;B <span class="hljs-built_in">=</span> eye(nx)*(-<span class="hljs-number">2</span>);B(<span class="hljs-number">2</span>:end,<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>) <span class="hljs-built_in">=</span> B(<span class="hljs-number">2</span>:end,<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>)+eye(nx-<span class="hljs-number">1</span>);B(<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end) <span class="hljs-built_in">=</span> B(<span class="hljs-number">1</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end)+eye(nx-<span class="hljs-number">1</span>);B <span class="hljs-built_in">=</span> B*(k*ht/hx^<span class="hljs-number">2</span>);<span class="hljs-comment">%B = eye(nx)+B;</span>tmp <span class="hljs-built_in">=</span> zeros(size(B)+[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]);tmp(<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>B;tmp(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) <span class="hljs-built_in">=</span> [ht*c/<span class="hljs-number">2</span>,-ht*c/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<span class="hljs-string">&#x27;;;</span><span class="hljs-string">tmp(end-2:end,end-1) = [0,-ht*c/2,ht*c/2]&#x27;</span>;<span class="hljs-comment">%tmp(1,1)=1;tmp(end,end)=1;</span>B <span class="hljs-built_in">=</span> tmp;<span class="hljs-comment">%% 差分模拟</span>for i <span class="hljs-built_in">=</span> <span class="hljs-number">2</span>:nt    <span class="hljs-comment">%维护空气温度</span>    u(<span class="hljs-number">1</span>,:)<span class="hljs-built_in">=</span>sqt(i*ht)*ones(size(u(<span class="hljs-number">1</span>,:)));    u(end,:)<span class="hljs-built_in">=</span>sqt(i*ht)*ones(size(u(end,:)));    u(:,<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>sqt(i*ht)*ones(size(u(:,<span class="hljs-number">1</span>)));    u(:,end)<span class="hljs-built_in">=</span>sqt(i*ht)*ones(size(u(:,end)));    <span class="hljs-comment">%交替隐式迭代法</span>    <span class="hljs-built_in">if</span> mod(i,<span class="hljs-number">2</span>)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>         u<span class="hljs-built_in">=</span>(eye(size(A))-A)\u*(eye(size(B))+B);    <span class="hljs-built_in">else</span>        u<span class="hljs-built_in">=</span>(eye(size(A))+A)*u/(eye(size(B))-B);    end    log(end+<span class="hljs-number">1</span>,:,:)<span class="hljs-built_in">=</span>u;end<span class="hljs-comment">%计算平均温度</span>for i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:nt    logMeanT(i)<span class="hljs-built_in">=</span>mean(mean(mean(log(i,<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:end-<span class="hljs-number">1</span>))));endfigure(<span class="hljs-number">1</span>);plot(ht:ht:t,logMeanT);fprintf(<span class="hljs-string">&#x27;极差:%d max:%d min:%d\n&#x27;</span>,max(logMeanT(<span class="hljs-number">48</span>/ht:<span class="hljs-number">72</span>/ht))-min(logMeanT(<span class="hljs-number">48</span>/ht:<span class="hljs-number">72</span>/ht)),max(logMeanT(<span class="hljs-number">48</span>/ht:<span class="hljs-number">72</span>/ht)),min(logMeanT(<span class="hljs-number">48</span>/ht:<span class="hljs-number">72</span>/ht)));<span class="hljs-comment">%% 可视化过程</span>for i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:nt    figure(<span class="hljs-number">2</span>);    mesh(x,y,reshape(log(i,:,:),size(u)));    xlabel(<span class="hljs-string">&#x27;x&#x27;</span>);    title(num2str(i*ht));    axis([<span class="hljs-number">0</span>-hx,xl+hx,<span class="hljs-number">0</span>-hy,yl+hy <span class="hljs-number">60</span> <span class="hljs-number">85</span>]);    pause(<span class="hljs-number">0.1</span>);        F<span class="hljs-built_in">=</span>getframe(gcf); <span class="hljs-comment">%捕获显示在屏幕上的当前坐标区作为影片帧</span>    I<span class="hljs-built_in">=</span>frame2im(F); <span class="hljs-comment">%将捕获的影片帧转换为图像数据</span>    [I,map]<span class="hljs-built_in">=</span>rgb2ind(I,<span class="hljs-number">256</span>);     <span class="hljs-built_in">if</span> i <span class="hljs-built_in">=</span><span class="hljs-built_in">=</span> <span class="hljs-number">1</span>        imwrite(I,map,<span class="hljs-string">&#x27;test.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;Loopcount&#x27;</span>,inf,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">0.05</span>);    <span class="hljs-built_in">else</span>        imwrite(I,map,<span class="hljs-string">&#x27;test.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;WriteMode&#x27;</span>,<span class="hljs-string">&#x27;append&#x27;</span>,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">0.05</span>);        endend</code></pre></div><h1 id="模型说明">模型说明</h1><p>二维热传导方程为</p><p><span class="math display">\[\frac{\partial T}{\partialt}=k\left(\frac{\partial^{2} T}{\partial x^{2}}+\frac{\partial^{2}T}{\partial y^{2}}\right)\]</span></p><h2 id="显式有限差分格式">显式有限差分格式</h2><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t}=\left(\frac{T_{i+1, j}^{n}-2 T_{i, j}^{n}+T_{i-1,j}^{n}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n}-2 T_{i, j}^{n}+T_{i,j-1}^{n}}{\Delta y^{2}}\right)\]</span></p><p>显式迭代格式免去了矩阵求解的麻烦，但却是条件稳定的。即只有保证时间步长和空间步长满足一定关系时才能获得收敛解，对于热传导问题需要满足：</p><p><span class="math display">\[\frac{\Delta t}{\min(\Delta x^2,\Deltay^2)}\le \frac{1}{2}\]</span></p><h2 id="隐式有限差分格式btcs">隐式有限差分格式(BTCS)</h2><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t}=\left(\frac{T_{i+1, j}^{n+1}-2 T_{i, j}^{n+1}+T_{i-1,j}^{n+1}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n+1}-2 T_{i, j}^{n+1}+T_{i,j-1}^{n+1}}{\Delta y^{2}}\right)\]</span></p><p>需要注意BTCS法是无条件稳定的，即时间步长可以任意取都不会计算发散（不发散不代表算得准）。由于BTCS时间项采用向后差分，因此该方法在时间层精度为一阶，而空间层精度为二阶。</p><h2id="隐式有限差分格式cranknicolson">隐式有限差分格式(Crank–Nicolson)</h2><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t}=0.5\left(\frac{T_{i+1, j}^{n+1}-2 T_{i,j}^{n+1}+T_{i-1, j}^{n+1}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n+1}-2 T_{i,j}^{n+1}+T_{i, j-1}^{n+1}}{\Delta y^{2}}\right) \\+0.5\left(\frac{T_{i+1, j}^{n}-2 T_{i, j}^{n}+T_{i-1, j}^{n}}{\Deltax^{2}}+\frac{T_{i, j+1}^{n}-2 T_{i, j}^{n}+T_{i, j-1}^{n}}{\Deltay^{2}}\right)\]</span></p><p>作为隐式方法，Crank–Nicolson格式是无条件稳定的，且其时间离散精度为二阶。</p><h2id="交替隐式迭代法alternating-direction-implicit-method">交替隐式迭代法(Alternating-directionimplicit method)</h2><ol type="1"><li>x方向隐式更新</li></ol><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t}=k\left(\frac{T_{i+1, j}^{n+1}-2 T_{i, j}^{n+1}+T_{i-1,j}^{n+1}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n}-2 T_{i, j}^{n}+T_{i,j-1}^{n}}{\Delta y^{2}}\right)\]</span></p><ol start="2" type="1"><li>y方向隐式更新</li></ol><p><span class="math display">\[\frac{T_{i, j}^{n+1}-T_{i,j}^{n}}{\Delta t / 2}=k\left(\frac{T_{i+1, j}^{n}-2 T_{i, j}^{n}+T_{i-1,j}^{n}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n+1}-2 T_{i, j}^{n+1}+T_{i,j-1}^{n+1}}{\Delta y^{2}}\right)\]</span></p><p>交替隐式迭代法是无条件稳定的，且时间和空间离散精度均为二阶，同时矩阵求解计算量优于上述其他隐式算法，具有独特的优势。</p><h1 id="参考">参考</h1><ul><li>matlab练习程序（差分法解二维热传导方程）. <ahref="http://t.zoukankan.com/tiandsp-p-14406223.html"class="uri">http://t.zoukankan.com/tiandsp-p-14406223.html</a></li><li>一文看懂交替隐式迭代法. <ahref="https://zhuanlan.zhihu.com/p/522899015"class="uri">https://zhuanlan.zhihu.com/p/522899015</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>显式差分</tag>
      
      <tag>交替隐式差分</tag>
      
      <tag>偏微分方程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拟牛顿法</title>
    <link href="/2022/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
    <url>/2022/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>拟牛顿法(Quasi-Newton Methods)<br />是求解非线性优化问题最有效的方法之一。其在牛顿法的基础上，利用相邻两个点的位移和一阶导数信息构造与二阶导数阵相似的正定矩阵。从而以在不直接计算Hessian矩阵的情况下实现高维问题的超线性收敛。</p><p>牛顿法通过计算每一步的梯度 <span class="math inline">\(\nablaf\left(\mathbf{x}_{k}\right)\)</span> 与Hessian矩阵 <spanclass="math inline">\(\mathbf{H}_{f}\left(\mathbf{x}_{k}\right)\)</span>迭代更逼近驻点的 <spanclass="math inline">\(\mathbf{x}_{k+1}\)</span></p><p><spanclass="math display">\[\mathbf{x}_{k+1}=\mathbf{x}_{k}-\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)\nabla f\left(\mathbf{x}_{k}\right).\]</span></p><p>其最大难度在于求解维度超大的Hessian矩阵与其逆矩阵 <spanclass="math inline">\(\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)\)</span>，而拟牛顿法则通过一维导数（梯度）的变化便可以得到近似的Hessian矩阵，而大大降低了求解难度与求逆的时间。</p><h1 id="基本步骤">基本步骤</h1><p>（以下高维向量、矩阵不再加粗表示）</p><p>记 <span class="math inline">\(B_k\)</span> 表示第 <spanclass="math inline">\(k\)</span>次迭代的近似Hessian矩阵称为切线刚度矩阵，其初始为单位矩阵，即 <spanclass="math inline">\(B_0=I\)</span>. 根据</p><p><span class="math display">\[B_kp_k=-\nablaf\left(x_{k}\right)\]</span></p><p>计算 <span class="math inline">\(p_k\)</span>，作为每一次迭代的步。</p><p><span class="math display">\[x_{k+1}=x_k+\alpha p_k\]</span></p><p>其中 <span class="math inline">\(\alpha\)</span> 一般计为 <spanclass="math inline">\(1.0\)</span>，也可以从 <spanclass="math inline">\(1.0\)</span> 折半查找，直到 <spanclass="math inline">\(f(x_{k+1})\)</span> 更优。计算</p><p><span class="math display">\[s_k=\alpha p_k\ ,\ y_k=\nablaf\left(x_{k+1}\right)-\nabla f\left(x_{k}\right).\]</span></p><p>计算新的刚度矩阵</p><p><span class="math display">\[B_{k+1}=B_{k}-\frac{B_{k} s_{k}s_{k}^{T} B_{k}}{s_{k}^{T} B_{k} s_{k}}+\frac{y_{k} y_{k}^{T}}{y_{k}^{T}s_{k}} （BFGS算法）.\]</span></p><p>若误差足够小，如等式约束两端误差小于 <spanclass="math inline">\(\epsilon\)</span> 则得到解，否则继续迭代。</p><h1 id="刚度矩阵算法">刚度矩阵算法</h1><p>以上以BFGS法为例，介绍了基本的拟牛顿法步骤，其他方法也仅仅在计算刚度矩阵上进行的变化。</p><h2 id="dfp法">DFP法</h2><p><span class="math display">\[B_{k+1}=B_{k}-\frac{B_{k} y_{k}y_{k}^{T} B_{k}}{y_{k}^{T} B_{k} y_{k}}+\frac{s_{k} s_{k}^{T}}{y_{k}^{T}s_{k}}\]</span></p><p>DFP方法是秩-2更新的一种，由它产生的矩阵 <spanclass="math inline">\(B_k\)</span> 是正定的，而且满足这样的极小性：</p><p><span class="math display">\[\min _{B}\left|B-B_{k}\right| \text {s.t. } B=B^{T}, B s_{k}=y_{k}\]</span></p><h2 id="bfgs法">BFGS法</h2><p><span class="math display">\[B_{k+1}=B_{k}-\frac{B_{k} s_{k}s_{k}^{T} B_{k}}{s_{k}^{T} B_{k} s_{k}}+\frac{y_{k} y_{k}^{T}}{y_{k}^{T}s_{k}} \]</span></p><p>该方法 <span class="math inline">\(B_k\)</span>同样正定，也同样满足上述的极小性。</p><p>且BFGS和DFP公式在形式上是对称的，但是BFGS比DFP更加有效。</p><h2 id="对称秩1sr1法">对称秩1（SR1）法</h2><p><span class="math display">\[B_{k+1}=B_{k}+\frac{\left(y_{k}-B_{k}s_{k}\right)\left(y_{k}-B_{k} s_{k}\right)^{T}}{\left(y_{k}-B_{k}s_{k}\right)^{T} s_{k}}\]</span></p><p>有别于DFP和BFG方法，SR1是一种秩-1更新。</p><p>SR1公式不要求矩阵 <span class="math inline">\(B_k\)</span>保持正定性，从而更逼近真实的Hesse矩阵，所以适用于信赖域方法(Trust RegionMethods)。</p><h2 id="broyden族">Broyden族</h2><p><span class="math display">\[B_{k+1}=\left(1-c_{k}\right) B_{k+1}^{BF G S}+c_{k} B_{k+1}^{D F P}\]</span></p><p>当 <span class="math inline">\(c_k=0\)</span>时，Broyden族公式就变成了BFGS公式；当 <spanclass="math inline">\(c_k=1\)</span>时，Broyden族公式就变成了DFP公式。因此BFGS和DFP均可看成Broyden族的特殊形式或者其中一员。</p><h1 id="参考">参考</h1><ul><li><ahref="https://baike.baidu.com/item/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/9340944"class="uri">https://baike.baidu.com/item/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/9340944</a></li><li><a href="https://zhuanlan.zhihu.com/p/45221013"class="uri">https://zhuanlan.zhihu.com/p/45221013</a></li><li><a href="https://zhuanlan.zhihu.com/p/222899764"class="uri">https://zhuanlan.zhihu.com/p/222899764</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>拟牛顿法</tag>
      
      <tag>BFGS法</tag>
      
      <tag>DFP法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛顿迭代与高斯牛顿法</title>
    <link href="/2022/08/19/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
    <url>/2022/08/19/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一元函数下">一元函数下</h1><p>对于一元函数 <span class="math inline">\(f(x)\)</span>，其泰勒二阶展开如下为</p><p><spanclass="math display">\[f(x_{k+1})=f(x_k)+f&#39;(x_k)(x_{k+1}-x_k)+\frac{1}{2}f&#39;&#39;(x_k)(x_{k+1}-x_k)^2+O(x^2).\]</span></p><p>记 <span class="math inline">\(z=x_{k+1}-x_k\)</span>省略余项可表示为</p><p><span class="math display">\[f(x_{k+1})\approxf(x_k)+f&#39;(x_k)\cdot z+\frac{1}{2}f&#39;&#39;(x_k)\cdotz^2=g(x).\]</span></p><ul><li>若要求 <span class="math inline">\(f(x)\)</span>的<strong>零点</strong>，即想要 <spanclass="math inline">\(f(x_{k+1})=0\)</span>，省略二阶展开易得</li></ul><p><span class="math display">\[f(x_k)+f&#39;(x_k)\cdotz=0,\]</span></p><p><spanclass="math display">\[z=-\frac{f(x_k)}{f&#39;(x_k)},\]</span></p><p><spanclass="math display">\[x_{k+1}=x_k-\frac{f(x_k)}{f&#39;(x_k)}.\]</span></p><ul><li>若要求 <span class="math inline">\(f(x)\)</span>的<strong>极值点</strong>，即想要 <spanclass="math inline">\(f&#39;(x_{k+1})=0\)</span>，也就是 <spanclass="math inline">\(g&#39;(z)=0\)</span> ，有</li></ul><p><spanclass="math display">\[g&#39;(z)=f&#39;(x_k)+f&#39;&#39;(x_k)\cdotz=0，\]</span></p><p><spanclass="math display">\[z=-\frac{f&#39;(x_k)}{f&#39;&#39;(x_k)},\]</span></p><p><spanclass="math display">\[x_{k+1}=x_k-\frac{f&#39;(x_k)}{f&#39;&#39;(x_k)}.\]</span></p><h1 id="多元函数下">多元函数下</h1><p>基本过程为：</p><ol type="1"><li>二阶逼近</li><li>逼近式对增量求一阶导为零</li><li>求出增量计算格式</li><li>代回得到迭代式</li></ol><p>二阶逼近为</p><p><span class="math display">\[f\left(\mathbf{x}_{k}+\mathbf{z}\right)\approx f\left(\mathbf{x}_{k}\right)+\left[\nablaf\left(\mathbf{x}_{k}\right)\right]^{T} \mathbf{z}+\frac{1}{2}\mathbf{z}^{T}\left[\nabla^{2} f\left(\mathbf{x}_{k}\right)\right]\mathbf{z}.\]</span></p><p>其中 <span class="math inline">\(\mathbf{x}=\left(x_1,x_2\cdotsx_n\right)^T\)</span>，<spanclass="math inline">\(\mathbf{z}=\left(z_1,z_2\cdotsz_n\right)^T.\)</span> 有</p><p><span class="math display">\[\nablaf\left(\mathbf{x}_{k}\right)=\left(\begin{array}{cccc}\frac{\partial f(\mathbf{x})}{\partial x_{1}} &amp;\frac{\partial f(\mathbf{x})}{\partial x_{2}} &amp;\cdots &amp;\frac{\partial f(\mathbf{x})}{\partial x_{n}}\end{array}\right)^T.\]</span></p><p>又有</p><p><span class="math display">\[\nabla^{2} \mathbf{f}=\nabla \otimes\nabla \mathbf{f}=\left[\begin{array}{cccc}\frac{\partial^{2} f}{\partial^{2} x_{1}} &amp; \frac{\partial^{2}f}{\partial x_{1} \partial x_{2}} &amp; \cdots &amp; \frac{\partial^{2}f}{\partial x_{1} \partial x_{n}} \\\frac{\partial^{2} f}{\partial x_{2} \partial x_{1}} &amp;\frac{\partial^{2} f}{\partial x_{2} \partial x_{2}} &amp; \cdots &amp;\frac{\partial^{2} f}{\partial x_{2} \partial x_{n}} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\frac{\partial^{2} f}{\partial x_{n} \partial x_{1}} &amp; \cdots &amp;\ldots &amp; \frac{\partial^{2} f}{\partial^{2} x_{n}}\end{array}\right]\]</span></p><p>这就是Hessian矩阵，记为 <spanclass="math inline">\(\mathbf{H}_{f}(\mathbf{x})\)</span>.</p><p>令一阶导为 <span class="math inline">\(0\)</span>，得到</p><p><span class="math display">\[\nablaf\left(\mathbf{x}_{k}\right)+\left[\nabla^{2}f\left(\mathbf{x}_{k}\right)\right] \mathbf{z}=0,\]</span></p><p><spanclass="math display">\[\mathbf{z}=-\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)\nabla f\left(\mathbf{x}_{k}\right),\]</span></p><p><spanclass="math display">\[\mathbf{x}_{k+1}=\mathbf{x}_{k}-\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)\nabla f\left(\mathbf{x}_{k}\right).\]</span></p><p>因为这里Hessian矩阵不一定可逆，最简单直接的思路是在 <spanclass="math inline">\(\mathbf{H}^{-1}_{f}(\mathbf{x})\)</span>的对角线上加上一个正数：</p><p><spanclass="math display">\[\mathbf{x}_{k+1}=\mathbf{x}_{k}-\left(\mathbf{H}_{f}^{-1}\left(\mathbf{x}_{k}\right)+\mu\mathbf{I}\right) \nabla f\left(\mathbf{x}_{k}\right).\]</span></p><h1 id="求最小二乘问题">求最小二乘问题</h1><p>记损失函数为</p><p><spanclass="math display">\[\ell(\mathbf{w})=\frac{1}{2}\|f(\mathbf{X} ,\mathbf{w})-\mathbf{Y}\|^{2}=\frac{1}{2} \mathbf{e}^{2}.\]</span></p><p>其中 <span class="math inline">\(\mathbf{w}\)</span>是全体参数组成的向量， <span class="math inline">\(\mathbb{e}\)</span>是误差值组成的向量。其二阶展开式如下</p><p><spanclass="math display">\[\ell\left(\mathbf{w}_{k}+\mathbf{z}\right)\approx \ell\left(\mathbf{w}_{k}\right)+\left(\nabla\ell\left(\mathbf{w}_{k}\right)\right)^{T} \mathbf{z}+\frac{1}{2}\mathbf{z}^{T}\left(\nabla^{2} \ell\left(\mathbf{w}_{k}\right)\right)\mathbf{z}.\]</span></p><p>因为最小二乘法的特殊性，可以简化为</p><p><span class="math display">\[\nabla\ell(\mathbf{w})=\frac{\partial\left(\frac{1}{2}\mathbf{e}^{2}\right)}{\partial \mathbf{w}}=\left(\frac{\partial\mathbf{e}}{\partial \mathbf{w}}\right)^{T}\mathbf{e}=\mathbf{J}_{\mathbf{e}}^{T}(\mathbf{w})\mathbf{e}.\]</span></p><p>这就是Jacobian矩阵即为 <spanclass="math inline">\(\mathbf{J}_{\mathbf{e}}^{}(\mathbf{w})\)</span>.注意始终保证最后的结果是列向量。求二阶导为</p><p><span class="math display">\[\nabla^{2}\ell(\mathbf{w})=\nabla(\nabla\ell(\mathbf{w}))=\frac{\partial\left(\left(\frac{\partial\mathbf{e}}{\partial \mathbf{w}}\right)^{T} \mathbf{e}\right)}{\partial\mathbf{w}}=\left(\frac{\partial \mathbf{e}}{\partial\mathbf{w}}\right)^{T}\left(\frac{\partial \mathbf{e}}{\partial\mathbf{w}}\right)+\frac{\partial^{2} \mathbf{e}}{\partial\mathbf{w}^{2}} \mathbf{e}\]</span></p><p><span class="math display">\[=\mathbf{J}_{\mathbf{e}}^{T}(\mathbf{w})\mathbf{J}_{\mathbf{e}}(\mathbf{w})+\frac{\partial^{2}\mathbf{e}}{\partial \mathbf{w}^{2}} \mathbf{e}\]</span></p><p>代回得到迭代式</p><p><spanclass="math display">\[\mathbf{w}_{k+1}=\mathbf{w}_{k}-\left.\left(\left(\mathbf{J}_{\mathbf{e}}^{T}(\mathbf{w})\mathbf{J}_{\mathbf{e}}(\mathbf{w})+\frac{\partial^{2}\mathbf{e}}{\partial \mathbf{w}^{2}} \mathbf{e}\right)^{-1}\mathbf{J}_{\mathbf{e}}^{T}(\mathbf{w})\mathbf{e}\right)\right|_{\mathbf{w}=\mathbf{w}_{k}}\]</span></p><h1 id="高斯-牛顿法">高斯-牛顿法</h1><p>在文章 Theoria motus corporum coelestium in sectionibus conicis solemambientum (1809), pp. 179-180. 中，高斯提到 <spanclass="math inline">\(\nabla^{2} \ell(\mathbf{w})\)</span>的二阶项应该很小，所以直接省略，于是再对符号简化一下，这个Hessian近似就可以写成：</p><p><span class="math display">\[\nabla^{2}\ell(\mathbf{w})=\mathbf{J}^T\mathbf{J}.\]</span></p><p>这个式子就是著名的 Gauss-Newton 法的迭代公式。但 <spanclass="math inline">\(\mathbf{J}^T\mathbf{J}\)</span>通常是半正定的，但不一定可逆的于是在对角线上加上一个正数，得到Levenberg-Marquardt 算法。</p><p><spanclass="math display">\[\mathbf{w}_{k+1}=\mathbf{w}_{k}-\left(\mathbf{J}^{T}\mathbf{J}+\mu \mathbf{I}\right)^{-1} \mathbf{J}^{T}\mathbf{e}\]</span></p><h1 id="代码">代码</h1><h2 id="一元函数">一元函数</h2><p>求<ahref="https://zhuanlan.zhihu.com/p/514647478">核酸混检问题</a>中， <spanclass="math display">\[E(x)=1-(1-p)^k-\frac{1}{k}\]</span>的最小值点。</p><div class="hljs code-wrapper"><pre><code class="hljs matlab">clc;clear;p=<span class="hljs-number">0.01</span>;syms k; <span class="hljs-comment">%自变量</span>E=@(k) <span class="hljs-number">1</span>-(<span class="hljs-number">1</span>-p).^k+<span class="hljs-number">1.</span>/k; <span class="hljs-comment">%每个人检测次数的期望</span>kDif=matlabFunction(diff(E,k,<span class="hljs-number">1</span>));kDiif=matlabFunction(diff(E,k,<span class="hljs-number">2</span>));<span class="hljs-comment">%% 牛顿迭代法</span>x=[<span class="hljs-number">0.1</span>];<span class="hljs-comment">%当x过大kDiif(x)为负，函数为凸，会倾向于寻找极大值</span><span class="hljs-keyword">while</span> <span class="hljs-built_in">abs</span>(kDif(x(<span class="hljs-keyword">end</span>)))&gt;<span class="hljs-number">1e-10</span>    z=-kDif(x(<span class="hljs-keyword">end</span>))/kDiif(x(<span class="hljs-keyword">end</span>));    x(<span class="hljs-keyword">end</span>+<span class="hljs-number">1</span>)=<span class="hljs-built_in">abs</span>(x(<span class="hljs-keyword">end</span>)+z);<span class="hljs-comment">%因为kDif(x)是偶函数</span><span class="hljs-keyword">end</span>fprintf(<span class="hljs-string">&#x27;ans=%d\n&#x27;</span>,x(<span class="hljs-keyword">end</span>));<span class="hljs-comment">%% 画图</span>xx = <span class="hljs-number">-10</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">100</span>;yy=kDif(xx);<span class="hljs-built_in">plot</span>(xx,yy,<span class="hljs-string">&#x27;LineWidth&#x27;</span>,<span class="hljs-number">3</span>);<span class="hljs-built_in">hold</span> on;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(x,<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;    <span class="hljs-built_in">plot</span>([x(<span class="hljs-built_in">i</span>),x(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>)],[kDif(x(<span class="hljs-built_in">i</span>)),<span class="hljs-number">0</span>]);    <span class="hljs-built_in">plot</span>([x(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>),x(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>)],[<span class="hljs-number">0</span>,kDif(x(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>))]);<span class="hljs-keyword">end</span>axis([<span class="hljs-number">-10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">-0.1</span>,<span class="hljs-number">1</span>]);</code></pre></div><h1 id="参考">参考</h1><p>本文几乎全部复制于<ahref="https://www.zhihu.com/question/419979308/answer/1461043023">知乎回答</a>，仅作学习使用。</p><ul><li><a href="https://www.zhihu.com/question/419979308/answer/1461043023"class="uri">https://www.zhihu.com/question/419979308/answer/1461043023</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牛顿迭代</tag>
      
      <tag>高斯牛顿法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【摘抄】夜访镜小记</title>
    <link href="/2022/06/29/24/"/>
    <url>/2022/06/29/24/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>注意！此文仅作摘抄，禁止挪用从事商业用途！</p>          </div><p>前语：这是一篇蹩脚语言模仿写就的文章。倘若有人阅读它，发现点什么的话，我需要说明，它没有任何嘲讽谁的意思，你的一切发现，请算作是我的弊病。</p><h1 id="夜访镜小记">《夜访镜小记》</h1><p>今夜瞧见镜子跟前有道亮光晃眼，走近才发现有人在里面点灯写着东西。敲敲镜面，里头的人看到我大吃一惊，骇得合上笔记：“现在还有人看得到镜里头有人？”</p><p>看到镜中人就是我，却一副难以置信的表情，不禁生疑，忙大声呵斥：“心中有愧，才鬼鬼祟祟，大半夜不睡，还点灯在桌前做什么？”听到这话，里头的人却大笑起来。</p><p>“有愧的人对镜方见得我！我就是你们，你们就是我。不信你且进来仔细瞧瞧。”几近迟疑，还是迈起步子进了镜。这下他更吃惊了：“快请坐！看来我境界远不及你。听闻一个人面孔越是有多张，越是狡诈虚伪，越是能够在镜内外顺畅而行。别看我长得和你一般模样，此刻心里却是恭敬极了。”</p><p>我试图寻找一个凳子坐下，环顾四周，除了他的桌子前有暗光一片，其他地方什么也看不清：“是我叫你这里蓬荜生暗了！我也想坐下，但是这里丝毫没有一点亮光，我找不到板凳。”他四处摸索一番，终于搬出一个破凳子：“实在招待不周，是我让你见了笑话。镜子里的光从来都是趁人家照镜子的时候收集起来，现在照镜子的人越来越少，我们也没什么像样的光能收集。好不容易以为人家照了镜子，结果全是在一颗小小的摄像头里成像，这样来的光，又能亮到哪里去？不瞒你说，我现在这里光也快耗尽了。我看到那面成像的镜子里头光鲜亮丽，和我这里照出来的，完全是两码模样。照来照去，我们几乎快一般黑了。”我对他的遭遇十分同情，拍了拍他肩膀：“想必过去这里一定辉煌！”</p><p>他高兴起来，连声喊道：“那是！那是！再早一点，黏附我们的人占了半个地球，大家以照镜子为荣，好写自我批评为风气，那时候此地终年不暗，镜内富丽堂皇，顶得上半个地球！”我没想到衰落如此迅捷，不由得唉声叹了口气。但我仍然很有疑惑：“那你们和镜子外的人，比方你和我，到底像不像？”</p><p>镜中人不高兴，头摇似波浪鼓。“枉我初觉你境界比我高来的，不曾想，还是落入下乘！我们面孔几时会倒映出那么多张？说到底只有一张罢，但偏是奇怪，虽然只有这一张脸，但又会看起来很多张。我这面镜子能知晓两张脸已然不错，而你们却有更多。”我一时间不能明白其中深意，只能请求他继续说。</p><p>好似尝到点甜头，他嘴如弹簧：“比方说一位道貌岸然的人，背地里想法不知道有多龌龊。越是光明正大，背地越是暗——如同现在镜中一般，因为人始终不是透明的。我越是表现得对这些东西不感兴趣，我就有可能越是知道它是个什么东西。别看有时候我是主席、书记、党员，但是我成为他的过程并不是我觉悟良知觉醒的过程，我依旧仰仗那点特权来行事。我身居其位，冠冕堂皇，但一无作为。我对于名利，表现得好像永不热衷，但你要叫我触碰到它，我定俯下身子渴求迎接它。”</p><p>一个镜中人胆敢妄议外界，我大声呵斥他：“这实在荒唐！那么多人怎因你一句话而什么也不是？”镜中人朝我微微一拜：“不得不说我实在对您是越来越崇敬了。刚才应是我走了眼，现在这副为人师的说教模样背后，是什么我可一清二楚，但您现在就是会叫我相信您的劝诫。我无意冒犯，因为钻空子、伪造材料仅仅有损道德的事我也做的太多，这方面怎么说都是五十步笑百步罢了。”我一时面红耳赤。镜中人赶忙赔不是：“我初衷不是要羞辱您的，您且相信我——我仍然打心眼佩服您，如同佩服您之于卡尔维诺文学理论、谢林深奥的哲学语言的评述一般。”</p><p>我面色稍微好看，但仍然冷哼：“不必如此捧杀我，我说不上通晓，仅仅是了解罢了。那些情况或许有，当然不是全部……”镜中人打断我：“对，您说的极是！就是这样只字未看或一无所知而大谈特谈的境界让我望尘莫及。我正是这样子，倘若有人爱好看书写文章，我就说他杜甫再世；有人家底殷实，不过看了两眼乞丐，我就说他悲天悯怀。如此大家也多愿意照照镜子。”</p><p>我不得接语，只得敷衍：“也行。”镜中人依旧兴奋，喋喋不语：“这就是您第三副面孔了，好似不反对我，也不同意我，俨然一个和事佬。但您此刻定在嘲笑我的自负。我贬低他人，贬低事物，当然是为了抬高我个人的精神境界。但我要装作有反思的模样，对这些时刻感到羞愧，方见的我的道德本心。我虽没有恒心与高见，我虽懒惰而成天沉溺网络，但这不妨碍我和大众——不论对错，一起抨击世界的黑暗。”</p><p>“这样非此即彼的事物被你提出来，你也敢说你了解我们么？”我希望在此刻为镜外扳回一城，看向他桌子前的文稿。上面写着诸如“去标签化”“非黑即白”“女拳”“爹味”一类的词语。镜中人注意到我的眼光，示意我翻翻看：“这些东西也叫您看个乐呵。我每天记录着镜外的思想，想要融入其中，但仍然有这些叫我摸不着头脑的词语。我看见您们总是闹腾，总是互相对立，围绕主题谈及社会、国家、性别等议题，好不热闹，恳请您向我讲述它们的含义。它们是否也如人们互相贬低一般，好彰显自己的高尚？”</p><p>我详细阐述这些语词，又表达自己看法，少数发言人不意味更多在都是，经验的归纳始终有其整体的缺陷。他听完低下了头，将唯一的灯光拢在文稿前，终于表露自己的惭愧：“看来我始终自以为是来理解镜外。看我的第一页吧，我将其和大家的左右逢源作比较，一面说着某人的坏话，一面与某人接触，这好似是‘非黑即白’的相处方式；并且做上了密密麻麻的注脚，用别人与我们说自己的秘密，我们权当它似一阵风四处散播。但其中无穷奥秘，难以参透。”</p><p>我翻看到第三页之后，惊呼于镜中人有其耐心，对这些事物皆有详细记录。第一章题头文字是“无关个人微小利益的语言传播”，第二章是“利益的牵涉与道德的反比关系研究”。我夸赞他已经在向人类学家路上迈进，这些值得被分享。他摇摇头：“看来我离得仍远，仍一无所知。而且我是一个自私的人，分享这些见不到我的大公，什么时候来了像样的活动，我定然会去参与，叫世人瞧瞧来自镜中的哲学。虽然您们自诩某种团体，因此有其骄傲，但我对此是不服气的，我虽无学历，难道就一定走得比你们差些么？”</p><p>当我想继续回答他时，最后一点灯光忽然灭了。迎接的是半晌得沉默。末了，他叹口气：“始终是大家窥探别人来满足自己太多，常和人交锋、闲聊彼此太多，不愿意照镜子了。我想大概你也很难再见到我罢。”我大声喊：“请继续等待，仍有人有良知本心！”</p><p>只听来一声，“你看看现在，我如何能等待”，即被大力推出镜外，还有一份未竟稿也落在地上，上面写满个人与义务、自由与责任等的讨论，显得矛盾而混乱，看来他没有得到想要的结果。将稿折成两半收起来，我再看看镜子，一片漆黑，偶有亮光，那是假反思、假羞愧的折射，偶尔露出镜中人——我的其他面孔。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>摘抄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编程训练】路径存储与迷宫寻路 - 指针</title>
    <link href="/2022/06/26/23/"/>
    <url>/2022/06/26/23/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题描述">问题描述</h1><p>试图充分运用所学的C++面向对象的知识和封装性，完成一个拓展度高，可编辑型高，有多种兼容性接口的程序。能完成对路径和结点的简历和存储，以此进行最短寻路。达到对所学内容的巩固。</p><h1 id="结果展示">结果展示</h1><figure><img src="https://s2.loli.net/2022/06/26/M8XfT6bvKjAFGny.png"alt="可视化结果" /><figcaption aria-hidden="true">可视化结果</figcaption></figure><h1 id="代码">代码</h1><p>注：以下为合并后的代码，根据注释是可以拆分为很多头文件的，更加可读和可编辑。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">/*</span><span class="hljs-comment">//point.h</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&#123;</span><span class="hljs-comment">//模板函数</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> identify;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Point</span>(<span class="hljs-keyword">int</span> x):<span class="hljs-built_in">identify</span>(x)&#123;        <span class="hljs-comment">//printf(&quot;create Point %d.\n&quot;,identify);</span>    &#125;    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Point</span>()&#123;        <span class="hljs-comment">//printf(&quot;clear Point %d.\n&quot;,identify);</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_ID</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> identify;&#125;&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment">path.h 与 node.h 的合并，防止相互引用头文件</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">#include&quot;point.h&quot;</span><span class="hljs-comment">#include&lt;cstdio&gt;</span><span class="hljs-comment">#include&lt;cstdlib&gt;</span><span class="hljs-comment">using namespace std;</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Path</span>&#123;</span>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> val;    Node *to;    Path *nxt;<span class="hljs-keyword">public</span>:        <span class="hljs-function">Path* <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> nxt;&#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vall</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> val;&#125;    <span class="hljs-function">Node* <span class="hljs-title">gono</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> to;&#125;    <span class="hljs-built_in">Path</span>(<span class="hljs-keyword">int</span> w,Node *go_v,Path *nex=<span class="hljs-literal">NULL</span>) : <span class="hljs-built_in">val</span>(w) &#123;        <span class="hljs-keyword">if</span>(w&lt;<span class="hljs-number">0</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[WAR]there are nagetive val way!\n&quot;</span>);        to=go_v;        nxt=nex;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create way val %d.\n&quot;</span>,w);    &#125;    ~<span class="hljs-built_in">Path</span>()&#123;        <span class="hljs-comment">//printf(&quot;clear way val %d.\n&quot;,val);</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><span class="hljs-keyword">public</span> Point&#123;    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_dist</span><span class="hljs-params">(Node &amp;a,Node &amp;b)</span></span>;    <span class="hljs-comment">//friend void spfa(Node &amp;u,Refmark &amp;R);</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> x,y;<span class="hljs-comment">//坐标</span>    Path *way_head;<span class="hljs-comment">//出路链表</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">bool</span> vis;<span class="hljs-keyword">int</span> dis;Node *Last;<span class="hljs-keyword">bool</span> If_Pass;    <span class="hljs-function">Path* <span class="hljs-title">head</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> way_head;    &#125;    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y):<span class="hljs-built_in">Point</span>(p),<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y)&#123;        dis=INF;        vis=<span class="hljs-number">0</span>;        way_head=<span class="hljs-literal">NULL</span>;        Last=<span class="hljs-literal">NULL</span>;        If_Pass=<span class="hljs-number">0</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create Node %d at (%d,%d), init.\n&quot;</span>,<span class="hljs-built_in">get_ID</span>(),x,y);    &#125;    ~<span class="hljs-built_in">Node</span>()&#123;        <span class="hljs-keyword">for</span>(Path *t2,*t = way_head;t!=<span class="hljs-literal">NULL</span>;t=t2)&#123;            t2=t-&gt;nxt;            <span class="hljs-keyword">delete</span> t;        &#125;        <span class="hljs-comment">//printf(&quot;clear Node %d at (%d,%d).\n&quot;,get_ID(),x,y);</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_dis</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-keyword">if</span>(dis==<span class="hljs-number">-1</span>)            <span class="hljs-keyword">return</span> INF;        <span class="hljs-keyword">if</span>(dis&lt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]get_dis error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">return</span> dis;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_way</span><span class="hljs-params">(Node *to,<span class="hljs-keyword">int</span> val)</span></span>&#123;        <span class="hljs-keyword">if</span>(way_head==<span class="hljs-literal">NULL</span>)&#123;            way_head= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Path</span>(val,to);        &#125;<span class="hljs-keyword">else</span>&#123;            way_head= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Path</span>(val,to,way_head);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add way %d to %d, val %d.\n&quot;</span>,<span class="hljs-built_in">get_ID</span>(),to-&gt;<span class="hljs-built_in">get_ID</span>(),val);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_way</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(Path *t = way_head;t!=<span class="hljs-literal">NULL</span>;t=t-&gt;nxt)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d &quot;</span>,<span class="hljs-built_in">get_ID</span>(),t-&gt;to-&gt;<span class="hljs-built_in">get_ID</span>());            cnt++;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;. totally %d ways.\n&quot;</span>,cnt);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_dist</span><span class="hljs-params">(Node &amp;a,Node &amp;b)</span></span>&#123;<span class="hljs-comment">//Point的友元函数 曼哈顿距离</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a.x-b.x)+<span class="hljs-built_in">abs</span>(a.y-b.y);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">queue_node.h 队列</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">#include&quot;graph.h&quot;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue_node_element</span>&#123;</span><span class="hljs-keyword">public</span>:    Node *element;    Queue_node_element *nxt;    <span class="hljs-built_in">Queue_node_element</span>(Node &amp;x,Queue_node_element *p=<span class="hljs-literal">NULL</span>):<span class="hljs-built_in">element</span>(&amp;x),<span class="hljs-built_in">nxt</span>(p)&#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue_node</span>&#123;</span><span class="hljs-keyword">private</span>:    Queue_node_element *head,*tail;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Queue_node</span>()&#123;head=tail=<span class="hljs-literal">NULL</span>;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//head</span>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]Queue_node pop error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        Queue_node_element *cl = head;        head = head-&gt;nxt;           <span class="hljs-keyword">delete</span> cl;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Node &amp;x)</span></span>&#123;<span class="hljs-comment">//tail</span>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;            head=tail= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Queue_node_element</span>(x,<span class="hljs-literal">NULL</span>);            <span class="hljs-keyword">return</span>;        &#125;        tail-&gt;nxt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Queue_node_element</span>(x,<span class="hljs-literal">NULL</span>);        tail = tail-&gt;nxt;    &#125;    <span class="hljs-function">Node&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//head</span>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]Queue_node front error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">return</span> *(head-&gt;element);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment">refmark.h</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">#include&quot;graph.h&quot;</span><span class="hljs-comment">#include&quot;node.h&quot;</span><span class="hljs-comment">#include&quot;path.h&quot;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e2</span>;<span class="hljs-comment">//1e3会过大</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm = <span class="hljs-number">1e2</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Refmark</span>&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> n,m;    Node *ref_p[maxn*maxm];<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-keyword">return</span> (x<span class="hljs-number">-1</span>)*m+y;    &#125;    <span class="hljs-function">Node* <span class="hljs-title">new_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;        <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">1</span>||p&gt;n*m)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]new_ref error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span>(ref_p[p]!=<span class="hljs-literal">NULL</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[WAR]new_ref cover old!\n&quot;</span>);        ref_p[p]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(p,(p<span class="hljs-number">-1</span>)/m+<span class="hljs-number">1</span>,(p<span class="hljs-number">-1</span>)%m+<span class="hljs-number">1</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init new ref %d.\n&quot;</span>,p);        <span class="hljs-keyword">return</span> ref_p[p];    &#125;    <span class="hljs-function">Node* <span class="hljs-title">new_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//重载</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_ref</span>(<span class="hljs-built_in">mark</span>(x,y));    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-function">Node* <span class="hljs-title">ask_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-comment">//询问对应的Node</span>        <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">1</span>||p&gt;n*m)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]ask_ref error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span>(ref_p[p]==<span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_ref</span>(p);        <span class="hljs-keyword">return</span> ref_p[p];    &#125;    <span class="hljs-function">Node* <span class="hljs-title">ask_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//重载</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask_ref</span>(<span class="hljs-built_in">mark</span>(x,y));    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">if_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<span class="hljs-comment">//询问对应的Node是否存在</span>        <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">1</span>||p&gt;n*m)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERR]ask_ref error!\n&quot;</span>);            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span>(ref_p[p]==<span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">if_ref</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-comment">//重载</span>        <span class="hljs-keyword">return</span> if_ref(<span class="hljs-built_in">mark</span>(x,y));    &#125;    <span class="hljs-built_in">Refmark</span>(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m):<span class="hljs-built_in">n</span>(n),<span class="hljs-built_in">m</span>(m)&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n*m) ref_p[i]=<span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;creat ref %d*%d, init.\n&quot;</span>,n,m);    &#125;    ~<span class="hljs-built_in">Refmark</span>()&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n*m)            <span class="hljs-keyword">delete</span> ref_p[i];        <span class="hljs-comment">//printf(&quot;clear ref.\n&quot;);</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memset_vis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>)</span></span>&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n*m)&#123;            <span class="hljs-keyword">if</span>(ref_p[i]==<span class="hljs-literal">NULL</span>)                <span class="hljs-keyword">continue</span>;            ref_p[i]-&gt;vis=k;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memset ref_p as %d.\n&quot;</span>,k);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_way</span><span class="hljs-params">(Node *u,Node *v,<span class="hljs-keyword">int</span> w=<span class="hljs-number">1</span>)</span></span>&#123;    u-&gt;<span class="hljs-built_in">add_way</span>(v,w);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_way</span><span class="hljs-params">(Refmark &amp;R,<span class="hljs-keyword">int</span> p1,<span class="hljs-keyword">int</span> p2,<span class="hljs-keyword">int</span> w=<span class="hljs-number">1</span>)</span></span>&#123;    R.<span class="hljs-built_in">ask_ref</span>(p1)-&gt;<span class="hljs-built_in">add_way</span>(R.<span class="hljs-built_in">ask_ref</span>(p2),w);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_way</span><span class="hljs-params">(Refmark &amp;R,<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> y1,<span class="hljs-keyword">int</span> x2,<span class="hljs-keyword">int</span> y2,<span class="hljs-keyword">int</span> w=<span class="hljs-number">1</span>)</span></span>&#123;    R.<span class="hljs-built_in">ask_ref</span>(x1,y1)-&gt;<span class="hljs-built_in">add_way</span>(R.<span class="hljs-built_in">ask_ref</span>(x2,y2),w);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">spfa.h</span><span class="hljs-comment">#pragma once</span><span class="hljs-comment">#include&quot;refmark.h&quot;</span><span class="hljs-comment">#include&quot;queue_node.h&quot;</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(Node &amp;u,Refmark &amp;R)</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nbegin spfa at %d.\n&quot;</span>,u.<span class="hljs-built_in">get_ID</span>());    Queue_node q;    R.<span class="hljs-built_in">memset_vis</span>(<span class="hljs-number">0</span>);    q.<span class="hljs-built_in">push</span>(u);u.vis=<span class="hljs-number">1</span>;    u.dis=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        Node &amp;u =q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        u.vis=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(Path *t = u.<span class="hljs-built_in">head</span>();t!=<span class="hljs-literal">NULL</span>;t=t-&gt;<span class="hljs-built_in">next</span>())&#123;            Node &amp;v = *(t-&gt;<span class="hljs-built_in">gono</span>());            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d\n&quot;</span>,u.<span class="hljs-built_in">get_ID</span>(),v.<span class="hljs-built_in">get_ID</span>());            <span class="hljs-keyword">if</span>(v.dis&gt;u.dis+t-&gt;<span class="hljs-built_in">vall</span>())&#123;                v.dis = u.dis + t-&gt;<span class="hljs-built_in">vall</span>();                 v.Last=&amp;u;            &#125;             <span class="hljs-comment">//printf(&quot;%d %d %d\n&quot;,v.dis,u.dis,t-&gt;vall());</span>            <span class="hljs-keyword">if</span>(v.vis)                <span class="hljs-keyword">continue</span>;            q.<span class="hljs-built_in">push</span>(v);            v.vis=<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end spfa.\n\n&quot;</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">main.cpp</span><span class="hljs-comment">#include&quot;refmark.h&quot;</span><span class="hljs-comment">#include&quot;queue_node.h&quot;</span><span class="hljs-comment">#include&quot;spfa.h&quot;</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Node *S,*T;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入地图大小：&quot;</span>);    cin&gt;&gt;n&gt;&gt;m;    Refmark R=<span class="hljs-built_in">Refmark</span>(n,m);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入地图路径：&quot;</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">int</span> x1,y1,x2,y2;        cin&gt;&gt;x1;        <span class="hljs-keyword">if</span>(x1==<span class="hljs-number">-1</span>)            <span class="hljs-keyword">break</span>;        cin&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;        <span class="hljs-built_in">build_way</span>(R,x1,y1,x2,y2);    &#125;    <span class="hljs-keyword">int</span> x,y;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n请输入出发点坐标：&quot;</span>);    cin&gt;&gt;x&gt;&gt;y;    S=R.<span class="hljs-built_in">ask_ref</span>(x,y);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入终点坐标：&quot;</span>);    cin&gt;&gt;x&gt;&gt;y;    T=R.<span class="hljs-built_in">ask_ref</span>(x,y);    <span class="hljs-built_in">spfa</span>(*S,R);<span class="hljs-comment">//出发点</span>    cout&lt;&lt;<span class="hljs-string">&quot;ans=&quot;</span>&lt;&lt;T-&gt;dis&lt;&lt;endl;    Node *P = T;    <span class="hljs-keyword">if</span>(T-&gt;dis&lt;INF)        <span class="hljs-keyword">while</span>(P!=S)&#123;            P-&gt;If_Pass=<span class="hljs-number">1</span>;            P = P-&gt;Last;        &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-keyword">if</span>(R.if_ref(i,j)==<span class="hljs-number">0</span>)&#123;                cout&lt;&lt;<span class="hljs-string">&quot; # &quot;</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//cout&lt;&lt;setw(3)&lt;&lt;R.ask_ref(i,j)-&gt;dis;</span>                <span class="hljs-keyword">if</span>(R.<span class="hljs-built_in">ask_ref</span>(i,j)==S)&#123;                    cout&lt;&lt;<span class="hljs-string">&quot; @ &quot;</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(R.<span class="hljs-built_in">ask_ref</span>(i,j)==T)&#123;                    cout&lt;&lt;<span class="hljs-string">&quot; $ &quot;</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(R.<span class="hljs-built_in">ask_ref</span>(i,j)-&gt;If_Pass)&#123;                    cout&lt;&lt;<span class="hljs-string">&quot; . &quot;</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                cout&lt;&lt;<span class="hljs-string">&quot;   &quot;</span>;            &#125;        &#125;        cout&lt;&lt;endl;    &#125;    cout&lt;&lt;endl;    cout&lt;&lt;<span class="hljs-string">&quot;END&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">10 10</span><span class="hljs-comment">1 1 1 2</span><span class="hljs-comment">1 2 2 2</span><span class="hljs-comment">2 2 2 3</span><span class="hljs-comment">2 3 3 3</span><span class="hljs-comment">3 3 4 3</span><span class="hljs-comment">4 3 4 4</span><span class="hljs-comment">4 4 4 5</span><span class="hljs-comment">4 5 5 5</span><span class="hljs-comment">5 5 6 5</span><span class="hljs-comment">6 5 7 5</span><span class="hljs-comment">7 5 7 6</span><span class="hljs-comment">7 6 7 7</span><span class="hljs-comment">7 7 7 8</span><span class="hljs-comment">7 8 8 8</span><span class="hljs-comment">8 8 9 8 </span><span class="hljs-comment">-1</span><span class="hljs-comment">1 1</span><span class="hljs-comment">5 5</span><span class="hljs-comment">*/</span></code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>大学相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>指针</tag>
      
      <tag>SPFA</tag>
      
      <tag>栈</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022a半年鉴 - 界</title>
    <link href="/2022/06/25/22%E5%B9%B4%E6%8A%A5/"/>
    <url>/2022/06/25/22%E5%B9%B4%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>你还好吗？要继续走啊……</p></blockquote>        <div id="aplayer-aelclChY" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"报国寺喝茶","author":"孔柏森 / 汪漾","url":"http://music.163.com/song/media/outer/url?id=1306585974.mp3","pic":"http://p2.music.126.net/4haOyOxkyFS2EzE3-TWnRg==/109951163527208913.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-aelclChY");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><hr /><h1 id="学习">1 学习</h1><h2 id="部分学科总结">1.1 部分学科总结</h2><p>来到大学，已然是一年了，一年以来的成长让我褪去的从前，改变了高中的习模式，也成为了一个真正的大学生。</p><p>问题依然显著。在今年一二月的寒假里，我提前完成了大学物理（浏览）、高等数学II、概率论与数理统计的预习，本以为能带来极大的先发优势和减轻学习压力，但是事实并不如人意。</p><p>对于大物，我仅仅是翻看完了整本书记，凭借高中物理竞赛的底，评估结果为难度不大，但是这学期里发现大物的许多公式并没有理解，同时考试与作业并不需要记底层的公式，仅仅需要记住简单的二级结论。这虽然大大减轻了学习难度，但是也给我带了了割裂感——我的大物并没有展现出应有的能力，特别是在经典力学（转动惯量）之后，进入狭义相对论与电磁场后，问题突出，我是在考试前一天才翻看理解了这部分的书上的内容。</p><p>对于高等数学，预习的成效还是有的，但是并不显著，以至于课上我开小差后甚至并不能跟上，究其原因是没有完全的深入的理解和记录内容，同时缺少题目的练习导致的缺陷。</p><p>对英语的学习时间少，同时逃避心理加剧，导致英语依然是严重的漏洞。</p><h2 id="学习时间与状态">1.2 学习时间与状态</h2><p>大概是在半期左右的以前，我基本上都做到了坚持的学习计划安排，特别是在开学的一个月内，心里巨大的压力，促成了我的早起较早睡的，包括早上7:10后起，7:30到达图书馆，9:20去上课的时间表，以及非上课时间段都在图书馆的习惯，可惜的是，学习效率并不理想。一直到几次数学建模比赛又大大的改变了我的作息，破坏了我的生物钟和脑海的鉴定，有小段时间的荒废，直到期末考试的压力下的重新奔走图书馆。这便是这学期大致的学习状态的变化。</p><p>关于心理状态，其实是渐渐减弱的，刚开学时我给自己的压力非常大。可能那是一面墙，一面光怪陆离仿佛是大千世界的壁障，在黑暗的宇宙里向我压下来。来自工作、学习、竞赛队伍的压力随着时间渐渐减弱……压力大到被自我调节了。</p><h1 id="竞赛">2 竞赛</h1><p>看起来每年的上半年和学年的下期，才是我所参加竞赛的集中展开时间。依托ACM/ICPC类的程序设计比赛的举办和数学建模风暴月，我获得了可观的奖项数和一定的质量，这大大增添了我的简历，但也开始成为群里被“阴阳”和捧杀的对象。</p><h1 id="同道">3 同道</h1><p>换届大大削减了我过多的所在集体，最后仅仅还有：ACM校队（协会）、数学建模学术部（老头痛部长团）、惟悦工作室</p><p>对我刺痛最深的是数学建模协会没能任选与留任，具体情况已经有写过了，不作赘述。但是，在“老头乐”的欢乐谷之旅以及后来的两次烧烤摊故事会和最近的会长脱单行动里和大家打成一片，也很好……</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>年报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编程训练】山区地貌 - 插值</title>
    <link href="/2022/05/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E5%B1%B1%E5%8C%BA%E5%9C%B0%E8%B2%8C/"/>
    <url>/2022/05/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E5%B1%B1%E5%8C%BA%E5%9C%B0%E8%B2%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题描述">问题描述</h1><p>山区地貌:在某山区测得一些地点的高程为一个矩阵。（平面区域<spanclass="math inline">\(1200&lt;=x&lt;=4000,1200&lt;=y&lt;=3600\)</span>）</p><p>试作出该山区的地貌图和等高线图，并对几种插值方法进行比较。</p><h1 id="结果展示">结果展示</h1><figure><img src="https://s2.loli.net/2022/05/07/VnZ9MyY8WvLqhtd.png"alt="原始数据" /><figcaption aria-hidden="true">原始数据</figcaption></figure><figure><img src="https://s2.loli.net/2022/05/07/cuavoiRJ46zNBFg.png"alt="插值后" /><figcaption aria-hidden="true">插值后</figcaption></figure><h1 id="插值代码">插值代码</h1><p>注：以下采用的是两组线性插值来得到二维平面的插值数据。</p><p>对于相同的题型，仅需要修改下面<code>x,y,z</code>。 [MATLAB] main.m主程序</p><div class="hljs code-wrapper"><pre><code class="hljs m">clc;clear;x <span class="hljs-built_in">=</span> [<span class="hljs-number">1200</span><span class="hljs-number">1600</span><span class="hljs-number">2000</span><span class="hljs-number">2400</span><span class="hljs-number">2800</span><span class="hljs-number">3200</span><span class="hljs-number">3600</span><span class="hljs-number">4000</span>];y <span class="hljs-built_in">=</span> [<span class="hljs-number">3600</span><span class="hljs-number">3200</span><span class="hljs-number">2800</span><span class="hljs-number">2400</span><span class="hljs-number">2000</span><span class="hljs-number">1600</span><span class="hljs-number">1200</span>]<span class="hljs-string">&#x27;;</span><span class="hljs-string">z = [1480150015501510143013001200980</span><span class="hljs-string">     15001550160015501600160016001550</span><span class="hljs-string">     15001200110015501600155013801070</span><span class="hljs-string">     15001200110013501450120011501010</span><span class="hljs-string">     1390150015001400900    11001060950</span><span class="hljs-string">     13201450142014001300700    900    850</span><span class="hljs-string">     11301250128012301040900    500    700];</span><span class="hljs-string"></span><span class="hljs-string">figure(2);</span><span class="hljs-string">    [X,Y]=meshgrid(x,y);</span><span class="hljs-string">    mesh(X,Y,z);</span><span class="hljs-string">    title(&#x27;</span>原数据<span class="hljs-string">&#x27;);</span><span class="hljs-string"></span><span class="hljs-string">%% init</span><span class="hljs-string">h = 1;</span><span class="hljs-string">xco = [x(1):h:x(end)];</span><span class="hljs-string">yco = [y(1):-h:y(end)]&#x27;</span>;zco <span class="hljs-built_in">=</span> [];zco2 <span class="hljs-built_in">=</span> [];<span class="hljs-comment">%% spline</span>for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(z,<span class="hljs-number">1</span>)    zco(i,:) <span class="hljs-built_in">=</span> spline(x,z(i,:),xco);endfor j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(zco,<span class="hljs-number">2</span>)    zco2(:,j)<span class="hljs-built_in">=</span>spline(y,zco(:,j),yco);endfigure(<span class="hljs-number">1</span>);    [X,Y]<span class="hljs-built_in">=</span>meshgrid(xco,yco);    Z<span class="hljs-built_in">=</span>zco2;    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">%三维图</span>        mesh(X,Y,Z);    subtitle(<span class="hljs-string">&#x27;插值后三维图&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">%三维等高线</span>        contour3(X,Y,Z,<span class="hljs-number">20</span>);    title(<span class="hljs-string">&#x27;三次样条插值&#x27;</span>,<span class="hljs-string">&#x27;Color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>);    subtitle(<span class="hljs-string">&#x27;插值后三维等高线&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">%平面等高线</span>        contour(X,Y,Z,<span class="hljs-number">20</span>);    subtitle(<span class="hljs-string">&#x27;插值后平面等高线&#x27;</span>);<span class="hljs-comment">%% pchip</span>for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(z,<span class="hljs-number">1</span>)    zco(i,:) <span class="hljs-built_in">=</span> pchip(x,z(i,:),xco);endfor j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(zco,<span class="hljs-number">2</span>)    zco2(:,j) <span class="hljs-built_in">=</span> pchip(y,zco(:,j),yco);endfigure(<span class="hljs-number">1</span>);    [X,Y]<span class="hljs-built_in">=</span>meshgrid(xco,yco);    Z<span class="hljs-built_in">=</span>zco2;    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">%三维图</span>        mesh(X,Y,Z);    subtitle(<span class="hljs-string">&#x27;插值后三维图&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">%三维等高线</span>        contour3(X,Y,Z,<span class="hljs-number">20</span>);    title(<span class="hljs-string">&#x27;分段三次 Hermite 插值多项式&#x27;</span>,<span class="hljs-string">&#x27;Color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>);    subtitle(<span class="hljs-string">&#x27;插值后三维等高线&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">%平面等高线</span>        contour(X,Y,Z,<span class="hljs-number">20</span>);    subtitle(<span class="hljs-string">&#x27;插值后平面等高线&#x27;</span>);<span class="hljs-comment">%% makima</span>for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(z,<span class="hljs-number">1</span>)    zco(i,:) <span class="hljs-built_in">=</span> makima(x,z(i,:),xco);endfor j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(zco,<span class="hljs-number">2</span>)    zco2(:,j) <span class="hljs-built_in">=</span> makima(y,zco(:,j),yco);endfigure(<span class="hljs-number">1</span>);    [X,Y]<span class="hljs-built_in">=</span>meshgrid(xco,yco);    Z<span class="hljs-built_in">=</span>zco2;    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>); <span class="hljs-comment">%三维图</span>        mesh(X,Y,Z);    subtitle(<span class="hljs-string">&#x27;插值后三维图&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>); <span class="hljs-comment">%三维等高线</span>        contour3(X,Y,Z,<span class="hljs-number">20</span>);    title(<span class="hljs-string">&#x27;修正 Akima 分段三次 Hermite 插值&#x27;</span>,<span class="hljs-string">&#x27;Color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>);    subtitle(<span class="hljs-string">&#x27;插值后三维等高线&#x27;</span>);    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">%平面等高线</span>        contour(X,Y,Z,<span class="hljs-number">20</span>);    subtitle(<span class="hljs-string">&#x27;插值后平面等高线&#x27;</span>);</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维插值</tag>
      
      <tag>分段插值</tag>
      
      <tag>多项式插值</tag>
      
      <tag>埃尔米特插值</tag>
      
      <tag>样条插值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>火锅、大雨和欢庆</title>
    <link href="/2022/04/30/18/"/>
    <url>/2022/04/30/18/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>这雨湿透了整片夜，夜色下的徒步奔走与嬉戏，化为了礼物与分别。</p></blockquote><p>这一晚上过的很愉快，很难想象，在大学还能有这样的氛围，这样的环境，这样的经历。所以呢？回味吧，毕竟，可能没有下次了。</p><p><br></p><p><span class="math display">\[\tiny就老去吧，孤独别醒来\\就歌唱吧，眼睛眯起来\]</span></p><p><br></p>        <div id="aplayer-ZOAHHEEH" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"理想三旬","author":"陈鸿宇","url":"http://music.163.com/song/media/outer/url?id=31445772.mp3","pic":"http://p2.music.126.net/cqTTEPAaxXG3cOwaE4E_-g==/109951163104103366.jpg?param=130y130","lrc":""},{"title":"理想三旬（女生版）","author":"花柒柒柒","url":"http://music.163.com/song/media/outer/url?id=1432542306.mp3","pic":"http://p2.music.126.net/qIJZ6B7jw6nyZMzQhCvtWw==/109951164821687515.jpg?param=130y130","lrc":""}]};  options.element = document.getElementById("aplayer-ZOAHHEEH");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><center><hr width=300px></center><p>从买奶茶-吃火锅-去ktv可以作为的第一阶段；从雨中奔波-ktv活动-返回学校可以作为另一阶段。</p><p>因为凯德广场的ktv没位置了，不得不转战另一家ktv，在去这ktv的最后一段路，是一公里余的公路边的步行，那时候已经是网上十一点多了，而且下起了大雨，这便是上文中提到的那一场雨。</p><p>在去第二家ktv时也有想回学校的还有想看电影的，但是因为氛围，大家还是一个不落的去到了ktv，玩到了晚上两点半。真是这第二阶段让整段记忆，变得有意思了起来。</p><p>上面那首歌，便是ktv里面我给我留下最深印象的歌，从英口中歌唱出来的歌曲，给我的感觉很深刻，以至于第二天在我脑海中单曲循环，不，应该是单句循环。</p><p>通过ktv的游戏，与几人能够“交换”出故事，了解对方的思想，这在大学是非常珍贵的。也确实给了我很大感触，与之同时带来的还有疑惑和恐惧——我居然问不出问题了——对于我所好奇的人。</p><p>这里倒不是那么严重，只是到了活动后期，大家都没有很好的问题问了，就好像已经没有疑惑了，或者是，到此就已经满足了。</p><p>也许是自我的变化，也许是整个大环境，潜移默化，我们而丧失了部分好奇，丧失了询问一个人所想的能力。</p><p>凯德，是高中毕业聚餐的地方，也是流落了记忆的地方，在十一个月以前的那个夜晚，烟花散尽后，的落寞，还有之后的那一个早上，她的离开。相同的地点，我又来到了他的前面，不过还好，我没能进去，还好没进去，那段记忆就留在那里吧。</p><p>雨中漫步，也是很久没有的事情了……高中我还经常下课散步看雨，而上一次仔细的听雨，看雨，是多久？早已经不清楚了吧？</p><p>真心话大冒险，其实更重要的是提供了大家真心交流的机会，不仅仅是感情，还可以是三观，思想等等的了解。心灵的互动是必要的，是难得的，是珍贵的，希望还能有机会……</p><center><hr width=300px></center><p>另外有一个有意思的是，最后分礼品（活动剩下的奖品）的时候，是摇色子，谁大就能得到奖品，而我一直想要那一把扇子。但是我抽奖等的运气从来就不好，所以知道规矩后我基本上是无望了的，第一次抽另一个电子钟的数仿佛已经证实了这点，但是抽扇子的时候，我第一次投出了六，和我一样是六的就只有另一个女生；之后她先投，我再投，但是忘了把她投的色子取出来，就要重新投，我好像还是投了个六，最后，我还是投出了六……很惊讶，惊喜？（联想到第一把斗地主我直接春天）</p><p>我这个运气……不好评价，很有玄妙的感觉，但是这并不是重点，最终我还是在回学校的车上个人打算把扇子让给那位女生——在活动的时候，她就把玩了扇子，那时候她的旗袍和扇子很搭配，我们哦都说她很合适，而她？大概也是想要吧。</p><p>而我做出了这个让出的扇子的决定，我也有些思考，奇怪，我为什么会这样做？毕竟，我更倾向于是自私的人，同时她对于我并没有什么特别的，此外，我曾经一直是不会考虑别人的感受的，而这次？</p><p>也许是那晚上的环境使然，也许是成长使然吧。那把折扇更适合曾经的我，和现在的她。我希望这折扇，是因为曾经的喜欢，而今天的我，应该把它让给更合适的人吧。这算是什么呢？</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编程训练】旅行商问题(TSP) - 遗传算法</title>
    <link href="/2022/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>注意！此题目版权归本人指导老师卢鹏所有，禁止外传！</p>          </div><h1 id="问题描述">问题描述</h1><p>某公司计划在某个地区做广告选宣传，推销员从城市 1出发，经过各个乡镇，再回到城市1，城镇的坐标位置见下表。为节约开支，公司希望推销员走过这 50个城镇的总距离最少，请你使用 LINGO 和 MATLAB软件编程求出最少总距离及其路径（需画出最后的线路图）。</p><p><img src="https://s2.loli.net/2022/04/27/69d7PcNYHeZD2ES.png" /></p><p>数学模型：</p><p><span class="math display">\[\min \sum_{i \neq j} d_{i j} x_{ij}\]</span> <span class="math display">\[s.t.  \left\{\begin{array}{l}\sum\nolimits_{j=1}^{50} x_{i j}=1, i=1,2, \ldots, 50 , ,\small(每个点只有一条边出去),\\\sum\nolimits_{i=1}^{50} x_{i j}=1, j=1,2, \ldots, 50, \small (\text {每个点只有一条边进去), } \\\sum\nolimits_{i, j \in s} x_{i j} \leq|s|-1,2 \leq|s| \leq n-1, s\subset\{1,2, \ldots, 50\},\\\small 即  S  为  \{1,2, \ldots, 50\}  的真子集 (除终点和起点外,各边不构成圈),  \\x_{i j} \in\{0,1\}, i, j=1,2, \ldots 50, i \neq j\end{array}\right.\]</span></p><p>说明：</p><p>采用 LINGO求解主要是约束当中第三个不好写，可以采用下面的约束替换：</p><p>计算详细步骤略。</p><p><span class="math display">\[{} \text { \small 破圈约束: } \quadu_{i}-u_{j}+n x_{i j} \leq n-1 ; u_{i}, u_{j} \geq 0 ; i=1,2, \cdots, n; j=2, \cdots, n ; i \neq j\]</span></p><h1 id="遗传算法代码">遗传算法代码</h1><h2 id="lingo">LINGO</h2><div class="hljs code-wrapper"><pre><code class="hljs lg4">model:set:    c/1..50/:xco,yco,u;    link(c,c):d,x; !d表示距离，x表示路径;endsetsdata:  xco=185 21 127 177 180 73 123 144 110 47      131 85 200 52 151 5 148 102 77 161      157 165 114 43 30 78 36 134 180 89      175 4 9 12 77 88 89 99 69 6      104 49 4 43 114 68 114 185 29 164;  yco=151 15 32 87 196 137 19 157 14 144      41 36 109 171 143 181 95 79 33 182      49 3 93 104 164 3 150 50 56 21      179 104 12 95 101 164 184 150 106 43      179 8 40 185 178 46 157 143 196 57;enddata@for(link(i,j): !初始化d;d(i,j)=@if(i #ne#j ,@sqrt( (xco(i)-xco(j))*(xco(i)-xco(j)) + (yco(i)-yco(j))*(yco(i)-yco(j))),100000); );min = @sum(c(i):@sum(c(j):d(i,j)*x(i,j))); !破圈约束;n = @size(c);@for(link(i,j)|i #ne# j #and# i #ne# 1 #and# j #ne# 1:u(i) - u(j) + n * x(i,j) &lt;= n - 1);@for(c(i):@sum(c(j)|i #ne# j :x(i,j))=1; !约束出度为1;@sum(c(j)|i #ne# j :x(j,i))=1; !约束入度为1;);@for(link(i,j):@bin(x(i,j))); !约束x为0-1，可以不要;end</code></pre></div><h2 id="未优化matlab">未优化MATLAB</h2><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%%数据初始化</span>clc;clear;xco<span class="hljs-built_in">=</span>[<span class="hljs-number">185</span> <span class="hljs-number">21</span> <span class="hljs-number">127</span> <span class="hljs-number">177</span> <span class="hljs-number">180</span> <span class="hljs-number">73</span> <span class="hljs-number">123</span> <span class="hljs-number">144</span> <span class="hljs-number">110</span> <span class="hljs-number">47</span> <span class="hljs-number">131</span> <span class="hljs-number">85</span> <span class="hljs-number">200</span> <span class="hljs-number">52</span> <span class="hljs-number">151</span> <span class="hljs-number">5</span> <span class="hljs-number">148</span> <span class="hljs-number">102</span> <span class="hljs-number">77</span> <span class="hljs-number">161</span> <span class="hljs-number">157</span> <span class="hljs-number">165</span> <span class="hljs-number">114</span> <span class="hljs-number">43</span> <span class="hljs-number">30</span> <span class="hljs-number">78</span> <span class="hljs-number">36</span> <span class="hljs-number">134</span> <span class="hljs-number">180</span> <span class="hljs-number">89</span> <span class="hljs-number">175</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">77</span> <span class="hljs-number">88</span> <span class="hljs-number">89</span> <span class="hljs-number">99</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span> <span class="hljs-number">104</span> <span class="hljs-number">49</span> <span class="hljs-number">4</span> <span class="hljs-number">43</span> <span class="hljs-number">114</span> <span class="hljs-number">68</span> <span class="hljs-number">114</span> <span class="hljs-number">185</span> <span class="hljs-number">29</span> <span class="hljs-number">164</span>];yco<span class="hljs-built_in">=</span>[<span class="hljs-number">151</span> <span class="hljs-number">15</span> <span class="hljs-number">32</span> <span class="hljs-number">87</span> <span class="hljs-number">196</span> <span class="hljs-number">137</span> <span class="hljs-number">19</span> <span class="hljs-number">157</span> <span class="hljs-number">14</span> <span class="hljs-number">144</span> <span class="hljs-number">41</span> <span class="hljs-number">36</span> <span class="hljs-number">109</span> <span class="hljs-number">171</span> <span class="hljs-number">143</span> <span class="hljs-number">181</span> <span class="hljs-number">95</span> <span class="hljs-number">79</span> <span class="hljs-number">33</span> <span class="hljs-number">182</span> <span class="hljs-number">49</span> <span class="hljs-number">3</span> <span class="hljs-number">93</span> <span class="hljs-number">104</span> <span class="hljs-number">164</span> <span class="hljs-number">3</span> <span class="hljs-number">150</span> <span class="hljs-number">50</span> <span class="hljs-number">56</span> <span class="hljs-number">21</span> <span class="hljs-number">179</span> <span class="hljs-number">104</span> <span class="hljs-number">12</span> <span class="hljs-number">95</span> <span class="hljs-number">101</span> <span class="hljs-number">164</span> <span class="hljs-number">184</span> <span class="hljs-number">150</span> <span class="hljs-number">106</span> <span class="hljs-number">43</span> <span class="hljs-number">79</span> <span class="hljs-number">8</span> <span class="hljs-number">40</span> <span class="hljs-number">185</span> <span class="hljs-number">178</span> <span class="hljs-number">46</span> <span class="hljs-number">157</span> <span class="hljs-number">143</span> <span class="hljs-number">196</span> <span class="hljs-number">57</span>];city_n<span class="hljs-built_in">=</span>size(xco,<span class="hljs-number">2</span>);for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:city_n    for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:city_n        dis(i,j)<span class="hljs-built_in">=</span>sqrt((xco(i)-xco(j))*(xco(i)-xco(j))+(yco(i)-yco(j))*(yco(i)-yco(j)));    endend<span class="hljs-comment">%%遗传算法</span><span class="hljs-comment">%生成初始路径</span>best_way<span class="hljs-built_in">=</span>[];best_fit<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;best_dist<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;new<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;fit_time<span class="hljs-built_in">=</span>[];dis_time<span class="hljs-built_in">=</span>[];way_n<span class="hljs-built_in">=</span><span class="hljs-number">10</span>;for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n    way0(i,:)<span class="hljs-built_in">=</span>randperm(city_n);end<span class="hljs-comment">%开始迭代</span>for o <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">100000</span>    way<span class="hljs-built_in">=</span>way0;    for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n         d(i)<span class="hljs-built_in">=</span>fit(way(i,:),dis);<span class="hljs-comment">%路径距离</span>    end    v<span class="hljs-built_in">=</span>ones([<span class="hljs-number">1</span>,way_n])*sum(d)./d;<span class="hljs-comment">%适应度</span>    for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n         <span class="hljs-built_in">if</span> v(i)&gt;best_fit            best_fit<span class="hljs-built_in">=</span>v(i);            best_way<span class="hljs-built_in">=</span>way(i,:);            best_dist<span class="hljs-built_in">=</span>d(i);            new<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;        end;    end    v<span class="hljs-built_in">=</span>v/sum(v);<span class="hljs-comment">%选择概率</span>    q<span class="hljs-built_in">=</span>v(<span class="hljs-number">1</span>);    for i <span class="hljs-built_in">=</span> <span class="hljs-number">2</span>:way_n        q(i)<span class="hljs-built_in">=</span>q(i-<span class="hljs-number">1</span>)+v(i);<span class="hljs-comment">%累积概率</span>    end    for l <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">5</span>        <span class="hljs-comment">%选择第一条路</span>        q_rand <span class="hljs-built_in">=</span> rand();        k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;<span class="hljs-comment">%为选择的路径编号</span>        for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n            <span class="hljs-built_in">if</span> q_rand&gt;q(i)                k<span class="hljs-built_in">=</span>i+<span class="hljs-number">1</span>;            end        end        way1<span class="hljs-built_in">=</span>k;        <span class="hljs-comment">%选择第二条路</span>        q_rand <span class="hljs-built_in">=</span> rand();        k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;<span class="hljs-comment">%为选择的路径编号</span>        for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n            <span class="hljs-built_in">if</span> q_rand&gt;q(i)                k<span class="hljs-built_in">=</span>i+<span class="hljs-number">1</span>;            end        end        way2<span class="hljs-built_in">=</span>k;        <span class="hljs-comment">%交配</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.9</span> &amp;&amp; i~<span class="hljs-built_in">=</span>j)            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            <span class="hljs-comment">%交叉互换</span>            for i <span class="hljs-built_in">=</span> ran1:ran2                k<span class="hljs-built_in">=</span>way(way1,i);                way(way1,i)<span class="hljs-built_in">=</span>way(way2,i);                way(way2,i)<span class="hljs-built_in">=</span>k;            end            <span class="hljs-comment">%查重与去重way1</span>            mark<span class="hljs-built_in">=</span>zeros([<span class="hljs-number">1</span>,city_n]);            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                mark(way(way1,i))<span class="hljs-built_in">=</span>mark(way(way1,i))+<span class="hljs-number">1</span>;            end            p1<span class="hljs-built_in">=</span>[];p2<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>                    p1(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">2</span>                    p2(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end            end            ran<span class="hljs-built_in">=</span>randperm(size(p1,<span class="hljs-number">2</span>));<span class="hljs-comment">%随机化</span>            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(p2,<span class="hljs-number">2</span>);                for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                    <span class="hljs-built_in">if</span> (j&lt;ran1 || j&gt;ran2) &amp;&amp; way(way1,j)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>p2(i)                        way(way1,j)<span class="hljs-built_in">=</span>p1(ran(i));                        break;                    end                end            end            <span class="hljs-comment">%查重与去重way2</span>            mark<span class="hljs-built_in">=</span>zeros([<span class="hljs-number">1</span>,city_n]);            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                mark(way(way2,i))<span class="hljs-built_in">=</span>mark(way(way2,i))+<span class="hljs-number">1</span>;            end            p1<span class="hljs-built_in">=</span>[];p2<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>                    p1(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">2</span>                    p2(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end            end            ran<span class="hljs-built_in">=</span>randperm(size(p1,<span class="hljs-number">2</span>));<span class="hljs-comment">%随机化</span>            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(p2,<span class="hljs-number">2</span>);                for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                    <span class="hljs-built_in">if</span> (j&lt;ran1 || j&gt;ran2) &amp;&amp; way(way2,j)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>p2(i)                        way(way2,j)<span class="hljs-built_in">=</span>p1(ran(i));                        break;                    end                end            end            <span class="hljs-comment">%</span>        end        <span class="hljs-comment">%变异</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.2</span>)            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            k<span class="hljs-built_in">=</span>way(way1,ran1);            way(way1,ran1)<span class="hljs-built_in">=</span>way(way1,ran2);            way(way1,ran2)<span class="hljs-built_in">=</span>k;            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            k<span class="hljs-built_in">=</span>way(way2,ran1);            way(way2,ran1)<span class="hljs-built_in">=</span>way(way2,ran2);            way(way2,ran2)<span class="hljs-built_in">=</span>k;        end        <span class="hljs-comment">%存储为下一代</span>        way0(l*<span class="hljs-number">2</span>-<span class="hljs-number">1</span>,:)<span class="hljs-built_in">=</span>way(way1,:);        way0(l*<span class="hljs-number">2</span>,:)<span class="hljs-built_in">=</span>way(way2,:);    end    <span class="hljs-comment">%绘图</span>    figure(<span class="hljs-number">1</span>)    <span class="hljs-built_in">if</span> new<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">1</span>        new<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;        gox<span class="hljs-built_in">=</span>[];goy<span class="hljs-built_in">=</span>[];        for i<span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n            gox(i)<span class="hljs-built_in">=</span>xco(best_way(i));            goy(i)<span class="hljs-built_in">=</span>yco(best_way(i));        end        gox(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>xco(best_way(<span class="hljs-number">1</span>));        goy(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>yco(best_way(<span class="hljs-number">1</span>));        plot(gox,goy,<span class="hljs-string">&#x27;o--&#x27;</span>);        title(best_fit,best_dist);        drawnow;        <span class="hljs-comment">%pause(0);</span>    end    fit_time(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>best_fit;    dis_time(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>best_dist;endfigure(<span class="hljs-number">2</span>)plot(fit_time);figure(<span class="hljs-number">3</span>)plot(dis_time);clear ran d i j k l o mark new p1 p2 l q q_rand ran1 ran2 v way way0 way1 way2 ;clear dis gox goy xco yco;</code></pre></div><h2 id="优化后matlab">优化后MATLAB</h2><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%%数据初始化</span>clc;clear;xco<span class="hljs-built_in">=</span>[<span class="hljs-number">185</span> <span class="hljs-number">21</span> <span class="hljs-number">127</span> <span class="hljs-number">177</span> <span class="hljs-number">180</span> <span class="hljs-number">73</span> <span class="hljs-number">123</span> <span class="hljs-number">144</span> <span class="hljs-number">110</span> <span class="hljs-number">47</span> <span class="hljs-number">131</span> <span class="hljs-number">85</span> <span class="hljs-number">200</span> <span class="hljs-number">52</span> <span class="hljs-number">151</span> <span class="hljs-number">5</span> <span class="hljs-number">148</span> <span class="hljs-number">102</span> <span class="hljs-number">77</span> <span class="hljs-number">161</span> <span class="hljs-number">157</span> <span class="hljs-number">165</span> <span class="hljs-number">114</span> <span class="hljs-number">43</span> <span class="hljs-number">30</span> <span class="hljs-number">78</span> <span class="hljs-number">36</span> <span class="hljs-number">134</span> <span class="hljs-number">180</span> <span class="hljs-number">89</span> <span class="hljs-number">175</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">77</span> <span class="hljs-number">88</span> <span class="hljs-number">89</span> <span class="hljs-number">99</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span> <span class="hljs-number">104</span> <span class="hljs-number">49</span> <span class="hljs-number">4</span> <span class="hljs-number">43</span> <span class="hljs-number">114</span> <span class="hljs-number">68</span> <span class="hljs-number">114</span> <span class="hljs-number">185</span> <span class="hljs-number">29</span> <span class="hljs-number">164</span>];yco<span class="hljs-built_in">=</span>[<span class="hljs-number">151</span> <span class="hljs-number">15</span> <span class="hljs-number">32</span> <span class="hljs-number">87</span> <span class="hljs-number">196</span> <span class="hljs-number">137</span> <span class="hljs-number">19</span> <span class="hljs-number">157</span> <span class="hljs-number">14</span> <span class="hljs-number">144</span> <span class="hljs-number">41</span> <span class="hljs-number">36</span> <span class="hljs-number">109</span> <span class="hljs-number">171</span> <span class="hljs-number">143</span> <span class="hljs-number">181</span> <span class="hljs-number">95</span> <span class="hljs-number">79</span> <span class="hljs-number">33</span> <span class="hljs-number">182</span> <span class="hljs-number">49</span> <span class="hljs-number">3</span> <span class="hljs-number">93</span> <span class="hljs-number">104</span> <span class="hljs-number">164</span> <span class="hljs-number">3</span> <span class="hljs-number">150</span> <span class="hljs-number">50</span> <span class="hljs-number">56</span> <span class="hljs-number">21</span> <span class="hljs-number">179</span> <span class="hljs-number">104</span> <span class="hljs-number">12</span> <span class="hljs-number">95</span> <span class="hljs-number">101</span> <span class="hljs-number">164</span> <span class="hljs-number">184</span> <span class="hljs-number">150</span> <span class="hljs-number">106</span> <span class="hljs-number">43</span> <span class="hljs-number">79</span> <span class="hljs-number">8</span> <span class="hljs-number">40</span> <span class="hljs-number">185</span> <span class="hljs-number">178</span> <span class="hljs-number">46</span> <span class="hljs-number">157</span> <span class="hljs-number">143</span> <span class="hljs-number">196</span> <span class="hljs-number">57</span>];city_n<span class="hljs-built_in">=</span>size(xco,<span class="hljs-number">2</span>);for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:city_n    for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:city_n        dis(i,j)<span class="hljs-built_in">=</span>sqrt((xco(i)-xco(j))*(xco(i)-xco(j))+(yco(i)-yco(j))*(yco(i)-yco(j)));    endend<span class="hljs-comment">%%遗传算法</span><span class="hljs-comment">%生成初始路径</span>best_way<span class="hljs-built_in">=</span>[];best_fit<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;best_dist<span class="hljs-built_in">=</span><span class="hljs-number">100000</span>;new<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;<span class="hljs-comment">%记录最优解</span>fit_time<span class="hljs-built_in">=</span>[];dis_time<span class="hljs-built_in">=</span>[];<span class="hljs-comment">%记录最优解变化</span>way_n<span class="hljs-built_in">=</span><span class="hljs-number">10</span>;for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n    way0(i,:)<span class="hljs-built_in">=</span>randperm(city_n);end<span class="hljs-comment">%开始迭代</span>for o <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">10000</span>    way<span class="hljs-built_in">=</span>way0;    for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n         d(i)<span class="hljs-built_in">=</span>fit(way(i,:),dis);<span class="hljs-comment">%路径距离</span>    end    v<span class="hljs-built_in">=</span>ones([<span class="hljs-number">1</span>,way_n])*sum(d)./d;<span class="hljs-comment">%适应度</span>    for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n         <span class="hljs-built_in">if</span> d(i)&lt;best_dist <span class="hljs-comment">%改动1：以距离评判最优解</span>            best_fit<span class="hljs-built_in">=</span>v(i);            best_way<span class="hljs-built_in">=</span>way(i,:);            best_dist<span class="hljs-built_in">=</span>d(i);            new<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;        end;    end    v<span class="hljs-built_in">=</span>v/sum(v);<span class="hljs-comment">%选择概率</span>    q<span class="hljs-built_in">=</span>v(<span class="hljs-number">1</span>);    for i <span class="hljs-built_in">=</span> <span class="hljs-number">2</span>:way_n        q(i)<span class="hljs-built_in">=</span>q(i-<span class="hljs-number">1</span>)+v(i);<span class="hljs-comment">%累积概率</span>    end    for l <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:<span class="hljs-number">5</span>        <span class="hljs-comment">%选择第一条路</span>        q_rand <span class="hljs-built_in">=</span> rand();        k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;<span class="hljs-comment">%为选择的路径编号</span>        for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n            <span class="hljs-built_in">if</span> q_rand&gt;q(i)                k<span class="hljs-built_in">=</span>i+<span class="hljs-number">1</span>;            end        end        way1<span class="hljs-built_in">=</span>k;        <span class="hljs-comment">%选择第二条路</span>        q_rand <span class="hljs-built_in">=</span> rand();        k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>;<span class="hljs-comment">%为选择的路径编号</span>        for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:way_n            <span class="hljs-built_in">if</span> q_rand&gt;q(i)                k<span class="hljs-built_in">=</span>i+<span class="hljs-number">1</span>;            end        end        way2<span class="hljs-built_in">=</span>k;        <span class="hljs-comment">%交配</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.9</span> &amp;&amp; i~<span class="hljs-built_in">=</span>j)            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            <span class="hljs-comment">%交叉互换</span>            for i <span class="hljs-built_in">=</span> ran1:ran2                k<span class="hljs-built_in">=</span>way(way1,i);                way(way1,i)<span class="hljs-built_in">=</span>way(way2,i);                way(way2,i)<span class="hljs-built_in">=</span>k;            end            <span class="hljs-comment">%查重与去重way1</span>            mark<span class="hljs-built_in">=</span>zeros([<span class="hljs-number">1</span>,city_n]);            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                mark(way(way1,i))<span class="hljs-built_in">=</span>mark(way(way1,i))+<span class="hljs-number">1</span>;            end            p1<span class="hljs-built_in">=</span>[];p2<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>                    p1(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">2</span>                    p2(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end            end            ran<span class="hljs-built_in">=</span>randperm(size(p1,<span class="hljs-number">2</span>));<span class="hljs-comment">%随机化</span>            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(p2,<span class="hljs-number">2</span>);                for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                    <span class="hljs-built_in">if</span> (j&lt;ran1 || j&gt;ran2) &amp;&amp; way(way1,j)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>p2(i)                        way(way1,j)<span class="hljs-built_in">=</span>p1(ran(i));                        break;                    end                end            end            <span class="hljs-comment">%查重与去重way2</span>            mark<span class="hljs-built_in">=</span>zeros([<span class="hljs-number">1</span>,city_n]);            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                mark(way(way2,i))<span class="hljs-built_in">=</span>mark(way(way2,i))+<span class="hljs-number">1</span>;            end            p1<span class="hljs-built_in">=</span>[];p2<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span>                    p1(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end                <span class="hljs-built_in">if</span> mark(i)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">2</span>                    p2(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>i;                end            end            ran<span class="hljs-built_in">=</span>randperm(size(p1,<span class="hljs-number">2</span>));<span class="hljs-comment">%随机化</span>            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(p2,<span class="hljs-number">2</span>);                for j <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n                    <span class="hljs-built_in">if</span> (j&lt;ran1 || j&gt;ran2) &amp;&amp; way(way2,j)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>p2(i)                        way(way2,j)<span class="hljs-built_in">=</span>p1(ran(i));                        break;                    end                end            end            <span class="hljs-comment">%</span>        end        <span class="hljs-comment">%变异1：交换两点</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.2</span>)            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            k<span class="hljs-built_in">=</span>way(way1,ran1);            way(way1,ran1)<span class="hljs-built_in">=</span>way(way1,ran2);            way(way1,ran2)<span class="hljs-built_in">=</span>k;            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            k<span class="hljs-built_in">=</span>way(way2,ran1);            way(way2,ran1)<span class="hljs-built_in">=</span>way(way2,ran2);            way(way2,ran2)<span class="hljs-built_in">=</span>k;        end        <span class="hljs-comment">%改动2</span>        <span class="hljs-comment">%变异2：路径翻折 能有效防止路径交叉、加速迭代出最优解的改动</span>        q_rand <span class="hljs-built_in">=</span> rand();        <span class="hljs-built_in">if</span>(q_rand&lt;<span class="hljs-number">0.2</span>) <span class="hljs-comment">%概率越大，迭代优解速度越快，但解微微变差</span>            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            way3<span class="hljs-built_in">=</span>[];            for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n <span class="hljs-comment">%存储旋转</span>                way3(mod(i+ran1,city_n)+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>way(way1,i);            end            ran1 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            ran2 <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,city_n]);            <span class="hljs-built_in">if</span>(ran1&gt;ran2)                 k<span class="hljs-built_in">=</span>ran1;                ran1<span class="hljs-built_in">=</span>ran2;                ran2<span class="hljs-built_in">=</span>k;            end            for i <span class="hljs-built_in">=</span> ran1 : (ran2+ran1)/<span class="hljs-number">2</span>;<span class="hljs-comment">%翻转</span>                k<span class="hljs-built_in">=</span>way3(i);                way3(i)<span class="hljs-built_in">=</span>way3(ran2+ran1-i);                way3(ran2+ran1-i)<span class="hljs-built_in">=</span>k;            end            way(way1,:)<span class="hljs-built_in">=</span>way3;        end         <span class="hljs-comment">%存储为下一代</span>        way0(l*<span class="hljs-number">2</span>-<span class="hljs-number">1</span>,:)<span class="hljs-built_in">=</span>way(way1,:);        way0(l*<span class="hljs-number">2</span>,:)<span class="hljs-built_in">=</span>way(way2,:);        ran <span class="hljs-built_in">=</span> randi([<span class="hljs-number">1</span>,way_n]);         way0(ran,:)<span class="hljs-built_in">=</span>best_way; <span class="hljs-comment">%改动3 ：最显著的改动</span>    end    <span class="hljs-comment">%绘图</span>    figure(<span class="hljs-number">1</span>)    <span class="hljs-built_in">if</span> new<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">1</span>        new<span class="hljs-built_in">=</span><span class="hljs-number">0</span>;        gox<span class="hljs-built_in">=</span>[];goy<span class="hljs-built_in">=</span>[];        for i<span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:city_n            gox(i)<span class="hljs-built_in">=</span>xco(best_way(i));            goy(i)<span class="hljs-built_in">=</span>yco(best_way(i));        end        gox(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>xco(best_way(<span class="hljs-number">1</span>));        goy(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>yco(best_way(<span class="hljs-number">1</span>));        plot(gox,goy,<span class="hljs-string">&#x27;o--&#x27;</span>);        title(best_fit,best_dist);        drawnow;        <span class="hljs-comment">%pause(0);</span>    end    fit_time(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>best_fit;    dis_time(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>best_dist;endfigure(<span class="hljs-number">2</span>)plot(fit_time);figure(<span class="hljs-number">3</span>)plot(dis_time);clear ran d i j k l o mark new p1 p2 l q q_rand ran1 ran2 v way way0 way1 way2 ;clear dis gox goy xco yco;</code></pre></div><h1 id="结果说明">结果说明</h1><p><img src="https://s2.loli.net/2022/04/27/3wy2MexZS8fKHlA.png" /></p><p>评价：</p><ol type="1"><li>经过多次迭代检验，新的程序能在减少一个数量级的迭代次数情况下，每次都能得到一个近似的最优解（局部最优解），且其效率快，得到结果较优。</li><li>同时注意到其适应度迭代曲线，反应适应度（竞争优势度）并不能很好反应个体的优劣，猜想得验证。</li></ol><p><img src="https://s2.loli.net/2022/04/27/aFjB89XECsOKIG3.png" /></p><p>依然存在的问题：</p><p>经过手动多次迭代才找到了一个几乎是最优的解。根据迭代曲线可以看出解在前段已经收敛，且极难跳出当前解，而解的产生很大程度上取决于随机的初始化以及随机过程。为让解进一步迭代和增大单次运行找到最优解的可能性，应该引入更多可能的变异情况，而走出因为变异的单一性和局限性导致难以产生更优解的情况。</p><p>Ps：虽然我有想法，但是懒得改了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行商问题</tag>
      
      <tag>TSP</tag>
      
      <tag>MATLAB</tag>
      
      <tag>遗传算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【编程训练】登山问题 - 梯度上升法</title>
    <link href="/2022/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E7%99%BB%E5%B1%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E3%80%90%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83%E3%80%91%E7%99%BB%E5%B1%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>注意！此题目版权归本人指导老师卢鹏所有，禁止外传！</p>          </div><h1 id="问题描述">问题描述</h1><p>有一座小山，其表面方程可以用 <spanclass="math inline">\(z=1-x^2-2y^2\)</span> 底部为 <spanclass="math inline">\(xOy\)</span> ，记起点为 <spanclass="math inline">\(P(0.7,0.5,0.01)\)</span>，从该起点开始爬山，要求登山线路沿着梯度方向前进。试着研究一下从起点到顶点的登山曲线。</p><p>计算注意要点：</p><ol type="1"><li>每个具体位置的梯度方向并不完全相同，所以必须采用逐步迭代的方法登上山顶；</li><li>因为梯度有两个方向（x和y），所以不能简单取一个步长，合理的方式可以在梯度方向上取单位向量并乘以取定步长（参考值 0.01）来确定x和y方向上的变化；</li><li>判断登上山顶条件，可以取高度大于 0.9999即为登顶。（循环退出条件）；</li><li>函数的空间图形与空间登上曲线画在一个图形里面；</li><li>平面线路图形的意思是需要画出空间曲线在平面中的投影曲线以及函数的等高线。注：方法并不唯一，同学们也可以发挥想象完成此题！</li></ol><h1 id="结果展示">结果展示</h1><p><img src="https://s2.loli.net/2022/04/27/o1HkqYFcv76eKwD.png" /></p><h1 id="梯度上升法代码">梯度上升法代码</h1><p>对于相同的题型，仅需要修改下面三个function。</p><p>此外可以调整主函数的迭代参数。</p><p>[MATLAB] f.m 原函数</p><div class="hljs code-wrapper"><pre><code class="hljs m">function z <span class="hljs-built_in">=</span> f(x,y)    z<span class="hljs-built_in">=</span><span class="hljs-number">1</span>-x.*x-<span class="hljs-number">2</span>*y.*y;end</code></pre></div><p>[MATLAB] fx.m 偏导x</p><div class="hljs code-wrapper"><pre><code class="hljs m">function k <span class="hljs-built_in">=</span> fx(x,y)    k<span class="hljs-built_in">=</span>-<span class="hljs-number">2</span>*x;end</code></pre></div><p>[MATLAB] fy.m 偏导y</p><div class="hljs code-wrapper"><pre><code class="hljs m">function k <span class="hljs-built_in">=</span> fy(x,y)    k<span class="hljs-built_in">=</span>-<span class="hljs-number">4</span>*y;end</code></pre></div><p>[MATLAB] main.m 主程序</p><div class="hljs code-wrapper"><pre><code class="hljs m"><span class="hljs-comment">%%开始绘图</span>clear;clc;x<span class="hljs-built_in">=</span>[-<span class="hljs-number">0.5</span>:<span class="hljs-number">0.005</span>:<span class="hljs-number">0.5</span>];y<span class="hljs-built_in">=</span>[-<span class="hljs-number">0.5</span>:<span class="hljs-number">0.005</span>:<span class="hljs-number">0.5</span>];[X,Y]<span class="hljs-built_in">=</span>meshgrid(x,y);<span class="hljs-comment">%Z=1-X.*X - 2*Y.*Y;</span>Z<span class="hljs-built_in">=</span>f(X,Y);<span class="hljs-comment">%%迭代和绘图</span>figure(<span class="hljs-number">1</span>);hold on;    subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);        mesh(X,Y,Z);<span class="hljs-comment">%绘制三维图</span>        xlabel(<span class="hljs-string">&#x27;X&#x27;</span>);ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>);zlabel(<span class="hljs-string">&#x27;Z&#x27;</span>);        hold on;        x0<span class="hljs-built_in">=</span><span class="hljs-number">0.1</span>;y0<span class="hljs-built_in">=</span><span class="hljs-number">0.5</span>; <span class="hljs-comment">%起始点</span>        z0<span class="hljs-built_in">=</span>f(x0,y0);        way_x<span class="hljs-built_in">=</span>[x0];way_y<span class="hljs-built_in">=</span>[y0];way_z<span class="hljs-built_in">=</span>[z0];        t<span class="hljs-built_in">=</span><span class="hljs-number">0.1</span>; <span class="hljs-comment">%步长：方向向量*t</span>        <span class="hljs-comment">%%开始迭代 梯度上升</span>        while z0&lt;<span class="hljs-number">0.999</span> &amp;&amp; t&gt;<span class="hljs-number">0.00001</span>             x1<span class="hljs-built_in">=</span>x0+fx(x0,y0)*t;<span class="hljs-comment">% fx为偏x</span>            y1<span class="hljs-built_in">=</span>y0+fy(x0,y0)*t; <span class="hljs-comment">%fy为偏y</span>            z1<span class="hljs-built_in">=</span>f(x1,y1);            <span class="hljs-built_in">if</span>(z1&gt;z0) <span class="hljs-comment">%防止步长过大</span>                x0<span class="hljs-built_in">=</span>x1;                y0<span class="hljs-built_in">=</span>y1;                z0<span class="hljs-built_in">=</span>z1;                way_x(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>x0; <span class="hljs-comment">%记录迭代路径</span>                way_y(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>y0;                way_z(end+<span class="hljs-number">1</span>)<span class="hljs-built_in">=</span>z0;            <span class="hljs-built_in">else</span>                t<span class="hljs-built_in">=</span>t*<span class="hljs-number">0.1</span>; <span class="hljs-comment">%步长过大，“降温”</span>            end        end        <span class="hljs-comment">%%开始绘图</span>        plot3(way_x,way_y,way_z,<span class="hljs-string">&#x27;-o&#x27;</span>,<span class="hljs-string">&#x27;Color&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;MarkerSize&#x27;</span>,<span class="hljs-number">10</span>,...,        <span class="hljs-string">&#x27;MarkerFaceColor&#x27;</span>,<span class="hljs-string">&#x27;#D9FFFF&#x27;</span>);<span class="hljs-comment">% 绘制迭代点        </span>        camorbit(<span class="hljs-number">180</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;data&#x27;</span>,[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>])<span class="hljs-comment">% 转180度方便看</span>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">%三维等高线和迭代图</span>    contour3(X,Y,Z,<span class="hljs-number">20</span>);        hold on;        plot3(way_x,way_y,way_z,<span class="hljs-string">&#x27;*--&#x27;</span>)        camorbit(<span class="hljs-number">180</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;data&#x27;</span>,[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>]) <span class="hljs-comment">% 转180度方便看</span>     subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">%平面等高线和迭代图</span>        contour(X,Y,Z,<span class="hljs-number">20</span>);        hold on;        plot3(way_x,way_y,way_z,<span class="hljs-string">&#x27;o--&#x27;</span>)        camorbit(<span class="hljs-number">180</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;data&#x27;</span>,[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>]) <span class="hljs-comment">% 转180度方便看</span>hold off;</code></pre></div><h1 id="补充">补充</h1><p>梯度下降法是一种“显而易见”的方法，其思维复合常理没有太多难度所以在这里不对该方法进行详细叙述。</p><p>基于梯度下降法和其思想诞生了很多行之有效的方法，例如动量梯度下降法、自适应梯度算法等改进算法，这种改进思想可以在很多算法上得到运用。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MATLAB</tag>
      
      <tag>梯度上升</tag>
      
      <tag>梯度下降</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022—蓝桥杯C++A组复盘</title>
    <link href="/2022/04/27/16%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <url>/2022/04/27/16%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="链接">链接</h1><div class="note note-info">            <p><ahref="http://oj.ecustacm.cn/viewnews.php?id=1021"><b>补题传送门</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/fzl194/article/details/124347039"><b>参考的博客</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><p>非常失败的一次比赛……</p><h2 id="a---裁纸刀">A - 裁纸刀 √</h2><p>题意： 一张纸上打印了20 2020行22 2222列共440440440个二维码，至少需要裁多少次可以全部裁出。如下图，2 22行333列共需要裁9 99次。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> f[maxn][maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    n=<span class="hljs-number">22</span>;<span class="hljs-comment">//=read();</span>    m=<span class="hljs-number">20</span>;<span class="hljs-comment">//=read();</span>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)            f[i][j]=<span class="hljs-number">0x3f3f3f3f</span>;    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-built_in">FOR</span>(k1,<span class="hljs-number">0</span>,i)                <span class="hljs-built_in">FOR</span>(k2,<span class="hljs-number">0</span>,j)&#123;                    f[i][j]=<span class="hljs-built_in">min</span>((k1==<span class="hljs-number">0</span>||k1==i?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>)+(k2==<span class="hljs-number">0</span>||k2==j?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>)+(k1!=<span class="hljs-number">0</span>&amp;&amp;k1!=i&amp;&amp;k2!=<span class="hljs-number">0</span>&amp;&amp;k2!=j?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>)                    +f[k1][k2]+f[i-k1][k2]+f[k1][j-k2]+f[i-k1][j-k2],f[i][j]);                &#125;            <span class="hljs-comment">//cout&lt;&lt;f[i][j]&lt;&lt;&quot; &quot;;</span>        &#125;        <span class="hljs-comment">//cout&lt;&lt;endl;</span>    &#125;    cout&lt;&lt;f[n][m]+<span class="hljs-number">4</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="b---灭鼠先锋-x">B - 灭鼠先锋 x</h2><p>题意： 在2 22行4 44列的棋盘中，两人轮流操作，每次可选择在空位上放置111个棋子，或者在同一行连续的两个空位上放置棋子。最后使得棋盘放满的人输掉。</p><p>先手存在4 44种初始局面如下所示，O OO表示空，XXX表示已放置。每人均以最优策略放棋子。判断先手胜利（输出VVV）还是后手胜利（输出L LL）。</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">XOOO XXOO OXOO OXXO</span><span class="hljs-attribute">OOOO OOOO OOOO OOOO</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">///判断是否仅存在一个空格</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string s)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : s)<span class="hljs-keyword">if</span>(x == <span class="hljs-string">&#x27;O&#x27;</span>)        tot++;    <span class="hljs-keyword">return</span> tot == <span class="hljs-number">1</span>;&#125;map&lt;string, <span class="hljs-keyword">bool</span>&gt;SG;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(SG.<span class="hljs-built_in">count</span>(s))        <span class="hljs-keyword">return</span> SG[s];    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(s))        <span class="hljs-keyword">return</span> SG[s] = <span class="hljs-literal">false</span>;    <span class="hljs-comment">///模拟放1个棋子</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;O&#x27;</span>)    &#123;        string tmp = s;        tmp[i] = <span class="hljs-string">&#x27;X&#x27;</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(tmp) == <span class="hljs-literal">false</span>)<span class="hljs-comment">///可以到达必败态均为必胜态</span>            <span class="hljs-keyword">return</span> SG[s] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">///模拟放2个棋子</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; i != <span class="hljs-number">3</span>)    &#123;        string tmp = s;        tmp[i] = tmp[i + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;X&#x27;</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(tmp) == <span class="hljs-literal">false</span>)<span class="hljs-comment">///可以到达必败态均为必胜态</span>            <span class="hljs-keyword">return</span> SG[s] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">///运行到此，说明只能转移到必胜态，此时为必败态</span>    <span class="hljs-keyword">return</span> SG[s] = <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string s[] = &#123;<span class="hljs-string">&quot;XOOOOOOO&quot;</span>, <span class="hljs-string">&quot;XXOOOOOO&quot;</span>, <span class="hljs-string">&quot;OXOOOOOO&quot;</span>, <span class="hljs-string">&quot;OXXOOOOO&quot;</span>&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(s[i]))cout&lt;&lt;<span class="hljs-string">&quot;L&quot;</span>;<span class="hljs-comment">///此时为必胜态，说明后手面临的局面必胜，输出L</span>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;V&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="c---求和-x-30">C - 求和 x 30%</h2><p>题意：给定数组 <span class="math inline">\(a\)</span> ，求 <spanclass="math inline">\(\sum_{i=1}^n\sum_{j=i+1}^n\)</span>。</p><p>我的：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span>+<span class="hljs-number">100</span>;<span class="hljs-comment">//const int maxm = 4e5+100;</span><span class="hljs-keyword">int</span> a[maxn],num[maxn]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    cin&gt;&gt;n;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        a[i]=<span class="hljs-built_in">read</span>();        num[i]=num[i<span class="hljs-number">-1</span>]+a[i];    &#125;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        ans+=a[i]*num[i<span class="hljs-number">-1</span>];    &#125;    cout&lt;&lt;ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;ll a[maxn], sum[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    ll ans = <span class="hljs-number">0</span>;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">///预处理前缀和</span>        cin &gt;&gt; a[i], sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">///求和即可</span>        ans += a[i] * (sum[n] - sum[i]);    cout&lt;&lt;ans&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="d---选数异或-x-40">D - 选数异或 x 40%</h2><p>题意： 给定数组 <span class="math inline">\(a\)</span> 和整数 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(m\)</span>次询问，每次询问区间 <span class="math inline">\([l,r]\)</span>是否存在两个数字使得异或值等于 <spanclass="math inline">\(x\)</span>。</p><p>我的暴力：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//const int maxm = 4e5+100;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m,x;    n=<span class="hljs-built_in">read</span>();    m=<span class="hljs-built_in">read</span>();    x=<span class="hljs-built_in">read</span>();    <span class="hljs-comment">//±©Á¦</span>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1000</span>)&#123;        <span class="hljs-keyword">int</span> a[<span class="hljs-number">1020</span>];        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)            a[i]=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">int</span> l,r;        <span class="hljs-keyword">while</span>(m--)&#123;            <span class="hljs-keyword">int</span> f=<span class="hljs-number">0</span>;            l=<span class="hljs-built_in">read</span>();            r=<span class="hljs-built_in">read</span>();            <span class="hljs-built_in">FOR</span>(i,l,r)&#123;                <span class="hljs-built_in">FOR</span>(j,i+<span class="hljs-number">1</span>,r)&#123;                    <span class="hljs-keyword">if</span>((a[i]^a[j])==x)&#123;                        f=<span class="hljs-number">1</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(f)                    <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(f)                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);            <span class="hljs-keyword">else</span>                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100000</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> tree[maxn &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> Left[maxn], pos[(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>) + <span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> a[maxn], n, m, x;<span class="hljs-comment">//线段树模板</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l == r)    &#123;        tree[o] = Left[l];        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid);    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);    tree[o] = <span class="hljs-built_in">max</span>(tree[o &lt;&lt; <span class="hljs-number">1</span>], tree[o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)<span class="hljs-keyword">return</span> tree[o];    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(L &lt;= mid)ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R));    <span class="hljs-keyword">if</span>(R &gt; mid)ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R));    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//预处理Left数组</span>    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);        Left[i] = pos[a[i] ^ x];        pos[a[i]] = i;    &#125;    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<span class="hljs-comment">//线段树建树</span>    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-keyword">int</span> l, r;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) &gt;= l)<span class="hljs-comment">//查询区间最值</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="e---爬树的甲壳虫-x">E - 爬树的甲壳虫 x</h2><p>题意： 甲壳虫想要爬上高度为 <span class="math inline">\(n\)</span>的树，开始位于树根，高度为 0，当它尝试从高度 <spanclass="math inline">\(i-1\)</span> 爬到高度为 <spanclass="math inline">\(i\)</span> 的位置时有 <spanclass="math inline">\(P_i\)</span>的概率会掉回树根，求它从树根爬到树顶时，经过的时间的期望值是多少。</p><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">998244353</span>;ll x[maxn], y[maxn];<span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll a, ll b, ll m)</span></span><span class="hljs-function"></span>&#123;    ll ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(b)    &#123;        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)ans = ans * a % m;        b &gt;&gt;= <span class="hljs-number">1</span>;        a = a * a % m;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ksm</span>(x, MOD - <span class="hljs-number">2</span>, MOD);&#125;<span class="hljs-function">ll <span class="hljs-title">extgcd</span><span class="hljs-params">(ll a, ll b, ll&amp;x, ll&amp;y)</span><span class="hljs-comment">//ax+by = gcd(a, b)的解。返回值为gcd</span></span><span class="hljs-function"></span>&#123;    ll d = a;    <span class="hljs-keyword">if</span>(b)    &#123;       d = <span class="hljs-built_in">extgcd</span>(b, a % b, y, x);       y -= (a / b) * x;    &#125;    <span class="hljs-keyword">else</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; x[i] &gt;&gt; y[i];        ll g = __gcd(x[i], y[i]);        x[i] = x[i] / g;        y[i] = y[i] / g;    &#125;    ll a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--)    &#123;        ll p = x[i] * <span class="hljs-built_in">inv</span>(y[i]) % MOD, p_1 = (y[i] - x[i]) * <span class="hljs-built_in">inv</span>(y[i]) % MOD;        a = (p + p_1 * a) % MOD;        b = (<span class="hljs-number">1</span> + p_1 * b) % MOD;    &#125;    <span class="hljs-comment">///cout&lt;&lt;x[1]&lt;&lt;&quot; &quot;&lt;&lt;y[1]&lt;&lt;&quot; &quot;&lt;&lt;inv(y[1])&lt;&lt;endl;</span>    <span class="hljs-comment">///dp[0] = a * dp[0] + b</span>    <span class="hljs-comment">///(a-1)dp[0]+k * MOD = MOD - b</span>    <span class="hljs-comment">///(a - 1)x + MOD * y = MOD - b</span>    <span class="hljs-comment">///cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span>    ll c = a - <span class="hljs-number">1</span>, d = MOD, x, y;    ll g = <span class="hljs-built_in">extgcd</span>(c, d, x, y);    <span class="hljs-comment">///cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span>    ll x1 = x * (MOD - b) / g;    ll y1 = y * (MOD - b) / g;    cout&lt;&lt;(x1 % MOD + MOD ) % MOD&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="f---青蛙过河-x-10">F - 青蛙过河 x 10%</h2><p>题意：小青蛙住在一条河边，它想到河对岸的学校去学习。小青蛙打算经过河里的石头跳到对岸。河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。不过，每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就会下降1，当石头的高度下降到0 时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 0是允许的）。</p><p>小青蛙一共需要去学校上x天课，所以它需要往返2x次。当小青蛙具有一个跳跃能力y时，它能跳不超过y的距离。请问小青蛙的跳跃能力至少是多少才能用这些石头上完x次课。</p><p>我的：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//const int maxm = 4e5+100;</span><span class="hljs-keyword">int</span> n,x;<span class="hljs-keyword">int</span> h[maxn];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q)</span></span>&#123;    <span class="hljs-keyword">int</span> f[maxn];    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//=h[0];</span>    f[<span class="hljs-number">0</span>]=h[<span class="hljs-number">0</span>];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        num+=f[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(i-q<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)            num-=f[i-q<span class="hljs-number">-1</span>];        <span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;num&lt;&lt;endl;</span>        f[i]=<span class="hljs-built_in">min</span>(num,h[i]);    &#125;    <span class="hljs-comment">// cout&lt;&lt;q&lt;&lt;&quot;:&quot;;</span>    <span class="hljs-comment">// FOR(i,1,n)</span>    <span class="hljs-comment">//     cout&lt;&lt;f[i]&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">// cout&lt;&lt;endl;</span>    <span class="hljs-keyword">if</span>(f[n]&gt;=x)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=n;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span>(l&lt;r)&#123;        mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;            r=mid;        &#125;<span class="hljs-keyword">else</span>&#123;            l=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//cout&lt;&lt;l&lt;&lt;&quot;-&quot;&lt;&lt;r&lt;&lt;endl;</span>    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    n=<span class="hljs-built_in">read</span>();    x=<span class="hljs-built_in">read</span>();    x*=<span class="hljs-number">2</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)        h[i]=<span class="hljs-built_in">read</span>();    h[<span class="hljs-number">0</span>]=h[n]=<span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-built_in">solve</span>();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x * w;&#125;<span class="hljs-keyword">int</span> h[maxn], sum[maxn];<span class="hljs-keyword">int</span> n, x;<span class="hljs-comment">//判断所有长度为mid的区间之和是否大于等于2x</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mid)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + mid - <span class="hljs-number">1</span> &lt;= n; i++)        <span class="hljs-keyword">if</span>(sum[i + mid - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">2</span> * x)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">read</span>(n); <span class="hljs-built_in">read</span>(x);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; i++)<span class="hljs-comment">//预处理前缀和</span>        <span class="hljs-built_in">read</span>(h[i]), sum[i] = sum[i - <span class="hljs-number">1</span>] + h[i];    sum[n] = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = n, ans = n;    <span class="hljs-keyword">while</span>(left &lt;= right)<span class="hljs-comment">//二分答案</span>    &#123;        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))            ans = mid, right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//求最小合法解</span>        <span class="hljs-keyword">else</span>            left = mid + <span class="hljs-number">1</span>;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="g---最长不下降子序列-x-30">G - 最长不下降子序列 x 30%</h2><p>题意：给定数组a，可以修改连续的K个数字变成一个相同值。请计算修改后的最长不下降子序列长度。</p><p>我的：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ld double</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) s=(s&lt;&lt;<span class="hljs-number">3</span>)+(s&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> f*s;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<span class="hljs-comment">//const int maxm = 4e5+100;</span><span class="hljs-keyword">int</span> n,q;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-keyword">int</span> b[maxn];<span class="hljs-keyword">int</span> d[maxn];<span class="hljs-keyword">int</span> l[maxn];<span class="hljs-keyword">int</span> len;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    d[<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>];    l[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span> (a[i]&gt;=d[len])&#123;  <span class="hljs-comment">//如果可以接在len后面就接上，如果是最长上升子序列，这里变成&gt; </span>            d[++len]=a[i];            l[i]=len;        &#125;         <span class="hljs-keyword">else</span>  <span class="hljs-comment">//否则就找一个最该替换的替换掉 </span>        &#123;            <span class="hljs-keyword">int</span> j=<span class="hljs-built_in">upper_bound</span>(d+<span class="hljs-number">1</span>,d+len+<span class="hljs-number">1</span>,a[i])-d;  <span class="hljs-comment">//找到第一个大于它的d的下标，如果是最长上升子序列，这里变成lower_bound </span>            d[j]=a[i];             l[i]=j;        &#125;    &#125;    <span class="hljs-comment">//printf(&quot;%d\n&quot;,len);  </span>    <span class="hljs-comment">// FOR(i,1,n)</span>    <span class="hljs-comment">//     cout&lt;&lt;l[i]&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">// cout&lt;&lt;endl;</span>&#125;<span class="hljs-keyword">int</span> l1[maxn],l2[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-built_in">solve</span>();    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        l1[i]=l[i];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        b[i]=<span class="hljs-number">1e6</span>-a[<span class="hljs-number">1</span>+n-i];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        a[i]=b[i];    <span class="hljs-built_in">solve</span>();    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        l2[i]=l[<span class="hljs-number">1</span>+n-i];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        b[i]=<span class="hljs-number">1e6</span>-a[<span class="hljs-number">1</span>+n-i];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        a[i]=b[i];    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    l1[<span class="hljs-number">0</span>]=l2[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    a[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    a[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-keyword">if</span>(i+q&gt;n+<span class="hljs-number">1</span>)            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>(a[i+q]&gt;=a[i<span class="hljs-number">-1</span>])            ans=<span class="hljs-built_in">max</span>(ans,l1[i<span class="hljs-number">-1</span>]+l2[i+q]+q);    &#125;    cout&lt;&lt;ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">6 1</span><span class="hljs-comment">1 1 5 4 6 1</span><span class="hljs-comment">*/</span></code></pre></div><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x * w;&#125;<span class="hljs-keyword">int</span> a[maxn], b[maxn];<span class="hljs-keyword">int</span> dp[maxn];<span class="hljs-comment">///dp[i]表示以i结尾的最长上升子序列</span><span class="hljs-comment">///权值线段树，维护dp数组</span><span class="hljs-keyword">int</span> tree[maxn &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    tree[o] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l == r)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid);    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l == r)    &#123;        tree[o] = <span class="hljs-built_in">max</span>(tree[o], val);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x &lt;= mid)<span class="hljs-built_in">update</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, val);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, val);    tree[o] = <span class="hljs-built_in">max</span>(tree[o &lt;&lt; <span class="hljs-number">1</span>], tree[o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)        <span class="hljs-keyword">return</span> tree[o];    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(L &lt;= mid)ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R));    <span class="hljs-keyword">if</span>(R &gt; mid)ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R));    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n, k, tot = <span class="hljs-number">0</span>;    <span class="hljs-built_in">read</span>(n); <span class="hljs-built_in">read</span>(k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-built_in">read</span>(a[i]), b[++tot] = a[i];    <span class="hljs-keyword">if</span>(n == k)    &#123;        cout&lt;&lt;n&lt;&lt;endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">///离散化</span>    <span class="hljs-built_in">sort</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + tot);    tot = <span class="hljs-built_in">unique</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + tot) - (b + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        a[i] = <span class="hljs-built_in">lower_bound</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + tot, a[i]) - b;        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot);    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">///从前往后遍历a，放入权值线段树中</span>    &#123;        <span class="hljs-comment">///dp[i] = max(dp[j]) 满足j=1...i-1 &amp;&amp; a[j] &lt;= a[i]</span>        dp[i] = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, <span class="hljs-number">1</span>, a[i]) + <span class="hljs-number">1</span>;        <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, a[i], dp[i]);    &#125;    <span class="hljs-comment">///重新清空</span>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt; k; i--)<span class="hljs-comment">///从后往前遍历a，放入权值线段树中</span>    &#123;        <span class="hljs-comment">///a[i-k+1] ... a[i]相等 均等于a[i-k]</span>        <span class="hljs-comment">///最后一段要注意：查询的是[a[i-k],tot]中的最大值</span>        ans = <span class="hljs-built_in">max</span>(ans, dp[i - k] + k - <span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, a[i - k], tot) + <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, a[i], tot) + <span class="hljs-number">1</span>; <span class="hljs-comment">///以a[i]开始的最长上升子序列长度</span>        ans = <span class="hljs-built_in">max</span>(ans, tmp + k);        <span class="hljs-comment">///插入的是a[i]</span>        <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot, a[i], tmp);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="h---扫描游戏">H - 扫描游戏</h2><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x = x * w;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    ll x, y, z;    <span class="hljs-keyword">int</span> id;&#125;a[maxn];ll n;__int128 L;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Quadrant</span><span class="hljs-params">(point a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a.x &gt;= <span class="hljs-number">0</span> &amp;&amp; a.y &gt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">///y的正半轴放到第一象限</span>    <span class="hljs-keyword">if</span>(a.x &gt; <span class="hljs-number">0</span> &amp;&amp; a.y &lt;= <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">///x的正半轴放到第二象限</span>    <span class="hljs-keyword">if</span>(a.x &lt;= <span class="hljs-number">0</span> &amp;&amp; a.y &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">cross</span><span class="hljs-params">(point a, point b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(point a, point b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Quadrant</span>(a) == <span class="hljs-built_in">Quadrant</span>(b))    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cross</span>(a, b) == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> a.x * a.x + a.y * a.y &lt; b.x * b.x + b.y * b.y;        <span class="hljs-keyword">else</span>           <span class="hljs-keyword">return</span> <span class="hljs-built_in">cross</span>(a, b) &lt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Quadrant</span>(a) &lt; <span class="hljs-built_in">Quadrant</span>(b);&#125;__int128 mi[maxn &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o)</span></span><span class="hljs-function"></span>&#123;    mi[o] = <span class="hljs-built_in">min</span>(mi[o &lt;&lt; <span class="hljs-number">1</span>], mi[o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l == r)    &#123;        mi[o] = a[l].x * a[l].x + a[l].y * a[l].y;        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid);    <span class="hljs-built_in">build</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);    <span class="hljs-built_in">push_up</span>(o);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> x, __int128 val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l == r)    &#123;        mi[o] = val;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x &lt;= mid)<span class="hljs-built_in">update</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, val);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, val);    <span class="hljs-built_in">push_up</span>(o);&#125;<span class="hljs-comment">///找右边第一个小于等于z^2的数字</span>ll idx;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> o, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, __int128 z)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(L &gt; R)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(l == r)    &#123;        idx = l;        <span class="hljs-keyword">return</span> mi[o] &lt;= z;    &#125;    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L &lt;= mid)    &#123;        <span class="hljs-keyword">if</span>((mi[o &lt;&lt; <span class="hljs-number">1</span>] &lt;= z) &amp;&amp; <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, z))            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span>(R &gt; mid)    &#123;        <span class="hljs-keyword">if</span>((mi[o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] &lt;= z) &amp;&amp; <span class="hljs-built_in">query</span>(o &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, z))            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">read</span>(n);<span class="hljs-built_in">read</span>(L);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        <span class="hljs-built_in">read</span>(a[i].x);<span class="hljs-built_in">read</span>(a[i].y);<span class="hljs-built_in">read</span>(a[i].z);        a[i].id = i;        ans[i] = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n, cmp);    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> lastcnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;  <span class="hljs-comment">///上一个位置</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)    &#123;        <span class="hljs-keyword">bool</span> ok = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, last + <span class="hljs-number">1</span>, n, L * L);        <span class="hljs-keyword">if</span>(ok)L = L + a[idx].z;        <span class="hljs-keyword">else</span>        &#123;            ok = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, last - <span class="hljs-number">1</span>, L * L);            <span class="hljs-keyword">if</span>(ok)L = L + a[idx].z;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx, <span class="hljs-number">1e32</span>);        <span class="hljs-keyword">if</span>(last)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Quadrant</span>(a[last]) == <span class="hljs-built_in">Quadrant</span>(a[idx]) &amp;&amp; <span class="hljs-built_in">cross</span>(a[last], a[idx]) == <span class="hljs-number">0</span>)                ans[a[idx].id] = lastcnt, ++cnt;            <span class="hljs-keyword">else</span>                ans[a[idx].id] = ++cnt, lastcnt = cnt;        &#125;        <span class="hljs-keyword">else</span>            ans[a[idx].id] = ++cnt, lastcnt = cnt;        last = idx;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        cout&lt;&lt;ans[i];        <span class="hljs-keyword">if</span>(i != n)cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="i---数的拆分">I - 数的拆分</h2><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x * w;&#125;<span class="hljs-keyword">bool</span> not_prime[<span class="hljs-number">4010</span>];<span class="hljs-keyword">int</span> prime[<span class="hljs-number">4010</span>], tot;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<span class="hljs-keyword">if</span>(!not_prime[i])    &#123;        prime[++tot] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + i; j &lt;= n; j += i)            not_prime[j] = <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">///检查平方数</span>    ll y = <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">0.5</span>);    <span class="hljs-keyword">if</span>(y * y == x || (y + <span class="hljs-number">1</span>) * (y + <span class="hljs-number">1</span>) == x)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">///检查立方数</span>    y = <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">1.0</span> / <span class="hljs-number">3</span>);    <span class="hljs-keyword">if</span>(y * y * y == x || (y + <span class="hljs-number">1</span>) * (y + <span class="hljs-number">1</span>) * (y + <span class="hljs-number">1</span>) == x || (y + <span class="hljs-number">2</span>) * (y + <span class="hljs-number">2</span>) * (y + <span class="hljs-number">2</span>) == x)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">init</span>(<span class="hljs-number">4000</span>);    <span class="hljs-keyword">int</span> T;    <span class="hljs-built_in">read</span>(T);    <span class="hljs-keyword">while</span>(T--)    &#123;        ll x;        <span class="hljs-built_in">read</span>(x);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(x))        &#123;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;yes&quot;</span>);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++)<span class="hljs-keyword">if</span>(x % prime[i] == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(x % prime[i] == <span class="hljs-number">0</span>)            &#123;                now++;                x /= prime[i] ;            &#125;            <span class="hljs-comment">///cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;endl;</span>            <span class="hljs-keyword">if</span>(now == <span class="hljs-number">1</span>)            &#123;                flag = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag &amp; <span class="hljs-built_in">check</span>(x))        &#123;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;yes&quot;</span>);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;no&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="j---推导部分和-x-10">J - 推导部分和 x 10%</h2><p>题解：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;  x = <span class="hljs-number">0</span>;  T w = <span class="hljs-number">1</span>;  <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;    x = x * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);    ch = <span class="hljs-built_in">getchar</span>();  &#125;  <span class="hljs-keyword">return</span> x = x * w;&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> ll INF = <span class="hljs-number">-1e13</span>;<span class="hljs-keyword">int</span> n, m, q;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> v; ll w;    <span class="hljs-built_in">edge</span>()&#123;&#125;    <span class="hljs-built_in">edge</span>(<span class="hljs-keyword">int</span> v, ll w):<span class="hljs-built_in">v</span>(v), <span class="hljs-built_in">w</span>(w)&#123;&#125;&#125;;vector&lt;edge&gt;Map[maxn];ll sum[maxn];<span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, ll d)</span></span><span class="hljs-function"></span>&#123;    vis[u] = <span class="hljs-number">1</span>;    sum[u] = d;    <span class="hljs-comment">///cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : Map[u])    &#123;        <span class="hljs-keyword">int</span> v = x.v; ll w = x.w;        <span class="hljs-keyword">if</span>(vis[v])<span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs</span>(v, d + w);    &#125;&#125;queue&lt;pair&lt;<span class="hljs-keyword">int</span>,ll&gt; &gt;Q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, ll d)</span></span><span class="hljs-function"></span>&#123;    vis[u] = <span class="hljs-number">1</span>;    sum[u] = d;    Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(u, d));    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())    &#123;        <span class="hljs-keyword">auto</span> now = Q.<span class="hljs-built_in">front</span>();        Q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">int</span> u = now.first; ll d = now.second;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : Map[u])        &#123;            <span class="hljs-keyword">int</span> v = x.v; ll w = x.w;            <span class="hljs-keyword">if</span>(vis[v])<span class="hljs-keyword">continue</span>;            vis[v] = <span class="hljs-number">1</span>;            sum[v] = d + w;            Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(v, d + w));        &#125;    &#125;&#125;<span class="hljs-keyword">int</span> f[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x == f[x] ? x : f[x] = <span class="hljs-built_in">Find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">read</span>(n);<span class="hljs-built_in">read</span>(m);<span class="hljs-built_in">read</span>(q);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)f[i] = i;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)    &#123;        <span class="hljs-keyword">int</span> l, r; ll s;        <span class="hljs-built_in">read</span>(l);<span class="hljs-built_in">read</span>(r);<span class="hljs-built_in">read</span>(s);        <span class="hljs-comment">///cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;endl;</span>        <span class="hljs-comment">///sum[r] - sum[l - 1] = s</span>        Map[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(r, s));        Map[r].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(l - <span class="hljs-number">1</span>, -s));        f[<span class="hljs-built_in">Find</span>(l - <span class="hljs-number">1</span>)] = <span class="hljs-built_in">Find</span>(r);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<span class="hljs-keyword">if</span>(!vis[i])        <span class="hljs-built_in">bfs</span>(i, <span class="hljs-number">0</span>);    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-keyword">int</span> l, r;        <span class="hljs-built_in">read</span>(l), <span class="hljs-built_in">read</span>(r);        --l;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Find</span>(l) != <span class="hljs-built_in">Find</span>(r))<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;UNKNOWN&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum[r] - sum[l]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022—GPLT程序设计天梯赛复盘</title>
    <link href="/2022/04/27/17%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    <url>/2022/04/27/17%E5%A4%A9%E6%A2%AF%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>注：本文1-4题因为没有保存源码，使用的是下述参考博客的代码，其他代码均为本人比赛场上的ac代码。</p>          </div><h1 id="链接">链接</h1><div class="note note-info">            <p><a href="https://gplt.patest.cn/rank/student"><b>比赛官网</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/m0_46381590/article/details/124368368"><b>参考的博客</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><figure><img src="https://pic.imgdb.cn/item/6268dde3239250f7c5634740.png"alt="最终成绩" /><figcaption aria-hidden="true">最终成绩</figcaption></figure><h2 id="l1-1-今天我要赢-5-分">L1-1 今天我要赢 (5 分)</h2><p><strong>题目大意：</strong> 2018 年我们曾经出过一题，是输出“2018我们要赢”。今年是 2022年，你要输出的句子变成了“我要赢！就在今天！”然后以比赛当天的日期落款。</p><p>输入格式：</p><p>本题没有输入。</p><p>输出格式：</p><p>输出分 2 行。在第一行中输出 I’m gonna win! Today!，在第二行中用年年年年-月月-日日 的格式输出比赛当天的日期。已知比赛的前一天是2022-04-22。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs">无</code></pre></div><p>输出样例（第二行的内容要你自己想一想，这里不给出）：</p><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">I’m gonna win! Today!</code></pre></div><p>这一行的内容我不告诉你…… 你要自己输出正确的日期呀~</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m gonna win! Today!&quot;</span>&lt;&lt;endl; cout&lt;&lt;<span class="hljs-string">&quot;2022-04-23&quot;</span>;&#125; </code></pre></div><h2 id="l1-2-种钻石-5-分">L1-2 种钻石 (5 分)</h2><p>2019年10月29日，中央电视台专题报道，中国科学院在培育钻石领域，取得科技突破。科学家们用金刚石的籽晶片作为种子，利用甲烷气体在能量作用下形成碳的等离子体，慢慢地沉积到钻石种子上，一周“种”出了一颗1 克拉大小的钻石。</p><p>本题给出钻石的需求量和人工培育钻石的速度，请你计算出货需要的时间。</p><p>输入格式：</p><p>输入在一行中给出钻石的需求量 N（不超过 107的正整数，以微克拉为单位）和人工培育钻石的速度v（1≤v≤200，以微克拉/天为单位的整数）。</p><p>输出格式：</p><p>在一行中输出培育 N微克拉钻石需要的整数天数。不到一天的时间不算在内。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">102000 </span><span class="hljs-number">130</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs">784</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> n,m; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;n/m;&#125;</code></pre></div><h2 id="l1-3-谁能进图书馆-10-分">L1-3 谁能进图书馆 (10 分)</h2><p>为了保障安静的阅读环境，有些公共图书馆对儿童入馆做出了限制。例如“12岁以下儿童禁止入馆，除非有 18 岁以上（包括 18岁）的成人陪同”。现在有两位小/大朋友跑来问你，他们能不能进去？请你写个程序自动给他们一个回复。</p><p>输入格式：</p><p>输入在一行中给出 4 个整数：</p><p>禁入年龄线 陪同年龄线 询问者1的年龄 询问者2的年龄</p><p>这里的禁入年龄线是指严格小于该年龄的儿童禁止入馆；陪同年龄线是指大于等于该年龄的人士可以陪同儿童入馆。默认两个询问者的编号依次分别为1 和 2；年龄和年龄线都是 [1, 200] 区间内的整数，并且保证 陪同年龄线严格大于 禁入年龄线。</p><p>输出格式：</p><p>在一行中输出对两位询问者的回答，如果可以进就输出 年龄-Y，否则输出年龄-N，中间空 1 格，行首尾不得有多余空格。</p><p>在第二行根据两个询问者的情况输出一句话：</p><ul><li><p>如果两个人必须一起进，则输出 qing X zhao gu hao Y，其中 X是陪同人的编号， Y 是小孩子的编号；</p></li><li><p>如果两个人都可以进但不是必须一起的，则输出 huan ying ruguan；</p></li><li><p>如果两个人都进不去，则输出 zhang da zai lai ba；</p></li><li><p>如果一个人能进一个不能，则输出 X: huan ying ru guan，其中 X是可以入馆的那个人的编号。</p></li></ul><p>输入样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">18</span> <span class="hljs-number">18</span> <span class="hljs-number">8</span></code></pre></div><p>输出样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">18</span>-Y <span class="hljs-number">8</span>-Y<span class="hljs-attribute">qing</span> <span class="hljs-number">1</span> zhao gu hao <span class="hljs-number">2</span></code></pre></div><p>输入样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">18</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span></code></pre></div><p>输出样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">10</span>-N <span class="hljs-number">15</span>-Y<span class="hljs-attribute">2</span>: huan ying ru guan</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> a,b,c,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; <span class="hljs-keyword">int</span> x,y; <span class="hljs-keyword">if</span>(c&lt;a)&#123;  <span class="hljs-keyword">if</span>(d&lt;a)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-N &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-N&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;zhang da zai lai ba&quot;</span>&lt;&lt;endl;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;=a&amp;&amp;d&lt;b)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-N &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;2: huan ying ru guan&quot;</span>;  &#125;  <span class="hljs-keyword">else</span>&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;qing 2 zhao gu hao 1&quot;</span>;  &#125; &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c&gt;=b)&#123;  <span class="hljs-keyword">if</span>(d&lt;a)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;qing 1 zhao gu hao 2&quot;</span>;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;=a)&#123;        cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;        cout&lt;&lt;<span class="hljs-string">&quot;huan ying ru guan&quot;</span>;  &#125; &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-keyword">if</span>(d&lt;a)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-N&quot;</span>&lt;&lt;endl;   cout&lt;&lt;<span class="hljs-string">&quot;1: huan ying ru guan&quot;</span>;  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;=a)&#123;   cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;-Y &quot;</span>&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot;-Y&quot;</span>&lt;&lt;endl;       cout&lt;&lt;<span class="hljs-string">&quot;huan ying ru guan&quot;</span>;  &#125; &#125;&#125;</code></pre></div><h2 id="l1-4-拯救外星人-10-分">L1-4 拯救外星人 (10 分)</h2><p>你的外星人朋友不认得地球上的加减乘除符号，但是会算阶乘 —— 正整数 N的阶乘记为 “N!”，是从 1 到 N的连乘积。所以当他不知道“5+7”等于多少时，如果你告诉他等于“12!”，他就写出了“479001600”这个答案。</p><p>本题就请你写程序模仿外星人的行为。</p><p>输入格式：</p><p>输入在一行中给出两个正整数 A 和 B。</p><p>输出格式：</p><p>在一行中输出 (A+B) 的阶乘。题目保证 (A+B) 的值小于 12。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">6</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs">362880</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,i,j,k,s=<span class="hljs-number">1</span>,m; cin&gt;&gt;m&gt;&gt;n; <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n+m;i++) s*=i; cout&lt;&lt;s;&#125;</code></pre></div><h2 id="l1-5-试试手气-15-分">L1-5 试试手气 (15 分)</h2><p>我们知道一个骰子有 6 个面，分别刻了 1 到 6 个点。下面给你 6个骰子的初始状态，即它们朝上一面的点数，让你一把抓起摇出另一套结果。假设你摇骰子的手段特别精妙，每次摇出的结果都满足以下两个条件：</p><ol type="1"><li>每个骰子摇出的点数都跟它之前任何一次出现的点数不同；</li><li>在满足条件 1 的前提下，每次都能让每个骰子得到可能得到的最大点数。那么你应该可以预知自己第 n 次（1≤n≤5）摇出的结果。 输入格式：输入第一行给出 6 个骰子的初始点数，即 [1,6]之间的整数，数字间以空格分隔；第二行给出摇的次数 n（1≤n≤5）。 输出格式：在一行中顺序列出第 n 次摇出的每个骰子的点数。数字间必须以 1个空格分隔，行首位不得有多余空格。 输入样例：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><span class="hljs-number">3</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span></code></pre></div><p>样例解释：</p><p>这 3 次摇出的结果依次为：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a[<span class="hljs-number">8</span>];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>) cin&gt;&gt;a[i];    <span class="hljs-keyword">int</span> k;    cin&gt;&gt;k;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">7</span>-k;        <span class="hljs-keyword">if</span>(ans&lt;=a[i])            ans--;        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">6</span>)            cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;        <span class="hljs-keyword">else</span>                cout&lt;&lt;ans;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="l1-6-斯德哥尔摩火车上的题-15-分">L1-6 斯德哥尔摩火车上的题 (15分)</h2><p>上图是新浪微博上的一则趣闻，是瑞典斯德哥尔摩火车上的一道题，看上去是段伪代码：</p><div class="hljs code-wrapper"><pre><code class="hljs gcode">s = ‘’a = ‘<span class="hljs-number">1112031584</span>’for <span class="hljs-comment">(i = 1; i &lt; length(a)</span>; i++) &#123;<span class="hljs-keyword">if</span> <span class="hljs-comment">(a[i] % 2 == a[i-1] % 2)</span> &#123;s += max<span class="hljs-comment">(a[i], a[i-1])</span>&#125;&#125;goto_url<span class="hljs-comment">(‘www.multisoft.se/’ + s)</span></code></pre></div><p>其中字符串的 +操作是连接两个字符串的意思。所以这道题其实是让大家访问网站www.multisoft.se/112358（注意：比赛中千万不要访问这个网址！！！）。</p><p>当然，能通过上述算法得到 112358 的原始字符串 a是不唯一的。本题就请你判断，两个给定的原始字符串，能否通过上述算法得到相同的输出？</p><p>输入格式：</p><p>输入为两行仅由数字组成的非空字符串，长度均不超过104，以回车结束。</p><p>输出格式：</p><p>对两个字符串分别采用上述斯德哥尔摩火车上的算法进行处理。如果两个结果是一样的，则在一行中输出那个结果；否则分别输出各自对应的处理结果，每个占一行。题目保证输出结果不为空。</p><p>输入样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">1112031584</span><span class="hljs-number">011102315849</span></code></pre></div><p>输出样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs">112358</code></pre></div><p>输入样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs">11120315841233412341112031584</code></pre></div><p>输出样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">1123583</span><span class="hljs-number">112358</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e4</span>+<span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">char</span> c[maxn];    <span class="hljs-keyword">int</span> a[maxn];    <span class="hljs-keyword">int</span> ans1[maxn],cnt1=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> ans2[maxn],cnt2=<span class="hljs-number">0</span>;    cin&gt;&gt;c;    <span class="hljs-keyword">int</span>  l = <span class="hljs-built_in">strlen</span>(c);    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">0</span>,l<span class="hljs-number">-1</span>)        a[i]=c[i]-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; l; i++) &#123;        <span class="hljs-keyword">if</span> (a[i] % <span class="hljs-number">2</span> == a[i<span class="hljs-number">-1</span>] % <span class="hljs-number">2</span>)             ans1[++cnt1] = <span class="hljs-built_in">max</span>(a[i], a[i<span class="hljs-number">-1</span>]);    &#125;    cin&gt;&gt;c;    l = <span class="hljs-built_in">strlen</span>(c);    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">0</span>,l<span class="hljs-number">-1</span>)        a[i]=c[i]-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; l; i++) &#123;        <span class="hljs-keyword">if</span> (a[i] % <span class="hljs-number">2</span> == a[i<span class="hljs-number">-1</span>] % <span class="hljs-number">2</span>)             ans2[++cnt2] = <span class="hljs-built_in">max</span>(a[i], a[i<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(cnt1!=cnt2) f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(f)    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt1)&#123;        <span class="hljs-keyword">if</span>(ans1[i]!=ans2[i])&#123;            f=<span class="hljs-number">0</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(f)&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt1)            cout&lt;&lt;ans1[i];    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt1)            cout&lt;&lt;ans1[i];        cout&lt;&lt;endl;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt2)            cout&lt;&lt;ans2[i];    &#125;&#125;</code></pre></div><h2 id="l1-7-机工士姆斯塔迪奥-20-分">L1-7 机工士姆斯塔迪奥 (20 分)</h2><p>在 MMORPG《最终幻想14》的副本“乐欲之所瓯博讷修道院”里，BOSS机工士姆斯塔迪奥将会接受玩家的挑战。</p><p>你需要处理这个副本其中的一个机制：N×M 大小的地图被拆分为了 N×M 个 1×1的格子，BOSS会选择若干行或/及若干列释放技能，玩家不能站在释放技能的方格上，否则就会被击中而失败。</p><p>给定 BOSS所有释放技能的行或列信息，请你计算出最后有多少个格子是安全的。</p><p>输入格式:</p><p>输入第一行是三个整数 N,M,Q (1≤N×M≤105，0≤Q≤1000)，表示地图为 N 行 M列大小以及选择的行/列数量。</p><p>接下来 Q 行，每行两个数 Ti​,Ci​，其中 Ti​=0 表示 BOSS选择的是一整行，Ti​=1 表示选择的是一整列，Ci​ 为选择的行号/列号。</p><p>行和列的编号均从 1 开始。</p><p>输出格式:</p><p>输出一个数，表示安全格子的数量。</p><p>输入样例:</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-symbol">0 </span><span class="hljs-number">2</span><span class="hljs-symbol">0 </span><span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span></code></pre></div><p>输出样例:</p><div class="hljs code-wrapper"><pre><code class="hljs">12</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">bool</span> e[<span class="hljs-number">2</span>][maxn]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    cin&gt;&gt;n&gt;&gt;m;    <span class="hljs-keyword">int</span> q;    cin&gt;&gt;q;    <span class="hljs-keyword">while</span>(q--)&#123;        <span class="hljs-keyword">int</span> t,c;        cin&gt;&gt;t&gt;&gt;c;        e[t][c]=<span class="hljs-number">1</span>;    &#125;    ll a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-keyword">if</span>(e[<span class="hljs-number">0</span>][i]==<span class="hljs-number">0</span>)            a++;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,m)        <span class="hljs-keyword">if</span>(e[<span class="hljs-number">1</span>][i]==<span class="hljs-number">0</span>)            b++;    cout&lt;&lt;a*b;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="l1-8-静静的推荐-20-分">L1-8 静静的推荐 (20 分)</h2><p>天梯赛结束后，某企业的人力资源部希望组委会能推荐一批优秀的学生，这个整理推荐名单的任务就由静静姐负责。企业接受推荐的流程是这样的：</p><ul><li>只考虑得分不低于 175 分的学生；</li><li>一共接受 K 批次的推荐名单；</li><li>同一批推荐名单上的学生的成绩原则上应严格递增；</li><li>如果有的学生天梯赛成绩虽然与前一个人相同，但其参加过 PAT考试，且成绩达到了该企业的面试分数线，则也可以接受。</li></ul><p>给定全体参赛学生的成绩和他们的 PAT考试成绩，请你帮静静姐算一算，她最多能向企业推荐多少学生？</p><p>输入格式：</p><p>输入第一行给出 3个正整数：N（≤105）为参赛学生人数，K（≤5×103）为企业接受的推荐批次，S（≤100）为该企业的PAT 面试分数线。</p><p>随后 N 行，每行给出两个分数，依次为一位学生的天梯赛分数（最高分290）和 PAT 分数（最高分 100）。</p><p>输出格式：</p><p>在一行中输出静静姐最多能向企业推荐的学生人数。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">2</span> <span class="hljs-number">90</span><span class="hljs-symbol">203 </span><span class="hljs-number">0</span><span class="hljs-symbol">169 </span><span class="hljs-number">91</span><span class="hljs-symbol">175 </span><span class="hljs-number">88</span><span class="hljs-symbol">175 </span><span class="hljs-number">0</span><span class="hljs-symbol">175 </span><span class="hljs-number">90</span><span class="hljs-symbol">189 </span><span class="hljs-number">0</span><span class="hljs-symbol">189 </span><span class="hljs-number">0</span><span class="hljs-symbol">189 </span><span class="hljs-number">95</span><span class="hljs-symbol">189 </span><span class="hljs-number">89</span><span class="hljs-symbol">256 </span><span class="hljs-number">100</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs">8</code></pre></div><p>样例解释： 第一批可以选择 175、189、203、256这四个分数的学生各一名，此外 175 分 PAT 分数达到 90 分的学生和 189 分PAT 分数达到 95 分的学生可以额外进入名单。第二批就只剩下 175、189两个分数的学生各一名可以进入名单了。最终一共 8 人进入推荐名单。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">291</span>],b[<span class="hljs-number">291</span>];<span class="hljs-comment">//175-290的桶</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,k,s;    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-keyword">int</span> x,y;        cin&gt;&gt;x&gt;&gt;y;        a[x]++;        <span class="hljs-keyword">if</span>(y&gt;=s)            b[x]++;    &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">175</span>,<span class="hljs-number">290</span>)&#123;        ans+=<span class="hljs-built_in">min</span>(a[i]-b[i],k)+b[i];    &#125;    cout&lt;&lt;ans;&#125;</code></pre></div><h2 id="l2-1-插松枝-25-分">L2-1 插松枝 (25 分)</h2><p>就是这道题卡了我好久，最后重新写才A的QAQ。</p><p>人造松枝加工场的工人需要将各种尺寸的塑料松针插到松枝干上，做成大大小小的松枝。他们的工作流程（并不）是这样的：</p><ul><li>每人手边有一只小盒子，初始状态为空。</li><li>每人面前有用不完的松枝干和一个推送器，每次推送一片随机型号的松针片。</li><li>工人首先捡起一根空的松枝干，从小盒子里摸出最上面的一片松针 ——如果小盒子是空的，就从推送器上取一片松针。将这片松针插到枝干的最下面。</li><li>工人在插后面的松针时，需要保证，每一步插到一根非空松枝干上的松针片，不能比前一步插上的松针片大。如果小盒子中最上面的松针满足要求，就取之插好；否则去推送器上取一片。如果推送器上拿到的仍然不满足要求，就把拿到的这片堆放到小盒子里，继续去推送器上取下一片。注意这里假设小盒子里的松针片是按放入的顺序堆叠起来的，工人每次只能取出最上面（即最后放入）的一片。</li><li>当下列三种情况之一发生时，工人会结束手里的松枝制作，开始做下一个：</li></ul><p>（1）小盒子已经满了，但推送器上取到的松针仍然不满足要求。此时将手中的松枝放到成品篮里，推送器上取到的松针压回推送器，开始下一根松枝的制作。</p><p>（2）小盒子中最上面的松针不满足要求，但推送器上已经没有松针了。此时将手中的松枝放到成品篮里，开始下一根松枝的制作。</p><p>（3）手中的松枝干上已经插满了松针，将之放到成品篮里，开始下一根松枝的制作。</p><p>现在给定推送器上顺序传过来的 N片松针的大小，以及小盒子和松枝的容量，请你编写程序自动列出每根成品松枝的信息。</p><p>输入格式：</p><p>输入在第一行中给出 3个正整数：N（≤103），为推送器上松针片的数量；M（≤20）为小盒子能存放的松针片的最大数量；K（≤5）为一根松枝干上能插的松针片的最大数量。</p><p>随后一行给出 N 个不超过 100的正整数，为推送器上顺序推出的松针片的大小。</p><p>输出格式：</p><p>每支松枝成品的信息占一行，顺序给出自底向上每片松针的大小。数字间以 1个空格分隔，行首尾不得有多余空格。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><span class="hljs-symbol">20 </span><span class="hljs-number">25</span> <span class="hljs-number">15</span> <span class="hljs-number">18</span> <span class="hljs-number">20</span> <span class="hljs-number">18</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">20 </span><span class="hljs-number">15</span><span class="hljs-symbol">20 </span><span class="hljs-number">18</span> <span class="hljs-number">18</span> <span class="hljs-number">8</span><span class="hljs-symbol">25 </span><span class="hljs-number">5</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e3</span>+<span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">int</span> pus[maxn],pus_long;<span class="hljs-keyword">int</span> box[maxn],box_long;<span class="hljs-keyword">int</span> tre[maxn],tre_long;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">out_tre</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,tre_long)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,tre[i]);        <span class="hljs-keyword">if</span>(i!=tre_long)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    tre_long=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m,k;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)        pus[i]=<span class="hljs-built_in">read</span>();    pus_long=n;    tre[<span class="hljs-number">0</span>]=<span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-keyword">while</span>(box_long||pus_long||tre_long)&#123;        <span class="hljs-keyword">if</span>( (box_long==m&amp;&amp;pus[pus_long]&gt;tre[tre_long]&amp;&amp;box[box_long]&gt;tre[tre_long]) ||            (box[box_long]&gt;tre[tre_long]&amp;&amp;pus_long==<span class="hljs-number">0</span>) ||            (tre_long==k) ||            (box_long==<span class="hljs-number">0</span>&amp;&amp;pus_long==<span class="hljs-number">0</span>)            )        &#123;            <span class="hljs-built_in">out_tre</span>();        &#125;        <span class="hljs-keyword">if</span>(box_long&gt;<span class="hljs-number">0</span>&amp;&amp;box[box_long]&lt;=tre[tre_long])&#123;            tre[++tre_long]=box[box_long--];        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pus_long&gt;<span class="hljs-number">0</span>&amp;&amp;pus[pus_long]&lt;=tre[tre_long])&#123;            tre[++tre_long]=pus[pus_long--];        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pus_long&gt;<span class="hljs-number">0</span>&amp;&amp;box_long&lt;m)&#123;            box[++box_long]=pus[pus_long--];        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="l2-2-老板的作息表-25-分">L2-2 老板的作息表 (25 分)</h2><p>新浪微博上有人发了某老板的作息时间表，表示其每天 4:30就起床了。但立刻有眼尖的网友问：这时间表不完整啊，早上九点到下午一点干啥了？</p><p>本题就请你编写程序，检查任意一张时间表，找出其中没写出来的时间段。</p><p>输入格式：</p><p>输入第一行给出一个正整数 N，为作息表上列出的时间段的个数。随后 N行，每行给出一个时间段，格式为：</p><p>hh:mm:ss - hh:mm:ss</p><p>其中 hh、mm、ss分别是两位数表示的小时、分钟、秒。第一个时间是开始时间，第二个是结束时间。题目保证所有时间都在一天之内（即从00:00:00 到 23:59:59）；每个区间间隔至少 1秒；并且任意两个给出的时间区间最多只在一个端点有重合，没有区间重叠的情况。</p><p>输出格式：</p><p>按照时间顺序列出时间表中没有出现的区间，每个区间占一行，格式与输入相同。题目保证至少存在一个区间需要输出。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">8</span><span class="hljs-attribute">13</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">18</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-attribute">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">05</span><span class="hljs-attribute">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">09</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-attribute">07</span>:<span class="hljs-number">10</span>:<span class="hljs-number">59</span> - <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-attribute">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">05</span> - <span class="hljs-number">04</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span><span class="hljs-attribute">06</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span> - <span class="hljs-number">07</span>:<span class="hljs-number">10</span>:<span class="hljs-number">58</span><span class="hljs-attribute">05</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span> - <span class="hljs-number">06</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span><span class="hljs-attribute">18</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">19</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">04</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span> - <span class="hljs-number">05</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span><span class="hljs-attribute">07</span>:<span class="hljs-number">10</span>:<span class="hljs-number">58</span> - <span class="hljs-number">07</span>:<span class="hljs-number">10</span>:<span class="hljs-number">59</span><span class="hljs-attribute">09</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">13</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-attribute">19</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> - <span class="hljs-number">23</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> h1,m1,s1;    <span class="hljs-keyword">int</span> h2,m2,s2;    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> c=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> d=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> e=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> f=<span class="hljs-number">0</span>):<span class="hljs-built_in">h1</span>(a),<span class="hljs-built_in">m1</span>(b),<span class="hljs-built_in">s1</span>(c),<span class="hljs-built_in">h2</span>(d),<span class="hljs-built_in">m2</span>(e),<span class="hljs-built_in">s2</span>(f)&#123;&#125;&#125;e[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span>&#123;    <span class="hljs-keyword">if</span>(a.h1!=b.h1)        <span class="hljs-keyword">return</span> a.h1&lt;b.h1;    <span class="hljs-keyword">if</span>(a.m1!=b.m1)        <span class="hljs-keyword">return</span> a.m1&lt;b.m1;    <span class="hljs-keyword">return</span> a.s1&lt;b.s1;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">com</span><span class="hljs-params">(node a,node b)</span></span>&#123;    <span class="hljs-keyword">if</span>(a.h2!=b.h1)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(a.m2!=b.m1)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(a.s2!=b.s1)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0%d&quot;</span>,x);    <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    cin&gt;&gt;n;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d - %d:%d:%d&quot;</span>,&amp;e[i].h1,&amp;e[i].m1,&amp;e[i].s1,&amp;e[i].h2,&amp;e[i].m2,&amp;e[i].s2);        <span class="hljs-comment">//printf(&quot;%d %d %d %d %d %d\n&quot;,e[i].h1,e[i].m1,e[i].s1,e[i].h2,e[i].m2,e[i].s2);</span>    &#125;    e[<span class="hljs-number">0</span>]=<span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    e[n+<span class="hljs-number">1</span>]=<span class="hljs-built_in">node</span>(<span class="hljs-number">23</span>,<span class="hljs-number">59</span>,<span class="hljs-number">59</span>,<span class="hljs-number">23</span>,<span class="hljs-number">59</span>,<span class="hljs-number">59</span>);    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+<span class="hljs-number">1</span>+n,cmp);    <span class="hljs-comment">// FOR(i,0,n+1)&#123;</span>    <span class="hljs-comment">//     //scanf(&quot;%d:%d:%d - %d:%d:%d&quot;,&amp;e[i].h1,&amp;e[i].m1,&amp;e[i].s1,&amp;e[i].h2,&amp;e[i].m2,&amp;e[i].s2);</span>    <span class="hljs-comment">//     printf(&quot;%d %d %d %d %d %d\n&quot;,e[i].h1,e[i].m1,e[i].s1,e[i].h2,e[i].m2,e[i].s2);</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">0</span>,n)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">com</span>(e[i],e[i+<span class="hljs-number">1</span>]))            <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//printf(&quot;%d:%d:%d - %d:%d:%d\n&quot;,e[i].h2,e[i].m2,e[i].s2,e[i+1].h2,e[i+1].m2,e[i+1].s2);</span>                <span class="hljs-built_in">prin</span>(e[i].h2);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-built_in">prin</span>(e[i].m2);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-built_in">prin</span>(e[i].s2);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; - &quot;</span>);        <span class="hljs-built_in">prin</span>(e[i+<span class="hljs-number">1</span>].h1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-built_in">prin</span>(e[i+<span class="hljs-number">1</span>].m1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-built_in">prin</span>(e[i+<span class="hljs-number">1</span>].s1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;&#125;</code></pre></div><h2 id="l2-3-龙龙送外卖-25-分">L2-3 龙龙送外卖 (25 分)</h2><p>龙龙是“饱了呀”外卖软件的注册骑手，负责送帕特小区的外卖。帕特小区的构造非常特别，都是双向道路且没有构成环——你可以简单地认为小区的路构成了一棵树，根结点是外卖站，树上的结点就是要送餐的地址。</p><p>每到中午 12点，帕特小区就进入了点餐高峰。一开始，只有一两个地方点外卖，龙龙简单就送好了；但随着大数据的分析，龙龙被派了更多的单子，也就送得越来越累……</p><p>看着一大堆订单，龙龙想知道，从外卖站出发，访问所有点了外卖的地方至少一次（这样才能把外卖送到）所需的最短路程的距离到底是多少？每次新增一个点外卖的地址，他就想估算一遍整体工作量，这样他就可以搞明白新增一个地址给他带来了多少负担。</p><p>输入格式:</p><p>输入第一行是两个数 N 和 M (2≤N≤105,1≤M≤105)，分别对应树上节点的个数（包括外卖站），以及新增的送餐地址的个数。</p><p>接下来首先是一行 N 个数，第 i 个数表示第 i个点的双亲节点的编号。节点编号从 1 到 N，外卖站的双亲编号定义为 −1。</p><p>接下来有 M 行，每行给出一个新增的送餐地点的编号Xi​。保证送餐地点中不会有外卖站，但地点有可能会重复。</p><p>为了方便计算，我们可以假设龙龙一开始一个地址的外卖都不用送，两个相邻的地点之间的路径长度统一设为1，且从外卖站出发可以访问到所有地点。</p><p>注意：所有送餐地址可以按任意顺序访问，且完成送餐后无需返回外卖站。</p><p>输出格式:</p><p>对于每个新增的地点，在一行内输出题目需要求的最短路程的距离。</p><p>输入样例:</p><div class="hljs code-wrapper"><pre><code class="hljs tap">7 4-1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>35624</code></pre></div><p>输出样例:</p><div class="hljs code-wrapper"><pre><code class="hljs">2446</code></pre></div><h2 id="l2-4-大众情人-25-分">L2-4 大众情人 (25 分)</h2><p>人与人之间总有一点距离感。我们假定两个人之间的亲密程度跟他们之间的距离感成反比，并且距离感是单向的。例如小蓝对小红患了单相思，从小蓝的眼中看去，他和小红之间的距离为1，只差一层窗户纸；但在小红的眼里，她和小蓝之间的距离为108000，差了十万八千里……另外，我们进一步假定，距离感在认识的人之间是可传递的。例如小绿觉得自己跟小蓝之间的距离为2，则即使小绿并不直接认识小红，我们也默认小绿早晚会认识小红，并且因为跟小蓝很亲近的关系，小绿会觉得自己跟小红之间的距离为1+2=3。当然这带来一个问题，如果小绿本来也认识小红，或者他通过其他人也能认识小红，但通过不同渠道推导出来的距离感不一样，该怎么算呢？我们在这里做个简单定义，就将小绿对小红的距离感定义为所有推导出来的距离感的最小值。</p><p>一个人的异性缘不是由最喜欢他/她的那个异性决定的，而是由对他/她最无感的那个异性决定的。我们记一个人i 在一个异性 j 眼中的距离感为 Dij​；将 i 的“异性缘”定义为1/maxj∈S(i)​{Dij​}，其中 S(i) 是相对于 i的所有异性的集合。那么“大众情人”就是异性缘最好（值最大）的那个人。</p><p>本题就请你从给定的一批人与人之间的距离感中分别找出两个性别中的“大众情人”。</p><p>输入格式：</p><p>输入在第一行中给出一个正整数N（≤500），为总人数。于是我们默认所有人从 1 到 N 编号。</p><p>随后 N 行，第 i 行描述了编号为 i 的人与其他人的关系，格式为：</p><p>性别 K 朋友1:距离1 朋友2:距离2 …… 朋友K:距离K</p><p>其中 性别 是这个人的性别，F 表示女性，M 表示男性；K（小于 N的非负整数）为这个人直接认识的朋友数；随后给出的是这 K个朋友的编号、以及这个人对该朋友的距离感。距离感是不超过 106的正整数。</p><p>题目保证给出的关系中一定两种性别的人都有，不会出现重复给出的关系，并且每个人的朋友中都不包含自己。</p><p>输出格式：</p><p>第一行给出自身为女性的“大众情人”的编号，第二行给出自身为男性的“大众情人”的编号。如果存在并列，则按编号递增的顺序输出所有。数字间以一个空格分隔，行首尾不得有多余空格。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">6</span><span class="hljs-attribute">F</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>:<span class="hljs-number">1</span><span class="hljs-attribute">F</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>:<span class="hljs-number">3</span> <span class="hljs-number">4</span>:<span class="hljs-number">10</span><span class="hljs-attribute">F</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span>:<span class="hljs-number">2</span> <span class="hljs-number">2</span>:<span class="hljs-number">2</span><span class="hljs-attribute">M</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span>:<span class="hljs-number">1</span> <span class="hljs-number">3</span>:<span class="hljs-number">2</span><span class="hljs-attribute">M</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>:<span class="hljs-number">2</span> <span class="hljs-number">6</span>:<span class="hljs-number">2</span><span class="hljs-attribute">M</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>:<span class="hljs-number">1</span> <span class="hljs-number">2</span>:<span class="hljs-number">5</span></code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><span class="hljs-number">4</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn =<span class="hljs-number">510</span>;<span class="hljs-keyword">int</span> e[maxn][maxn];<span class="hljs-keyword">int</span> mark[maxn];<span class="hljs-keyword">int</span> v[maxn];<span class="hljs-keyword">int</span> ma[<span class="hljs-number">2</span>][maxn],cnt[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(e,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(e));    <span class="hljs-keyword">int</span> n;    cin&gt;&gt;n;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        e[i][i]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> c;        cin&gt;&gt;c;        mark[i]=(c==<span class="hljs-string">&#x27;F&#x27;</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> m;        cin&gt;&gt;m;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-keyword">int</span> x,y;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d&quot;</span>,&amp;x,&amp;y);            e[i][x]=y;            <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&quot;-&gt;&quot;&lt;&lt;i&lt;&lt;endl;</span>        &#125;    &#125;    <span class="hljs-comment">// FOR(i,1,n)&#123;</span>    <span class="hljs-comment">//     FOR(j,1,n)&#123;</span>    <span class="hljs-comment">//         cout&lt;&lt;(e[i][j]==0x3f3f3f3f?9:e[i][j])&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     cout&lt;&lt;endl;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)            <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,n)&#123;                e[i][j]=<span class="hljs-built_in">min</span>(e[i][j],e[i][k]+e[k][j]);            &#125;    &#125;    <span class="hljs-comment">// cout&lt;&lt;endl;</span>    <span class="hljs-comment">// FOR(i,1,n)&#123;</span>    <span class="hljs-comment">//     FOR(j,1,n)&#123;</span>    <span class="hljs-comment">//         cout&lt;&lt;e[i][j]&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     cout&lt;&lt;endl;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,n)&#123;            <span class="hljs-keyword">if</span>(mark[i]^mark[j]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//ÒìÐÔ</span>                v[i]=<span class="hljs-built_in">max</span>(v[i],e[j][i]);                <span class="hljs-comment">//cout&lt;&lt;j&lt;&lt;&quot;-&quot;&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;e[j][i]&lt;&lt;endl;</span>            &#125;        &#125;        <span class="hljs-keyword">if</span>(v[i]&lt;v[ ma[mark[i]][<span class="hljs-number">1</span>] ]||cnt[mark[i]]==<span class="hljs-number">0</span>)&#123;            cnt[mark[i]]=<span class="hljs-number">0</span>;            ma[mark[i]][++cnt[mark[i]]]=i;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v[i]==v[ ma[mark[i]][<span class="hljs-number">1</span>] ])            ma[mark[i]][++cnt[mark[i]]]=i;    &#125;    <span class="hljs-comment">// cout&lt;&lt;endl;</span>    <span class="hljs-comment">// FOR(i,1,n)</span>    <span class="hljs-comment">//     cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;</span>    <span class="hljs-comment">// cout&lt;&lt;endl;</span>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt[<span class="hljs-number">0</span>])&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ma[<span class="hljs-number">0</span>][i]);        <span class="hljs-keyword">if</span>(i!=cnt[<span class="hljs-number">0</span>])            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);    &#125;    cout&lt;&lt;endl;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,cnt[<span class="hljs-number">1</span>])&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ma[<span class="hljs-number">1</span>][i]);        <span class="hljs-keyword">if</span>(i!=cnt[<span class="hljs-number">1</span>])            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;&#125;</code></pre></div><h2 id="l3-1-千手观音-30-分">L3-1 千手观音 (30 分)</h2><p>人类喜欢用 10 进制，大概是因为人类有一双手 10根手指用于计数。于是在千手观音的世界里，数字都是 10 000进制的，因为每位观音有 1 000 双手 ……</p><p>千手观音们的每一根手指都对应一个符号（但是观音世界里的符号太难画了，我们暂且用小写英文字母串来代表），就好像人类用自己的10 根手指对应 0 到 9 这 10 个数字。同样的，就像人类把这 10个数字排列起来表示更大的数字一样，ta们也把这些名字排列起来表示更大的数字，并且也遵循左边高位右边低位的规则，相邻名字间用一个点. 分隔，例如 pat.pta.cn 表示千手观音世界里的一个 3 位数。</p><p>人类不知道这些符号代表的数字的大小。不过幸运的是，人类发现了千手观音们留下的一串数字，并且有理由相信，这串数字是从小到大有序的！于是你的任务来了：请你根据这串有序的数字，推导出千手观音每只手代表的符号的相对顺序。</p><p>注意：有可能无法根据这串数字得到全部的顺序，你只要尽量推出能得到的结果就好了。当若干根手指之间的相对顺序无法确定时，就暂且按它们的英文字典序升序排列。例如给定下面几个数字：</p><div class="hljs code-wrapper"><pre><code class="hljs stylus">patcnlao<span class="hljs-selector-class">.cn</span>lao<span class="hljs-selector-class">.oms</span>pta<span class="hljs-selector-class">.lao</span>pta<span class="hljs-selector-class">.pat</span>cn.pat</code></pre></div><p>我们首先可以根据前两个数字推断 pat &lt;cn；根据左边高位的顺序可以推断 lao &lt; pta &lt;cn；再根据高位相等时低位的顺序，可以推断出 cn &lt; oms，lao &lt;pat。综上我们得到两种可能的顺序：lao &lt; pat &lt; pta &lt; cn &lt;oms；或者 lao &lt; pta &lt; pat &lt; cn &lt; oms，即 pat 和 pta之间的相对顺序无法确定，这时我们按字典序排列，得到 lao &lt; pat &lt; pta&lt; cn &lt; oms。</p><p>输入格式：</p><p>输入第一行给出一个正整数 N (≤105)，为千手观音留下的数字的个数。随后 N行，每行给出一个千手观音留下的数字，不超过 10 位数，每一位的符号用不超过3 个小写英文字母表示，相邻两符号之间用 . 分隔。</p><p>我们假设给出的数字顺序在千手观音的世界里是严格递增的。题目保证数字是104 进制的，即符号的种类肯定不超过 104 种。</p><p>输出格式：</p><p>在一行中按大小递增序输出符号。当若干根手指之间的相对顺序无法确定时，按它们的英文字典序升序排列。符号间仍然用. 分隔。</p><p>输入样例：</p><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">7</span>patcnlao<span class="hljs-selector-class">.cn</span>lao<span class="hljs-selector-class">.oms</span>pta<span class="hljs-selector-class">.lao</span>pta<span class="hljs-selector-class">.pat</span>cn.pat</code></pre></div><p>输出样例：</p><div class="hljs code-wrapper"><pre><code class="hljs stylus">lao<span class="hljs-selector-class">.pat</span><span class="hljs-selector-class">.pta</span><span class="hljs-selector-class">.cn</span>.oms</code></pre></div><h2id="l3-2-关于深度优先搜索和逆序对的题应该不会很难吧这件事-30-分">L3-2关于深度优先搜索和逆序对的题应该不会很难吧这件事 (30 分)</h2><p>背景知识</p><p>深度优先搜索与 DFS 序</p><p>深度优先搜索算法（DFS）是一种用于遍历或搜索树或图的算法。以下伪代码描述了在树T 上进行深度优先搜索的过程：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">procedure <span class="hljs-title">DFS</span><span class="hljs-params">(T, u, L)</span> <span class="hljs-comment">// T 是被深度优先搜索的树</span></span><span class="hljs-function"><span class="hljs-comment">// u 是当前搜索的节点</span></span><span class="hljs-function"><span class="hljs-comment">// L 是一个链表，保存了所有节点被第一次访问的顺序</span></span><span class="hljs-function">append u to L <span class="hljs-comment">// 将节点 u 添加到链表 L 的末尾</span></span><span class="hljs-function"><span class="hljs-keyword">for</span> v in u.children <span class="hljs-keyword">do</span> <span class="hljs-comment">// 枚举节点 u 的所有子节点 v</span></span><span class="hljs-function"><span class="hljs-title">DFS</span><span class="hljs-params">(T, v)</span> <span class="hljs-comment">// 递归搜索节点 v</span></span></code></pre></div><p>令 r 为树 T 的根，调用 DFS(T, r, L) 即可完成对 T的深度优先搜索，保存在链表 L 中的排列被称为 DFS序。相信聪明的你已经发现了，如果枚举子节点的顺序不同，最终得到的 DFS序也会不同。</p><p>逆序对</p><p>给定一个长度为 n 的整数序列a1​,a2​,⋯,an​，该序列的逆序对数量是同时满足以下条件的有序数对 (i,j)的数量：</p><ul><li>1≤i&lt;j≤n；</li><li>ai​&gt;aj​。</li></ul><p>问题求解</p><p>给定一棵 n 个节点的树，其中节点 r 为根。求该树所有可能的 DFS序中逆序对数量之和。</p><p>输入格式</p><p>第一行输入两个整数 n，r（2≤n≤3×105，1≤r≤n）表示树的大小与根节点。</p><p>对于接下来的 (n−1) 行，第 i 行输入两个整数 ui​ 与vi​（1≤ui​,vi​≤n），表示树上有一条边连接节点 ui​ 与 vi​。</p><p>输出格式</p><p>输出一行一个整数，表示该树所有可能的 DFS序中逆序对数量之和。由于答案可能很大，请对 109+7 取模后输出。</p><p>样例输入 1</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span></code></pre></div><p>样例输出 1</p><div class="hljs code-wrapper"><pre><code class="hljs">24</code></pre></div><p>样例输入 2</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">5</span><span class="hljs-symbol">10 </span><span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><span class="hljs-symbol">10 </span><span class="hljs-number">7</span><span class="hljs-symbol">7 </span><span class="hljs-number">1</span><span class="hljs-symbol">7 </span><span class="hljs-number">9</span><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><span class="hljs-symbol">10 </span><span class="hljs-number">8</span><span class="hljs-symbol">3 </span><span class="hljs-number">6</span></code></pre></div><p>样例输出 2</p><div class="hljs code-wrapper"><pre><code class="hljs">516</code></pre></div><p>样例解释</p><p>下图展示了样例 1 中的树。</p><p>该树共有 4 种可能的 DFS 序：</p><ul><li>{3,4,5,1,2}，有 6 个逆序对；</li><li>{3,4,5,2,1}，有 7 个逆序对；</li><li>{3,5,1,2,4}，有 5 个逆序对；</li><li>{3,5,2,1,4}，有 6 个逆序对。</li></ul><p>此答案为 6+7+5+6=24。</p><h2 id="l3-3-教科书般的亵渎-30-分">L3-3 教科书般的亵渎 (30 分)</h2><p>九条可怜最近在玩一款卡牌游戏。在每一局游戏中，可怜都要使用抽到的卡牌来消灭一些敌人。每一名敌人都有一个初始血量，而当血量降低到0 及以下的时候，这名敌人就会立即被消灭并从场上消失。</p><p>现在，可怜面前有 n 个敌人，其中第 i 名敌人的血量是ai​，而可怜手上只有如下两张手牌：</p><p>1.如果场上还有敌人，等概率随机选中一个敌人并对它造成一点伤害（即血量减1），重复 K 次。</p><p>2.对所有敌人造成一点伤害，重复该效果直到没有新的敌人被消灭。</p><p>下面是这两张手牌效果的一些示例：</p><p>1.假设存在两名敌人，他们的血量分别是 1,2 且K=2。那么在可怜打出第一张手牌后，可能会发生如下情况：</p><ul><li><p>第一轮中，两名敌人各有 0.5的概率被选中。假设第一名敌人被选中，那么它会被造成一点伤害。这时它的血量变成了0，因此它被消灭并消失了。</p></li><li><p>第二轮中，因为场上只剩下了第二名敌人，所以它一定会被选中并被造成一点伤害。这时它剩下的血量为1。</p></li></ul><p>2.同样假设存在两名敌人且血量分别为1,2。那么在可怜打出第二张手牌后，会发生如下情况：</p><ul><li>第一轮中，所有敌人被造成了一点伤害。这时第一名敌人被消灭了，因此卡牌效果会被重复一遍。</li><li>第二轮中，所有敌人（此时只剩下第二名敌人了）被造成了一点伤害。这时第二名敌人也被消灭了，因此卡牌效果会被再重复一遍。</li><li>第三轮中，所有敌人（此时没有敌人剩下了）被造成了一点伤害。因为没有新的敌人被消灭了，所以卡牌效果结束。</li></ul><p>3.如果面对的是四名血量分别为 1,2,2,4的敌人，那么在可怜打出第二张手牌后，只有第四名敌人还会存活，且它的剩余血量为1。</p><p>现在，可怜先打出了第一张手牌，再打出了第二张手牌。她发现，在第一张手牌效果结束后，没有任何一名敌人被消灭，但是在第二张手牌的效果结束后，所有敌人都被消灭了。</p><p>可怜想让你计算一下这种情况发生的概率是多少。</p><p>输入格式：</p><p>第一行输入两个整数n,K(1≤n,K≤50)，分别表示敌人的数量以及第一张卡牌效果的发动次数。</p><p>第二行输入 n 个由空格隔开的整数ai​(1≤ai​≤50)，表示每个敌人的初始血量。</p><p>输出格式：</p><p>在一行中输出一个整数，表示发生概率对 998244353 取模后的结果。</p><p>具体来说，如果概率的最简分数表示为a/b(a≥0,b≥1,gcd(a,b)=1)，那么你需要输出 a×b998244351mod998244353。</p><p>输入样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span></code></pre></div><p>输出样例 1：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">665496236</span></code></pre></div><p>样例解释 1：</p><p>在第一张手牌的效果结束后，三名敌人的剩余血量只可能在如下几种中：[1,3,2],[1,2,3], [2,1,3] 和 [2,3,1]。前两种发生的概率是 2/9，后两种发生的概率是1/9。因此答案为 2/3，输出 2×3998244351mod998244353=665496236。 输入样例2：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span></code></pre></div><p>输出样例 2：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">776412275</span></code></pre></div><p>样例解释 2:</p><p>在第一张手牌的效果结束后，三名敌人的剩余血量只可能在如下几种中：[1,2,2]、[2,1,2]和 [2,2,1]。第一种发生的概率是 2/9，后两种发生的概率是 1/9。因此答案为4/9，输出 4×9998244351mod998244353=776412275。</p><p>输入样例 3：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span></code></pre></div><p>输出样例 3：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">367353922</span></code></pre></div><p>输入样例 4：</p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">12</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span></code></pre></div><p>输出样例 4：</p><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-number">452061016</span></code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022—SWJTU寒假选拔赛第五场复盘</title>
    <link href="/2022/02/26/15/"/>
    <url>/2022/02/26/15/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>又是一篇迟到许久的复盘，终于在回到学校的第一天补上了。</p><h1 id="链接">链接</h1><div class="note note-info">            <p><ahref="https://vjudge.net/contest/480842"><b>2022—SWJTU寒假选拔赛第五场</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><figure><img src="https://pic.imgdb.cn/item/621a02102ab3f51d915a71aa.png"alt="RANK" /><figcaption aria-hidden="true">RANK</figcaption></figure><h2 id="a---codeforces-114e-很强的素数">A - CodeForces 114E 很强的素数×</h2><p><strong>题目大意：</strong></p><p>　　　　给定区间[L,R]，求区间内满足条件的数的个数：</p><p>　　　　条件1）z是素数</p><p>　　　　条件2）z=x<sup>2+y</sup>2 x和y为任意的正整数</p><p><strong>解题思路：</strong></p><p>　　　　其实就是求满足费马定理的数的个数。</p><p>　　　**费马定理：一个奇素数z可以表示成z=x<sup>2+y</sup>2的形式,当且仅当z可以表示成4*t+1的时候。（偶素数2=1<sup>2+1</sup>2）**</p><p>　　　　LR的范围是1到3*10^8用普通的筛选法求素数表，时间空间都会超。使用两次筛选来求素数。</p><p>　　　　3*10^8的平方根小于17500，用17500以内的素数可以筛出范围内的所有素数。在通过判断是否满足z=t%4+1来累加。</p><p>　　　　又由于z的范围过大，但对于唯一确定的z来说，t也唯一确定，故可以用t作为数组下标即(z-1)/4。数组大小就会小4倍左右。</p><p>　　　　具体细节看代码备注。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bitset&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 17500</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;bitset&lt;MAXN&gt;ISP; <span class="hljs-comment">//类似于bool型，可以存01</span>bitset&lt;300000000/4+10&gt;result;<span class="hljs-keyword">int</span> prime[MAXN];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_prime</span><span class="hljs-params">()</span><span class="hljs-comment">//先筛选1-17500的素数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>;    ISP[<span class="hljs-number">0</span>]=ISP[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=MAXN; i++)        <span class="hljs-keyword">if</span> (ISP[i]==<span class="hljs-number">0</span>)        &#123;            prime[p++]=i;<span class="hljs-comment">//用prime素组将素数存起来留到后面筛选用。。</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=i+i; j&lt;=MAXN; j+=i)                ISP[j]=<span class="hljs-number">1</span>;        &#125;    <span class="hljs-keyword">return</span> p<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> p=<span class="hljs-built_in">is_prime</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;=p; j++)    &#123;        <span class="hljs-keyword">int</span> x=L/prime[j];        <span class="hljs-keyword">if</span> (x*prime[j]&lt;L) x++;        <span class="hljs-keyword">if</span> (x==<span class="hljs-number">1</span>) x++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=x*prime[j]; k&lt;=R; k+=prime[j]) <span class="hljs-comment">//通过素数表再来筛选[L,R]中的素数</span>               <span class="hljs-keyword">if</span> (k%<span class="hljs-number">4</span>==<span class="hljs-number">1</span>) <span class="hljs-comment">//标记符合条件2且不符合条件1的数</span>                result[(k<span class="hljs-number">-1</span>)/<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=L;i&lt;=R;i+=<span class="hljs-number">4</span>)        <span class="hljs-keyword">if</span> (!result[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">4</span>]) cnt++;    <span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">is_prime</span>();    <span class="hljs-keyword">int</span> L,R;    <span class="hljs-keyword">int</span> ok=<span class="hljs-number">0</span>;    cin&gt;&gt;L&gt;&gt;R;    <span class="hljs-keyword">if</span> (L&lt;=<span class="hljs-number">2</span>&amp;&amp;R&gt;=<span class="hljs-number">2</span>) ok=<span class="hljs-number">1</span>; <span class="hljs-comment">//2作为偶素数且符合条件 单独判断</span>    <span class="hljs-keyword">while</span> (L%<span class="hljs-number">4</span>!=<span class="hljs-number">1</span>||L==<span class="hljs-number">1</span>) <span class="hljs-comment">//将区间边界缩小到符合 %4==1</span>        L++;    <span class="hljs-keyword">while</span> (R%<span class="hljs-number">4</span>!=<span class="hljs-number">1</span>)        R--;    cout&lt;&lt;<span class="hljs-built_in">cnt</span>(L,R)+ok;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="b---codeforces-514c-字符串">B - CodeForces 514C 字符串</h2><p><strong>思路一：哈希表</strong></p><p>字符串hash<br />因为只有3个字符<br />所以权值就为3^x;<br />找个大质数取模就好；<br />不够大就再大一点。。<br />然后对于每一位,尝试换成其他两个字母,看看存不存在</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson l,m,rt&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson m+1,r,rt&lt;&lt;1|1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep1(i,a,b) for (int i = a;i &lt;= b;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep2(i,a,b) for (int i = a;i &gt;= b;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ps push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rei(x) scanf(<span class="hljs-meta-string">&quot;%d&quot;</span>,&amp;x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rel(x) scanf(<span class="hljs-meta-string">&quot;%lld&quot;</span>,&amp;x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ref(x) scanf(<span class="hljs-meta-string">&quot;%lf&quot;</span>,&amp;x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ms(x,y) memset(x,y,sizeof x)</span><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<span class="hljs-keyword">typedef</span> pair&lt;LL,LL&gt; pll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dy[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">6e5</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> LL MOD = <span class="hljs-number">1e12</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n,m;LL p[N];string s;set&lt;LL&gt; myset;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen(&quot;F:\\rush.txt&quot;,&quot;r&quot;,stdin);</span>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep1</span>(i,<span class="hljs-number">1</span>,N<span class="hljs-number">-2</span>)        p[i] = (p[i<span class="hljs-number">-1</span>]*<span class="hljs-number">3</span>)%MOD;    <span class="hljs-built_in">rei</span>(n),<span class="hljs-built_in">rei</span>(m);    <span class="hljs-built_in">rep1</span>(i,<span class="hljs-number">1</span>,n)    &#123;        cin &gt;&gt; s;        LL temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">rep1</span>(j,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>)            temp = (temp*<span class="hljs-number">3</span>+s[j]-<span class="hljs-string">&#x27;0&#x27;</span>)%MOD;        myset.<span class="hljs-built_in">insert</span>(temp);    &#125;    <span class="hljs-built_in">rep1</span>(i,<span class="hljs-number">1</span>,m)    &#123;        cin &gt;&gt; s;        <span class="hljs-keyword">bool</span> ok = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();        LL temp = <span class="hljs-number">0</span>,ttemp;        <span class="hljs-built_in">rep1</span>(j,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>)            temp = (temp*<span class="hljs-number">3</span>+s[j]-<span class="hljs-string">&#x27;0&#x27;</span>)%MOD;        <span class="hljs-built_in">rep1</span>(j,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>)        &#123;            <span class="hljs-keyword">char</span> t = s[j];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> d=<span class="hljs-string">&#x27;a&#x27;</span>;d&lt;=<span class="hljs-string">&#x27;c&#x27;</span>;d++)            <span class="hljs-keyword">if</span> (t!=d)            &#123;                ttemp = (temp-(t-<span class="hljs-string">&#x27;0&#x27;</span>)*p[len-j<span class="hljs-number">-1</span>])%MOD;                <span class="hljs-keyword">if</span> (ttemp&lt;<span class="hljs-number">0</span>) ttemp=(ttemp+MOD)%MOD;                ttemp=(ttemp+(d-<span class="hljs-string">&#x27;0&#x27;</span>)*p[len-j<span class="hljs-number">-1</span>])%MOD;                <span class="hljs-keyword">if</span> (myset.<span class="hljs-built_in">count</span>(ttemp))                &#123;                    ok = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (ok) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span> (ok)            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);    &#125;    <span class="hljs-comment">//printf(&quot;\n%.2lf sec \n&quot;, (double)clock() / CLOCKS_PER_SEC);</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>思路二：字典树</strong></p><p>考虑字典树。</p><p>首先把n个单词插入字典树中。</p><p>询问的时候用dfs，flag表示搜索到当前是否已经改变过一个字符。</p><p>如果已经改变过那只能按照当前剩下的字符串一条路查询下去。</p><p>否则可以按老字符或新字符进行查询。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b)    for (int i(a); i &lt;= (b); ++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i, a, b)    for (int i(a); i &gt;= (b); --i)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e7</span> + <span class="hljs-number">3</span>; <span class="hljs-keyword">char</span> s[<span class="hljs-number">600010</span>];<span class="hljs-keyword">int</span> n, q, ans, len, tot = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> ch[N][<span class="hljs-number">3</span>];bitset &lt;N&gt; cnt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span></span>&#123;    ++tot;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) ch[tot][i] = <span class="hljs-number">0</span>;    cnt[tot] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> tot;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span></span>&#123;    <span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i]; ++i)&#123;        <span class="hljs-keyword">int</span> w = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">if</span> (!ch[now][w]) ch[now][w] = <span class="hljs-built_in">newnode</span>();        now = ch[now][w];    &#125;    cnt[now] = <span class="hljs-number">1</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> now)</span></span>&#123;    <span class="hljs-keyword">if</span> (ans) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (x == len &amp;&amp; flag &amp;&amp; cnt[now])&#123; ans = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span>;&#125;    <span class="hljs-keyword">if</span> (x &gt;= len) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (flag)&#123;        <span class="hljs-keyword">int</span> w = s[x] - <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">if</span> (ch[now][w]) <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, flag, ch[now][w]);    &#125;     <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> (i != s[x] - <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; x + <span class="hljs-number">1</span> == len &amp;&amp; ch[now][i] &amp;&amp; cnt[ch[now][i]]) ans = <span class="hljs-number">1</span>;         <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> (i != s[x] - <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch[now][i])&#123;            <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ch[now][i]);        &#125;         <span class="hljs-keyword">int</span> w = s[x] - <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">if</span> (ch[now][w])&#123;            <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, flag, ch[now][w]);        &#125;             &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);        <span class="hljs-built_in">insert</span>(s);    &#125;     <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, q)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);        len = <span class="hljs-built_in">strlen</span>(s);        ans = <span class="hljs-number">0</span>;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-built_in">puts</span>(ans ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>);    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="c---codeforces-243a-或">C - CodeForces 243A 或 ×</h2><p>我着实没想到真的用枚举</p><p><strong>思路一: 枚举+剪枝</strong></p><p>枚举左端点,在枚举 <code>&gt;i</code> 的每一个 <code>j</code>。求两个值，以i为起点的和，与以 <code>i+1</code>为起点的或和。如果两个值是一样的说明没必要 <code>a[i]</code>没必要在此区间存在</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> a[<span class="hljs-number">200005</span>];set&lt;<span class="hljs-keyword">int</span>&gt;s;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> n; cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cin &gt;&gt; a[i];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">int</span> x = a[i], y = <span class="hljs-number">0</span>;        s.<span class="hljs-built_in">insert</span>(x);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;        x |= a[j], y |= a[j];        s.<span class="hljs-built_in">insert</span>(x);        <span class="hljs-keyword">if</span> (x == y) <span class="hljs-comment">//离谱的剪枝</span>        &#123; <span class="hljs-keyword">break</span>; &#125;        &#125;    &#125;    cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>思路二:st表+贪心.</strong></p><p>st表可以求出每个区间的或和.我们枚举点,再枚举每一位 <code>j</code>,对于点的第 <code>j</code> 位为 <code>i</code>的点,我们直接记录当前最右的第 <code>j</code> 位为 1 的位置是<code>i</code> , <code>last[j]=i</code>.如果 <code>i</code> 的第<code>j</code> 位不为 1 ,那么求 <code>(last[j],i)</code> 之间的或和,用<code>set</code> 记录.这样是不会漏解的.</p><p>相当于把每个点作为右端点 <code>r</code>，找到能使得<code>(l,r)</code> 间的亦或与 <code>r</code> 的第 <code>j</code>位相异的最靠右的左端点，即 <code>last[j]</code>。本质是每次的记录<code>ask(last[j],i)</code> 都是能改变(相异于) <code>a[i]</code>的。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>,M = <span class="hljs-number">21</span>;<span class="hljs-keyword">int</span> a[N],n,last[M],f[N][M];set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//st表预处理与的区间和. </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;M;j++)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++)    <span class="hljs-keyword">if</span>(!j) f[i][j] = a[i];    <span class="hljs-keyword">else</span> f[i][j] = f[i][j<span class="hljs-number">-1</span>]|f[i+(<span class="hljs-number">1</span>&lt;&lt;j<span class="hljs-number">-1</span>)][j<span class="hljs-number">-1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(!l) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> len = r-l+<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> k = <span class="hljs-built_in">log</span>(len)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> f[l][k]|f[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;s.<span class="hljs-built_in">insert</span>(a[i]);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;M;j++)&#123;<span class="hljs-keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="hljs-number">1</span>) last[j] = i;<span class="hljs-keyword">else</span> s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">ask</span>(last[j],i));&#125;&#125;s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">-1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s.<span class="hljs-built_in">size</span>());<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="d---codeforces-864c-校车">D - CodeForces 864C 校车 √</h2><p>其实是用省略重复情况的模拟，经常遇到，但是我经常被卡很久，因为各种细节考虑情况。</p><p><strong>题面：</strong> 一辆校车的路线是在坐标轴上的 0 点到 a点之间往返，每消耗一升汽油能行驶一个单位长度。油箱容量为 b ，在 0 点和 a点之间有一个加油站，位置是 f 点，在加油站，校车能把油加满。校车从 0点出发，出发时油是满的。我们称校车从 0 点到 a 点或者从 a 点到 0点为一趟，请问要进行 k 趟，校车最少要加几次油。</p><p>将 0 - a 的 k 次往返的路径展开为一条轴，则题目变成小车从 0 驶向 k·a的单项行驶，再考虑加油站与油箱最大容积的问题。每次 while循环为当前点加满油驶向下一个最远的加油站的计算，若移动后位置不变，则为无法驶向下一个加油站，若情况满足直接输出“无解”；还要考虑是否为起步，是否已经为第k 趟，能否直接到达终点。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a,b,f,k;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;k;    <span class="hljs-keyword">int</span> x=f,y=a-f;    <span class="hljs-keyword">if</span>(b&lt;x)&#123;        cout&lt;&lt;<span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> l,r,o,m;    r=k;l=<span class="hljs-number">1</span>;    o=b-x;    m=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> xy=<span class="hljs-number">2</span>*x+<span class="hljs-number">2</span>*y;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> mm=<span class="hljs-number">1</span>;    <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span>    <span class="hljs-keyword">while</span>(l&lt;=r)&#123;        <span class="hljs-keyword">if</span>(l==r)&#123;            <span class="hljs-keyword">if</span>(o&gt;=(m==<span class="hljs-number">0</span>?y:x))                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">int</span> l1=l;        l+=(o/xy)*<span class="hljs-number">2</span>;        o=o%xy;        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(o&gt;=<span class="hljs-number">2</span>*y)&#123;                l++;                m=<span class="hljs-number">1</span>;                o-=<span class="hljs-number">2</span>*y;            &#125;                        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(o&gt;=<span class="hljs-number">2</span>*x)&#123;                l++;                m=<span class="hljs-number">0</span>;                o-=<span class="hljs-number">2</span>*x;            &#125;        &#125;        <span class="hljs-comment">//cout&lt;&lt;o&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(l==r)&#123;            <span class="hljs-keyword">if</span>(o&gt;=(m==<span class="hljs-number">0</span>?y:x))                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">break</span>;        o=b;        ans++;        <span class="hljs-keyword">if</span>(l==l1&amp;&amp;mm!=<span class="hljs-number">1</span>)&#123;            ans=<span class="hljs-number">-1</span>;            <span class="hljs-keyword">break</span>;        &#125;        mm=<span class="hljs-number">0</span>;        <span class="hljs-comment">//cout&lt;&lt;l&lt;&lt;&quot;:&quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl;</span>    &#125;    cout&lt;&lt;ans;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre></div><h2 id="e---codeforces-753a-送给你的新年礼物">E - CodeForces 753A送给你的新年礼物 √</h2><p>签到题，构造红包数最多的情况</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;n-k&gt;=<span class="hljs-number">0</span>;k++)&#123;        n-=k;    &#125;    k--;    cout&lt;&lt;k&lt;&lt;endl;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,k<span class="hljs-number">-1</span>)        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    cout&lt;&lt;k+n;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre></div><h2 id="f---codeforces-923a-升级">F - CodeForces 923A 升级 ×</h2><p>一个数论</p><p>【题解】</p><blockquote><p>考虑怎么得到数字x2=N,假设是质数p的倍数那么x1肯定在x2-p+1~x2这个范围内才行 因为p的倍数要刚好大于等于x1,所以x1肯定是在这两个倍数之间才行 结果已经很显然了 肯定让p的值越大越好。这样得到的x1才可能越小。 枚举x1在x2-p+1~x2之间。用同样的方式得到x0就好。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> x0,x1,x2;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxfac</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> j = x;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i*i&lt;=x;i++)&#123;        <span class="hljs-keyword">if</span> (x%i==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">while</span> (x%i==<span class="hljs-number">0</span>)&#123;                x/=i;            &#125;            j = i;        &#125;    &#125;    <span class="hljs-keyword">if</span> (x&gt;<span class="hljs-number">1</span>) j = x;    <span class="hljs-keyword">return</span> j;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>),cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; x2;    <span class="hljs-keyword">int</span> p = x2-<span class="hljs-built_in">maxfac</span>(x2)+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ans = x2;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x1 = p;x1 &lt;= x2;x1++)&#123;        <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">maxfac</span>(x1);        <span class="hljs-keyword">if</span> (temp!=x1)&#123;            x0 = x1-temp+<span class="hljs-number">1</span>;            ans = <span class="hljs-built_in">min</span>(ans,x0);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n,ans;<span class="hljs-keyword">int</span> f[maxn]; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x&lt;y?x:y; &#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    ans = n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++) &#123;        <span class="hljs-keyword">if</span> (!f[i]) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*i; j&lt;=n; j+=i) f[j] = i;        &#125;        f[i] = i-f[i]+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=f[n]; i&lt;=n; i++) ans = <span class="hljs-built_in">Min</span>(ans,f[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="g---codeforces-961d-贯穿">G - CodeForces 961D 贯穿 √</h2><p><strong>题目复述：</strong>对于二维坐标系上的给出的一系列点，是否能用两条直线涵盖所有点。（n&lt;100000）</p><p><strong>解题思路：</strong>我们假设题目成立，在条件成立的情况下，尝试找到这两条直线。对于这一系列点的任意三个点，三个点表示的三条直线中一定有一条为两条直线中的一条。即，对次三条线各做一次尝试，若被第一条线排除后的点能被另一条线贯穿则题目成立。三条线都不满足则题目不成立。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> ll maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<span class="hljs-keyword">const</span> ll inf = <span class="hljs-number">0x3f3f3f3f</span>; ll n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    ll x, y;&#125;pre[maxn];<span class="hljs-keyword">bool</span> vis[maxn]; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">kkk</span><span class="hljs-params">(node a, node b, node c)</span></span>&#123;<span class="hljs-comment">//注意不能用除法</span>    ll k1 = (b.y-a.y)*(c.x-a.x);    ll k2 = (c.y-a.y)*(b.x-a.x);    <span class="hljs-keyword">return</span> k1==k2?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll a, ll b)</span></span>&#123;         <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));    vis[a] = vis[b] = <span class="hljs-literal">true</span>;         <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        <span class="hljs-keyword">if</span> (i == a || i == b) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">kkk</span>(pre[a], pre[b], pre[i])) vis[i] = <span class="hljs-literal">true</span>;    &#125;    ll p1=<span class="hljs-number">-1</span>, p2=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        <span class="hljs-keyword">if</span> (!vis[i])&#123;            <span class="hljs-keyword">if</span>(p1 == <span class="hljs-number">-1</span>) &#123;p1=i;&#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2==<span class="hljs-number">-1</span>)&#123;p2=i;&#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (p1==<span class="hljs-number">-1</span>||p2==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        <span class="hljs-keyword">if</span> (i == p1 || i == p2) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; !<span class="hljs-built_in">kkk</span>(pre[p1], pre[p2], pre[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        cin&gt;&gt;pre[i].x&gt;&gt;pre[i].y;           &#125;    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span> || <span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) || <span class="hljs-built_in">check</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) || <span class="hljs-built_in">check</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="h---codeforces-733d-球球人">H - CodeForces 733D 球球人 √</h2><p><strong>题目复述：</strong> 对于 n个长方体，输出能使得单个或两个长方体拼合的新长方体的最短棱长最长的情况。（n&lt;100000）</p><p>我最开始以为可以无数个长方体拼在一起，就放了，后来才发现只能两个或一个。</p><p><strong>解题思路：</strong></p><p>考虑单个：直接一边读入，一边记录长方体的最短棱长的最长值和长方体对应编号</p><p>考虑两个：两个长方体能拼合当且仅当两个长方体各有两条棱长对应相等，而为了使得拼合后超越单个的情况，拼合的两个长方体一定是补短，即拼合的面是最长棱和第二长棱构成的面。考虑时间复杂度不能两两匹配尝试，考虑将最长棱和第二长棱相同的长方体聚集在一起，考虑以第二棱长、第一棱长、第三棱长的优先级排序O(nlogn)，再线性的扫描一遍，因为能拼合的一定相邻，最大的情况只可能为第二棱长、第一棱长相同的，且第三棱长在此基础上最长的两个，一定相邻。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100000</span>+<span class="hljs-number">100</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> a,b,c;<span class="hljs-keyword">int</span> k;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sor</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b);        <span class="hljs-keyword">if</span>(b&gt;c) <span class="hljs-built_in">swap</span>(b,c);        <span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b);    &#125;&#125;x[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node e1,node e2)</span></span>&#123;    <span class="hljs-keyword">if</span>(e1.b!=e2.b) <span class="hljs-keyword">return</span> e1.b&gt;e2.b;    <span class="hljs-keyword">if</span>(e1.c!=e2.c) <span class="hljs-keyword">return</span> e1.c&gt;e2.c;    <span class="hljs-keyword">return</span> e1.a&gt;e2.a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> ma=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>,q=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        cin&gt;&gt;x[i].a&gt;&gt;x[i].b&gt;&gt;x[i].c;        x[i].k=i;        x[i].<span class="hljs-built_in">sor</span>();        <span class="hljs-keyword">if</span>(x[i].a&gt;ma)&#123;            ma=x[i].a;            p=i;        &#125;    &#125;    <span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+n,cmp);    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;        <span class="hljs-keyword">if</span>(x[i].b&lt;=ma) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(x[i].b==x[i+<span class="hljs-number">1</span>].b&amp;&amp;x[i].c==x[i+<span class="hljs-number">1</span>].c)&#123;            <span class="hljs-keyword">if</span>(x[i].a+x[i+<span class="hljs-number">1</span>].a&gt;ma)&#123;                ma=x[i].a+x[i+<span class="hljs-number">1</span>].a;                p=x[i].k;                q=x[i+<span class="hljs-number">1</span>].k;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(q)&#123;        cout&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;endl;        cout&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;q;    &#125;<span class="hljs-keyword">else</span>&#123;        cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;        cout&lt;&lt;p;    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre></div><h2 id="i---codeforces-687c-经验书">I - CodeForces 687C 经验书</h2><p>题意：给你n个数，然后让这些数相加组合，然后在这些组合的数里可以再相加组合搞出给定k，输出这些组合的数。</p><p>思路： DP。 <code>dp[i][j]</code>代表数值为i时值为j能否被构成那么如果<code>dp[i][j]</code>能被构成那么<code>dp[i+x][j]</code> <code>dp[i+x][j+x]</code>都能被构成，这样状态转移方程就出来了</p><p>在枚举到第i个coin的时，<code>dp[i][j]</code>,i肯定能被<code>a[i]</code>组合，<br />然后再枚举<code>&lt;=a[i]</code>的部分，<code>dp[i][j]</code>的具体意义就是在coin值是i的时候，能用j去组合。<br />为了防止重复利用coin，从j枚举到<code>a[i]</code>;<br />最后<code>dp[k][h]==1</code>的把h塞到容器里去，最后输出。</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> qq = <span class="hljs-number">505</span>;<span class="hljs-keyword">int</span> dp[qq][qq];<span class="hljs-comment">//代表当数值为i的时候，j数字能否被构成 </span><span class="hljs-keyword">int</span> num[qq]; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n,k;cin &gt;&gt; n &gt;&gt; k;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>; l&lt;n; ++l)&#123;<span class="hljs-keyword">int</span> x; cin &gt;&gt; x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k; i&gt;=x; --i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;=k-x; ++j)<span class="hljs-keyword">if</span>(dp[i-x][j])dp[i][j] = dp[i][j+x] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=k; ++i)<span class="hljs-keyword">if</span>(dp[k][i])num[tot++] = i;cout &lt;&lt; tot &lt;&lt; endl;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tot; ++i)cout &lt;&lt; num[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;cout &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>典型相关分析</title>
    <link href="/2022/02/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>典型相关分析 （Canonical Correlation Analysis ，CCA）<br />是为了研究两组变量（向量）之间的关联关系，其目的是找出两组变量的各自的<span class="math inline">\(r\)</span>组线性组合，线性组合的相关性从大到小排列，以主成分思想衡量两组变量之间的线性关系。</p><p><spanclass="math display">\[[\boldsymbol{x}_1,\boldsymbol{x}_2,\dotsb,\boldsymbol{x}_p],[\boldsymbol{y}_1,\boldsymbol{y}_2,\dotsb,\boldsymbol{y}_q]\]</span></p><p>首先分别在每组变量中找出第 <span class="math inline">\(k\)</span>对线性组合，使其具有第 <span class="math inline">\(k\)</span>大最大相关性，即</p><p><span class="math display">\[\left\{\begin{matrix}  \boldsymbol{u}_k=\alpha_{k1}\boldsymbol{x}_1+\alpha_{k2}\boldsymbol{x}_2+\dotsb+\alpha_{kp}\boldsymbol{x}_p\\\boldsymbol{v}_k=\alpha_{k1}\boldsymbol{y}_1+\alpha_{k2}\boldsymbol{y}_2+\dotsb+\alpha_{kq}\boldsymbol{y}_q\end{matrix}\right. \]</span> <spanclass="math display">\[\left(k=1,2,\dotsb,r \small \leqslant\min(p,q)\right)\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{u}_k\)</span> 与 <spanclass="math inline">\(\boldsymbol{u}_1,\boldsymbol{u}_2,\dots,\boldsymbol{u}_{k-1}\)</span>线性无关， <span class="math inline">\(\boldsymbol{v}_k\)</span> 与<spanclass="math inline">\(\boldsymbol{v}_1,\boldsymbol{v}_2,\dots,\boldsymbol{v}_{k-1}\)</span>线性无关，且相关性从小到大依次排列。</p><h1 id="典型相关分析数学模型">典型相关分析数学模型</h1><h2 id="典型相关和典型相关变量定义">典型相关和典型相关变量定义</h2><p>设两组随机变量为 <span class="math inline">\(\small\boldsymbol{X}=[\boldsymbol{x}_1,\boldsymbol{x}_2,\dotsb,\boldsymbol{x}_p]^T,\boldsymbol{Y}=[\boldsymbol{y}_1,\boldsymbol{y}_2,\dotsb,\boldsymbol{y}_q]^T\)</span>。我们希望找到 <span class="math inline">\(\small\boldsymbol{\alpha}=[\alpha_1,\dotsb,\alpha_p],\boldsymbol{\beta}=[\beta_1,\dotsb,\beta_p]\)</span> 使得 <spanclass="math inline">\(\small\rho(\boldsymbol{\alpha}\boldsymbol{X},\boldsymbol{\beta}\boldsymbol{Y})\)</span>最大。由相关系数定义：</p><p><span class="math display">\[\rho\left(\boldsymbol{\alpha X},\boldsymbol{\betaY}\right)=\frac{\operatorname{Cov}\left(\boldsymbol{\alphaX},\boldsymbol{ \betaY}\right)}{\sqrt{\operatorname{Var}\left(\boldsymbol{\alpha X}\right)}\sqrt{\operatorname{Var}\left(\boldsymbol{\beta Y}\right)}}\]</span></p><p>对于任意常数 <span class="math inline">\(k_1,k_2,c_1,c_2\)</span> 有<span class="math display">\[\rho(k_1\boldsymbol{\alphaX}+c_1,k_2\boldsymbol{\beta Y}+c_2)=\rho(\boldsymbol{\alphaX},\boldsymbol{\beta Y})\]</span></p><p>说明 <span class="math inline">\(\boldsymbol{\alphaX},\boldsymbol{\beta Y}\)</span> 不唯一，故限定 <spanclass="math inline">\(\small{Var}(\boldsymbol{\alphaX})=1,Var(\boldsymbol{\beta Y})=1\)</span> 即满足与协方差矩阵的关系<span class="math inline">\(\small\boldsymbol{\alpha}\boldsymbol{\Sigma}_{\tiny\boldsymbol{XX}}\boldsymbol{\alpha}^T=1,\boldsymbol{\beta}\boldsymbol{\Sigma}_{\tiny\boldsymbol{YY}}\boldsymbol{\beta}^T=1\)</span> 。</p><p>如果存在 <spanclass="math inline">\(\boldsymbol{\alpha}_k=[\alpha_{k1},\alpha_{k2},\dotsb,\alpha_{kp}],\boldsymbol{\beta}_k=[\beta_{k1},\beta_{k2},\dotsb,\beta_{kq}]\)</span>使得</p>$$ {<span class="math display">\[\begin{array}{l}\rho(\boldsymbol{\alpha}_k\boldsymbol{X},\boldsymbol{\alpha}_j\boldsymbol{X})=0,\rho(\boldsymbol{\beta}_k\boldsymbol{Y},\boldsymbol{\beta}_j\boldsymbol{Y})=0,\smallj=1,2,\dots,k-1&amp;\\\rho(\boldsymbol{\alpha}_k\boldsymbol{X},\boldsymbol{\beta}_k\boldsymbol{Y})=\max_{}\rho(\boldsymbol{\alpha}\boldsymbol{X},\boldsymbol{\beta}\boldsymbol{Y})&lt;\rho(\boldsymbol{\alpha}_{k-1}\boldsymbol{X},\boldsymbol{\beta}_{k-1}\boldsymbol{Y})\\\boldsymbol{\alpha}_k\boldsymbol{\Sigma}_{\tiny\boldsymbol{XX}}\boldsymbol{\alpha}_k^T=1,\boldsymbol{\beta}_k\boldsymbol{\Sigma}_{\tiny\boldsymbol{YY}}\boldsymbol{\beta}_k^T=1\\\end{array}\]</span><p>. $$</p><p>则称 <spanclass="math inline">\(\boldsymbol{\alpha}_k\boldsymbol{X},\boldsymbol{\beta}_k\boldsymbol{Y}\)</span>是 <span class="math inline">\(\boldsymbol{X},\boldsymbol{Y}\)</span>的<strong>第 <span class="math inline">\(k\)</span>对（组）典型相关变量</strong>，他们之间的相关系数称之为<strong>第 <spanclass="math inline">\(k\)</span> 个典型相关系数</strong> <spanclass="math inline">\(\small\left(k=1,2,\dots,min(p,q)\right)\)</span>。</p><h2 id="典型相关变量的解法">典型相关变量的解法</h2><p>将两组变量的协方差矩阵分块得</p><p><span class="math display">\[Cov\begin{bmatrix}\boldsymbol{X} \\\boldsymbol{Y} \\\end{bmatrix}     =\begin{bmatrix}  Var(\boldsymbol{X})&amp; Cov(\boldsymbol{X},\boldsymbol{Y})   \\Cov(\boldsymbol{Y},\boldsymbol{X}) &amp;Var(\boldsymbol{Y})  \\     \end{bmatrix}=\begin{bmatrix}  \boldsymbol{\Sigma_{XX}} &amp;\boldsymbol{\Sigma_{XY}}   \\ \boldsymbol{\Sigma_{YX}}&amp;  \boldsymbol{\Sigma_{YY}} \\     \end{bmatrix}\]</span></p><p>此时</p><p><spanclass="math display">\[\rho(\boldsymbol{u},\boldsymbol{v})=\frac{Cov(\boldsymbol{\alphaX},\boldsymbol{\beta Y})}{\sqrt{D(\boldsymbol{\alphaX})}\sqrt{D(\boldsymbol{\beta Y})}}=\boldsymbol{\alpha\Sigma_{\tinyXY}\beta^T}\]</span></p><p>此问题转换为在 <span class="math inline">\(\small\boldsymbol{\alpha}\boldsymbol{\Sigma}_{\tiny\boldsymbol{XX}}\boldsymbol{\alpha}^T=1,\boldsymbol{\beta}\boldsymbol{\Sigma}_{\tiny\boldsymbol{YY}}\boldsymbol{\beta}^T=1\)</span> 条件下求 <spanclass="math inline">\(\small \boldsymbol{\alpha\Sigma_{\tiny XY}\beta^T}\)</span> 的极大值。</p><p>引入拉格朗日乘数 <span class="math inline">\(\lambda,\omega\)</span>即问题为求下式的最大值。</p><p><spanclass="math display">\[S(\boldsymbol{\alpha},\boldsymbol{\beta})=\boldsymbol{\alpha\Sigma_{\tinyXY}\beta^T}-\frac{\lambda}{2}(\boldsymbol{\alpha}\boldsymbol{\Sigma}_{\tiny\boldsymbol{XX}}\boldsymbol{\alpha}^T-1)-\frac{\omega}{2}(\boldsymbol{\beta}\boldsymbol{\Sigma}_{\tiny\boldsymbol{YY}}\boldsymbol{\beta}^T-1)\]</span></p><p>由极值的必要条件得到偏导方程组</p><p><span class="math display">\[\left\{\begin{matrix}  \frac{\partial S}{\partial \boldsymbol{\alpha}}=\boldsymbol{\Sigma_{\tiny XY}\beta }-\lambda\boldsymbol{\Sigma_{\tiny XX}\alpha }=0\\  \frac{\partial S}{\partial \boldsymbol{\beta}}=\boldsymbol{\Sigma_{\tiny YX}\alpha }-\omega\boldsymbol{\Sigma_{\tiny YY}\beta }=0\\\end{matrix}\right.\]</span></p><p>中间过程略，详见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第268页.">[1]</span></a></sup>或<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="高惠璇. 应用多元统计分析[M]. 第2版. 第354页.">[3]</span></a></sup>。得</p><p><span class="math display">\[\left\{\begin{matrix}  \left(\boldsymbol{\Sigma_{XY}}\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}}-\lambda^2\boldsymbol{\Sigma_{XX}}\right)\boldsymbol{\alpha}=0\\  \left(\boldsymbol{\Sigma_{YX}}\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}-\lambda^2\boldsymbol{\Sigma_{YY}}\right)\boldsymbol{\beta}=0\\\end{matrix}\right.\]</span></p><p>记</p><p><spanclass="math display">\[M_1=\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}},M_{2}=\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}}\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}\]</span></p><p>得</p><p><spanclass="math display">\[M_1\boldsymbol{\alpha}=\lambda^2\boldsymbol{\alpha},M_2\boldsymbol{\beta}=\lambda^2\boldsymbol{\beta}\]</span></p><p>记 <span class="math inline">\(\smallT=\boldsymbol{\Sigma_{XX}^{-1/2}\Sigma_{XY}\Sigma_{YY}^{-1/2}}\)</span>有 <span class="math inline">\(\smallM_1=TT^{\prime},M_2=T^{\prime}T\)</span> 故 <spanclass="math inline">\(M_1,M_2\)</span> 有相同的非零特征值</p><p>说明 <span class="math inline">\(\lambda^2\)</span> 既是 <spanclass="math inline">\(M_1\)</span> 又是 <spanclass="math inline">\(M_2\)</span> 的特征根， <spanclass="math inline">\(\boldsymbol{\alpha},\boldsymbol{\beta}\)</span>是对应的特征向量， <span class="math inline">\(M_1,M_2\)</span>的特征根非负数且在区间 <span class="math inline">\([0,1]\)</span>上，非零特征根的数量不妨设为 <span class="math inline">\(\smallr=\min(p,q)\)</span>。</p><p>设特征根排列为 <span class="math inline">\(\small \lambda_1^2 \ge\lambda_2^2 \ge \dotsb \ge \lambda_r^2\)</span> 其余特征根为 <spanclass="math inline">\(0\)</span> ,称 <spanclass="math inline">\(\lambda_1,\lambda_2,\dotsb,\lambda_r\)</span>为典型相关系数。对应从 <span class="math inline">\(\smallM_1\boldsymbol{\alpha}=\lambda^2\boldsymbol{\alpha}\)</span>解出的特征向量为 <span class="math inline">\(\small\boldsymbol{\alpha}_1,\dotsb,\boldsymbol{\alpha}_r\)</span> ；从 <spanclass="math inline">\(\smallM_2\boldsymbol{\beta}=\lambda^2\boldsymbol{\beta}\)</span>解出的特征向量为 <span class="math inline">\(\small\boldsymbol{\beta}_1,\dotsb,\boldsymbol{\beta}_r\)</span> 。可得到 <spanclass="math inline">\(\boldsymbol{u_k}\)</span> <spanclass="math inline">\(\boldsymbol{v_k}\)</span> 的线性组合： <spanclass="math display">\[\boldsymbol{u}_k=\boldsymbol{\alpha}_k\boldsymbol{X},\boldsymbol{v}_k=\boldsymbol{\beta}_k\boldsymbol{X},k=1,2,\dotsb,r,\]</span></p><p>满足：</p><p><spanclass="math display">\[Cov(\boldsymbol{u}_i,\boldsymbol{u}_j)=0,Cov(\boldsymbol{v}_i,\boldsymbol{v}_j)=0,{\smalli \ne j}\\Cov(\boldsymbol{u}_i,\boldsymbol{v}_i)=\lambda_i,Cov(\boldsymbol{u}_i,\boldsymbol{v}_j)=0,\smalli \ne j\]</span></p><h1 id="样本典型相关分析步骤">样本典型相关分析步骤</h1><p>设样本总体 <span class="math inline">\(\small\boldsymbol{Z}=[\boldsymbol{x}_1,\dotsb,\boldsymbol{x}_p,\boldsymbol{y}_1,\dotsb,\boldsymbol{y}_q]^T\)</span></p><p>对于每次观测</p><p><span class="math display">\[Z_{(t)}=\left[\begin{array}{l}\boldsymbol{X}_{(t)} \\\boldsymbol{Y}_{(t)}\end{array}\right]_{(p+q) \times 1} \quad(t=1,2, \cdots, n)\]</span></p><p>于是样本数据矩阵为</p><p><span class="math display">\[\left(\left[\begin{array}{cccc:cccc}x_{11} &amp; x_{21} &amp; \cdots &amp; x_{p1} &amp; y_{11} &amp; y_{21}&amp; \cdots &amp; y_{q1} \\x_{12} &amp; x_{22} &amp; \cdots &amp; x_{p2} &amp; y_{12} &amp; y_{22}&amp; \cdots &amp; y_{q2} \\\vdots &amp; \vdots &amp; &amp; \vdots &amp; \vdots &amp; \vdots &amp;&amp; \vdots \\x_{1n} &amp; x_{2n} &amp; \cdots &amp; x_{pn} &amp; y_{1n} &amp; y_{2n}&amp; \cdots &amp; y_{qn}\end{array}\right]^T\right)_{(p+q)\times n}\]</span></p><p>协方差矩阵的无偏估计为</p><p><span class="math display">\[\boldsymbol{\hat{\Sigma}}=\frac{1}{n-1}\sum_{t=1}^{n}\left(Z_{(t)}-\bar{Z}\right)\left(Z_{(t)}-\bar{Z}\right)^{\prime}\]</span></p><p>其中 <spanclass="math inline">\(\bar{Z}=\frac{1}{n}\sum\limits_{i=1}^nX_{(i)}\)</span></p><p>记样本矩阵 <span class="math inline">\(\boldsymbol{Z}_{\tiny(p+q)\times n}\)</span> 每个元素减去每一行的平均值得到矩阵 <spanclass="math inline">\(\boldsymbol{Z}^*_{\tiny (p+q)\timesn}\)</span></p><p><spanclass="math display">\[\boldsymbol{\hat{\Sigma}}=\frac{1}{n-1}\boldsymbol{Z}^*(\boldsymbol{Z}^*)^T=\left[\begin{array}{c:c}\boldsymbol{\hat{\Sigma}_{\tiny XX}} &amp;\boldsymbol{\hat{\Sigma}_{\tiny XY}} \\\hdashline \boldsymbol{\hat{\Sigma}_{\tiny Y X}} &amp;\boldsymbol{\hat{\Sigma}_{\tiny YY}}\end{array}\right]\begin{array}{c}\tiny p\\\tiny q\end{array}\]</span></p><h2 id="样本典型相关变量和系数">样本典型相关变量和系数</h2><p>以下用 <span class="math inline">\(\boldsymbol{\hat{\Sigma}}\)</span>替换 <span class="math inline">\(\boldsymbol{\Sigma}\)</span> 。</p><ul><li><strong>方法一</strong></li></ul><p>记</p><p><spanclass="math display">\[M_1=\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}}\\M_{2}=\boldsymbol{\Sigma_{YY}^{-1}}\boldsymbol{\Sigma_{YX}}\boldsymbol{\Sigma_{XX}^{-1}}\boldsymbol{\Sigma_{XY}}\]</span></p><p>分别求出 <span class="math inline">\(M_1,M_2\)</span>的特征值与特征向量，特征值从大到小排列为 <spanclass="math inline">\(\lambda_1^2,\lambda_2^2,\dots\)</span>，其对应的特征向量分别为 <spanclass="math inline">\((\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\dots)\)</span>和 <spanclass="math inline">\((\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\dots)\)</span></p><ul><li><strong>方法二</strong></li></ul><p>令 <spanclass="math inline">\(T=\boldsymbol{\Sigma_{XX}^{-1/2}\Sigma_{XY}\Sigma_{YY}^{-1/2}}\)</span>，计算 <span class="math inline">\(TT^{\prime}\)</span>的特征值从大到小排列为 <spanclass="math inline">\(\lambda_1^2,\lambda_2^2,\dots\)</span> ，记 <spanclass="math inline">\(\boldsymbol{l}_k\)</span> 为 <spanclass="math inline">\(TT^{\prime}\)</span> 的特征根 <spanclass="math inline">\(\lambda_k^2\)</span>对应的单位正交特征向量。令</p><p><span class="math display">\[\left\{\begin{array}{c}  \boldsymbol{\alpha}_k=\boldsymbol{\Sigma_{\tinyXX}^{-1/2}}\boldsymbol{l}_k,\\  \boldsymbol{\beta}_k=\lambda_k^{-1}\boldsymbol{\Sigma_{\tinyYY}^{-1}\Sigma_{YX}}\boldsymbol{\alpha}_k,\end{array}\right.\]</span></p><h2 id="原始变量与典型变量相关性">原始变量与典型变量相关性</h2><h3 id="原始变量与典型变量的相关系数">原始变量与典型变量的相关系数</h3><p><span class="math display">\[\begin{array}{l}\rho\left(\boldsymbol{x}_{i},\boldsymbol{u}_{j}\right)=\sum\limits_{k=1}^{p} \alpha_{k j}\operatorname{Cov}\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{k}\right) /\sqrt{D\left(\boldsymbol{x}_{i}\right)}, j=1, \cdots, s_{\circ} \\\rho\left(\boldsymbol{x}_{i},\boldsymbol{v}_{j}\right)=\sum\limits_{k=1}^{q} \beta_{k j}\operatorname{Cov}\left(\boldsymbol{x}_{i}, \boldsymbol{y}_{k}\right) /\sqrt{D\left(\boldsymbol{x}_{i}\right)}, j=1, \cdots, s, \\\rho\left(\boldsymbol{y}_{i},\boldsymbol{u}_{j}\right)=\sum\limits_{k=1}^{p} \alpha_{k j}\operatorname{Cov}\left(\boldsymbol{y}_{i}, \boldsymbol{x}_{k}\right) /\sqrt{D\left(\boldsymbol{y}_{i}\right)}, j=1, \cdots, s, \\\rho\left(\boldsymbol{y}_{i},\boldsymbol{v}_{j}\right)=\sum\limits_{k=1}^{q} \beta_{k j}\operatorname{Cov}\left(\boldsymbol{y}_{i}, \boldsymbol{y}_{k}\right) /\sqrt{D\left(\boldsymbol{y}_{i}\right)}, j=1, \cdots, s_{\circ}\end{array}\]</span></p><h3id="各组原始变量被典型变量所解释的方差比例">各组原始变量被典型变量所解释的方差比例</h3><p>原始变量 <span class="math inline">\(\boldsymbol{X}\)</span> 被 <spanclass="math inline">\(\boldsymbol{u}_i\)</span> 解释的方差比例 <spanclass="math display">\[m_{u_i}=\sum_{k=1}^p\rho^2(\boldsymbol{u}_i,\boldsymbol{x}_k)/p\]</span></p><p>原始变量 <span class="math inline">\(\boldsymbol{X}\)</span> 被 <spanclass="math inline">\(\boldsymbol{v}_i\)</span> 解释的方差比例 <spanclass="math display">\[m_{v_i}=\sum_{k=1}^p\rho^2(\boldsymbol{v}_i,\boldsymbol{x}_k)/p\]</span></p><p>原始变量 <span class="math inline">\(\boldsymbol{Y}\)</span> 被 <spanclass="math inline">\(\boldsymbol{u}_i\)</span> 解释的方差比例 <spanclass="math display">\[n_{u_i}=\sum_{k=1}^q\rho^2(\boldsymbol{u}_i,\boldsymbol{y}_k)/q\]</span></p><p>原始变量 <span class="math inline">\(\boldsymbol{Y}\)</span> 被 <spanclass="math inline">\(\boldsymbol{v}_i\)</span> 解释的方差比例 <spanclass="math display">\[n_{v_i}=\sum_{k=1}^q\rho^2(\boldsymbol{v}_i,\boldsymbol{y}_k)/q\]</span></p><h2 id="样本典型相关系数显著性检验">样本典型相关系数显著性检验</h2><h3 id="整体检验">整体检验</h3><p><spanclass="math display">\[H_0:\lambda_1=\lambda_2=\dotsb=\lambda_r=0\quad,{\tiny即\boldsymbol{\Sigma_{\tiny XY}}=0}\\H_1:\lambda_i\small(i=1,2,\dots,r)中至少有一个非0,{\tiny即\boldsymbol{\Sigma_{\tinyXY}}\ne0}\]</span></p><p>记 <spanclass="math display">\[\Lambda_{1}=\frac{|\hat{\boldsymbol{\Sigma}}|}{\left|\hat{\boldsymbol{\Sigma}}_{XX}\right|\left|\hat{\boldsymbol{\Sigma}}_{Y Y}\right|}\\\]</span> 得<spanclass="math display">\[\Lambda_{1}=\left|\boldsymbol{I}_{p}-\hat{\boldsymbol{\Sigma}}_{XX}^{-1} \hat{\boldsymbol{\Sigma}}_{X Y} \hat{\boldsymbol{\Sigma}}_{YY}^{-1} \hat{\boldsymbol{\Sigma}}_{YX}\right|=\prod_{i=1}^{r}\left(1-\lambda_{i}^{2}\right)\]</span></p><p>验证统计量 <spanclass="math display">\[Q_{1}=-\left[n-1-\frac{1}{2}(p+q+1)\right] \ln\Lambda_{1}\]</span></p><p>近似服从自由度为 <span class="math inline">\(pq\)</span> 的 <spanclass="math inline">\(\chi ^2\)</span> 分布，在给定的显著性水平 <spanclass="math inline">\(\alpha\)</span> 下，若 <spanclass="math inline">\(Q_1\ge \chi_\alpha^2(pq)\)</span>，则拒绝原假设，认为至少第一对典型变量之间相关性显著。</p><h3 id="部分总体为零的检验">部分总体为零的检验</h3><p><spanclass="math display">\[H_0:\lambda_2=\lambda_3=\dotsb=\lambda_r=0,\\H_1:\lambda_2,\lambda_3,\dotsb,\lambda_r\small至少有一个非零\]</span></p><p>若原假设 <span class="math inline">\(H_0\)</span>被接受，则认为只有第一对典型变量有用；若 <spanclass="math inline">\(H_0\)</span>被拒绝，则第二对典型变量也有用，并进行进一步假设</p><p><spanclass="math display">\[H_0:\lambda_3=\lambda_4=\dotsb=\lambda_r=0,\\H_1:\lambda_3,\lambda_4,\dotsb,\lambda_r\small至少有一个非零\]</span></p><p>如此进行下去直到对于某个 <span class="math inline">\(k\)</span><br /><spanclass="math display">\[H_0:\lambda_k=\lambda_{k+1}=\dotsb=\lambda_r=0,\\H_1:\lambda_k,\lambda_{k+1},\dotsb,\lambda_r\small至少有一个非零\]</span></p><p>记</p><p><spanclass="math display">\[\Lambda_{k}=\prod_{i=k}^{r}\left(1-\lambda_{i}^{2}\right)\]</span>在原假设为真的情况下 <spanclass="math display">\[Q_k=-\left[n-k-\frac{1}{2}(p+q+1)\right] \ln\Lambda_{k}\]</span> 近似服从自由度为 <spanclass="math inline">\((p-k+1)(p-k+1)\)</span> 的 <spanclass="math inline">\(\chi ^2\)</span> 分布。在显著性水平 <spanclass="math inline">\(\alpha\)</span> 下若 <spanclass="math inline">\(Q_k\ge\chi_\alpha^2\left[(p-k+1)(p-k+1)\right]\)</span>，则拒绝原假设，则至少认为第 <span class="math inline">\(k\)</span>对典型变量之间相关性显著。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第268页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/372774724"class="uri">https://zhuanlan.zhihu.com/p/372774724</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>高惠璇. 应用多元统计分析[M].第2版. 第354页.<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>相关系数矩阵</tag>
      
      <tag>典型相关分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>因子分析</title>
    <link href="/2022/02/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因子分析（Factor Analysis，FA）<br />用少数几个假象变量来表示其根本的数据结构，能反应原来众多变量的主要信息。因子分析的前提条件是观测变量间有较强的相关性，这样才能有共享因子。</p><figure><img src="https://s2.loli.net/2022/02/18/56XgZSYPbUt9LHW.png"alt="高中生成绩分析" /><figcaption aria-hidden="true">高中生成绩分析</figcaption></figure><h1 id="步骤">步骤</h1><ul><li>选择分析变量</li><li>计算所选原始变量的相关系数矩阵</li><li>提取公共因子，确定因子数目</li><li>因子旋转，解释因子</li><li>计算因子得分</li></ul><h1 id="模型">模型</h1><blockquote><p>本文的变量名大体可分为三种：大写粗体、大写、小写。<br />大写粗体一般表示整个矩阵，一般为二维；大写参数一般表示为指标/因子，包含<span class="math inline">\(n\)</span>个元素（观测值）可以看作向量；小写表示元素或单个变量。</p></blockquote><h2 id="数学模型">数学模型</h2><p>记 <span class="math inline">\(m\)</span> 个观测值 <spanclass="math inline">\(X_i(i=1,2,\dots,m)\)</span> 可以表示为</p><p><span class="math display">\[X_{i}=\mu_{i}+\alpha_{i 1}F_{1}+\cdots+\alpha_{i m} F_{m}+\varepsilon_{i}\]</span></p><p>即 <span class="math display">\[\left[\begin{array}{c}X_{1} \\X_{2} \\\vdots \\X_{m}\end{array}\right]=\left[\begin{array}{c}\mu_{1} \\\mu_{2} \\\vdots \\\mu_{m}\end{array}\right]+\left[\begin{array}{cccc}\alpha_{11} &amp; \alpha_{12} &amp; \cdots &amp; \alpha_{1 r} \\\alpha_{21} &amp; \alpha_{22} &amp; \cdots &amp; \alpha_{2 r} \\\vdots &amp; \vdots &amp; &amp; \vdots \\\alpha_{m 1} &amp; \alpha_{m 2} &amp; \cdots &amp; \alpha_{m r}\end{array}\right]\left[\begin{array}{c}F_{1} \\F_{2} \\\vdots \\F_{r}\end{array}\right]+\left[\begin{array}{c}\varepsilon_{1} \\\varepsilon_{2} \\\vdots\\\varepsilon_{m}\end{array}\right]\]</span> 即 <spanclass="math display">\[\boldsymbol{X}-\boldsymbol{\mu}=\boldsymbol{\Lambda}\boldsymbol{F}+\boldsymbol{\varepsilon}\]</span></p><p>满足：</p><ol type="1"><li><span class="math inline">\(E(\boldsymbol{F})=0\)</span> 且 <spanclass="math inline">\(E(\boldsymbol{\varepsilon})=0\)</span></li><li>载荷因子 <span class="math inline">\(F_i\)</span> 之间无线性关系：<span class="math inline">\(Cov(\boldsymbol{F})=E_m\)</span></li><li>特殊因子 <span class="math inline">\(\varepsilon_i\)</span>之间无线性关系： <spanclass="math inline">\(Cov(\boldsymbol{\varepsilon})=D(\boldsymbol{\varepsilon})=diag(\sigma_1^2,\sigma _2^2,\dots,\sigma _m^2)\)</span></li><li>特殊因子和载荷因子无线性关系：<spanclass="math inline">\(Cov(\boldsymbol{F},\boldsymbol{\varepsilon})=0\)</span></li></ol><h3 id="模型的性质">模型的性质</h3><ul><li><strong>原子变量 <span class="math inline">\(\boldsymbol{X}\)</span>的协方差矩阵分解</strong></li></ul><p>由 <spanclass="math inline">\(\boldsymbol{X}-\boldsymbol{\mu}=\boldsymbol{\Lambda}\boldsymbol{F}+\boldsymbol{\varepsilon}\)</span>得 <spanclass="math inline">\(Cov(\boldsymbol{X}-\boldsymbol{\mu})=\boldsymbol{\Lambda}Cov(\boldsymbol{F})\boldsymbol{\Lambda}^T+Cov(\boldsymbol{\varepsilon})\)</span>即</p><p><spanclass="math display">\[Cov(\boldsymbol{X})=\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+D(\boldsymbol{\Lambda})\]</span></p><p><span class="math inline">\(\sigma _1^2,\sigma _2^2,\dots,\sigma_m^2\)</span> 的值越小，公共因子贡献成分越多。</p><ul><li><strong>因子载荷矩阵不唯一（可旋转的原因）</strong></li></ul><p>设 <span class="math inline">\(\Gamma\)</span> 是一个标准正交矩阵，有<spanclass="math display">\[\widetilde{\boldsymbol{\Lambda}}=\boldsymbol{\Lambda}\Gamma, \widetilde{\boldsymbol{F}}=\Gamma^{\tiny T}\boldsymbol{F} \]</span><spanclass="math display">\[\boldsymbol{X}=\boldsymbol{\mu}+\widetilde{\boldsymbol{\Lambda}}\widetilde{\boldsymbol{F}}+\boldsymbol{\varepsilon}\]</span></p><h3 id="载荷矩阵统计性质">载荷矩阵统计性质</h3><ul><li><strong><span class="math inline">\(\alpha_{i j}\)</span>的含义</strong></li></ul><p>因子载荷矩阵 <span class="math inline">\(\alpha_{i j}\)</span> 表示第<span class="math inline">\(i\)</span> 个变量与第 <spanclass="math inline">\(j\)</span> 个公共因子的相关系数，反应第 <spanclass="math inline">\(i\)</span> 个变量与第 <spanclass="math inline">\(j\)</span> 个公共因子的相关重要性。 <spanclass="math inline">\(|\alpha_{i j}|\)</span>越大，相关的密切程度越高。</p><ul><li><strong>变量共同度的统计意义</strong></li></ul><p>变量 <span class="math inline">\(X_i\)</span>的共同度是因子载荷矩阵第 <span class="math inline">\(i\)</span>行的元素平方和，记 <spanclass="math inline">\(h_i^2=\sum\limits_{j=1}^{r}\alpha_{ij}^2\)</span></p><p>因为</p><p><spanclass="math display">\[Var(X_i)=\alpha_{i1}^2Var(F_1)+\dots+\alpha_{ir}^2Var(F_r)+Var(\varepsilon_i)\]</span></p><p>得</p><p><spanclass="math display">\[1=\sum\limits_{j=1}^{r}\alpha_{ij}^2+\sigma_i^2\]</span></p><p>可以看出 <span class="math inline">\(h_i^2\)</span> 越靠近 <spanclass="math inline">\(1\)</span> ， <spanclass="math inline">\(\sigma_i^2\)</span> 越靠近 <spanclass="math inline">\(0\)</span> ， 原变量 <spanclass="math inline">\(X_i\)</span> 被公共因子表现的越好。</p><ul><li><strong>公共因子 <span class="math inline">\(F_j\)</span>的方差贡献统计意义</strong></li></ul><p>因子 <span class="math inline">\(F_j\)</span>的方差贡献和是因子载荷矩阵第 <span class="math inline">\(j\)</span>列的平方和，记为 <span class="math inline">\(S_j=\sum\limits_{i=1}^{m}\alpha_{ij}^2=\lambda_j\)</span></p><p>用于衡量 <span class="math inline">\(F_j\)</span> 的相对重要性。</p><ul><li><strong>残差阵</strong></li></ul><p>用原协方差阵减去公因子协方差阵与特殊因子协方差阵，得到残差阵</p><p><span class="math display">\[(\epsilon_{ij})_{m\times m} =\boldsymbol{R}-(\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+\boldsymbol{D})\]</span></p><p>残差阵元素的平方和为残差平方和</p><p><spanclass="math display">\[Q(m)=\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}\epsilon_{ij}^2\le \sum\limits_{k=r+1}^{m}\lambda_k^2\]</span></p><h2 id="因子载荷矩阵估计法">因子载荷矩阵估计法</h2><h3 id="主成分分析法">主成分分析法</h3><blockquote><p>和“主成分分析”本质相同，主成分分析是将样本经过载荷矩阵 <spanclass="math inline">\(\boldsymbol{P}\)</span>变换到坐标轴上使得坐标轴方向方差最大；因子分析的主成分分析法相当于主成分分析的逆过程，因子代表的<span class="math inline">\(\R^r\)</span> 空间上的点，经过因子载荷矩阵<span class="math inline">\(\boldsymbol{\Lambda}\)</span>变换后得原样本点。</p></blockquote><p>设样本相关系数矩阵为 <spanclass="math inline">\(\boldsymbol{R}\)</span> ，计算其特征值为 <spanclass="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_m\)</span>(<span class="math inline">\(\lambda_1\ge \lambda_2\ge \dots\ge\lambda_m\)</span>) ，对应的特征向量为 <spanclass="math inline">\(\boldsymbol{\eta} _1,\boldsymbol{\eta}_2,\dots,\boldsymbol{\eta} _m\)</span> ，记 <spanclass="math inline">\(\boldsymbol{H}=[\boldsymbol{\eta}_1,\boldsymbol{\eta }_2,\dots,\boldsymbol{\eta }_m]\)</span> 有</p><p><spanclass="math display">\[\boldsymbol{R}=\boldsymbol{H}\begin{bmatrix}  \boldsymbol{\lambda_1}&amp;  &amp;  &amp; \\  &amp; \boldsymbol{\lambda_2} &amp;  &amp; \\  &amp;  &amp;\ddots &amp; \\  &amp;  &amp;  &amp; \boldsymbol{\lambda_1}\end{bmatrix}\boldsymbol{H}^T=\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+D\]</span></p><p>（ <span class="math inline">\(\small\boldsymbol{D}\)</span>被忽略）即因子载荷矩阵为</p><p><spanclass="math display">\[\boldsymbol{\Lambda}=[\sqrt{\lambda_1}\boldsymbol{\eta_1},\sqrt{\lambda_2}\boldsymbol{\eta_2},\dots,\sqrt{\lambda_m}\boldsymbol{\eta_m}]\]</span></p><p>使得公共因子方差贡献<spanclass="math inline">\(S_j=\lambda_j\)</span></p><p>根据碎石图，用碎石原则确定因子个数 <spanclass="math inline">\(r\)</span>。</p><p>特殊因子方差可以用 <spanclass="math inline">\(\boldsymbol{R}-\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T\)</span>的主对角线元素估计： <spanclass="math display">\[\sigma_i^2=1-\sum_{j=1}^m\alpha_{ij}^2\]</span></p><p><strong>缺点</strong>：上式有一个假定，模型中的特殊因子是不重要的，因而从<span class="math inline">\(\boldsymbol{R}\)</span>的<strong>分解中忽略了特殊因子的方差</strong>。所得的特殊因子 <spanclass="math inline">\(\varepsilon_{1}，\varepsilon_{2},...,\varepsilon_{p}\)</span>之间并不相互独立，不完全符合假设前提。因此，当共同度较大时，特殊因子所起作用小时，它们之间存在的相关性所带来的影响可以几乎忽略。实际应用中，可以先用主成分法进行分析，再尝试其他方法。</p><h3 id="主因子法">主因子法</h3><p>主因子方法是对主成分方法的修正，假定我们首先对变量进行标准化变换。则</p><p><spanclass="math display">\[\boldsymbol{R}=\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+\boldsymbol{D}\\\boldsymbol{R}^*=\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T=\boldsymbol{R}-\boldsymbol{D}\]</span></p><p>式中 <span class="math inline">\(\boldsymbol{R}^*\)</span>为约相关系数矩阵，其对角线上的元素为 <spanclass="math inline">\(h_i^2\)</span> 。</p><p>特殊因子方差是未知的，一般通过样本估计得到。方法可以有；</p><ol type="1"><li>取 <span class="math inline">\(\hat{h_i^2}=1\)</span>，这种情况下主因子解与主成分分解等价</li><li>取 <span class="math inline">\(\hat{h_i^2}=\max\limits_{\tiny i \nej}|r_{ij}|\)</span> ，取 <span class="math inline">\(X_i\)</span>与其他指标简单相关系数最大者</li><li>取 <spanclass="math inline">\(\hat{h_i^2}=\frac{1}{m-1}\sum\limits_{sj=1,j\nei}^{m}r_{ij}\)</span> ，其中要求该值为正数</li></ol><p>记</p><p><spanclass="math display">\[\boldsymbol{R}^*=\boldsymbol{R}-\boldsymbol{D}=\left[\begin{array}{cccc}\hat{h_{1}^{2}} &amp; r_{12} &amp; \cdots &amp; r_{1 m} \\r_{21} &amp; \hat{h_{2}^{2}} &amp; \cdots &amp; r_{2 m} \\\vdots &amp; \vdots &amp; &amp; \vdots \\r_{m 1} &amp; r_{m 2} &amp; \cdots &amp; \hat{h_{m}^{2}}\end{array}\right]\]</span></p><p>直接求出 <span class="math inline">\(\boldsymbol{R}^*\)</span>的特征值为 <spanclass="math inline">\(\lambda_1^*,\lambda_2^*,\dots,\lambda_m^*\)</span>(<span class="math inline">\(\lambda_1^*\ge \lambda_2^*\ge \dots\ge\lambda_m^*\)</span>) ，和对应的特征向量为 <spanclass="math inline">\(\boldsymbol{\eta} _1^*,\boldsymbol{\eta}_2^*,\dots,\boldsymbol{\eta} _m^*\)</span> ，得到载荷矩阵：</p><p><spanclass="math display">\[\boldsymbol{\Lambda}=[\sqrt{\lambda_1^*}\boldsymbol{\eta}_1^*,\sqrt{\lambda_2^*}\boldsymbol{\eta}_2^*,\dots,\sqrt{\lambda_m^*}\boldsymbol{\eta}_m^*]\]</span></p><h3 id="极大似然估计法">极大似然估计法</h3><p>假设数据 <span class="math inline">\(X_1,...,X_n\)</span> 服从 <spanclass="math inline">\(m\)</span>元正态，公因子与特殊因子也假定服从正态。</p><p><span class="math display">\[L(\mu, \boldsymbol{\Lambda},\boldsymbol{D})=\prod_{i=1}^{d} \frac{1}{(2 \pi)^{m /2}|\boldsymbol{R}|^{1 / 2}} \exp\left[-\frac{1}{2}\left(\boldsymbol{X}_{\mathbf{i}}-\mu\right)^{\prime}\boldsymbol{\boldsymbol{R}}^{-1}\left(\boldsymbol{X}_{\mathbf{i}}-\mu\right)\right]\]</span></p><p>用数值极大化的方法可以得到极大似然估计。</p><p>Matlab 工具箱求因子载荷矩阵使用的是最大似然估计，其命令为<code>factoran</code> 。</p><h2 id="因子旋转">因子旋转</h2><p>建立因子模型不仅要得到公共因子，还要能解释这些公共因子的具体含义。</p><p>由于因子载荷矩阵不唯一，所以可以对载荷矩阵进行旋转，使得载荷矩阵每行或每列的元素平方值向<span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>两极分化，即使信息分布尽可能不均匀，也就是信息要集中分布于几个不同的因子上。</p><p><span class="math display">\[\boldsymbol{X} = \boldsymbol{\Lambda}\Gamma {\Gamma ^{ - 1}} \boldsymbol{F} +\boldsymbol{\varepsilon}\]</span></p><figure><img src="https://s2.loli.net/2022/02/18/jwF6TtrqLuAHeoD.png"alt="旋转结果（r=4）" /><figcaption aria-hidden="true">旋转结果（r=4）</figcaption></figure><p>因为是对整个 <span class="math inline">\(\R^r\)</span>的空间正交变换（可以理解为坐标轴旋转或者样本旋转），所以银子旋转不会是损耗信息量只会改变因子载荷矩阵的权重分配，<strong>变量共同度<span class="math inline">\(h_i^2\)</span>不变</strong>，<strong>因子方差贡献 <spanclass="math inline">\(S_j\)</span>不变</strong>（正交旋转不改变向量长度）。</p><p>对于任意两列，正交矩阵形式可以设为</p><p><span class="math display">\[\Gamma=\left[\begin{array}{ll} \cos \phi&amp; -\sin \phi \\ \sin \phi &amp; \cos \phi\end{array}\right]\\\]</span></p><p>带入得到</p><p><spanclass="math display">\[\boldsymbol{\Lambda}^*=\boldsymbol{\Lambda}\Gamma=\left[\begin{array}{ll} \alpha_{11} \cos \phi+\alpha_{12} \sin\phi &amp; -\alpha_{11} \sin \phi+\alpha_{12} \cos \phi \\ \vdots &amp;\vdots \\ \alpha_{p 1} \cos \phi+a_{p 2} \sin \phi &amp; -\alpha_{p 1}\sin \phi+\alpha_{p 2} \cos \phi \end{array}\right]=\left[\begin{array}{ll}\alpha_{11}^* &amp;  \alpha_{12}^*\\\vdots &amp;  \vdots \\\alpha_{m 1}^* &amp;\alpha_{m2}^*\end{array}\right]\]</span></p><h3 id="方差最大的正交旋转">方差最大的正交旋转</h3><p><strong>基本思想：</strong> <spanclass="math inline">\(\alpha_{ij}^*\)</span> 表示变量 <spanclass="math inline">\(i\)</span> 与因子 <spanclass="math inline">\(j\)</span>的关联程度，要使每一列的元素值越分散，就要<strong>使因子载荷矩阵的每一列元素的方差更大</strong>。</p><p>因为 <span class="math inline">\(r&lt;m\)</span>，每一行向量的长度不统一，所以先对每一行都除以共同度 <spanclass="math inline">\(h_i^2\)</span> ，记</p><p><span class="math display">\[d_{i j}=\frac{ { \alpha_{i j}^{*} }^2}{h_i^2} , \scriptsize  (i=1,2,\dots,m,j=1,2,\dots,r)\]</span></p><p>定义因子载荷第 j 列的方差为</p><p><span class="math display">\[V_{j}=\frac{1}{m}\sum\limits_{\tinyi=1}^{\tiny m}\left(d_{ij}^{2}-\bar{d}_{j}\right)^{2}=\frac{1}{m^2}\left[m \sum_{i=1}^{m}d_{ij}^2-{\left(\sum_{i=1}^{m} d_{ij}\right)}^{2}\right]\\\]</span></p><p>其中 <span class="math inline">\(\bar{d}_{j}=\frac{1}{m}\sum\limits_{\tiny i=1}^{\tiny m} d_{i j}^{2}\)</span></p><p>定义因子载荷矩阵 <spanclass="math inline">\(\boldsymbol{\Lambda}\)</span>的方差等于每一列的方差之和</p><p><spanclass="math display">\[V=\sum_{j=1}^rV_{j}=\frac{1}{m^2}\sum_{j=1}^{r}\left[m\sum_{i=1}^{m} d_{ij}^2-{\left(\sum_{i=1}^{m}d_{ij}\right)}^{2}\right]\]</span></p><ul><li><strong>二维空间</strong></li></ul><p>设因子载荷矩阵有两列 <span class="math inline">\(r=2\)</span> ，</p><p><spanclass="math display">\[\boldsymbol{\Lambda}^*=\boldsymbol{\Lambda}\Gamma=\left[\begin{array}{ll}\alpha_{11}^* &amp;  \alpha_{12}^*\\\vdots &amp;  \vdots \\\alpha_{m 1}^* &amp;\alpha_{m2}^*\end{array}\right]\\\]</span></p><p>将 <span class="math inline">\(\boldsymbol{\Lambda}^*\)</span> 带入<span class="math inline">\(V_{\boldsymbol{\Lambda}}\)</span> ，让 <spanclass="math inline">\(V_{\boldsymbol{\Lambda}^*}\)</span> 对 <spanclass="math inline">\(\phi\)</span> 求导数</p><p>令</p><p><span class="math display">\[\frac{\partialV_{\boldsymbol{\Lambda}}}{\partial \phi}=0\]</span></p><p>得到 <span class="math inline">\(\phi\)</span> 应该满足</p><p><span class="math display">\[\tan 4 \phi=\frac{d-2 ab /m}{c-\left(a^{2}-b^{2}\right) / m}\]</span></p><p>其中，若记</p><p><span class="math display">\[\mu_{i}=d_{i1}-d_{i2} , \quad \nu_{i}=2\frac{\alpha_{i 1}\alpha_{i2}}{h_{i}^{2}}=2\sqrt{d_{i1}d_{i2}}\]</span></p><p>则</p><p><span class="math display">\[\begin{array}{c}a=\sum\limits_{i=1}^{m} \mu_{i}, \quad b=\sum\limits_{i=1}^{m} \nu_{i},\\c=\sum\limits_{i=1}^{m}\left(\mu_{i}^{2}-\nu_{i}^{2}\right), \quad d=2\sum\limits_{i=1}^{m} \mu_{i} \nu_{i} .\end{array}\]</span></p><ul><li><strong>高维空间</strong></li></ul><p>当 <span class="math inline">\(m{\small&gt;}2\)</span> 时,可逐次对每两个因子 <span class="math inline">\(F_{i}, F_{j}\small (i\neq j)\)</span> 进行以上旋转。</p><p>选择正交旋转的角度 <span class="math inline">\(\varphi_{i j}\)</span>，即使这两个因子的方差之和达最大。 <spanclass="math inline">\(m\)</span> 个因子的全部配对旋转， 共需旋转 <spanclass="math inline">\(C_{m}^{2}\)</span> 次，全部旋转 完毕即算一次循环(或一轮)。经第一轮旋转后计算所得的因子载荷 方差 <spanclass="math inline">\(V_{(1)}\)</span> ， 此时不能认为 <spanclass="math inline">\(V_{(1)}\)</span>就是最大方差，还需从旋转后的载荷矩 阵出发, 再进行第二轮、第三轮旋转,直到 <span class="math inline">\(V\)</span>不能再增大为止<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="高惠璇. 应用多元统计分析[M]. 第2版. 第310页.">[5]</span></a></sup>。</p><h3 id="四次方最大化旋转">四次方最大化旋转</h3><p><strong>基本思想：</strong>使得因子载荷的每一行只在少部分地方取较大的值，每个变量只在一个因子上有较高的载荷，即<strong>使因子载荷矩阵每一行的元素方差最大化</strong>。</p><p>用于度量方差的量为</p><p><span class="math display">\[Q=\sum_{i=1}^{m}\sum_{j=1}^{r}\left({\alpha_{i j}^{*}}^2-\frac{1}{r}\right)^{2}\overset{\tiny 化}{=} \sum_{i=1}^{m} \sum_{j=1}^{r}\left({\alpha_{ij}^{*}}^4-2+\frac{m}{r}\right)\]</span></p><p>得到最简式</p><p><span class="math display">\[Q=\sum_{i=1}^{m}\sum_{j=1}^{r}{\alpha_{i j}^{*}}^4\]</span></p><p>这里的 <span class="math inline">\(1/r\)</span>可以理解为近似的每一行均值。</p><h3 id="等量最大法">等量最大法</h3><p><strong>基本思想：</strong>同时考虑载荷矩阵每行的方差和每列的方差，对其加权平均最大化。</p><p><span class="math inline">\(V\)</span> 近似化简为 <spanclass="math display">\[V=-\frac{1}{m}\sum_{j=1}^{r}{\left(\sum_{i=1}^{m}d_{ij}\right)}^{2}\quad\color{Gray} \tiny ,\sum_{i=1}^{m} d_{ij}^2\approx  1 ,\quad d_{ij}\approx \alpha_{i j}^{*} \]</span></p><p><span class="math inline">\(Q\)</span> 近似化简为 <spanclass="math display">\[Q=\sum_{i=1}^{m} \sum_{j=1}^{r}{\alpha_{ij}^{*}}^4\color{Gray}\quad \tiny ,\frac{1}{r}\approx\sum_{j=1}^rd_{ij}^2  ,\quad d_{ij}\approx \alpha_{i j}^{*}\]</span></p><p>构造</p><p><span class="math display">\[E=\sum_{i=1}^{m}\sum_{j=1}^{r}{\alpha_{i j}^{*}}^4 -\frac{\gamma  }{m}\sum_{j=1}^{r}{\left(\sum_{i=1}^{m}d_{ij}\right)}^{2}\]</span></p><p>其中 <span class="math inline">\(\gamma\)</span> 取 <spanclass="math inline">\(\frac{m}{2}\)</span></p><h2 id="因子得分">因子得分</h2><p>利用已知的观测值 <span class="math inline">\(\boldsymbol{X}\)</span>与构造的因子载荷矩阵 <spanclass="math inline">\(\boldsymbol{\Lambda}\)</span>可以对公共因子测度，即给出公共因子的值。</p><p>因子分析的数学模型已经给出，为</p><p><span class="math display">\[\left[\begin{array}{c}X_{1} \\X_{2} \\\vdots \\X_{m}\end{array}\right]=\left[\begin{array}{c}\mu_{1} \\\mu_{2} \\\vdots \\\mu_{m}\end{array}\right]+\left[\begin{array}{cccc}\alpha_{11} &amp; \alpha_{12} &amp; \cdots &amp; \alpha_{1 r} \\\alpha_{21} &amp; \alpha_{22} &amp; \cdots &amp; \alpha_{2 r} \\\vdots &amp; \vdots &amp; &amp; \vdots \\\alpha_{m 1} &amp; \alpha_{m 2} &amp; \cdots &amp; \alpha_{m r}\end{array}\right]\left[\begin{array}{c}F_{1} \\F_{2} \\\vdots \\F_{r}\end{array}\right]+\left[\begin{array}{c}\varepsilon_{1} \\\varepsilon_{2} \\\vdots\\\varepsilon_{m}\end{array}\right]\]</span></p><p>注：此处的 <spanclass="math inline">\(X_1,X_2\dots;F_1,F_2\dots;\varepsilon_1,\varepsilon_2\dots\)</span>都表示为一个指标下的一组 <span class="math inline">\(n\)</span>个样本的值，即 <spanclass="math inline">\(X_i=[x_{i1},x_{i2},\dotsb,x_{in}]\)</span></p><p>原变量 <span class="math inline">\(\boldsymbol{X}\)</span>被表示为公共因子的线性组合，载荷矩阵旋转后，公共因子可以做出解释，现在目的是把公共因子用原变量线性表示出来。</p><p>记因子得分函数为</p><p><spanclass="math display">\[F_j=c_j+\beta_{j1}X_1+\dotsb+\beta_{jm}X_m,\quadj=1,2,\dots,r\]</span></p><p>要求因子的得分，我们想要得分函数的系数，而因为 <spanclass="math inline">\(m&gt;r\)</span>不能得到精确的得分，载荷矩阵也不存在逆矩阵。</p><h3id="加权最小二乘法巴特莱特因子得分">加权最小二乘法（巴特莱特因子得分）</h3><p>把 <span class="math inline">\(X_i\)</span>看作因变量，把因子载荷矩阵看作自变量(不妨设 <spanclass="math inline">\(\mu_i=0\)</span> )。</p><p><span class="math display">\[\left\{\begin{array}{l}X_{1}=\alpha _{11} F_{1}+\alpha_{12} F_{2}+\cdots+\alpha_{1 r}F_{r}+\varepsilon_{1} \\X_{2}=\alpha_{21} F_{1}+\alpha_{22} F_{2}+\cdots+\alpha_{2 r}F_{r}+\varepsilon_{2} \\\cdots \\X_{m}=\alpha_{\tiny m 1} F_{1}+\alpha_{\tiny m 2}F_{2}+\cdots+\alpha_{\tiny m r} F_{r}+\varepsilon_{p}\end{array}\right.\]</span></p><p>考虑特殊因子方差相异，用加权的最小二乘法，使</p><p><spanclass="math display">\[\sum_{i=1}^m\frac{1}{\sigma_i^2}\left[(X_i)-(\alpha_{i1}\hat{F_1}+\dotsb+a_{ir}\hat{F_r})\right]^2\]</span></p><p>最小的 <spanclass="math inline">\(\hat{F_1},\hat{F_2},\dots,\hat{F_r}\)</span>是相应各个样本的因子得分。</p><p>矩阵表示： <spanclass="math display">\[\boldsymbol{X}=\boldsymbol{\Lambda}\boldsymbol{F}+\boldsymbol{\varepsilon}\]</span>要使 <spanclass="math display">\[(\boldsymbol{X}-\bold{\Lambda}\hat{\boldsymbol{F}})^T\boldsymbol{D}^{-1}(\boldsymbol{X}-\bold{\Lambda}\hat{\boldsymbol{F}})\]</span></p><p>即取偏导，令</p><p><span class="math display">\[\frac{\partial\phi(\boldsymbol{F})}{\partial \boldsymbol{F}}=2\boldsymbol{\Lambda}^{T}(\boldsymbol{X}-\boldsymbol{\Lambda}\boldsymbol{F})=0\]</span></p><p>达到最小，计算得</p><ul><li><p><spanclass="math display">\[\hat{\boldsymbol{F}}=(\boldsymbol{\Lambda}^T\boldsymbol{\Lambda})^{-1}\boldsymbol{\Lambda}^T\boldsymbol{X}\]</span></p></li><li><p><spanclass="math display">\[\hat{\boldsymbol{F}}=(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1}\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{X}\]</span></p></li></ul><blockquote><p>这种方法得到的因子得分 <spanclass="math inline">\(F_i=[f_{i1},\dots,f_{in}]\)</span>与主成分分析结果 <spanclass="math inline">\(Z_i=[z_{i1},\dots,z_{in}]\)</span>，仅仅相差一个常数：<span class="math inline">\(f_{ij}=z_{ij}/\sqrt{\lambda_j}\)</span></p></blockquote><h3 id="回归法汤普森因子得分">回归法（汤普森因子得分）</h3><p>设</p><p><span class="math display">\[\left[\begin{array}{c}X_{1} \\X_{2} \\\vdots \\X_{m}\end{array}\right]=\left[\begin{array}{cccc}\alpha_{11} &amp; \alpha_{12} &amp; \cdots &amp; \alpha_{1 r} \\\alpha_{21} &amp; \alpha_{22} &amp; \cdots &amp; \alpha_{2 r} \\\vdots &amp; \vdots &amp; &amp; \vdots \\\alpha_{m 1} &amp; \alpha_{m 2} &amp; \cdots &amp; \alpha_{m r}\end{array}\right]\left[\begin{array}{c}F_{1} \\F_{2} \\\vdots \\F_{r}\end{array}\right]+\left[\begin{array}{c}\varepsilon_{1} \\\varepsilon_{2} \\\vdots\\\varepsilon_{m}\end{array}\right]\]</span> 记第 <span class="math inline">\(j\)</span>个因子得分函数为</p><p><spanclass="math display">\[F_j=\beta_{j1}X_1+\dotsb+\beta_{jm}X_m,\quadj=1,2,\dots,r\]</span></p><p>因子载荷矩阵的元素表示了样本和因子的相关系数，有</p><p><span class="math display">\[\alpha_{ij}=\gamma_{\tiny X_iF_j}=E(X_iF_j)=E[X_i(\beta_{j1}X_1+\dotsb+\beta_{jm}X_m)]=\beta_{j1}\gamma_{i1}+\dotsb+\beta_{jm}\gamma_{im}\]</span></p><p>有</p><p><span class="math display">\[\begin{bmatrix}\gamma_{11} &amp; \gamma_{12} &amp; \dotsb &amp; \gamma_{1m}\\  \gamma_{21}&amp;\gamma_{22}  &amp; \dotsb &amp; \gamma_{2m}\\  \vdots &amp;  \vdots  &amp; \ddots &amp;  \vdots \\  \gamma_{m1}&amp;\gamma_{m2}  &amp; \dotsb &amp; \gamma_{mm}\end{bmatrix}\begin{bmatrix}\beta_{j1}\\  \beta_{j2}\\\vdots\\\beta_{jm}\end{bmatrix}=\begin{bmatrix}\alpha_{1j}\\\alpha_{2j} \\\vdots\\\alpha_{mj}\end{bmatrix}\]</span></p><p>其中三个矩阵分布代表原始变量系数相关系数矩阵 <spanclass="math inline">\(\boldsymbol{R}\)</span> 、第 <spanclass="math inline">\(j\)</span> 个因子得分函数系数、载荷矩阵第 <spanclass="math inline">\(j\)</span> 列。</p><p>得</p><p><span class="math display">\[\begin{bmatrix}\beta_{11} &amp; \beta_{12} &amp; \dotsb &amp; \beta_{1m}\\  \beta_{21}&amp;\beta_{22}  &amp; \dotsb &amp; \beta_{2m}\\  \vdots &amp;  \vdots  &amp; \ddots &amp;  \vdots \\  \beta_{m1}&amp;\beta_{m2}  &amp; \dotsb &amp; \beta_{rm}\end{bmatrix}^T=\boldsymbol{R}^{-1}\boldsymbol{\Lambda}\]</span></p><p>因此，因子得分估计为</p><ul><li><p><spanclass="math display">\[\hat{\boldsymbol{F}}=\boldsymbol{\Lambda}^T\boldsymbol{R}^{-1}\boldsymbol{X}\]</span></p></li><li><p><spanclass="math display">\[\hat{\boldsymbol{F}}=\boldsymbol{\Lambda}^T(\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+\boldsymbol{D})\boldsymbol{X}\]</span></p></li></ul><blockquote><p>司守奎给出的结果有误</p></blockquote><h3 id="两种估计方法的比较">两种估计方法的比较</h3><p><spanclass="math display">\[\begin{array}{l}\hat{\boldsymbol{F}}(1)=(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1}\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{X},\\\hat{\boldsymbol{F}}(2)=\boldsymbol{\Lambda}^T(\boldsymbol{\Lambda}\boldsymbol{\Lambda}^T+\boldsymbol{D})\boldsymbol{X}\end{array}\]</span></p><ul><li><strong>两者得分关系</strong></li></ul><p><spanclass="math display">\[\hat{\boldsymbol{F}}(1)=(I_r+(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1})\hat{\boldsymbol{F}}(2)\]</span></p><p><spanclass="math inline">\((\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1}\)</span>正定性得到 <span class="math inline">\(\hat{\boldsymbol{F}}(1)\)</span>不小于 <span class="math inline">\(\hat{\boldsymbol{F}}(2)\)</span> ；<spanclass="math inline">\(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda}\)</span>近似 <span class="math inline">\(0\)</span> 时，结果几乎相等。</p><ul><li><strong>无偏性</strong></li></ul><p><spanclass="math display">\[E(\hat{\boldsymbol{F}}(1)|\boldsymbol{F})=\boldsymbol{F}\\E(\hat{\boldsymbol{F}}(2)|\boldsymbol{F})=(I_r+(\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda})^{-1})\boldsymbol{\Lambda}^T\boldsymbol{D}^{-1}\boldsymbol{\Lambda}\boldsymbol{F}\]</span></p><p>第一种估计无偏，回归估计有偏。</p><ul><li><strong>均方误差</strong></li></ul><p><spanclass="math display">\[\mathrm{E}\left[(\hat{\boldsymbol{F}}(1)-\boldsymbol{F})(\hat{\boldsymbol{F}}(1)-{}^{I} \boldsymbol{F})^{\prime} \mid\boldsymbol{F}\right]=\left(\boldsymbol{\Lambda}^{\prime}\boldsymbol{D}^{-1} \boldsymbol{\Lambda}\right)^{-1} \\\mathrm{E}\left[(\hat{\boldsymbol{F}}(2)-\boldsymbol{F})(\hat{\boldsymbol{F}}(2)-{}^{I} \boldsymbol{F})^{\prime} \mid\boldsymbol{F}\right]=\left(I_{m}+\boldsymbol{\Lambda}^{\prime}\boldsymbol{D}^{-1} \boldsymbol{\Lambda}\right)^{-1}\]</span></p><p>这表示第二种估计（汤普森因子得分）有较小的平均预报误差.</p><h1 id="缺陷">缺陷</h1><p>因子分析是十分主观的，在许多出版的资料中，因子分析模型都用少数可命名因子提供了合理解释。实际上，绝大多数因子分析并没有产生如此明确的结果。评价因子分析质量的法则尚未很好量化，因子分析的质量参差不齐。</p><h1 id="参考">参考</h1><ul><li>本文章花费大量时间查询比较各版本的过程，最终以司守奎的参数名为主体，调整了部分参数命名以符合笔者习惯。</li><li>本文章的格式不清晰，多次差错后依然有公式格式，变量名错误的问题，还请见谅。</li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第240页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/340497643<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://www.jianshu.com/p/2456837720fb<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/24008426<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>高惠璇. 应用多元统计分析[M].第2版. 第310页.<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>Wolfgang Hardle LeopoldSimar. Applied Multivariate Statistical Analysis[M].<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>相关系数矩阵</tag>
      
      <tag>因子分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主成分分析</title>
    <link href="/2022/02/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主成分分析（Principal Component Analysis，PCA）<br />目的是用较少的变量代表解释原有的变量。将相关性高的变量转换为相互独立的变量<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第231页.">[1]</span></a></sup>。</p><p>原理：降维，有关联的变量反映的信息有一定的重叠。对于原有变量，将重复的变量（关系紧密的变量）删去，建立尽可能少的新变量，使得新变量是两两不相关的<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://baike.baidu.com/item/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/829840">[3]</span></a></sup>，且能<strong>尽可能保持原有的信息</strong>（方差最大化）和解释原有变量，使样本具有相对较好的区分性。</p><p>定义：一个正交化线性变换，把数据（包含降维）变换到一个新的坐标系统中，使得这一数据的任何投影的第一大方差在第一个坐标（称为第一主成分）上，第二大方差在第二个坐标（第二主成分）上，依次类推<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/342659017">[4]</span></a></sup>。</p><h1 id="方法">方法</h1><p>主成分分析仅是变量转换，以下是得到变量转换的方法。</p><p>记 <span class="math inline">\(Z_1,Z_2,\dots,Z_r\)</span> 为主成分<span class="math display">\[\left\{\begin{array}{c}Z_{1}=c_{11} X_{1}+c_{12} X_{2}+\cdots+c_{1 m} X_{m} \\Z_{2}=c_{21} X_{1}+c_{22} X_{2}+\cdots+c_{2 m} X_{m} \\\vdots \\Z_{r}=c_{r 1} X_{1}+c_{r 2} X_{2}+\cdots+c_{r m} X_{m}\end{array}\right.\]</span></p><p>即 <span class="math display">\[\begin{bmatrix}\boldsymbol{Z}_1\\  \boldsymbol{Z}_2\\\vdots\\\boldsymbol{Z}_r\end{bmatrix}=\begin{bmatrix}  c_{11}&amp; c_{12} &amp; \cdots  &amp; c_{1m}\\  c_{21}&amp; c_{22} &amp; \cdots   &amp;c_{2m} \\  \vdots &amp;  \vdots &amp;  &amp; \vdots\\  c_{r1}&amp; c_{r2} &amp; \cdots &amp; c_{rm}\end{bmatrix}\begin{bmatrix}\boldsymbol{X}_1\\  \boldsymbol{X}_2\\\vdots\\\boldsymbol{X}_m\end{bmatrix}\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{X}_i\)</span> 和 <spanclass="math inline">\(\boldsymbol{Z}_i\)</span> 都表示为长度为 <spanclass="math inline">\(n\)</span> 的观察值向量； <spanclass="math inline">\([ c_{i1}, c_{i2} , \cdots , c_{im}]\)</span> 为第<span class="math inline">\(i\)</span> 个特征向量 <spanclass="math inline">\(\boldsymbol{\alpha}_i\)</span> 。</p><h2 id="步骤">步骤</h2><p>设有 <span class="math inline">\(m\)</span> 个指标，<spanclass="math inline">\(n\)</span> 组观测值 <spanclass="math inline">\(\boldsymbol{X}=[\boldsymbol{X}_1,\boldsymbol{X}_2,\dots,\boldsymbol{X}_m]\)</span><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/342659017">[4]</span></a></sup></p><ol type="1"><li>将各指标数据标准化(去除量纲)和中心化，即 <spanclass="math inline">\(x_{ik}&#39;=\frac{x_{ik}-\mu_k}{\sigma_k}\)</span>，得到矩阵 <span class="math inline">\(\boldsymbol{X&#39;}\)</span>；</li><li>计算相关系数矩阵 <spanclass="math inline">\(\boldsymbol{R}=\frac{1}{n-1}\boldsymbol{A&#39;}^T\boldsymbol{A&#39;}\)</span>；</li><li>（特征值分解或奇异值分解）求出协方差矩阵的特征值 <spanclass="math inline">\(\lambda\)</span> 及对应的特征向量 <spanclass="math inline">\(\boldsymbol{\alpha}\)</span> ；</li><li>计算累计贡献率确定解释度 <spanclass="math inline">\(\alpha\)</span>，取前 <spanclass="math inline">\(r\)</span>个特征向量（标准化、正交化）<strong>按行排列</strong>组成矩阵 <spanclass="math inline">\(\boldsymbol{P}\)</span> ；</li><li><span class="math inline">\((\boldsymbol{Z}_{ij})_{r1}=\boldsymbol{P}_{rn}(\boldsymbol{X}^T)_{n 1}\)</span> ；</li><li>解释主成分的含义。</li></ol><p>注：若不能够给出主成分的较好解释，整个主成分分析也就失败了，可以采用因子分析。</p><h2 id="计算贡献">计算贡献</h2><ul><li>贡献率（特征值占比） <spanclass="math display">\[\frac{\lambda_{i}}{\sum_{k=1}^{r} \lambda_{k}}\quad(i=1,2, \cdots, r)\]</span></li><li>累计贡献率 <span class="math display">\[\frac{\sum_{k=1}^{i}\lambda_{k}}{\sum_{i=1}^{r} \lambda_{k}}\quad(i=1,2, \cdots,r)\]</span></li><li>对原始变量 <span class="math inline">\(\boldsymbol{x}_i\)</span>贡献值（相关系数平方和） <spanclass="math display">\[\rho_i=\sum\limits_{j=1}^{r}r^2(\boldsymbol{z}_j,\boldsymbol{x}_i)\]</span></li></ul><h1 id="理解">理解</h1><h2 id="主成分含义">主成分含义</h2><p>记 <span class="math inline">\(Z_1,Z_2,\dots,Z_r\)</span>为主成分</p><p><span class="math display">\[\left\{\begin{array}{c}Z_{1}=c_{11} X_{1}+c_{12} X_{2}+\cdots+c_{1 m} X_{m} \\Z_{2}=c_{21} X_{1}+c_{22} X_{2}+\cdots+c_{2 m} X_{m} \\\vdots \\Z_{r}=c_{r 1} X_{1}+c_{r 2} X_{2}+\cdots+c_{r m} X_{m}\end{array}\right.\]</span></p><p>对于每一个式子有 <spanclass="math inline">\(c_{i1}^2+c_{i2}^2+\dots+c_{im}^2=1\)</span>（单位向量）。</p><p><span class="math inline">\([c_{11},c_{12},\dots,c_{1m}]\)</span>使得 <span class="math inline">\(Var(Z_1)\)</span>的值最大（信息量最大）；<spanclass="math inline">\([c_{21},c_{22},\dots,c_{2m}]\)</span> 垂直于 <spanclass="math inline">\([c_{11},c_{12},\dots,c_{1m}]\)</span>在该条件下使得 <span class="math inline">\(Var(Z_2)\)</span>的值最大；<spanclass="math inline">\([c_{31},c_{32},\dots,c_{3m}]\)</span> 垂直于 <spanclass="math inline">\(\boldsymbol{c_{1·}}\)</span> ， <spanclass="math inline">\(\boldsymbol{c_{2·}}\)</span>……可推得到全部主成分，每个主成分是满足与所有特征向量正交情况下的信息量最大的单位向量。</p><p><strong>直观解释（几何）</strong></p><p>一般情况， <span class="math inline">\(m\)</span> 个变量组成 <spanclass="math inline">\(m\)</span> 维空间， <spanclass="math inline">\(n\)</span> 个样品点就是 <spanclass="math inline">\(m\)</span> 维空间的 <spanclass="math inline">\(n\)</span> 个点。对于 <spanclass="math inline">\(m\)</span> 维正态随机向量来说,找主成分的问题就是找<span class="math inline">\(m\)</span>维空间中椭球的主轴问题<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="高惠璇. 应用多元统计分析[M]. 第2版. 第310页.">[6]</span></a></sup>。</p><p>初始数据集合中的样本由(正交)坐标系中的点来表示，每一个轴代表一个变量。对原坐标系中的数据进行主成分分析等价于对坐标系进行旋转变换，将数据投影到新坐标系的坐标轴上，此时每一个轴代表一个主成分。将新坐标系中的点在每个主成分轴上投影，得到对应的投影点。投影点的平方和则称为该主成分的方差，方差最大的轴称为第一主成分，依次类推第二主成分的选取，且保证与已选坐标轴正交<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/339038035">[5]</span></a></sup>。</p><h2 id="矩阵变换的理解">矩阵变换的理解</h2><p>对于矩阵变换有两个理解，第一个是来自3Blue1Brown的解释。</p><h3 id="理解一基变换">理解一：基变换</h3><p><span class="math display">\[\begin{bmatrix}i_1 &amp; j_1 &amp; k_1\\i_2 &amp; j_2 &amp; k_2\\i_3 &amp; j_3 &amp; k_3\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}=x\begin{bmatrix}i_1\\i_2\\i_3\end{bmatrix}+y\begin{bmatrix}j_1\\j_2\\j_3\end{bmatrix}+z\begin{bmatrix}k_1\\k_2\\k_3\end{bmatrix}\]</span></p><p><span class="math inline">\(\small[i_1,i_2,i_3]&#39;,[j_1,j_2,j_3]&#39;,[k_1,k_2,k_3]&#39;\)</span>就是新的基，变换 <span class="math inline">\(\small\boldsymbol{AX}\)</span> 的结果就是将点 <spanclass="math inline">\(\boldsymbol{X}\)</span>经过坐标基的旋转伸缩变换后，点在<strong>原坐标</strong>中的表示形式。</p><h3 id="理解二新坐标轴投影">理解二：新坐标轴投影</h3><p><span class="math display">\[\begin{bmatrix}i_1 &amp; j_1 &amp; k_1\\i_2 &amp; j_2 &amp; k_2\\i_3 &amp; j_3 &amp; k_3\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}=\begin{bmatrix}\begin{bmatrix} i_1 &amp;j_1&amp;k_1\end{bmatrix}\boldsymbol{X}\\\begin{bmatrix} i_2 &amp;j_2&amp;k_2\end{bmatrix}\boldsymbol{X}\\\begin{bmatrix} i_3 &amp;j_3&amp;k_3\end{bmatrix}\boldsymbol{X}\\\end{bmatrix},\boldsymbol{X}=\begin{bmatrix}x\\y\\z\end{bmatrix}.\]</span></p><p>可以理解为点 <span class="math inline">\(\boldsymbol{X}\)</span>在各个方向向量上的投影（在乘以长度）的结果。<spanclass="math inline">\([i,j,k]\)</span>就是变换后坐标系的原坐标轴，逆变换后在原空间的表示结果。</p><h2 id="协方差矩阵与特征值理解">协方差矩阵与特征值理解</h2><h3 id="理解一旋转">理解一：旋转</h3><p>通过线性代数知识有，对于任意一对称矩阵 <spanclass="math inline">\(\boldsymbol{\Sigma}\)</span>存在一个特征值分解(eigenvalue decomposition, EVD)： <spanclass="math display">\[\boldsymbol{\Sigma}=\boldsymbol{U}\boldsymbol{\Lambda}\boldsymbol{U}^T\]</span> 其中，<spanclass="math inline">\(\boldsymbol{U}\)</span>的每一列为标准相互正交的特征向量，<spanclass="math inline">\(\boldsymbol{\lambda}\)</span>对角线上的元素是从大到小排列的特征值，非对角线上的元素均为 <spanclass="math inline">\(0\)</span> 。可以看出 <spanclass="math inline">\(\boldsymbol{\Lambda}\)</span> 与 <spanclass="math inline">\(\boldsymbol{\Sigma}\)</span>是同一个向量在不同坐标系中的表示。</p><p>也可以写作 <spanclass="math display">\[\boldsymbol{\Sigma}=\left(\boldsymbol{U}\boldsymbol{\Lambda}^{1/2}\right)\left(\boldsymbol{U}\boldsymbol{\Lambda}^{1/2}\right)^T=\boldsymbol{A}\boldsymbol{A}^T\]</span>因子分析中用的就是上式。</p><p>可以理解到，<strong>协方差矩阵的特征向量控制旋转(rotation)，特征值控制尺度(scale)</strong>，特征值的大小代表了信息量（原始特征）多少<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/37609917">[2]</span></a></sup>。</p><h3 id="理解二投影">理解二：投影</h3><p>记协方差矩阵与中心化后的样本矩阵有以下关系<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/435001757">[8]</span></a></sup>：</p><p><spanclass="math display">\[\boldsymbol{\Sigma}=\boldsymbol{A}^T\boldsymbol{A}\]</span></p><p>其特征向量与特征特征值满足</p><p><spanclass="math display">\[\boldsymbol{A}^T\boldsymbol{A}\boldsymbol{\beta}=\lambda\boldsymbol{\beta}\]</span></p><p>左右同时左乘 <spanclass="math inline">\(\small\boldsymbol{\beta}^T\)</span> 得到</p><p><spanclass="math display">\[\boldsymbol{\beta}^T\boldsymbol{A}^T\boldsymbol{A}\boldsymbol{\beta}=\boldsymbol{\beta}^T\lambda\boldsymbol{\beta}\]</span></p><p><span class="math inline">\(\small \boldsymbol{\beta}\)</span>为单位向量，化简如下：</p><p><spanclass="math display">\[\left(\boldsymbol{A}\boldsymbol{\beta}\right)^T\left(\boldsymbol{A}\boldsymbol{\beta}\right)=\lambda\]</span></p><p><span class="math inline">\(\small \boldsymbol{A}\)</span>的每行是个样本点在这里 <span class="math inline">\(\small\boldsymbol{a_i}·\boldsymbol{\beta}\)</span> 是 <spanclass="math inline">\(\small \boldsymbol{a_i}\)</span> 在 <spanclass="math inline">\(\boldsymbol{\beta}\)</span> 方向上的投影，故 <spanclass="math inline">\(\small\boldsymbol{A}\boldsymbol{\beta}\)</span>可理解为样本空间中的样本点投影到轴 <spanclass="math inline">\(\small\boldsymbol{\beta}\)</span> 上的结果， <spanclass="math inline">\(\small\left(\boldsymbol{A}\boldsymbol{\beta}\right)^T\left(\boldsymbol{A}\boldsymbol{\beta}\right)\)</span>则是投影平方和。故 <span class="math inline">\(\lambda\)</span>最大，表示投影后方差最大即信息量最大。</p><p><imgsrc="https://pic.imgdb.cn/item/622201105baa1a80ab9a2b94.png" /></p><h2 id="主成分分析的滥用">主成分分析的滥用</h2><p>参考<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="王学明. 应用多元统计分析[M].">[7]</span></a></sup>，国内以 <span class="math inline">\(\small\lambda_i/\sum\limits_{i=1}^r\lambda_i\)</span>作为权重对主成分加权得到的结果作为评价的综合评价的方法是对主成分分析思想的误用（如高惠璇老师的书中内容）。</p><p>主成分分析得到的主成分 <span class="math inline">\(\small\boldsymbol{Z}_1,\boldsymbol{Z}_2,\dotsb,\boldsymbol{Z}_r\)</span>仅使得其表示的信息量趋大，其不满足正负向性，不具有作为综合评价的条件；其次，主成分的线性组合会瓦解主成分分析在信息上的优势；主成分意义模糊，其线性组合一般没有意义。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第231页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/37609917<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://baike.baidu.com/item/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/829840<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/342659017<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/339038035<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>高惠璇. 应用多元统计分析[M].第2版. 第310页.<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>王学明. 应用多元统计分析[M].<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/435001757<a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主成分分析</tag>
      
      <tag>相关系数矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聚类分析</title>
    <link href="/2022/02/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>聚类分析（Cluster Analysis）<br />又称为群分析，是对多个样本(或指标)进行定量分类的一种多元统计分析。对样本进行分析称为<strong>Q型聚类分析</strong>，对指标进行分类称为<strong>R型聚类分析</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第216页.">[1]</span></a></sup>。聚类与分类的不同在于，聚类所要求划分的类是未知的。</p><p>聚类是将数据分类到不同的类或者簇这样的一个过程，所以同一个簇中的对象有很大的相似性，而不同簇间的对象有很大的相异性<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/3450227">[2]</span></a></sup>。组内相似性越大，组间差距越大，说明聚类效果越好。</p><p>聚类效果的好坏依赖于两个因素：1.<strong>衡量距离的方法（distancemeasurement）</strong>2.<strong>聚类算法（algorithm）</strong><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/37856153">[3]</span></a></sup></p><h1 id="相似性衡量">相似性衡量</h1><p>相似性衡量（similarity measurement）<br />可近似为距离的计算（distance measurement）<br />距离，是抽象化的相似程度度量，不同的数据类型有着不同的距离计算方法，我们需要用数量化的方法刻画事物之间的相似程度。</p><h2 id="样本间距离度量">1. 样本间距离度量</h2><p>对于 <span class="math inline">\(m\)</span>个指标描述的样本可以看成是 <spanclass="math inline">\(\bold{R}^m\)</span>空间中的一个点，自然用距离衡量样本的相似度。</p><h3 id="数值变量">1.1 数值变量</h3><p>在做距离计算前，还需要对数据做<strong>标准化</strong>处理 <spanclass="math inline">\(x_i^*=\frac{x_i-mean_x}{S_x}\)</span>，以防止量纲的不同导致空间拉伸距离失真。</p><p><strong>闵氏(Minkowski)距离</strong>： <spanclass="math display">\[dis_q(\boldsymbol{x},\boldsymbol{y})=[\sum_{k=1}^{m}|x_k-y_k|^q]^{\frac{1}{q}}\]</span></p><p>以下均为闵氏(Minkowski)距离的子式</p><ul><li><p>曼哈顿(Manhattan)距离：<span class="math inline">\(q=1\)</span>时 <spanclass="math display">\[dis_q(\boldsymbol{x},\boldsymbol{y})=\sum_{k=1}^{m}|x_k-y_k|\]</span></p></li><li><p>欧几里得(Euclid)距离：<span class="math inline">\(q=2\)</span> 时（<strong>坐标轴正交旋后转保持不变</strong>） <spanclass="math display">\[dis_q(\boldsymbol{x},\boldsymbol{y})=\sqrt{\sum_{k=1}^{m}|x_k-y_k|^2}\]</span></p></li><li><p>切比雪夫(Chebyshev)距离：<spanclass="math inline">\(q\to+\infty\)</span> 时 <spanclass="math display">\[dis(\boldsymbol{x},\boldsymbol{y})=\max_{1\leqslantk\leqslant m}|x_k-y_k|\]</span></p></li></ul><p>对于不同的指标有不同的权重，还可以对上述公式的距离加权。将上述式子中<span class="math inline">\(|x_k-y_k|\)</span> 替换为 <spanclass="math inline">\(w_k|x_k-y_k|\)</span>(第一个和第三个式子会使加权与结果非线性)。此外使用闵氏(Minkowski)距离时，变量的多重相关性(Multicollinearity)会导致信息重叠，片面强调某些变量的重要性。因为上述缺点，一种改进的距离是马氏距离<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第216页.">[1]</span></a></sup>。</p><ul><li>马氏(Mahalanobis)距离： <spanclass="math display">\[dis(\boldsymbol{x},\boldsymbol{y})=\sqrt{(\boldsymbol{x}-\boldsymbol{y})^{T}\boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{y})}\]</span>其中：<span class="math inline">\(\boldsymbol{x},\boldsymbol{y}\)</span>来自总体 <span class="math inline">\(Z\)</span> 的样本观测值；<spanclass="math inline">\(\boldsymbol{\Sigma}\)</span> 为 <spanclass="math inline">\(Z\)</span> 的协方差矩阵。</li></ul><p><strong>马氏距离对一切线性变换是不变的</strong>，故而不受量纲影响。</p><p>根据聚类分析目的或者指标的不同，还可以使用夹角余弦等方法度量相似度（数据挖掘拓展）。</p><h3 id="二元变量">1.2 二元变量</h3><p>构造二元变量为0-1虚拟变量 |Name|指标1|指标2|指标3|指标4|指标5|指标6||:-:|:-:|:-:|:-:|:-:|:-:|:-:| |Eirc|1|0|1|1|0|0| |Freddie|1|0|0|1|1|1||Dramwig|0|1|1|1|1|0|</p><p>构造列联表</p><table><thead><tr class="header"><th style="text-align: center;">X</th><th style="text-align: center;">1</th><th style="text-align: center;">0</th><th style="text-align: center;">sum</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">a</td><td style="text-align: center;">b</td><td style="text-align: center;">a+b</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">c</td><td style="text-align: center;">d</td><td style="text-align: center;">c+d</td></tr><tr class="odd"><td style="text-align: center;">sum</td><td style="text-align: center;">a+c</td><td style="text-align: center;">b+d</td><td style="text-align: center;">a+b+c+d</td></tr></tbody></table><p>构造 <spanclass="math display">\[dis(X,Y)=\frac{b+c}{a+b+c}\]</span></p><h3 id="分类变量">1.3 分类变量</h3><ul><li>简单匹配：<spanclass="math inline">\(dis(X,Y)=\frac{p-m}{p}\)</span>p为类别数，m为配对数</li><li>二元化：<spanclass="math inline">\(Categories:\{C_1,C_2,C_3\}\)</span> <spanclass="math inline">\(\to\)</span> <spanclass="math inline">\(C_1:\{0,1\}\)</span> ; <spanclass="math inline">\(C_2:\{0,1\}\)</span> ; <spanclass="math inline">\(C_3:\{0,1\}\)</span>,</li></ul><h3 id="有序变量">1.4 有序变量</h3><ol type="1"><li>记序列为<span class="math inline">\(rank\to[1\dots N]\)</span></li><li>z-scores来标准化 <span class="math inline">\(r_i/N\)</span> 得 <spanclass="math inline">\(r\in [0,1]\)</span></li><li>计算马氏(Minkowski)距离</li></ol><h2 id="类与类间距度量">2. 类与类间距度量</h2><p>记两个类分别为 <span class="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span>，有以下方法度量类间距。</p><ul><li><p>最短距离法（Nearest Neighbor or Single Linkage Method）： <spanclass="math display">\[D(G_1,G_2)=\min_{\tiny{\boldsymbol{x_i}\inG_1,\boldsymbol{y_j}\in G_2}}{dis(\boldsymbol{x_i},\boldsymbol{y_j})}\]</span></p></li><li><p>最长距离法（Farthest Neighbor or Complete Linkage Method）：<span class="math display">\[D(G_1,G_2)=\max_{\tiny{\boldsymbol{x_i}\inG_1,\boldsymbol{y_j}\in G_2}}{dis(\boldsymbol{x_i},\boldsymbol{y_j})}\]</span></p></li><li><p>重心法（Centetoid Method） <spanclass="math display">\[D(G_1,G_2)=dis(\boldsymbol{\bar{x}},\boldsymbol{\bar{y}})\]</span></p></li><li><p>类平均法（Group AverageMethod）(被<strong>认为是最常用也最好用的方法</strong>其单调性良好，空间扩张/浓缩的程度适中)<spanclass="math display">\[D(G_1,G_2)=\frac{1}{n_1n_2}\sum_{\boldsymbol{x_i}\inG_1}\sum_{\boldsymbol{y_j}\inG_2}dis(\boldsymbol{x_i},\boldsymbol{y_j})\]</span></p></li><li><p>离差平方和法（Sum of Squares Method）又称 Ward 方法</p></li></ul><p>记 <span class="math display">\[D_1=\sum_{\boldsymbol{x_i}\inG_1}(\boldsymbol{x_i-\boldsymbol{\bar{x}}})^{T}(\boldsymbol{x_i-\boldsymbol{\bar{x}}}),D_2=\sum_{\boldsymbol{y_j}\inG_2}(\boldsymbol{y_j-\boldsymbol{\bar{y}}})^{T}(\boldsymbol{y_j-\boldsymbol{\bar{y}}})\]</span></p><p><span class="math display">\[D_{12}=\sum_{\boldsymbol{z_k}\in G_1\cupG_2}(\boldsymbol{z_k-\boldsymbol{\bar{z}}})^{T}(\boldsymbol{z_k-\boldsymbol{\bar{z}}})\]</span></p><p>定义 <spanclass="math display">\[D(G_1,G_2)=D_{12}-D_1-D_2\]</span></p><p>含义：<span class="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> 内点很聚集 <spanclass="math inline">\(D_1\)</span>、<spanclass="math inline">\(D_2\)</span> 就会很小，即自聚为一类；<spanclass="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> 相聚很远则 <spanclass="math inline">\(D_{12}\)</span> 很大，即 <spanclass="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> 充分分离。</p><h2 id="指标间距离度量">3. 指标间距离度量</h2><ul><li>相关系数</li></ul><p><spanclass="math display">\[r_{jk}=\frac{\sum\limits_{i=1}^{n}(x_{ij}-\bar{x}_j)(x_{ik}-\bar{x}_k)}{[\sum\limits_{i=1}^{n}(x_{ij}-\bar{x}_j)^2\sum\limits_{i=1}^{n}(x_{ik}-\bar{x}_k)^2]^{\frac{1}{2}}}\]</span></p><ul><li>夹角余弦</li></ul><p><spanclass="math display">\[r_{jk}=\frac{\sum\limits_{i=1}^{n}x_{ij}x_{ik}}{(\sum\limits_{i=1}^{n}x_{ij}^2\sum\limits_{i=1}^{n}x_{ik}^2)^{\frac{1}{2}}}\]</span></p><h1 id="聚类算法">聚类算法</h1><p>聚类算法多种多样，搭配上不同的相似性衡量算法对于聚类结果有巨大的差异。一下只给出了几种最根本的聚类算法，其他算法大都是在此基础上的优化与改进。<ahref="https://www.zhihu.com/question/34554321/answer/64372216">这个回答</a>可以窥视向外的拓展。</p><h2 id="k-均值聚类k-means">K-均值聚类(k-means)</h2><h3 id="步骤">步骤</h3><p>迭代算法如下： 1. 随机得到 K 个初始质心，每一个质心代表一个类 2.扫描所有样本点，把每个点划归到到离它最近的质心的簇类中 3.重新计算每个类的质心。 4. 重复 2. 和 3. 5.直到分类/质心不在发生变化时结束</p><figure><img src="https://s2.loli.net/2022/02/13/wtx935INsrcuWZA.png"alt="迭代" /><figcaption aria-hidden="true">迭代</figcaption></figure><h3 id="spss">SPSS</h3><p>SPSS-分析-分类-K均值聚类</p><h3 id="缺陷">缺陷</h3><ol type="1"><li>每次计算需要给定簇数目K</li><li>对孤立点（异常点）敏感，（会产生孤立点为单独一类的情况）</li><li>对于初始值敏感</li><li>k-means不能解决非凸（non-convex）数据（不规则形状聚类）</li></ol><h2 id="层次系统聚类hierarchical">层次(系统)聚类(Hierarchical)</h2><h3 id="步骤-1">步骤</h3><ol type="1"><li>迭代步骤<ol type="1"><li>把每个样本作为单独一个类，计算类与类之间的距离，用邻近度矩阵记录</li><li>将邻接矩阵中最小的距离连接的类归为一类</li><li>根据新的类，更新邻近度矩阵（若以类中样本间最短距离为类距离则不需要更新）</li><li>重复2. 3.</li><li>到只只剩下一个类的时候，停止</li></ol></li><li>画出<strong>聚类谱系图</strong>（SPSS自带）</li><li>画出<strong>聚合系数折线图</strong><ol type="1"><li>对于每个聚合类别，计算每个类 <spanclass="math inline">\(C_k\)</span> 的畸变程度：<spanclass="math inline">\(\sum\limits_{\tiny\boldsymbol{x}_i\inC_k}|\boldsymbol{x}_i-\boldsymbol{\bar{x}}|^2\)</span></li><li>计算所有类的总畸变程度，即聚合系数：<spanclass="math inline">\(J=\sum\limits_{k=1}^{K}\sum\limits_{\tiny\boldsymbol{x}_i\inC_k}|\boldsymbol{x}_i-\boldsymbol{\bar{x}}|^2\)</span></li><li>以聚合类别数 <span class="math inline">\(K\)</span>为横坐标，以聚合系数 <span class="math inline">\(J\)</span>为纵坐标</li></ol></li><li>通过肘部法则（Elbow Method）判断最优聚合数量，得到聚类结果</li></ol><p><img src="https://s2.loli.net/2022/02/13/1RztJXYsvk2j735.png" /></p><p>以上是凝聚(agglomerative)途径，即自下而上方法，还可以使用分裂(divisive)的途径。</p><p>自下而上法就是一开始每个个体（object）都是一个类，然后根据linkage寻找同类，最后形成一个“类”；自上而下法就是反过来，一开始所有个体都属于一个“类”，然后根据linkage排除异己，最后每个个体都成为一个“类”<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/34554321/answer/64372216">[4]</span></a></sup>。</p><h3 id="spss-1">SPSS</h3><p>SPSS-分析-分类-系统聚类</p><h2 id="基于密度的dbscan算法">基于密度的DBSCAN算法</h2><p>DBSCAN(Density-based spatial clustering of applications withnoise)<br />是一种基于密度的聚类方法，该方法能在具有噪声的空间数据库中发现任意形状的簇，可将密度足够大的相邻区域连接，能有效处理异常数据。</p><p><img src="https://s2.loli.net/2022/02/13/xIaSo6GKqC71tJr.png" /></p><h3 id="基本概念">基本概念</h3><ul><li>核心点：在该点半径 <span class="math inline">\(Eps\)</span>内含的点数不少于 <span class="math inline">\(MinPts\)</span></li><li>边界点：在该点半径 <span class="math inline">\(Eps\)</span>内点的数量小于 <spanclass="math inline">\(MinPts\)</span>，但是落在核心点的半径 <spanclass="math inline">\(Eps\)</span> 邻域内</li><li>噪音点：既不是核心点也不是边界点的点，即不在核心点的半径 <spanclass="math inline">\(Eps\)</span> 邻域内的点</li></ul><p><ahref="https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/">DBSCAN密度聚类可视化</a></p><figure><img src="https://s2.loli.net/2022/02/13/JF8HMDxkIcdKlwf.png"alt="密度聚类" /><figcaption aria-hidden="true">密度聚类</figcaption></figure><h3 id="缺点">缺点</h3><ul><li>对输入参数 <code>Eps</code> 和 <code>Minpts</code>敏感，确定参数困难，不同参数相差很大</li><li>时间复杂度高，处理大量数据时慢</li></ul><h2 id="根据网格单元的聚类">根据网格单元的聚类</h2><p>其原理是将数据空间划分为网格单元，将数据对象映射到网格单元中，并计算每个单元的密度。根据预设阈值来判断每个网格单元是不是高密度单元，由邻近的稠密单元组成“类”<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/37856153">[3]</span></a></sup>。</p><p><imgsrc="https://pic3.zhimg.com/e76863bafda37b0313d39f5338540488_r.jpg?source=1940ef5c" /></p><h3 id="步骤-2">步骤</h3><p>1.将数据空间划分为网格单元 2.依照设置的阈值，判定网格单元是否稠密3.合并相邻稠密的网格单元为一类</p><h3 id="特点">特点</h3><ul><li>优点<ul><li>效率快速度快</li><li>直观易于理解</li></ul></li><li>缺点<ul><li>拟合较为粗糙，分类不精确，无法处理不规则分布的数据</li><li>对输入参数敏感，难以确定方格宽以及稠密阈值，方格宽以及稠密阈值对结果影响很大</li></ul></li></ul><h2 id="基于概率的聚类">基于概率的聚类</h2><p>Model-based methods<br />这一类方法主要是指基于概率模型的方法和基于神经网络模型的方法，尤其以基于概率模型的方法居多。这里的概率模型主要指概率生成模型（generativeModel），同一”类“的数据属于同一种概率分布<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/34554321/answer/64372216">[4]</span></a></sup>。</p><p><imgsrc="https://pic3.zhimg.com/2bf5b20d2e44e3db4c55efde8209558c_r.jpg?source=1940ef5c" /></p><h1 id="数据简化">数据简化</h1><ul><li><strong>变换（Data Transformation）</strong>：<ul><li>离散傅里叶变换（Discrete FourierTransformation）可以提取数据的频域（frequency domain）信息</li><li>离散小波变换（Discrete WaveletTransformation）除了频域之外，还可以提取到时域（temporaldomain）信息<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/34554321/answer/64372216">[4]</span></a></sup></li></ul></li><li><strong>降维（Dimensionality Reduction）</strong>：<ul><li>线性方法<ul><li>PCA（Principle Component Analysis）</li><li>SVD（Singular Value Decomposition）</li><li>MDS（Multi-Dimensional Scaling）PCA拓展</li></ul></li><li>非线性降维的算法<ul><li>流形学习（Manifold Learning）<ul><li>ISOMAP、</li><li>LLE（Locally Linear Embedding）、</li><li>MVU（Maximum variance unfolding）、</li><li>Laplacian eigenmaps、Hessian eigenmaps、</li><li>Kernel PCA、</li><li>Probabilistic PCA</li></ul></li></ul></li></ul></li><li><strong>抽样（Sampling）</strong>：<ul><li>随机抽样</li></ul></li></ul><h1 id="三大步骤的综合">三大步骤的综合</h1><p>对于聚类分析三大步骤：</p><ol type="1"><li>相似性衡量：距离、相似系数、核函数、DTW（dynamic time warping）</li><li>聚类算法：Hierarchical methods、Partition-basedmethods、Density-based methods、Grid-based methods、Model-basedmethods</li><li>数据简化：变换、降维、抽样</li></ol><p>其中每个二级分类下含有多种方法。三个步骤每个选择一个方法可以组合出庞大数量的聚类模型。</p><p>例如：<strong>谱聚类（SpectralClustering）</strong>，就是先用Laplacianeigenmaps对数据降维（简单地说，就是先将数据转换成邻接矩阵或相似性矩阵，再转换成Laplacian矩阵，再对Laplacian矩阵进行特征分解，把最小的K个特征向量排列在一起），然后再使用k-means完成聚类。谱聚类是个很好的方法，效果通常比k-means好，计算复杂度还低，这都要归功于降维的作用<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/34554321/answer/64372216">[4]</span></a></sup>。</p><h1 id="参考">参考</h1><ul><li>这里非常感谢知乎答主<ahref="https://www.zhihu.com/people/guo-xiao-xian-24"><spanclass="citation"data-cites="郭小天">@郭小天</span></a>的分享给了我很大启发</li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第216页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/3450227<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/37856153<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://www.zhihu.com/question/34554321/answer/64372216<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类距离</tag>
      
      <tag>K-均值聚类</tag>
      
      <tag>层次聚类</tag>
      
      <tag>DBSCAN算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分类模型</title>
    <link href="/2022/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>判别分析是在已知研究对象分成若干类型并已经取得各种类型的一批已知样本的观测数据，在此基础上根据某些准则建立判别式，然后对未知类型的样品进行判别分析。</p><h1 id="回归">0-1回归</h1><p>即采用逻辑回归(logistic regressio)<br />把观测数据作为因变量对虚拟变量(0,1)进行回归，将y看作事件0发生的概率。</p><h2 id="模型构造">模型构造</h2><h3 id="构造线性概率模型">构造线性概率模型</h3><p><span class="math display">\[y_{i}=\beta_{0}+\beta_{1} x_{1i}+\beta_{2} x_{2 i}+\cdots+\beta_{k} x_{k i}+\mu_{i}\]</span></p><p>㝍成向量乘积形式: <spanclass="math inline">\(y_{i}=\boldsymbol{x}_{i}^{\prime}\boldsymbol{\beta}+u_{i}(i=1,2, \cdots, n)\)</span></p><h3 id="构造两点分布">构造两点分布</h3><p><span class="math display">\[\left\{\begin{array}{l}P(y=1 \mid \boldsymbol{x})=F(\boldsymbol{x}, \boldsymbol{\beta}) \\P(y=0 \mid \boldsymbol{x})=1-F(\boldsymbol{x}, \boldsymbol{\beta})\end{array} \text { 注: 一般 } F(\boldsymbol{x},\boldsymbol{\beta})=S\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)\right.\]</span></p><h3 id="构造连接函数">构造连接函数</h3><p>要使 <spanclass="math inline">\(F(\boldsymbol{x},\boldsymbol{\beta})\)</span>为值域 <span class="math inline">\([0,1]\)</span>上的函数。构造以下函数：</p><ol type="1"><li><spanclass="math inline">\(F(\boldsymbol{x},\boldsymbol{\beta})\)</span>取正态分布累计密度函数<span class="math inline">\((cdf)\)</span> <spanclass="math display">\[\begin{array}{c}F(\boldsymbol{x},\boldsymbol{\beta})=\Phi\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)=\int_{-\infty}^{\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}} \frac{1}{\sqrt{2 \pi}} e^{-\frac{t^{2}}{2}} d t \\\color{Red} (\text { probit 回归 })\end{array}\]</span></li><li><spanclass="math inline">\(F(\boldsymbol{x},\boldsymbol{\beta})\)</span>取<span class="math inline">\(Sigmoid\)</span>函数 <spanclass="math display">\[\begin{aligned}F(\boldsymbol{x}, \boldsymbol{\beta})=&amp;S\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right)=\frac{\exp\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right)}{1+\exp\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right)} \\&amp; \color{Red} (\text{ logistic回归  })\end{aligned}\]</span></li></ol><h3 id="参数求解">参数求解</h3><p>对于非线性模型采用极大似然估计法(MLE)估计： <spanclass="math display">\[f\left(y_{i} \mid \boldsymbol{x}_{i},\boldsymbol{\beta}\right)=\left\{\begin{array}{ll}S\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right) &amp; ,y_{i}=1 \\1-S\left(\boldsymbol{x}_{i}^{\prime} \boldsymbol{\beta}\right) &amp; ,y_{i}=0\end{array}\right.\]</span> 即 <span class="math display">\[f\left(y_{i}\mid \boldsymbol{x}_{i},\boldsymbol{\beta}\right)=\left[S\left(\boldsymbol{x}_{i}^{\prime}\boldsymbol{\beta}\right)\right]^{y_{i}}\left[1-S\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)\right]^{1-y_{i}}\]</span> 取对数 <spanclass="math display">\[\ln f\left(y_{i} \mid \boldsymbol{x}_{i},\boldsymbol{\beta}\right)=y_{i} \ln\left[S\left(\boldsymbol{x}_{i}^{\prime}\boldsymbol{\beta}\right)\right]+\left(1-y_{i}\right) \ln\left[1-S\left(\boldsymbol{x}_{i}^{\prime}\boldsymbol{\beta}\right)\right]\]</span> 得到样本对数似然函数 <spanclass="math display">\[\left.\ln L(\boldsymbol{\beta} \mid\boldsymbol{y}, \boldsymbol{x})=\sum_{i=1}^{n} y_{i} \ln\left[S\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)\right]+\sum_{i=1}^{n}\left(1-y_{i}\right) \ln\left[1-S\left(\boldsymbol{x}_{\boldsymbol{i}}^{\prime}\boldsymbol{\beta}\right)\right]\right.\]</span>求这个函数的最大化。</p><h3 id="求准确率">求准确率</h3><p>把数据分为<strong>训练组</strong>和<strong>测试组</strong>，一般取80%和20%，多次随机抽选训练组和测试组，对模型求一个平均的准确率(交叉验证)。</p><p><img src="https://s2.loli.net/2022/02/12/YVulZUi73kohRfN.png" /></p><h2 id="思考">思考</h2><p>对于这个模型 <span class="math inline">\(\hat{y}\)</span>理解为为事件“<span class="math inline">\(y=1\)</span>”发生的概率</p><p><span class="math display">\[\hat{y}_{i}=P\left(y_{i}=1 \mid\boldsymbol{x}\right)=S\left(\boldsymbol{x}_{i}^{\prime}\hat{\boldsymbol{\beta}}\right)=\frac{\exp\left(\boldsymbol{x}_{i}^{\prime}\hat{\boldsymbol{\beta}}\right)}{1+\exp\left(\boldsymbol{x}_{i}^{\prime}\hat{\boldsymbol{\beta}}\right)}=\frac{e^{\widehat{\beta}_{0}+\widehat{\beta}_{1}x_{1 i}+\widehat{\beta}_{2} x_{2 i}+\cdots+\widehat{\beta}_{k} x_{ki}}}{1+e^{\widehat{\beta}_{0}+\widehat{\beta}_{1} x_{1i}+\widehat{\beta}_{2} x_{2 i}+\cdots+\widehat{\beta}_{k} x_{ki}}}\]</span></p><p>对于 <span class="math inline">\(S\left(\boldsymbol{x}_{i}^{\prime}\hat{\boldsymbol{\beta}}\right)=\frac{1}{2}\)</span> 即</p><p><span class="math display">\[{\widehat{\beta}_{0}+\widehat{\beta}_{1}x_{1 i}+\widehat{\beta}_{2} x_{2 i}+\cdots+\widehat{\beta}_{k} x_{ki}}=0\]</span></p><p>可以看作一个超平面（ <span class="math inline">\(k=2\)</span>时是直线）。该分类的本质就是找到一个“曲线”把 '<spanclass="math inline">\(y=0\)</span>' 和 '<spanclass="math inline">\(y=1\)</span>' 分割到曲线的两侧。</p><h1 id="fisher线性判别分析">Fisher线性判别分析</h1><p>线性判别式分析(Linear Discriminant Analysis, LDA)<br />也叫做Fisher线性判别(Fisher Linear Discriminant ,FLD)</p><p>基本思想：选取适当的投影方向<strong>将高维数据投影到低维空间上</strong>使得投影后各样本类<strong>内离差</strong>平方和尽可能小，而使各样本类间的离差平方和尽可能大<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.jianshu.com/p/cd5ac0b95c03">[2]</span></a></sup>。即，使得在子空间上有最佳的可分离性。</p><figure><img src="https://s2.loli.net/2022/02/12/Eusi4l2NkGBMZj1.png"alt="LDA.png" /><figcaption aria-hidden="true">LDA.png</figcaption></figure><h2 id="一维压缩的fisher判别模型">一维压缩的Fisher判别模型</h2><p>Fisher判别可以将 <span class="math inline">\(C\)</span> 维指标压缩到<span class="math inline">\([1,C-1]\)</span>纬空间。这里只解释将样本压缩到一维的情况。</p><p>设样本数据集为 <spanclass="math inline">\(\{\boldsymbol{D_1},\boldsymbol{D_2}\}\)</span>(二维指标)， <span class="math inline">\(\boldsymbol{X_i}\)</span> 是第<span class="math inline">\(i\)</span> 类样本的集合 ，<spanclass="math inline">\(X_i\)</span> 是第 <spanclass="math inline">\(i\)</span> 类样本的集合，第 <spanclass="math inline">\(i\)</span> 个集合样本是数目是 <spanclass="math inline">\(N_i\)</span> ，<spanclass="math inline">\(x=(d_1,d_2)\)</span>。最佳的向量称为 <spanclass="math inline">\(\boldsymbol{w}\)</span><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/137968371">[4]</span></a></sup>。</p><p>记 <span class="math inline">\(\mu_i\)</span> 为第i类样本质心，为<span class="math display">\[\mu_{i}=\frac{1}{N_{i}} \sum_{x \in\boldsymbol{X_{i}}} x\]</span></p><p><span class="math inline">\(x\)</span> 到 <spanclass="math inline">\(\boldsymbol{w}\)</span> 投影后的样本点均值为</p><p><span class="math display">\[\tilde{\mu}_{i}=\frac{1}{N_{i}} \sum_{x\in  \boldsymbol{X}_{i}} y=\frac{1}{N_{i}} \sum_{x\in  \boldsymbol{X}_{i}} \boldsymbol{w}^{T} x=\boldsymbol{w}^{T}\mu_{i}\]</span></p><p><strong>类间方差最大化</strong>，那么就是要让 <spanclass="math inline">\(J(\boldsymbol{w})\)</span> 最大</p><p><spanclass="math display">\[J(\boldsymbol{w})=\left|\tilde{\mu}_{1}-\tilde{\mu}_{2}\right|=\left|\boldsymbol{w}^{T}\left(\mu_{1}-\mu_{2}\right)\right|\]</span></p><p>但是只满足这一个条件并不行，两个类达到了类间方差最大化的条件，但是可能轴上的投影两个类重合的部分太多，无法进行有效的区分。</p><p><strong>类内方差最小化</strong></p><p>对于类内方差，使用另外一个值<strong>散列值（scatter）</strong>，计算方法如果下，其实就是投影值与中心之间的方差和。目的就是使这个值最小。</p><p><span class="math display">\[\tilde{s_{i}}^{2}=\sum_{y \in\boldsymbol{Y}_{i}}\left(y-\tilde{\mu}_{i}\right)^{2},(y=\boldsymbol{w}^Tx)\]</span></p><p>最后，我们结合这两个条件</p><p><spanclass="math display">\[J(\boldsymbol{w})=\frac{\left|\tilde{\mu_{1}}-\tilde{\mu_{2}}\right|}{\tilde{s_{1}}^{2}+\tilde{s_{2}}^{2}}\]</span></p><p>我们要做的就是让 <spanclass="math inline">\(J(\boldsymbol{w})\)</span> 最大。<ahref="https://blog.csdn.net/antkillerfarm/article/details/80880221">推导过程</a></p><p>结论：</p><p><span class="math display">\[S_{i}=\sum_{x \in\omega_{i}}\left(x-\mu_{i}\right)\left(x-\mu_{i}\right)^{T}\]</span></p><p><span class="math display">\[S_{W}=S_{1}+S_{2}\]</span></p><p><spanclass="math display">\[\boldsymbol{w}=S_{W}^{-1}\left(\mu_{1}-\mu_{2}\right)\]</span></p><h2 id="思考-1">思考</h2><p><imgsrc="https://img-blog.csdnimg.cn/20190516120230815.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpbmFwcGxlTWk=,size_16,color_FFFFFF,t_70" /></p><p><strong>主成分分析(PCA)</strong>:是找到方差尽可能大的维度，使得信息尽可能都保存，不考虑样本的可分离性，不具备预测功能。</p><p><strong>线性判别分析(LAD)</strong>:是找到一个低维的空间，投影后，使得可分离性最佳(保留信息趋少)，投影后可进行判别以及对新的样本进行预测<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/PinappleMi/article/details/90261680">[3]</span></a></sup>。</p><p>相较于压缩至一维空间，压缩到二维平面或超平面上常常更能分离出不同的样本。<img src="https://s2.loli.net/2022/02/12/6gjoFQa8Hy5NWR9.png" /></p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>清风数学建模<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.jianshu.com/p/cd5ac0b95c03<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://blog.csdn.net/PinappleMi/article/details/90261680<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/137968371<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>0-1回归</tag>
      
      <tag>Fisher线性判别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回归分析</title>
    <link href="/2022/02/08/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/08/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="多元线性回归">多元线性回归</h1><h2 id="模型结构">模型结构</h2><p>多元线性回归是研究一个应变量依赖多个自变量的变化关系，并用线性关系刻画的模型。如下：</p><p><span class="math display">\[\left\{\begin{matrix}y = \beta_0 + \beta_1 x_1 + \cdots + \beta_mx_m + \varepsilon\\\varepsilon \sim N(0,\sigma ^2)\end{matrix}\right.\]</span></p><p>其中：<spanclass="math inline">\(\beta_0,\beta_1,\dotsb,\beta_m\)</span>为回归系数；<span class="math inline">\(x_0,x_1,\dotsb,x_m\)</span>为变量；<span class="math inline">\(\varepsilon\)</span>是误差随机项。</p><p>对于 <span class="math inline">\(n\)</span> 组观测，满足 <spanclass="math inline">\(y_i=\beta_{0} + \beta_1 x_{i1} + \cdots +\beta_mx_{im} + \varepsilon_i\)</span> ,记</p><p><span class="math display">\[\boldsymbol{Y}=\left[\begin{array}{l}y_{1} \\y_{2} \\\vdots \\y_{n}\end{array}\right] \quad, \quad \boldsymbol{X}=\left[\begin{array}{cccc}1 &amp; x_{11} &amp; \ldots &amp; x_{1m} \\1 &amp; x_{21} &amp; \ldots &amp; x_{2m} \\\vdots &amp; \vdots &amp; &amp; \vdots \\1 &amp; x_{n1} &amp; \ldots &amp; x_{nm}\end{array}\right] \quad, \quad\boldsymbol{\beta}=\left[\begin{array}{c}\beta_{0} \\\beta_{1} \\\vdots \\\beta_{k}\end{array}\right] \quad, \quad\boldsymbol{\varepsilon}=\left[\begin{array}{c}\varepsilon_{1} \\\varepsilon_{2} \\\vdots \\\varepsilon_{n}\end{array}\right]\]</span></p><p>这时模型可以写作:</p><p><span class="math display">\[\boldsymbol{Y}=\boldsymbol{X}\boldsymbol{\beta}+\boldsymbol{\varepsilon}\]</span></p><h2 id="参数估计">参数估计</h2><p>模型中的参数 <spanclass="math inline">\(\beta_0,\beta_1,\dotsb,\beta_m\)</span>用最小二乘法估计，得到估计值 <spanclass="math inline">\(\hat{\beta}_{i}\)</span> 。</p><p>需要最小化的函数是：</p><p><span class="math display">\[SSE = Q\left(\beta_{0}, \beta_{1},\ldots,\beta_{p}\right)=\sum_{i=1}^{n}(y_i-\hat{y_i})^2=\sum_{i=1}^{n}\left(y_{i}-\beta_{0}-\beta_{1}x_{i 1}-\ldots-\beta_{p} x_{i p}\right)^{2}\]</span></p><p>为此，令 <span class="math display">\[\frac{\partial Q}{\partial\beta _j} =0,(j=0,1,\dots ,m)\]</span></p><p>解得(详细过程参考<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/48541799">[3]</span></a></sup>或<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第150页.">[1]</span></a></sup>)： <spanclass="math display">\[\boldsymbol{\hat{\beta}}=\left(\boldsymbol{X}^{T}\boldsymbol{X}\right)^{-1} \boldsymbol{X}^{T}\boldsymbol{Y}\]</span></p><p>记 <spanclass="math inline">\(\boldsymbol{\hat{Y}}=\boldsymbol{X}\boldsymbol{\hat{\beta}}\)</span>，<spanclass="math inline">\(\boldsymbol{e}=\boldsymbol{Y}-\boldsymbol{\hat{Y}}\)</span>为残差，而 <span class="math inline">\(SSE=\sum e_i^2\)</span>为残差平方和<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第150页.">[1]</span></a></sup>。</p><h2 id="显著性检验">显著性检验</h2><h3 id="方程显著性检验">方程显著性检验</h3><p>检验这个回归方程本身是否有效。我们给出下列原假设和备择假设： <spanclass="math display">\[ H_0: \beta_j=0 , j=1,2,\dots,m\\H_1: \beta_1,\dots,\beta_m 不全为 0\]</span> 当假设 <spanclass="math inline">\(H_0\)</span> 成立时，满足： <spanclass="math display">\[F=\frac{SSR/m}{SSE/(n-m-1)} \simF(m,n-m-1)\]</span></p><p>式中, <spanclass="math inline">\(SSR=\sum_{i=1}^{n}\left(\hat{y}_{i}-\bar{y}\right)^{2}\)</span>是回归平方和； <spanclass="math inline">\(SSE=\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}\)</span>是残差平方和。再给定的 显著性水平 <spanclass="math inline">\(\alpha\)</span> 下，对于上 <spanclass="math inline">\(\alpha\)</span> 分位数 <spanclass="math inline">\(F_{\alpha}(k, n-k-1)\)</span> ， 检验的拒绝域为<span class="math inline">\(F&gt;F_{\alpha}(k, n-k-1)\)</span>接受域可以为：<span class="math inline">\(F_{1-\alpha/2}(k,n-k-1)&lt;F&lt;F_{\alpha/2}(k, n-k-1)\)</span>。</p><blockquote><p>上式，书上是这样写的，但是好像写错了。 (22.2.8)</p></blockquote><p>注：<span class="math inline">\(H_0\)</span> 仅说明 <spanclass="math inline">\(y\)</span> 与 <spanclass="math inline">\(x_1,x_2,\dots,x_m\)</span>的线性关系不明显，可能存在非线性关系(取对数)。</p><p>对于预测型回归需要检查拟合优度(<spanclass="math inline">\(R^2\)</span>)；解释型回归更多的关注模型整体显著性以及自变量的统计显著性和经济意义显著性即可。</p><p><spanclass="math display">\[R^2=\frac{SSR}{SST}=\frac{\sum_{i=1}^{n}(\hat{y_i}-\bar{y})^2}{\sum_{i=1}^{n}(y_i-\bar{y})^2}\]</span><span class="math inline">\(R\)</span> 称为复相关系数，<spanclass="math inline">\(R^2\)</span> 越大，<spanclass="math inline">\(y\)</span> 与 <spanclass="math inline">\(x_1,x_2,\dots,x_m\)</span> 相关关系越密切，通常<span class="math inline">\(R\)</span> 大于 <spanclass="math inline">\(0.8\)</span>才认为相关性成立<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第150页.">[1]</span></a></sup>,这是一个看拟合的好不好的一个综合指标。</p><h3 id="系数显著性检验">系数显著性检验</h3><p>经过上述验证得到 <span class="math inline">\(H_0\)</span>，被拒绝，<span class="math inline">\(\beta_j\)</span> 不全为 <spanclass="math inline">\(0\)</span> ,但不排除存在 <spanclass="math inline">\(\beta_j\)</span> 为 <spanclass="math inline">\(0\)</span> 。所以还要进行以下 <spanclass="math inline">\(m+1\)</span> 个检验。 <spanclass="math display">\[H_0^{(j)}：\beta_{j}=0 ,j=0,1,\cdots,m\]</span></p><p>根据无偏性和<span class="math inline">\(cov(\hat\beta)=\sigma^2(X^{T}X)^{-1}\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/heirenmin/article/details/94443404">[2]</span></a></sup>，得到 <span class="math inline">\(\hat \beta_j\sim N(\beta_j, c_{jj}\sigma^2)\)</span> ,其中 <spanclass="math inline">\(c_{jj}\)</span> 表示 <spanclass="math inline">\((X^{T}X)^{-1}\)</span> 的对角线元素 <spanclass="math inline">\((j,j)\)</span> 。考虑构造<strong>t检验</strong><span class="math inline">\(\frac{X}{\sqrt{Y/N}}\)</span>。</p><p><span class="math display">\[t=\frac{\hat\beta_j}{\sqrt{c_{jj}}\sigma}=\frac{\hat{\beta_j}/\sqrt{c_{jj}}}{\sqrt{SSE/(n-m-1)}}\sim t(n-m-1)\]</span></p><p>在 <span class="math inline">\(1-\alpha\)</span> 的置信水平下， <spanclass="math inline">\(\beta_j\)</span>的置信区间为<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="司守奎 孙兆亮. 数学建模算法与运用[M]. 第2版. 第150页.">[1]</span></a></sup>： <spanclass="math display">\[[\hat{\beta_j}-t_{\frac{\alpha}{2}}(n-m-1)s\sqrt{c_{jj}},\hat{\beta_j}+t_{\frac{\alpha}{2}}(n-m-1)s\sqrt{c_{jj}}]\]</span>其中 <span class="math inline">\(s=\sqrt{\frac{SSE}{n-m-1}}\)</span>；或者当 <spanclass="math inline">\(|t_j|&lt;t_{\frac{\alpha}{2}}(n-m-1)\)</span>判断接受 <span class="math inline">\(H_0^{(j)}\)</span> ,否则拒绝。</p><h2 id="检验异方差">检验异方差</h2><p>残差的方差齐(Equalvariance),即LINE原则。即残差的大小不随预测值水平的变化而变化，通常在分析残差的时候，可以通过绘制普通残差或者标准化残差与预测值的散点图进行判断。残差的分布随着变量的取值的增大而呈现扩散趋势产生异方差<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/161483493">[5]</span></a></sup>。</p><p>异方差是指各个扰动项的方差不相同，那么方差较大的扰动项破坏模型稳定性的程度就较大<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="清风数学建模视频">[4]</span></a></sup>；因变量的变异程度会随着自身数值或者其他变量的变化而变化，从而不满足残差方差齐性的条件<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/161483493">[5]</span></a></sup>。</p><p><img src="https://s2.loli.net/2022/02/09/ryLoOf9UKcPJqWg.png" /></p><h3 id="多种检验方法"><ahref="https://blog.csdn.net/weixin_46649908/article/details/117927359">多种检验方法</a></h3><h3 id="解决方法">解决方法</h3><ol type="1"><li>构建加权最小二乘法模型</li></ol><p>判断导致残差不满足方差齐性的指标，对其加权。</p><ol start="2" type="1"><li><p>使用“OLS + 稳健标准误”</p></li><li><p>广义最小二乘法 GLS</p></li></ol><h2 id="检验多重共线性">检验多重共线性</h2><p>方差膨胀因子(Variance Inflation Factor)VIF</p><p>假设 <span class="math inline">\(m\)</span> 个自变量中，第 <spanclass="math inline">\(j\)</span> 个自变量的 <spanclass="math inline">\(VIF=\frac{1}{1-R_{1-m/j}^2}\)</span></p><p><span class="math inline">\(R_{1-m/j}^2\)</span> 是将第 <spanclass="math inline">\(j\)</span> 个自变量作为因变量，对余下 <spanclass="math inline">\(m-1\)</span> 个自变量回归得到的拟合优度，<spanclass="math inline">\(VIF_j\)</span> 越大（也就是 <spanclass="math inline">\(R_{1-m/j}^2\)</span>越大），说明当前变量和其他变量关联度越大<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="清风数学建模视频">[4]</span></a></sup>。记模型：</p><p><spanclass="math display">\[VIF=max(VIF_1,VIF_2,\dots,VIF_m)\]</span></p><p>若，<span class="math inline">\(VIF &gt; 10\)</span>,则表示回归模型存在严重多重共线性。</p><p>注：多重共线性不影响回归方程的解释变量能力与预测能力，只会影响被多重共线性影响的变量的显著性（系数）。解决办法是增大样本或剔除共线性变量。</p><figure><img src="https://s2.loli.net/2022/02/08/tOTeL4yjENYF6ld.png"alt="用散点图观察相关性" /><figcaption aria-hidden="true">用散点图观察相关性</figcaption></figure><p>有时候逐步回归（Lasso回归）是个快捷不动脑子的做法。此外，<strong>主成分回归</strong>也可用来解决多重共线性的问题。</p><h2 id="spss实现多元线性回归">SPSS实现多元线性回归</h2><p><ahref="https://zhuanlan.zhihu.com/p/143049922">SPSS实现多元线性回归</a></p><h1 id="岭回归和lasso回归">岭回归和Lasso回归</h1><p>岭回归 (Ridge regression)<br />Lasso(Least absolute shrinkage and selection operator)回归<br />是一种压缩估计。它通过构造一个惩罚函数得到一个较为精炼的模型，使得它压缩一些回归系数。以损失部分信息、降低精度为代价获得回归系数更为符合实际、更可靠的回归方法，对病态数据的拟合要强于最小二乘法。</p><p><span class="math display">\[\left\{\begin{matrix}多元线性：\boldsymbol{\hat{\beta }} =argmin_{\hat{\beta }}\sum_{i=1}^{n}(y_i-\boldsymbol{x_i}^T \boldsymbol{\hat{\beta} } )^2，其中\boldsymbol{\hat{\beta}}=[\hat{\beta}_1,\hat{\beta}_2,\dots ]\\岭回归：\boldsymbol{\hat{\beta } }=argmin_{\hat{\beta }} [\sum_{i=1}^{n}(y_i-\boldsymbol{x_i}^T \boldsymbol{\hat{\beta}}  )^2 +\lambda \sum_{i=1}^n \hat{\beta_i}^2]，\lambda&gt;0\\Lasso回归：\boldsymbol{\hat{\beta }} =argmin_{\hat{\beta }} [\sum_{i=1}^{n}(y_i-\boldsymbol{x_i}^T \boldsymbol{\hat{\beta} } )^2 +\lambda \sum_{i=1}^n |\hat{\beta_i}|]\end{matrix}\right.\]</span></p><p>其中新增的最后一项<span class="math inline">\(\sum_{i=1}^n\hat{\beta_i}^2\)</span>称为惩罚函数。</p><p>对于岭回归有解为：</p><p><spanclass="math display">\[\boldsymbol{\widehat{\beta}}=\left(\boldsymbol{X}^{T}\boldsymbol{X}+\lambda \boldsymbol{I}\right)^{-1} \boldsymbol{X}^{T}\boldsymbol{y}\]</span></p><p>易知：<span class="math inline">\(\lambda\)</span> 趋近 <spanclass="math inline">\(0\)</span> 时，系数和多元线性回归相同；<spanclass="math inline">\(\lambda\)</span> 趋近无穷时，系数趋近 <spanclass="math inline">\(0\)</span> 。</p><p>Lasso回归相比岭回归，能将不重要的回归系数压缩至 <spanclass="math inline">\(0\)</span> ，可以进行降纬，但是没有显式解。</p><p><img src="https://s2.loli.net/2022/02/09/XOaLo1vwhMDCgbn.jpg" /></p><h1 id="多元二项式回归">多元二项式回归</h1><p>Matlab 的统计工具箱提供了多元二项式回归命令 <code>rstool</code></p><div class="hljs code-wrapper"><pre><code class="hljs matlab">rstool(X,Y,model,alpha)</code></pre></div><p>其中 <code>alpha</code> 为显著性水平（默认为 <spanclass="math inline">\(0.05\)</span>）, <code>model</code>有以下四个模型（默认为线性模型）</p><ol type="1"><li><span class="math inline">\(\operatorname{linear}( 线性 ):y=\beta_{0}+\beta_{1} x_{1}+\cdots+\beta_{m} x_{m}\)</span></li><li><span class="math inline">\(purequadratic (纯二次) :y=\beta_{0}+\beta_{1} x_{1}+\cdots+\beta_{m} x_{m}+\sum\limits_{\tinyj=1}^{\tiny m} \beta_{j j} x_{j}^{2}\)</span></li><li><span class="math inline">\(interaction(交叉) :y=\beta_{0}+\beta_{1} x_{1}+\cdots+\beta_{m} x_{m}+\sum\limits_{\tiny1\leqslant j&lt;k \leqslant m} \beta_{j k} x_{j} x_{k}\)</span></li><li><span class="math inline">\(quadratic(完全二次) :y=\beta_{0}+\beta_{1} x_{1}+\cdots+\beta_{m} x_{m}+\sum\limits_{\tiny 1\leqslant j \leqslant k \leqslant m} \beta_{j k} x_{j}x_{k}\)</span></li></ol><h1 id="非线性回归">非线性回归</h1><p>这里的“线性”是相对于模型参数 <spanclass="math inline">\(\beta_0,\beta_1,\dotsb,\beta_m\)</span>而言的。</p><p>对于此类问题，应先给出 <span class="math inline">\(y\)</span> 与<span class="math inline">\(x_1,x_2,\dots,x_n\)</span> 关于 <spanclass="math inline">\(\beta_0,\beta_1,\dotsb,\beta_m\)</span>的非线性表达式。</p><p>再使用 Matlab 的 <code>nlpredci</code> 计算回归系数。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>司守奎 孙兆亮.数学建模算法与运用[M]. 第2版. 第150页.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://blog.csdn.net/heirenmin/article/details/94443404<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/48541799<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>清风数学建模视频<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/161483493<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元线性回归</tag>
      
      <tag>多元二项式回归</tag>
      
      <tag>非线性回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插值算法</title>
    <link href="/2022/02/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.6，其中一些理解可能已被笔者证伪或废弃。</p>          </div><p><strong>定义</strong>：给定一组离散点列，要求一条曲线将点依次连接，称之为插值<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="《数学建模算法与运用》">[1]</span></a></sup>。</p><p>利用已知的点建立合适的插值函数 <spanclass="math inline">\(f(x)\)</span> ,未知点 <spanclass="math inline">\(x_i\)</span> 由插值函数 <spanclass="math inline">\(f(x)\)</span> 可以求得 <spanclass="math inline">\((x_i,f(x_i))\)</span>近似代替未知点<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/64855561">[3]</span></a></sup>。</p><p><strong>作用</strong>：利用插值曲线可以对数据进行填充——用少量模拟产生一些靠谱的新数据。</p><h1 id="分段插值">分段插值</h1><h2 id="分段线性插值">分段线性插值</h2><p>这是最简单也最基础的插值方法，折现统计图的连接方式就是用的分段线性插值。使用函数表时一般直接用该方法。</p><figure><img src="https://s2.loli.net/2022/02/06/7mO13pyTznUFW26.png"alt="某折线统计图" /><figcaption aria-hidden="true">某折线统计图</figcaption></figure><h2 id="分段二次插值">分段二次插值</h2><p>取结点 <span class="math inline">\(x_i\)</span> 以及其左右的三个节点<span class="math inline">\(x_{i-1},x_{i},x_{i+1}\)</span> 进行在区间<span class="math inline">\([x_{i-1},x_{i+1}]\)</span>的二次函数插值，即</p><p><span class="math display">\[f(x) \approxL_{2}(x)=\sum_{k=i-1}^{i+1}\left[y_{k} \prod_{j=i-1 \atop j \neqk}^{i+1}\frac{\left(x-x_{j}\right)}{\left(x_{k}-x_{i}\right)}\right]\]</span></p><p>其意义是用分段抛物线代替 <span class="math inline">\(y=f(x)\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="清风数学建模">[2]</span></a></sup>。这个方法能保证函数的连续型与一定看起来的平滑性，但是<strong>不保证函数光滑</strong>，即不保证函数可导。</p><p>分段二维插值可以很好的避免多项式插值带来的龙格效应，同时简单易于理解又能看起来平滑，是很常用的方法。</p><h1 id="多项式插值">多项式插值</h1><p>多项式插值的本质是对于 <span class="math inline">\(n+1\)</span>个互不相同的节点 <span class="math inline">\((x_i,y_i)(i=0,1,2,\dots,n)\)</span> 求得一个唯一的多项式： <spanclass="math display">\[L_{n}(x)=a_{0}+a_{1} x+a_{2} x^{2}+\ldots+a_{n}x^{n}\]</span> 使得 <span class="math inline">\(L_n(x_i)=y_i\)</span>,即 <span class="math display">\[\left[\begin{array}{cccc}1 &amp; x_{0} &amp; \cdots &amp; x_{0}^{n} \\1 &amp; x_{1} &amp; \cdots &amp; x_{1}^{n} \\\vdots &amp; \vdots &amp; \cdots &amp; \vdots \\1 &amp; x_{n} &amp; \cdots &amp; x_{n}^{n}\end{array}\right] \left[\begin{array}{c}a_{0} \\a_{1} \\\vdots \\a_{n}\end{array}\right] =\left[\begin{array}{c}y_{0} \\y_{1} \\\vdots \\y_{n}\end{array}\right]\]</span></p><p>对于上述范德蒙行列式，易得，<spanclass="math inline">\([a_1,a_2,\dotsb]\)</span> 有且仅有一组解。</p><h2 id="拉格朗日插值法">拉格朗日插值法</h2><p>上多项式组易解得</p><p><spanclass="math display">\[L(x)=y_1\frac{(x-x_2)(x-x_3)...(x-x_n)}{(x_1-x_2)(x_1-x_3)...(x_1-x_n)}+y_2\frac{(x-x_1)(x-x_3)...(x-x_n)}{(x_2-x_1)(x_2-x_3)...(x_2-x_n)}...+y_{n}\frac{(x-x_1)(x-x_2)...(x-x_{n-1})}{(x_{n}-x_1)(x_{n}-x_2)...(x_{n}-x_{n-1})}\]</span>即 <span class="math display">\[L(x)=\sum_{i=1}^{n}y_i \prod_{j=1,j\neq  i}^n \frac{x-x_j}{x_i-x_j} \]</span> 为拉格朗日插值法。</p><p><strong>注</strong>：拉格朗日插值公式在理论分析理解上很容易理解，但是若插值节点发生改变时，插值公式随之就要重新计算生成，在实际计算中会占用大量的计算量。牛顿法的出现正是克服这个问题<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/64855561">[3]</span></a></sup>。</p><h2 id="牛顿插值法">牛顿插值法</h2><p><span class="math display">\[\begin{aligned}f(x)=&amp; f\left(x_{0}\right)+f\left[x_{0},x_{1}\right]\left(x-x_{0}\right) \\&amp;+f\left[x_{0}, x_{1},x_{2}\right]\left(x-x_{0}\right)\left(x-x_{1}\right)+\cdots \\&amp;+f\left[x_{0}, x_{1}, \cdots, x_{n-2},x_{n-1}\right]\left(x-x_{0}\right)\left(x-x_{1}\right)\cdots\left(x-x_{n-3}\right)\left(x-x_{n-2}\right) \\&amp;+f\left[x_{0}, x_{1}, \cdots, x_{n-1},x_{n}\right]\left(x-x_{0}\right)\left(x-x_{1}\right)\cdots\left(x-x_{n-2}\right)\left(x-x_{n-1}\right)\end{aligned}\]</span></p><h3 id="商差">商差</h3><ul><li>一阶差商</li></ul><p><span class="math display">\[f\left[x_{i},x_{j}\right]=\frac{f\left(x_{i}\right)-f\left(x_{j}\right)}{x_{i}-x_{j}}\quad\left(i \neq j, x_{i} \neq x_{j}\right)\]</span></p><ul><li>二阶差商</li></ul><p><span class="math display">\[f\left[x_{i}, x_{j},x_{k}\right]=\frac{f\left[x_{i}, x_{j}\right]-f\left[x_{j},x_{k}\right]}{x_{i}-x_{k}} \quad(i \neq k)\]</span></p><ul><li>n阶差商</li></ul><p><span class="math display">\[f\left[x_{0}, x_{1}, \Lambdax_{n}\right]=\frac{f\left[x_{0}, x_{1}, \Lambda,x_{n-1}\right]-f\left[x_{1}, x_{2}, \Lambdax_{n}\right]}{x_{0}-x_{n}}\]</span></p><p>由以上定义我们的到<strong>差商表</strong>如下：</p><p><span class="math display">\[\begin{array}{cccrcc}x_{i} &amp; y_{i} &amp; \text { 一阶差商 } &amp; \text { 二阶差商 }&amp; \cdots \cdots &amp; n \text { 阶差商 } \\&amp; &amp; &amp; &amp; \\x_{0} &amp; f\left(x_{0}\right) &amp; &amp; &amp; \\x_{1} &amp; f\left(x_{1}\right) &amp; f\left[x_{0}, x_{1}\right] &amp;&amp; \\x_{2} &amp; f\left(x_{2}\right) &amp; f\left[x_{1}, x_{2}\right] &amp;f\left[x_{0}, x_{1}, x_{2}\right] &amp; \\&amp; \cdots \cdots &amp; \cdots \cdots &amp; \cdots \cdots &amp; \\x_{n-1} &amp; f\left(x_{n-1}\right) &amp; \cdots \cdots &amp; \cdots\cdots \\x_{n} &amp; f\left(x_{n}\right) &amp; f\left[x_{n-1}, x_{n}\right] &amp;f\left[x_{n-2}, x_{n-1}, x_{n}\right] &amp;\dots  &amp;f\left[x_{n}\ldots, x_{n}\right] \\\end{array}\]</span> 我们可以得到下面公式： <spanclass="math display">\[\begin{array}{l}f(x)=f\left(x_{\theta}\right)+f\left[x,x_{\theta}\right]\left(x-x_{\theta}\right),\\f\left[x, x_{0}\right]=f\left[x_{0}, x_{1}\right]+f\left[x, x_{0},x_{1}\right]\left(x-x_{1}\right),\\f\left[x, x_{0}, x_{1}\right]=f\left[x_{0}, x_{1},x_{2}\right]+f\left[x, x_{0}, x_{1}, x_{2}\right]\left(x-x_{2}\right),\\\cdots \\f\left[x, x_{\theta}, \cdots, x_{m-1}\right]=f\left[x_{\theta}, x_{1},\cdots, x_{n}\right]+J\left[x, x_{\theta}, \cdots,x_{n}\right]\left(x-x_{n}\right)\end{array}\]</span> 可得到牛顿插值法。</p><h2 id="拉格朗日插值与牛顿插值">拉格朗日插值与牛顿插值</h2><p>牛顿插值法和拉格朗日插值法两者都是多项式插值法，本质上，两者的结果相同，只不过表示的形式不同。牛顿插值法的计算过程具有继承性有易于变动的特点。</p><h2 id="龙格现象">龙格现象</h2><p>当次数渐高，很容易在多项式插值的边界处产生巨大波动，称为龙格现象。</p><p><ahref="https://www.zhihu.com/question/39329749">这里</a>是龙格现象产生原因</p><figure><img src="https://s2.loli.net/2022/02/06/6uklOIA1qyXJ5UZ.png"alt="龙格现象展示" /><figcaption aria-hidden="true"><ahref="https://www.51wendang.com/doc/ea665b984958ca1de13ba4ab">龙格现象展示</a></figcaption></figure><h1 id="埃尔米特hermite插值">埃尔米特(Hermite)插值</h1><p>不但要求在节点处上的函数值相等，而且还要求对应的导数值也相等，甚至要求高阶导数也相等，满足这种要求的插值多项式就是“Hermite插值多项式”<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/Rayme629/article/details/113174004">[4]</span></a></sup>。</p><p>直接使用Hermite插值得到的多项式次数较高，也存在着“龙格现象（Rungephenomenon）”。因此，在实际应用中，往往使用分段三次Hermite插值多项式（PCHIP），来提高“模拟数据的准确性”<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/Rayme629/article/details/113174004">[4]</span></a></sup>。</p><h2 id="原理">原理</h2><p>假定已知函数 <span class="math inline">\(f(x)\)</span> 在揷值区间<span class="math inline">\([p, q]\)</span> 上的 <spanclass="math inline">\(n+1\)</span> 个互不相同的节点 <spanclass="math inline">\(x_{i}(i=0,1, \ldots, n)\)</span> 处满足 <spanclass="math inline">\(f\left(x_{i}\right)=f_{i}\)</span> 及 <spanclass="math inline">\(f^{\prime}\left(x_{i}\right)=f_{i}^{\prime}(i=0,1,2,\ldots, n)\)</span> , 如果函数 <span class="math inline">\(G(x)\)</span>的存在满足下列条件: 1. <span class="math inline">\(G(x)\)</span>在每个小区间上的多项式次数为 3 ; 2. <span class="math inline">\(G(x) \inC^{1}[a, b]\)</span> ; 3. <spanclass="math inline">\(G\left(x_{i}\right)=f\left(x_{i}\right), \quadG^{\prime}\left(x_{i}\right)=f^{\prime}\left(x_{i}\right), \quad i=(0,1,\ldots, n)\)</span> 就称 <span class="math inline">\(G(x)\)</span> 是<span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(n+1\)</span> 个节点 <spanclass="math inline">\(x_{i}\)</span> 上的分段三次埃尔米特插值多项式。<span class="math display">\[\begin{aligned}G(x)=&amp; h_{k} y_{k}(x)+h_{k+1} y_{k+1}(x)+H_{k}(x)y_{k}^{\prime}+H_{k+1}(x) y_{k+1}^{\prime} \\=&amp;\left(1+2\frac{x-x_{k}}{x_{k+1}-x_{k}}\right)\left(\frac{x-x_{k+1}}{x_{k}-x_{k+1}}\right)^{2}y_{k}+\left(1+2\frac{x-x_{k+1}}{x_{k}-x_{k+1}}\right)\left(\frac{x-x_{k}}{x_{k+1}-x_{k}}\right)^{2}y_{k+1} \\&amp;+\left(x-x_{k}\right)\left(\frac{x-x_{k+1}}{x_{k}-x_{k+1}}\right)^{2}y_{k}^{\prime}+\left(x-x_{k+1}\right)\left(\frac{x-x_{k}}{x_{k+1}-x_{k}}\right)^{2}y_{k+1}^{\prime}\end{aligned}\]</span></p><h3 id="推广">推广</h3><p>Hermite 揷值多项式为: <span class="math display">\[H(x)=\sum_{i=0}^{n} h_{i}\left[\left(x_{i}-x\right)\left(2 a_{i}y_{i}-y_{i}^{\prime}\right)+y_{i}\right]\]</span> 其中: <spanclass="math display">\[h_{i}=\prod_{j=0 \atop j \neqi}^{n}\left(\frac{x-x_{j}}{x_{i}-x_{j}}\right)^{2}, \quada_{i}=\sum_{j=0 \atop j \neq i}^{n} \frac{1}{x_{i}-x_{j}}\]</span></p><h2 id="代码">代码</h2><h3 id="手写函数">手写函数</h3><p>设n个节点的数据以数组<code>x0</code>（已知点的横坐标），<code>y0</code>（函数值），<code>y1</code>（导数值）输入（注意Matlat 的数组下标从 <span class="math inline">\(1\)</span> 开始），<spanclass="math inline">\(m\)</span> 个插值点以数组 <code>x</code>输入，输出数组 <code>y</code> 为 <span class="math inline">\(m\)</span>个插值。编 <div class="hljs code-wrapper"><pre><code class="hljs m">function y<span class="hljs-built_in">=</span>hermite(x0,y0,y1,x);n<span class="hljs-built_in">=</span>length(x0);m<span class="hljs-built_in">=</span>length(x);for k<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:m    yy<span class="hljs-built_in">=</span><span class="hljs-number">0.0</span>;    for i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:n        h<span class="hljs-built_in">=</span><span class="hljs-number">1.0</span>;        a<span class="hljs-built_in">=</span><span class="hljs-number">0.0</span>;        for j<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:n            <span class="hljs-built_in">if</span> j~<span class="hljs-built_in">=</span>i                h<span class="hljs-built_in">=</span>h*((x(k)-x0(j))/(x0(i)-x0(j)))^<span class="hljs-number">2</span>;                a<span class="hljs-built_in">=</span><span class="hljs-number">1</span>/(x0(i)-x0(j))+a;            end        end        yy<span class="hljs-built_in">=</span>yy+h*((x0(i)-x(k))*(<span class="hljs-number">2</span>*a*y0(i)-y1(i))+y0(i));    end    y(k)<span class="hljs-built_in">=</span>yy;end</code></pre></div> ### 调用Matlab封装函数 <div class="hljs code-wrapper"><pre><code class="hljs m">x <span class="hljs-built_in">=</span> -<span class="hljs-number">3</span>:<span class="hljs-number">3</span>; y <span class="hljs-built_in">=</span> [-<span class="hljs-number">1</span> -<span class="hljs-number">1</span> -<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]; xq1 <span class="hljs-built_in">=</span> -<span class="hljs-number">3</span>:.<span class="hljs-number">01</span>:<span class="hljs-number">3</span>;p <span class="hljs-built_in">=</span> pchip(x,y,xq1);s <span class="hljs-built_in">=</span> spline(x,y,xq1);m <span class="hljs-built_in">=</span> makima(x,y,xq1);plot(x,y,<span class="hljs-string">&#x27;o&#x27;</span>,xq1,p,<span class="hljs-string">&#x27;-&#x27;</span>,xq1,s,<span class="hljs-string">&#x27;-.&#x27;</span>,xq1,m,<span class="hljs-string">&#x27;--&#x27;</span>)legend(<span class="hljs-string">&#x27;Sample Points&#x27;</span>,<span class="hljs-string">&#x27;pchip&#x27;</span>,<span class="hljs-string">&#x27;spline&#x27;</span>,<span class="hljs-string">&#x27;makima&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;SouthEast&#x27;</span>)</code></pre></div> <imgsrc="https://ww2.mathworks.cn/help/matlab/ref/datainterpolationcomparisonexample_01_zh_CN.png" />| <imgsrc="https://ww2.mathworks.cn/help/matlab/ref/datainterpolationcomparisonexample_02_zh_CN.png" />---|---</p><h1 id="样条插值">样条插值</h1><p>所谓样条（Spline）本来是工程设计中使用的一种绘图工具，它是富有弹性的细木条或细金属条。绘图员利用它把一些已知点连接成一条光滑曲线（称为样条曲线），并使连接点处有连续的曲率<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/Rayme629/article/details/113174004">[4]</span></a></sup>。</p><p>数学上将<strong>具有一定光滑性的分段多项式</strong>称为样条函数。</p><p>对于 <span class="math inline">\(\Delta : \quada=x_{0}&lt;x_{1}&lt;\cdots&lt;x_{n-1}&lt;x_{n}=b\)</span> 满足：</p><ol type="1"><li>在每个小区间 <span class="math inline">\(\left[x_{i},x_{i-1}\right](i=0,1, \cdots, n-1)\)</span> 上 <spanclass="math inline">\(s(x)\)</span> 是 <spanclass="math inline">\(k\)</span> 次多项式。</li><li><span class="math inline">\(s(x)\)</span> 在 <spanclass="math inline">\([a, b]\)</span> 上具有 <spanclass="math inline">\(k-1\)</span> 阶连续导数。即 <spanclass="math inline">\(S_{i}^{(j)}(x_{i+1})=S_{i+1}^{(j)}(x_{i+1})\)</span><span class="math inline">\((j=0,1,\dots,k-1)\)</span></li></ol><p>一般形式为：</p><p><span class="math display">\[s_{k}(x)=\sum_{i=0}^{k} \frac{\alpha_{i}x^{i}}{i !}+\sum_{j=1}^{n-1} \frac{\beta_{j}}{k!}\left(x-x_{j}\right)_{+}^{k}\]</span></p><p>在实际中最常用的是二次样条函数和<strong>三次样条函数</strong>。</p><p>三次样条生成的曲线更加光滑，相较Hermite更适合曲线(三角函数)。</p><h2 id="三次样条插值代码">三次样条插值代码</h2><div class="hljs code-wrapper"><pre><code class="hljs m">x <span class="hljs-built_in">=</span> ‐pi:pi;y <span class="hljs-built_in">=</span> sin(x);new_x <span class="hljs-built_in">=</span> ‐pi:<span class="hljs-number">0.1</span>:pi;p1 <span class="hljs-built_in">=</span> pchip(x,y,new_x); <span class="hljs-comment">%分段三次埃尔米特插值</span>p2 <span class="hljs-built_in">=</span> spline(x,y,new_x); <span class="hljs-comment">%三次样条插值</span>pp <span class="hljs-built_in">=</span> csape(x0,y0_ext,conds); <span class="hljs-comment">%另一个三次样条插值？</span>plot(x,y,<span class="hljs-string">&#x27;o&#x27;</span>,new_x,p1,<span class="hljs-string">&#x27;r‐&#x27;</span>,new_x,p2,<span class="hljs-string">&#x27;b‐&#x27;</span>)legend(<span class="hljs-string">&#x27;样本点&#x27;</span>,<span class="hljs-string">&#x27;三次埃尔米特插值&#x27;</span>,<span class="hljs-string">&#x27;三次样条插值&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;SouthEast&#x27;</span>) <span class="hljs-comment">%标注显示在东南方向</span></code></pre></div><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《数学建模算法与运用》<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>清风数学建模<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/64855561<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/Rayme629/article/details/113174004<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://www.jianshu.com/p/6dfca5f6b249<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://ww2.mathworks.cn/help/matlab/ref/pchip.html<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分段插值</tag>
      
      <tag>多项式插值</tag>
      
      <tag>埃尔米特插值</tag>
      
      <tag>样条插值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022—SWJTU寒假选拔赛第三场复盘</title>
    <link href="/2022/02/02/14/"/>
    <url>/2022/02/02/14/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一个迟到几周的复盘，现在大年初一才来补题(😓)</p><h1 id="链接">链接</h1><div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894"><b>2022—SWJTU寒假选拔赛第三场</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/m0_56007815/article/details/122655578?spm=1001.2014.3001.5501"><b>前辈写的题解</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><figure><img src="https://s2.loli.net/2022/02/02/ZaWudk8AX1nLYgm.png"alt="RANK(E题是一道AC题被删的补偿)" /><figcaptionaria-hidden="true">RANK(E题是一道AC题被删的补偿)</figcaption></figure><h2 id="a-a"><a href="https://vjudge.net/contest/477408#problem/A">A-A√</a></h2><p>要想让 <span class="math inline">\(S(x + 1) &lt; s(x)\)</span>只能可能发生在进位的时候,因此每逢尾数为 <spanclass="math inline">\(9\)</span> 时就会对答案产生贡献。</p><p>其实通过样例就可以得到解为<spanclass="math inline">\((n+1)/10\)</span></p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();        cout&lt;&lt;(n+<span class="hljs-number">1</span>)/<span class="hljs-number">10</span>&lt;&lt;endl;    &#125;&#125;</code></pre></div><h2 id="b-b"><a href="https://vjudge.net/contest/477408#problem/B">B-B√</a></h2><p>题目重述；给出 <span class="math inline">\(1\)</span> 个长度为 <spanclass="math inline">\(n\)</span> 的序列，以及 <spanclass="math inline">\(1\)</span> 个正整数 <spanclass="math inline">\(m\)</span>。问这个原序列中是否存在非空子序列，使其元素之和能被<span class="math inline">\(m\)</span> 整除。</p><p>看到数据范围数据范围：<spanclass="math inline">\(1&lt;=n&lt;=10^6,2&lt;=m&lt;=1000,1&lt;=n&lt;=10\)</span>。 自然不可能用 <spanclass="math inline">\(O(nm)\)</span>，时间复杂度仅仅与<spanclass="math inline">\(m\)</span>有关。</p><ul><li><p>考虑 <span class="math inline">\(n&gt;m\)</span>的情况：我们对整个数列做前缀和，然后再对 <spanclass="math inline">\(m\)</span> 取模。根据抽屉原理，因为 <spanclass="math inline">\(n&gt;m\)</span>，所以在 <spanclass="math inline">\(n\)</span> 个前缀和中必有两个对 <spanclass="math inline">\(m\)</span>取模于是相等，它们中间那段就是答案。</p></li><li><p>而 n⩽m 的情况，n⩽103，不会超时,直接 <spanclass="math inline">\(O(nm)\)</span> 的背包。</p></li></ul><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> x*f;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100010</span><span class="hljs-keyword">int</span> n, m, i, j, k; <span class="hljs-keyword">int</span> dp[N], f[N], x; <span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; n=<span class="hljs-built_in">read</span>(); m=<span class="hljs-built_in">read</span>();  <span class="hljs-keyword">if</span>(n&gt;m) <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES&quot;</span>), <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;  x=<span class="hljs-built_in">read</span>();  <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; ++j) f[j]=dp[j];  <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; ++j)   dp[(j+x)%m]+=f[j];   dp[x%m]++; <span class="hljs-comment">//只有当前x的子集</span> &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, (dp[<span class="hljs-number">0</span>] ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>));  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> int_;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getchar</span>(), f = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(; c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>; c=<span class="hljs-built_in">getchar</span>())  <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>) f = -f; <span class="hljs-keyword">for</span>(; <span class="hljs-string">&#x27;0&#x27;</span>&lt;=c&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>; c=<span class="hljs-built_in">getchar</span>())  a = (a&lt;&lt;<span class="hljs-number">3</span>)+(a&lt;&lt;<span class="hljs-number">1</span>)+(c^<span class="hljs-number">48</span>); <span class="hljs-keyword">return</span> a*f;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123; <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">9</span>) <span class="hljs-built_in">writeint</span>(x/<span class="hljs-number">10</span>); <span class="hljs-built_in">putchar</span>((x%<span class="hljs-number">10</span>)^<span class="hljs-number">48</span>);&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXM = <span class="hljs-number">1000</span>;<span class="hljs-keyword">int</span> gcd[MAXM];<span class="hljs-keyword">bool</span> dp[MAXM+<span class="hljs-number">5</span>];<span class="hljs-keyword">int</span> cnt[MAXM], dis[MAXM];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>(); <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i)  ++ cnt[<span class="hljs-built_in">read</span>()%m]; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;m; ++i)  <span class="hljs-keyword">if</span>(m%i == <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;m/i; ++j)    gcd[i*j] = i; dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">bool</span> ans = cnt[<span class="hljs-number">0</span>]; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>; a&lt;m&amp;&amp;!ans; ++a)&#123;  <span class="hljs-keyword">int</span> d = gcd[a];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;d; ++i)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*m/d<span class="hljs-number">-1</span>; ~j; --j)&#123;   <span class="hljs-keyword">int</span> now = (i+j*a)%m;   dis[now] = dis[(now+a)%m]+<span class="hljs-number">1</span>;   <span class="hljs-keyword">if</span>(dp[now]) dis[now] = !now;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;d; ++i)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;m/d; ++j)&#123;   <span class="hljs-keyword">int</span> now = (i+j*a)%m;   <span class="hljs-keyword">if</span>(dp[now])&#123;    <span class="hljs-keyword">int</span> t = dis[(now+a)%m];    t = <span class="hljs-built_in">min</span>(t,cnt[a]);    <span class="hljs-keyword">for</span>(; t; --t,++j)&#123;     now = (now+a)%m;     dp[now] = <span class="hljs-literal">true</span>;     <span class="hljs-keyword">if</span>(now == <span class="hljs-number">0</span>)      ans = <span class="hljs-literal">true</span>;    &#125;   &#125;  &#125; &#125; <span class="hljs-built_in">puts</span>(ans ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="c-c"><a href="https://vjudge.net/contest/477408#problem/C">C-C√</a></h2><p>最简单的签到题，直接过</p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)            sum+=<span class="hljs-built_in">read</span>();        <span class="hljs-keyword">if</span>(sum&gt;=n)             cout&lt;&lt;sum-n&lt;&lt;endl;        <span class="hljs-keyword">else</span>             cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;    &#125;&#125;</code></pre></div><h2 id="原d题">原D题 √</h2><p>本来是二维dp题目，硬生生被我做成了字符串（公共子串）匹配，再在得到的二维数组上对公共子串长度记录，再dp（但是我觉得思路更清晰？迷幻）。</p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> f[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>][<span class="hljs-number">13</span>];<span class="hljs-comment">//priority_queue &lt;int&gt; q;</span><span class="hljs-comment">//priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</span><span class="hljs-comment">//priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> r=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">char</span> s[<span class="hljs-number">1010</span>];    <span class="hljs-keyword">char</span> t[<span class="hljs-number">1001</span>];    cin&gt;&gt;s+<span class="hljs-number">1</span>;    cin&gt;&gt;t+<span class="hljs-number">1</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)            <span class="hljs-keyword">if</span>(s[i]==t[j])                a[i][j]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span>)                d[i][j]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span>                d[i][j]=d[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;        &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)            <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">1</span>,r)&#123;                f[i][j][k]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j][k],f[i][j<span class="hljs-number">-1</span>][k]);                f[i][j][k]=<span class="hljs-built_in">max</span>(f[i][j][k],f[i-d[i][j]][j-d[i][j]][k<span class="hljs-number">-1</span>]+d[i][j]);                ans=<span class="hljs-built_in">max</span>(ans,f[i][j][k]);            &#125;    cout&lt;&lt;ans;&#125;</code></pre></div><h2 id="d-e"><ahref="https://vjudge.net/contest/477408#problem/D">D-E</a></h2><p>组合数学，详解见题解</p><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; LL fac[N],inv[N];<span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(LL a, LL k, LL p)</span>  <span class="hljs-comment">// 求a^k mod p</span></span><span class="hljs-function"></span>&#123;    LL res = <span class="hljs-number">1</span> % p;    <span class="hljs-keyword">while</span> (k)    &#123;        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * a % p;        a = a * a % p;        k &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    inv[<span class="hljs-number">0</span>] = fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) fac[i] = (i * fac[i - <span class="hljs-number">1</span>]) % mod,inv[i] = <span class="hljs-built_in">qmi</span>(fac[i],mod - <span class="hljs-number">2</span>,mod);&#125; <span class="hljs-function">LL <span class="hljs-title">c</span><span class="hljs-params">(LL a,LL b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> fac[a] * inv[b] % mod * inv[a - b] % mod;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    LL n,k;    cin &gt;&gt; n &gt;&gt; k;    k = <span class="hljs-built_in">min</span>(k,n - <span class="hljs-number">1</span>);    <span class="hljs-built_in">fc</span>(N);    LL res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= k;i ++)    res = (res + <span class="hljs-built_in">c</span>(n,i) * <span class="hljs-built_in">c</span>(n - <span class="hljs-number">1</span>,i) % mod) % mod;    cout &lt;&lt; res &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-comment">//cin &gt;&gt; T;</span>    <span class="hljs-keyword">while</span>(T --)    <span class="hljs-built_in">solve</span>();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="e-f"><ahref="https://vjudge.net/contest/477408#problem/E">E-F</a></h2><p>看到这道题我先想到了树形dp、点分治。然而这是个图。</p><p><strong>正确思路</strong>:我们已经确定了起点和终点,那么我们只需要枚举 起点到 <spanclass="math inline">\(i\)</span> 的距离 + 终点到 <spanclass="math inline">\(j\)</span> 的距离 + <spanclass="math inline">\(i,j\)</span>之间的距离判断其是否大于等于最短距离,如果满足那么这个 <spanclass="math inline">\(i,j\)</span> 组合就是合法的加边结果。</p><p><strong>流程</strong>：我们对起点和终点分别跑两次最短路,枚举要加边的两个端点,判断其是否满足条件,计算其对答案的贡献即可。</p><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> vis[N][N];vector&lt;<span class="hljs-keyword">int</span>&gt; g[N];<span class="hljs-keyword">int</span> dist_s[N],<span class="hljs-keyword">dist_t</span>[N]; <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,s,t;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;    <span class="hljs-keyword">while</span>(m --)    &#123;        <span class="hljs-keyword">int</span> a,b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);        g[a].<span class="hljs-built_in">push_back</span>(b);        g[b].<span class="hljs-built_in">push_back</span>(a);        vis[a][b] = vis[b][a] = <span class="hljs-number">1</span>;    &#125;        <span class="hljs-built_in">memset</span>(dist_s,- <span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span> dist_s);    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">dist_t</span>,- <span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span> <span class="hljs-keyword">dist_t</span>);        queue&lt;<span class="hljs-keyword">int</span>&gt; q;    q.<span class="hljs-built_in">push</span>(s);    dist_s[s] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())    &#123;        <span class="hljs-keyword">auto</span> u = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; g[u].<span class="hljs-built_in">size</span>();i ++)        &#123;            <span class="hljs-keyword">int</span> v = g[u][i];            <span class="hljs-keyword">if</span>(dist_s[v] == <span class="hljs-number">-1</span>) dist_s[v] = dist_s[u] + <span class="hljs-number">1</span>,q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;        q.<span class="hljs-built_in">push</span>(t);    <span class="hljs-keyword">dist_t</span>[t] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())    &#123;        <span class="hljs-keyword">auto</span> u = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; g[u].<span class="hljs-built_in">size</span>();i ++)        &#123;            <span class="hljs-keyword">int</span> v = g[u][i];            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">dist_t</span>[v] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">dist_t</span>[v] = <span class="hljs-keyword">dist_t</span>[u] + <span class="hljs-number">1</span>,q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;     LL res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt;= n;j ++)      <span class="hljs-keyword">if</span>(!vis[i][j] &amp;&amp; dist_s[i] + <span class="hljs-number">1</span> + <span class="hljs-keyword">dist_t</span>[j] &gt;= dist_s[t] &amp;&amp; <span class="hljs-keyword">dist_t</span>[i] + <span class="hljs-number">1</span> + dist_s[j] &gt;= dist_s[t])       res ++;    cout &lt;&lt; res &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(T --) <span class="hljs-built_in">solve</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="f-g"><ahref="https://vjudge.net/contest/477408#problem/F">F-G</a></h2><p>线段树</p><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;vector &lt;pair &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt;in[maxn],out[maxn];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NODE</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum,num;&#125; p[maxn*<span class="hljs-number">4</span>];<span class="hljs-keyword">int</span> n,m,k;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> cur)</span></span><span class="hljs-function"></span>&#123;    p[cur].l=l;    p[cur].r=r;    p[cur].num=p[cur].sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l==r)        <span class="hljs-keyword">return</span> ;    <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-built_in">build</span>(l,mid,cur*<span class="hljs-number">2</span>);    <span class="hljs-built_in">build</span>(mid+<span class="hljs-number">1</span>,r,cur*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    p[k].num=p[k*<span class="hljs-number">2</span>].num+p[k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].num;    p[k].sum=p[k*<span class="hljs-number">2</span>].sum+p[k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> pri,<span class="hljs-keyword">int</span> cur)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=p[cur].l,r=p[cur].r;    <span class="hljs-keyword">if</span>(l==r)    &#123;        p[cur].num+=num;        p[cur].sum+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)num*pri;        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(pri&lt;=mid)        <span class="hljs-built_in">update</span>(num,pri,<span class="hljs-number">2</span>*cur);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">update</span>(num,pri,<span class="hljs-number">2</span>*cur+<span class="hljs-number">1</span>);    <span class="hljs-built_in">pushup</span>(cur);&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> cur)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=p[cur].l,r=p[cur].r;    <span class="hljs-keyword">if</span>(l==r)        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)l*<span class="hljs-built_in">min</span>(p[cur].num,(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)num);    <span class="hljs-keyword">if</span>(num&lt;=p[cur*<span class="hljs-number">2</span>].num)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(num,cur*<span class="hljs-number">2</span>);    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> p[cur*<span class="hljs-number">2</span>].sum+<span class="hljs-built_in">query</span>(num-p[cur*<span class="hljs-number">2</span>].num,cur*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l,r,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)    &#123;        in[i].<span class="hljs-built_in">clear</span>();        out[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x,&amp;y);        in[l].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(x,y));        out[r].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(x,y));    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,maxn,<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;in[i].<span class="hljs-built_in">size</span>(); j++)            <span class="hljs-built_in">update</span>(in[i][j].first,in[i][j].second,<span class="hljs-number">1</span>);        ans+=<span class="hljs-built_in">query</span>(k,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;out[i].<span class="hljs-built_in">size</span>(); j++)            <span class="hljs-built_in">update</span>(-out[i][j].first,out[i][j].second,<span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="原h题">原H题</h2><p>写了一个二分答案，wa后被告知题目要被删。</p><h2 id="g-i"><a href="https://vjudge.net/contest/477408#problem/G">G-I√</a></h2><p>一个奇葩的题目。你只需要构造出一个满足题意的树就行。</p><p>无法构造时： <span class="math inline">\(d&gt;2h\)</span>时必定不成立 <span class="math inline">\(d= 1\)</span> 时,节点数只能是<span class="math inline">\(2\)</span>。</p><p>先构建成一条满足条件的链,然后不够的再往上加点即可。有一些细节问题，所以我调了很久才A(哭)。</p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n,d,h;<span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    n=<span class="hljs-built_in">read</span>();d=<span class="hljs-built_in">read</span>();h=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">if</span>((!(<span class="hljs-number">2</span>*h&gt;=d&amp;&amp;d&gt;=h&amp;&amp;n&gt;=d+<span class="hljs-number">1</span>))||(d==<span class="hljs-number">1</span>&amp;&amp;n&gt;<span class="hljs-number">2</span>))&#123;        cout&lt;&lt;<span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,h)        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++cnt&lt;&lt;endl;    <span class="hljs-keyword">if</span>(h!=d)&#123;        cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++cnt&lt;&lt;endl;        <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">2</span>,d-h)            cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++cnt&lt;&lt;endl;    &#125;    <span class="hljs-keyword">int</span> o=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(cnt==n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(h==d&amp;&amp;h&gt;<span class="hljs-number">1</span>)o=<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(h==d&amp;&amp;h==<span class="hljs-number">1</span>)&#123;        cout&lt;&lt;<span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">while</span>(cnt!=n)&#123;        cout&lt;&lt;o&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++cnt&lt;&lt;endl;    &#125;        &#125;</code></pre></div><h2 id="h-j"><a href="https://vjudge.net/contest/477408#problem/H">H-J√</a></h2><p>在学长的点拨下做出来的题。</p><p>数据范围超空间，所以不能用数组作桶，用map。要用 <spanclass="math inline">\(O(n)\)</span>的做法，要用所以不能存位置，要map存奇数偶数的个数,还要开LL：<code>map&lt;int,ll&gt;m[2]</code>。导致我写了好几遍。</p><p>基本思路：两个相同的数的亦或为<spanclass="math inline">\(0\)</span>，<spanclass="math inline">\(0\)</span>和任意另外一个数的亦或都为另一个数。</p><p>所以对于题目要救“区间从<spanclass="math inline">\(1/2\)</span>的位置分割为两部分，两部分的元素异或和相同”，记两段的亦或分别为<code>l</code>，<code>r</code>当且仅当<code>a^l^r=a</code>时满足题意，可得<spanclass="math inline">\(O(n)\)</span>的算法（从左到右扫一遍）。</p><p>AC code:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span>map&lt;<span class="hljs-keyword">int</span>,ll&gt; m[<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> e;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    ll ans=<span class="hljs-number">0</span>;    m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]++;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        e=e^<span class="hljs-built_in">read</span>();        ans+=m[i%<span class="hljs-number">2</span>][e];<span class="hljs-comment">//cout&lt;&lt;e&lt;&lt;&quot;:&quot;&lt;&lt;m[e][i%2]&lt;&lt;&quot; &quot;;</span>        m[i%<span class="hljs-number">2</span>][e]++;    &#125;    cout&lt;&lt;ans;&#125;</code></pre></div><h2 id="i-k"><ahref="https://vjudge.net/contest/477408#problem/I">I-K</a></h2><p>我想了线性dp但我就是没想出来(哭)</p><p>让你求解整个序列上的极值问题,然后判断其是否无后效性和是否存在最优子结构就能够知道是不是个dp,这题整个序列上的极值显然是可以由其子序列转移而来的,具体证明就不多赘述,直接开始dp。</p><p><strong>状态表示</strong>：<code>f[i]</code> 表示前 <code>i</code>个数字中取 <span class="math inline">\(\frac{n}{2}\)</span>(向下取整)个数并且这些数两两不相邻,其最大的和。</p><p><strong>状态转移</strong>：</p><p>由于是 <span class="math inline">\(\frac{n}{2}\)</span>(向下取整)存在奇偶数不同的情况,因此我们对其分类讨论</p><p>若是奇数并且选了第 <span class="math inline">\(i\)</span> 个数则<code>f[i] = f[i-2] + a[i]</code> ,因为选了第 <spanclass="math inline">\(i\)</span> 个数后,第 <spanclass="math inline">\(i-1\)</span> 个数就不能被选中了,只能从<code>f[i-2]</code>转移而来</p><p>若没有选第 <span class="math inline">\(i\)</span> 个数则 <code>f[i] =f[i-1]</code></p><p>若是偶数并且选了第 <span class="math inline">\(i\)</span> 个数则同理,<code>f[i] = f[i-2] + a[i]</code> ,</p><p>若没有选第 <span class="math inline">\(i\)</span>个数,我们只能将奇数位置上的数全选上才能有 <spanclass="math inline">\(⌊n/2⌋\)</span> (向下取整)个数字,不然的话若还是<code>f[i-1]</code> ,此时 <span class="math inline">\(i-1\)</span>为奇数除二下取整会比原来少一个就不符合题目的条件了。</p><p>Stl:</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;LL a[N],f[N],s[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> n;cin &gt;&gt; n;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);s[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i += <span class="hljs-number">2</span>) s[i] = s[i - <span class="hljs-number">2</span>] + a[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++)&#123;<span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-comment">//奇数</span>&#123;f[i] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">2</span>] + a[i],f[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">//偶数</span>&#123;f[i] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">2</span>] + a[i],s[i - <span class="hljs-number">1</span>]);&#125;&#125;cout &lt;&lt; f[n] &lt;&lt; endl; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T --)<span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022—SWJTU寒假选拔赛第二场复盘</title>
    <link href="/2022/01/17/13/"/>
    <url>/2022/01/17/13/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="链接">链接</h1><div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894"><b>2022—SWJTU寒假选拔赛第二场</b></a></p>          </div><div class="note note-info">            <p><ahref="https://zhuanlan.zhihu.com/p/459020192"><b>某后台老板的赛后快乐分享</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/m0_56007815/article/details/122555017"><b>题解</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><figure><img src="https://s2.loli.net/2022/01/19/mrJYjLkT4XZVovt.png"alt="RANk.png" /><figcaption aria-hidden="true">RANk.png</figcaption></figure><h1 id="a-傻子楼梯">A-傻子楼梯 ?</h1><div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/A">题目链接</a><span class="label label-warning">Attempted</span></p>          </div><p></b></font></p><p>队列模拟即可</p><p>要转变方向当且仅当不同方向的人已抵达电梯,且该方向的下一个人还未到达电梯</p><p>然而从赛场到现在我一直wa在test7上，现在也不知道怎么错的。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的错误代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    queue&lt;<span class="hljs-keyword">int</span>&gt; e[<span class="hljs-number">2</span>];    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-keyword">int</span> t=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();        e[q].<span class="hljs-built_in">push</span>(t);    &#125;    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>,q=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(e[q^<span class="hljs-number">1</span>].<span class="hljs-built_in">front</span>()&lt;e[q].<span class="hljs-built_in">front</span>()) q^=<span class="hljs-number">1</span>;    t=e[q].<span class="hljs-built_in">front</span>()+<span class="hljs-number">10</span>;e[q].<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">//cout&lt;&lt;t&lt;&lt;&quot;:&quot;&lt;&lt;q&lt;&lt;&quot; &quot;;</span>    <span class="hljs-keyword">while</span>(!e[<span class="hljs-number">1</span>].<span class="hljs-built_in">empty</span>()||!e[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-keyword">if</span>(e[q].<span class="hljs-built_in">empty</span>()||e[q^<span class="hljs-number">1</span>].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-comment">//cout&lt;&lt;&quot;!&quot;;</span>            <span class="hljs-keyword">if</span>(e[q].<span class="hljs-built_in">empty</span>())&#123;                q^=<span class="hljs-number">1</span>;                t=<span class="hljs-built_in">max</span>(t,e[q].<span class="hljs-built_in">front</span>())+<span class="hljs-number">10</span>;                e[q].<span class="hljs-built_in">pop</span>();            &#125;<span class="hljs-keyword">else</span>&#123;                t=e[q].<span class="hljs-built_in">front</span>()+<span class="hljs-number">10</span>;                e[q].<span class="hljs-built_in">pop</span>();            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e[q].<span class="hljs-built_in">front</span>()&lt;t) &#123;            t=<span class="hljs-built_in">max</span>(t,e[q].<span class="hljs-built_in">front</span>()+<span class="hljs-number">10</span>);            e[q].<span class="hljs-built_in">pop</span>();        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(e[q^<span class="hljs-number">1</span>].<span class="hljs-built_in">front</span>()&lt;e[q].<span class="hljs-built_in">front</span>()) q^=<span class="hljs-number">1</span>;            t=<span class="hljs-built_in">max</span>(t,e[q].<span class="hljs-built_in">front</span>())+<span class="hljs-number">10</span>;            e[q].<span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-comment">//cout&lt;&lt;t&lt;&lt;&quot;:&quot;&lt;&lt;q&lt;&lt;&quot; &quot;;</span>    &#125;    cout&lt;&lt;t;   &#125;<span class="hljs-comment">/*</span><span class="hljs-comment">5</span><span class="hljs-comment">1 1 </span><span class="hljs-comment">7 0 </span><span class="hljs-comment">8 0 </span><span class="hljs-comment">10 0</span><span class="hljs-comment">12 1</span><span class="hljs-comment">*/</span></code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;queue&lt;<span class="hljs-keyword">int</span>&gt; q0,q1;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span>(n --)    &#123;        <span class="hljs-keyword">int</span> a,b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) q0.<span class="hljs-built_in">push</span>(a);        <span class="hljs-keyword">else</span> q1.<span class="hljs-built_in">push</span>(a);    &#125;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q0.<span class="hljs-built_in">size</span>() &amp;&amp; q1.<span class="hljs-built_in">size</span>())    &#123;           <span class="hljs-keyword">auto</span> up = q0.<span class="hljs-built_in">front</span>(),down = q1.<span class="hljs-built_in">front</span>();        <span class="hljs-comment">//printf(&quot;up = %d,down = %d\n&quot;,up,down);</span>        <span class="hljs-keyword">if</span>(up &lt; down)        &#123;            ans += <span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>(q0.<span class="hljs-built_in">front</span>() &lt; ans &amp;&amp; q0.<span class="hljs-built_in">size</span>())            &#123;                ans = <span class="hljs-built_in">max</span>(ans,q0.<span class="hljs-built_in">front</span>() + <span class="hljs-number">10</span>);                <span class="hljs-comment">//printf(&quot;q0.ans = %d\n&quot;,ans);</span>                q0.<span class="hljs-built_in">pop</span>();            &#125;        &#125;        <span class="hljs-keyword">else</span>         &#123;           ans += <span class="hljs-number">10</span>;           <span class="hljs-keyword">while</span>(ans &gt; q1.<span class="hljs-built_in">front</span>() &amp;&amp; q1.<span class="hljs-built_in">size</span>())           &#123;               ans = <span class="hljs-built_in">max</span>(ans,q1.<span class="hljs-built_in">front</span>() + <span class="hljs-number">10</span>);               <span class="hljs-comment">//printf(&quot;q1.ans = %d\n&quot;,ans);</span>               q1.<span class="hljs-built_in">pop</span>();           &#125;        &#125;    &#125;    ans += <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q0.<span class="hljs-built_in">size</span>())    &#123;        res = q0.<span class="hljs-built_in">front</span>() + <span class="hljs-number">10</span>;        q0.<span class="hljs-built_in">pop</span>();    &#125;    <span class="hljs-keyword">while</span>(q1.<span class="hljs-built_in">size</span>())    &#123;        res = q1.<span class="hljs-built_in">front</span>() + <span class="hljs-number">10</span>;        q1.<span class="hljs-built_in">pop</span>();    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">max</span>(res,ans));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h1 id="b-cold爱吃小蛋糕">B-cold爱吃小蛋糕√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/B">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p><span class="math inline">\(Cold\)</span>可以无限次吃蛋糕，每次吃掉蛋糕的重量是一个正整数且任意，只要并且不会超过原本蛋糕重量的一半。因为可以无限次合并蛋糕。所以，可以贪心的考虑将所有蛋糕合并，然后次多次将蛋糕吃到<span class="math inline">\(K\)</span>的重量，然后再最后吃一口最重的就是最优解。</p><p>也就是，会浪费 <span class="math inline">\(\frac{K}{2}\)</span>上取整重量的蛋糕。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();    ll sum=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">read</span>();        sum+=x;    &#125;    <span class="hljs-keyword">if</span>(sum&lt;k)&#123;        cout&lt;&lt;<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    cout&lt;&lt;sum-<span class="hljs-built_in">min</span>((k+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>,(k+<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>);<span class="hljs-comment">//这个min不需要 （k+1）/2 表示吃剩的 </span>&#125;</code></pre></div>    </div></div><h1 id="c-郑老板玩方块">C-郑老板玩方块√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/C">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p><strong>题目重述</strong>：判断给出的八个坐标能否构成正方体</p><p>最开始看到这个大模拟我是非常不想做的，但是看了其他题不是很有把握以及榜单上很多人这道题就写完了(神仙速度)然后就花了不少时间(30min?)把这个搞了出来。</p><p>因为只有500组数据，时间很宽裕，我就用了个O(T<em>8</em>8*8)的暴力：对于每个点，计算其他七个点与它的距离(直接不用开方)，用距离进行个冒泡排序，再判断该点与该点最近的三个点构成的向量长度是否相等，是否垂直。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">9</span>][<span class="hljs-number">4</span>],b[<span class="hljs-number">9</span>][<span class="hljs-number">4</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">double</span> di;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">8</span>;i++)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)            a[i][j]=<span class="hljs-built_in">read</span>();            &#125;    <span class="hljs-keyword">int</span> f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">8</span>;i++)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)&#123;            b[j][<span class="hljs-number">1</span>]=a[j][<span class="hljs-number">1</span>]-a[i][<span class="hljs-number">1</span>];            b[j][<span class="hljs-number">2</span>]=a[j][<span class="hljs-number">2</span>]-a[i][<span class="hljs-number">2</span>];            b[j][<span class="hljs-number">3</span>]=a[j][<span class="hljs-number">3</span>]-a[i][<span class="hljs-number">3</span>];            b[j][<span class="hljs-number">0</span>]=b[j][<span class="hljs-number">1</span>]*b[j][<span class="hljs-number">1</span>]+b[j][<span class="hljs-number">2</span>]*b[j][<span class="hljs-number">2</span>]+b[j][<span class="hljs-number">3</span>]*b[j][<span class="hljs-number">3</span>];        &#125;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)            <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)&#123;                <span class="hljs-keyword">if</span>(b[k][<span class="hljs-number">0</span>]&lt;b[k+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<span class="hljs-keyword">continue</span>;                <span class="hljs-built_in">FOR</span>(w,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)                    <span class="hljs-built_in">swap</span>(b[k][w],b[k+<span class="hljs-number">1</span>][w]);            &#125;        <span class="hljs-keyword">if</span>(b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>&amp;&amp;b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]==b[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]&amp;&amp;b[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]==b[<span class="hljs-number">4</span>][<span class="hljs-number">0</span>]&amp;&amp;            b[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]*b[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]+b[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]*b[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]+b[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]*b[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]==<span class="hljs-number">0</span>&amp;&amp;            b[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]+b[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]+b[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]==<span class="hljs-number">0</span>&amp;&amp;            b[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]+b[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]+b[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]*b[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]==<span class="hljs-number">0</span>        )            f++;    &#125;    <span class="hljs-keyword">if</span>(f==<span class="hljs-number">8</span>)cout&lt;&lt;<span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">solve</span>();    &#125;&#125;</code></pre></div>    </div></div><h1 id="d-风神瞳">D-风神瞳√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/D">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p>这是一个最短路模板+无穷背包模板的题目。</p><p>首先，用Dij或SPFA跑出出发点 <code>S=1</code>到每个点的最短距离，对于每个非出发点节点相当于背包的物品：花费时间为<code>dis[i]*2</code>、收益为<code>a[i]</code>。每个“物品”有无限个，然后无线背包dp就行。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">3200</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXM = <span class="hljs-number">3200</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node1</span>&#123;</span>    <span class="hljs-keyword">int</span> to,nxt,val;&#125;edge[MAXM];<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>,head[MAXN];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node2</span>&#123;</span>    <span class="hljs-keyword">int</span> to,val;    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> node2 &amp;x)<span class="hljs-keyword">const</span>    &#123;        <span class="hljs-keyword">return</span> val&gt;x.val;<span class="hljs-comment">//这里注意符号要为&#x27;&gt;&#x27;</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)</span></span>&#123;    edge[++cnt].to=v;    edge[cnt].val=w;    edge[cnt].nxt=head[u];    head[u]=cnt;&#125;<span class="hljs-keyword">int</span> vis[MAXN],dis[MAXN];priority_queue&lt;node2&gt; q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> s=<span class="hljs-number">1</span>;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));dis[s]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));    q.<span class="hljs-built_in">push</span>((node2)&#123;s,<span class="hljs-number">0</span>&#125;);    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-keyword">int</span> u=q.<span class="hljs-built_in">top</span>().to;q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;        vis[u]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i;i=edge[i].nxt)&#123;<span class="hljs-comment">//cout&lt;&lt;&quot;!&quot;;</span>            <span class="hljs-keyword">int</span> v=edge[i].to;            <span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+edge[i].val)&#123;                dis[v]=dis[u]+edge[i].val;<span class="hljs-comment">// cout&lt;&lt;u&lt;&lt;&quot;-&gt;&quot;&lt;&lt;v&lt;&lt;&quot;:&quot;&lt;&lt;dis[v]&lt;&lt;endl;</span>                q.<span class="hljs-built_in">push</span>((node2)&#123;v,dis[v]&#125;);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x,y;    <span class="hljs-keyword">int</span> T;    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();    T=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> a[MAXN]=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">2</span>,n)        a[i]=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        x=<span class="hljs-built_in">read</span>();y=<span class="hljs-built_in">read</span>();        <span class="hljs-built_in">add</span>(x,y,<span class="hljs-number">1</span>);        <span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">dij</span>();    <span class="hljs-keyword">int</span> f[<span class="hljs-number">3010</span>];    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,T)&#123;        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">2</span>,n)&#123;            <span class="hljs-keyword">if</span>(i&lt;dis[j]*<span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;            f[i]=<span class="hljs-built_in">max</span>(f[i],f[i-(dis[j]&lt;&lt;<span class="hljs-number">1</span>)]+a[j]);        &#125;        cout&lt;&lt;f[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    &#125;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h1 id="e-cold不会字符串">E-cold不会字符串</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/E">题目链接</a></p>          </div> </b></font></p><p>我一直没想到做法是因为我把题目：“如果给你一个P串，是否能构造出来一个T串使得cold的代码不通过”看为了“如果给你一个T串，是否能构造出来一个P串使得cold的代码不通过”，话说如果这样改能有低于<spanclass="math inline">\(O(n^2)\)</span>的做法吗。</p><p>题目的意思是已知这么一段错误的代码然后给我们一个匹配串，问能否构造一个串使得这个算法得到的答案是错误的。</p><p>很明显这段代码错误的原因在于指针 没有回溯。那么怎样的串我们可以把它hack 掉呢</p><p>倘若 <code>next[i]&gt;0</code> 的一定会被 hack,学过KMP的同学知道,KMP就是求解前后缀匹配情况即数组回溯进行匹配的,但改错误代码其没有回溯,因此产生了错误。那么知道了这点以后,甚至可以不用求<code>next</code> 数组了,直接判断串中是否有与 <code>s[1]</code>相同的,有相同的必然是<code>next&gt;1</code>了。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">char</span> s[<span class="hljs-number">100000</span> + <span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123; <span class="hljs-keyword">int</span> n ; cin &gt;&gt; n; cin &gt;&gt; s + <span class="hljs-number">1</span>; <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n;i ++) &#123;  <span class="hljs-keyword">if</span>(s[i] == s[<span class="hljs-number">1</span>]) flag = <span class="hljs-number">0</span>; &#125; <span class="hljs-keyword">if</span>(flag) cout&lt;&lt;<span class="hljs-string">&quot;Correct&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Wrong Answer&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h1 id="f-你一定会种树吧2.0">F-你一定会种树吧2.0</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/F">题目链接</a></p>          </div> </b></font></p><p>我知道这是个线段树，但我没时间去改模板了。也确实不想写。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> il inline</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;long, long&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb(x) push_back(x)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,x,y) for(auto i=(x);i&lt;=(y);++i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i,x,y) for(auto i=(x);i&gt;=(y);--i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem(num) memset(num,0,sizeof num)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowbit(x) ((x)&amp;-(x))</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>; <span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> a[maxn];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">int</span> l, r;<span class="hljs-keyword">int</span> mx;<span class="hljs-keyword">int</span> flag;&#125; sgt[maxn&lt;&lt;<span class="hljs-number">2</span>]; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> bitset&lt;<span class="hljs-number">32</span>&gt;(x).<span class="hljs-built_in">count</span>() == <span class="hljs-number">0</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;sgt[x].mx = <span class="hljs-built_in">max</span>(sgt[x&lt;&lt;<span class="hljs-number">1</span>].mx, sgt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mx);sgt[x].flag = sgt[x&lt;&lt;<span class="hljs-number">1</span>].flag | sgt[x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].flag;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">if</span>(l == r) &#123;sgt[x] = &#123;l, r, a[l], a[l]&#125;;<span class="hljs-keyword">return</span>;&#125;sgt[x] = &#123;l,r&#125;;<span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>, l, mid); <span class="hljs-built_in">build</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<span class="hljs-built_in">push_up</span>(x);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">if</span>(sgt[x].l == p &amp;&amp; sgt[x].r == p) &#123;sgt[x].mx = v;sgt[x].flag = v;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> mid = sgt[x].l + sgt[x].r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(p&lt;=mid) <span class="hljs-built_in">update</span>(x&lt;&lt;<span class="hljs-number">1</span>,p,v); <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,p,v);<span class="hljs-built_in">push_up</span>(x);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">if</span>(!((~v)&amp;sgt[x].flag)) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(sgt[x].l == sgt[x].r) &#123;sgt[x].mx &amp;= v;sgt[x].flag &amp;= v;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> mid = sgt[x].l + sgt[x].r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">modify</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,r,v);<span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">modify</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,v);<span class="hljs-built_in">push_up</span>(x);&#125;  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> l ,<span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-keyword">if</span>(sgt[x].l&gt;=l&amp;&amp;sgt[x].r&lt;=r) <span class="hljs-keyword">return</span> sgt[x].mx;<span class="hljs-keyword">int</span> mid = sgt[x].l + sgt[x].r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (r &lt;= mid)<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x &lt;&lt; <span class="hljs-number">1</span>, l, r);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; mid)<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);    <span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">query</span>(x&lt;&lt;<span class="hljs-number">1</span>,l,r));res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">query</span>(x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r));<span class="hljs-keyword">return</span> res;    &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;cin &gt;&gt; n;cin &gt;&gt; m;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;cin&gt;&gt;a[i];&#125;<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);string op;<span class="hljs-keyword">int</span> l, r, x, v;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;cin&gt;&gt;op;<span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<span class="hljs-comment">//cout&lt;&lt;1&lt;&lt;endl;</span>cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,l,r,v);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;U&#x27;</span>)&#123;cin&gt;&gt;x&gt;&gt;v;<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,x,v);&#125; <span class="hljs-keyword">else</span> &#123;cin&gt;&gt;l&gt;&gt;r;cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,l,r)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">NULL</span>);std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">NULL</span>);<span class="hljs-keyword">int</span> _ = <span class="hljs-number">1</span>;<span class="hljs-comment">//cin &gt;&gt; _;</span><span class="hljs-keyword">while</span> (_--) &#123;<span class="hljs-built_in">solve</span>();&#125;&#125;</code></pre></div>    </div></div><h1 id="g-郑老板爱玩博弈论">G-郑老板爱玩博弈论√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/G">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p>这道题属于是，一看题面长度吓死人，仔细看后可以算，算出来后直觉离谱的题。因为答案就输出一个<code>0.0000</code></p><p>老板对于每个选择都是 <spanclass="math inline">\(\frac{1}{20}\)</span>的概率，我直接写了个程序跑出来，无论学生取什么数字，期望得分都是 <spanclass="math inline">\(0\)</span>,</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">FOR</span>(a,<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)&#123;        <span class="hljs-keyword">double</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-built_in">FOR</span>(x,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)&#123;            <span class="hljs-keyword">if</span>(a&gt;x)ans+=(x-a+<span class="hljs-number">10</span>)/<span class="hljs-number">20</span>;            <span class="hljs-keyword">if</span>(a&lt;x)ans+=(x-a<span class="hljs-number">-10</span>)/<span class="hljs-number">20</span>;        &#125;        <span class="hljs-comment">//cout&lt;&lt;a&lt;&lt;&quot;:&quot;&lt;&lt;ans&lt;&lt;&quot; &quot;;</span>    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4f&quot;</span>,<span class="hljs-number">0</span>);&#125;</code></pre></div>    </div></div><h1 id="h-琴">H-琴</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/H">题目链接</a><span class="label label-warning">Attempted</span></p>          </div> </b></font></p><p><ahref="https://blog.csdn.net/weixin_43627118/article/details/104024380?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164247770616780255231125%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164247770616780255231125&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104024380.first_rank_v2_pc_rank_v29&amp;utm_term=%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97&amp;spm=1018.2226.3001.4187">数学- 数论 - 整除分块</a></p><p><span class="math inline">\(O(T\sqrt{n})\)</span></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T;    cin &gt;&gt; T;    <span class="hljs-keyword">while</span>(T --)    &#123;        LL res = <span class="hljs-number">0x3f3f3f3f</span>;        LL n,m;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);        <span class="hljs-keyword">if</span>(m % n == <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &gt; m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n - m);        <span class="hljs-keyword">else</span>         &#123;            <span class="hljs-keyword">for</span>(LL l = <span class="hljs-number">1</span>,r;l &lt;= n;l = r + <span class="hljs-number">1</span>)            &#123;                r = <span class="hljs-built_in">min</span>(n,(m - <span class="hljs-number">1</span>) / ((m - <span class="hljs-number">1</span>) / l));                res = <span class="hljs-built_in">min</span>(res,((m - <span class="hljs-number">1</span>) / l )* l);            &#125;             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n - m + res);        &#125;           &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h1 id="i-简单数学2.0">I-简单数学2.0</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/I">题目链接</a></p>          </div> </b></font></p><p>考虑离线莫队。题目相当于找出每段区间里每个数字的所有因子，找到其出现次数最多的因子的个数。但是 ai 最大可达到 <span class="math inline">\(1e^6\)</span>,因子数量太多。仔细想想会发现我们并不需要求出所有因子，只需要求出所有质因子即可，又因为一个数的质因子个数非常少（最多不超过7 个，记为 <spanclass="math inline">\(k\)</span>），因此我们可以预处理所有数的质因子后把问题近似为求区间众数。维护每个质因子出现的次数和出现i 次的质因子的数量，即可离线后使用莫队求解本题。 由于 n 和 q为同一数量级，总时间复杂度为 <spanclass="math inline">\(O(kn\sqrt{n})\)</span></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">10</span>, B=<span class="hljs-number">220</span>, X=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>; vector&lt;<span class="hljs-keyword">int</span>&gt; V[X];<span class="hljs-keyword">int</span> numofp[X], num[N];<span class="hljs-keyword">int</span> maxp;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> a[N];<span class="hljs-keyword">bool</span> visp[X];vector&lt;<span class="hljs-keyword">int</span>&gt; vis; <span class="hljs-comment">//prime</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getprime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-keyword">if</span>(V[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> x=i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>; j*j&lt;=x; ++j)&#123;<span class="hljs-keyword">if</span>(x%j==<span class="hljs-number">0</span>)&#123;V[i].<span class="hljs-built_in">push_back</span>(j);<span class="hljs-keyword">while</span>(x%j==<span class="hljs-number">0</span>)&#123;x/=j;&#125;&#125;&#125;<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) V[i].<span class="hljs-built_in">push_back</span>(x);&#125; <span class="hljs-comment">//modui</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Query</span>&#123;</span><span class="hljs-keyword">int</span> l, r, ans, id;<span class="hljs-built_in">Query</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> r=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> id=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(l),<span class="hljs-built_in">r</span>(r),<span class="hljs-built_in">id</span>(id)&#123;&#125;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Query&amp;t)<span class="hljs-keyword">const</span>&#123;<span class="hljs-keyword">int</span> a=l/B, b=t.l/B;<span class="hljs-keyword">if</span>(a!=b) <span class="hljs-keyword">return</span> a&lt;b;<span class="hljs-keyword">return</span> r&lt;t.r;&#125;&#125;q[N]; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span></span>&#123;<span class="hljs-comment">//printf(&quot;%d\n&quot;, a[w]);</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;p:V[a[w]])&#123;<span class="hljs-comment">//printf(&quot;+ %d\n&quot;, p);</span>num[numofp[p]]--;numofp[p]++;num[numofp[p]]++;maxp=<span class="hljs-built_in">max</span>(maxp,numofp[p]);<span class="hljs-comment">//printf(&quot;maxp=%d\n&quot;, maxp);</span>&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;p:V[a[w]])&#123;num[numofp[p]]--;numofp[p]--;num[numofp[p]]++;<span class="hljs-keyword">if</span>(num[maxp]==<span class="hljs-number">0</span>) maxp--;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Getans</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> maxp;&#125; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Query&amp;q1, <span class="hljs-keyword">const</span> Query&amp;q2)</span></span>&#123;<span class="hljs-keyword">return</span> q1.id&lt;q2.id;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> T; cin&gt;&gt;T;<span class="hljs-comment">//init V[]</span><span class="hljs-comment">//getprime();</span><span class="hljs-comment">//solve</span><span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-comment">//input n, q, a[], query[]</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);num[<span class="hljs-number">0</span>]=X;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a+i);<span class="hljs-built_in">getprime</span>(a[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>, l, r; i&lt;=m; ++i)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);q[i]=<span class="hljs-built_in">Query</span>(l,r,i);&#125;q[<span class="hljs-number">0</span>]=<span class="hljs-built_in">Query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//prime factor of a[]</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;j:V[a[i]])&#123;<span class="hljs-keyword">if</span>(!visp[j])&#123;visp[j]=<span class="hljs-literal">true</span>;vis.<span class="hljs-built_in">push_back</span>(j);&#125;&#125;&#125;<span class="hljs-comment">//block, sort</span><span class="hljs-built_in">sort</span>(q,q+m+<span class="hljs-number">1</span>);<span class="hljs-comment">//solve</span><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>, r=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=m; ++i)&#123;<span class="hljs-comment">//printf(&quot;l=%d r=%d\n&quot;, l, r);</span><span class="hljs-keyword">while</span>(l&lt;q[i].l) <span class="hljs-built_in">Del</span>(l++); <span class="hljs-keyword">while</span>(l&gt;q[i].l) <span class="hljs-built_in">Add</span>(--l);<span class="hljs-keyword">while</span>(r&lt;q[i].r) <span class="hljs-built_in">Add</span>(++r);<span class="hljs-keyword">while</span>(r&gt;q[i].r) <span class="hljs-built_in">Del</span>(r--);q[i].ans=<span class="hljs-built_in">Getans</span>();&#125;<span class="hljs-comment">//print</span><span class="hljs-built_in">sort</span>(q,q+m+<span class="hljs-number">1</span>,cmp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, q[i].ans);&#125;<span class="hljs-comment">//init</span>maxp=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;V[i].<span class="hljs-built_in">clear</span>();num[i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;i:vis)&#123;visp[i]=<span class="hljs-literal">false</span>;numofp[i]=<span class="hljs-number">0</span>;&#125;vis.<span class="hljs-built_in">clear</span>();&#125;&#125;</code></pre></div>    </div></div><h1 id="j-简单水题">J-简单水题√</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><a href="https://vjudge.net/contest/476894#problem/J">题目链接</a><span class="label label-success">AC</span></p>          </div> </b></font></p><p>看到棋盘格和从左上角走到右下角，只能向右边或者向下行走首先想到递推。</p><p>因为每个格子上只能是<span class="math inline">\(1\)</span>或<spanclass="math inline">\(0\)</span>,想到可以用路径和表示路过了多少个“<spanclass="math inline">\(1\)</span>”和“<spanclass="math inline">\(0\)</span>”,为了记录到达每个格子的各种已经路过数量的方案数，对每个格子<span class="math inline">\((i,j)\)</span> 还得开个 <spanclass="math inline">\(i+j-1\)</span>来储存各种可能的方案数量。即要开个<code>dp[n][m][n+m]</code>的三维数组，再在二维上对每个格子dp。</p><p>然后我用<spanclass="math inline">\(dp[510][510][1050]\)</span>写了出来。然后提交直接ME。于是想了想，压缩了第一纬度空间。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        我的代码    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">32767</span>*<span class="hljs-number">2</span>+<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>];<span class="hljs-keyword">int</span> b[<span class="hljs-number">2</span>][<span class="hljs-number">510</span>][<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> m=<span class="hljs-built_in">read</span>();    <span class="hljs-keyword">int</span> p=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)            a[i][j]=<span class="hljs-built_in">read</span>();    b[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)        <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">1</span>,m)&#123;            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>&amp;&amp;j==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">0</span>,i+j)&#123;                b[i%<span class="hljs-number">2</span>][j][k]=(b[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>][j][k-a[i][j]]+b[i%<span class="hljs-number">2</span>][(j<span class="hljs-number">-1</span>)][k-a[i][j]])%M;            &#125;        &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">FOR</span>(i,q,n+m<span class="hljs-number">-1</span>-p)        ans=(ans+b[n%<span class="hljs-number">2</span>][m][i])%M;    cout&lt;&lt;ans;&#125;</code></pre></div>    </div></div><h1 id="k-学不会的知识">K-学不会的知识*</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/K">题目链接</a></p>          </div> </b></font></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; M;<span class="hljs-keyword">int</span> mp[N];<span class="hljs-keyword">int</span> n, k;LL a[N];vector&lt;LL&gt; V; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span></span>&#123;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;i:M)&#123;        mp[i.second] = <span class="hljs-number">0</span>;    &#125;    M.<span class="hljs-built_in">clear</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)    &#123;        <span class="hljs-keyword">int</span> val = a[i];        <span class="hljs-keyword">if</span> (mp[val])&#123;            cnt++;            M.<span class="hljs-built_in">erase</span>(mp[val]);            mp[val] = i;            M[i] = val;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(M.<span class="hljs-built_in">size</span>()&lt;m)&#123;            mp[val] = i;            M[i] = val;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">auto</span> t = M.<span class="hljs-built_in">begin</span>();            <span class="hljs-keyword">int</span> v = t-&gt;second;            M.<span class="hljs-built_in">erase</span>(t);            mp[v] = <span class="hljs-number">0</span>;            mp[val] = i;            M[i] = val;        &#125;    &#125;    <span class="hljs-keyword">return</span> cnt &gt;= k;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lisan</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">sort</span>(V.<span class="hljs-built_in">begin</span>(), V.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;        a[i] = <span class="hljs-built_in">lower_bound</span>(V.<span class="hljs-built_in">begin</span>(), V.<span class="hljs-built_in">end</span>(), a[i]) - V.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>;    &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, a + i);        V.<span class="hljs-built_in">push_back</span>(a[i]);    &#125;    <span class="hljs-built_in">lisan</span>();    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n, mid;    <span class="hljs-keyword">while</span>(l&lt;r<span class="hljs-number">-1</span>)&#123;        mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))            r = mid;        <span class="hljs-keyword">else</span>            l = mid + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> ans;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(l))        ans = l;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(r)) ans=r;    <span class="hljs-keyword">else</span> ans=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(ans&gt;<span class="hljs-number">0</span>)&#123;    cout &lt;&lt; ans &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;cbddl&quot;</span>&lt;&lt;endl;&#125;    &#125;</code></pre></div>    </div></div><h1 id="l-写不完了">L-写不完了 *</h1><p><font size=0.1 face="微软雅黑"><b> <div class="note note-info">            <p><ahref="https://vjudge.net/contest/476894#problem/L">题目链接</a></p>          </div> </b></font></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        std    </div>    <div class='spoiler-content'>        <div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxm=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> head[maxm],nt[maxm&lt;&lt;<span class="hljs-number">1</span>],to[maxm&lt;&lt;<span class="hljs-number">1</span>],idx[maxm&lt;&lt;<span class="hljs-number">1</span>],cnt;<span class="hljs-keyword">int</span> d[maxm];<span class="hljs-keyword">int</span> a[maxm];<span class="hljs-keyword">int</span> e[maxm];<span class="hljs-keyword">int</span> n,q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span>&#123;    cnt++;nt[cnt]=head[x];head[x]=cnt;to[cnt]=y;idx[cnt]=z;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span></span>&#123;    d[x]=a[x];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=nt[i])&#123;        <span class="hljs-keyword">int</span> v=to[i],w=e[idx[i]];        <span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs1</span>(v,x);        d[x]=<span class="hljs-built_in">min</span>(d[x],d[v]+w);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=nt[i])&#123;        <span class="hljs-keyword">int</span> v=to[i],w=e[idx[i]];        <span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;        d[v]=<span class="hljs-built_in">min</span>(d[v],d[x]+w);        <span class="hljs-built_in">dfs2</span>(v,x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ans^=d[i];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">int</span> x,y,z;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);        <span class="hljs-built_in">add</span>(x,y,i);        <span class="hljs-built_in">add</span>(y,x,i);        e[i]=z;    &#125;    <span class="hljs-keyword">while</span>(q--)&#123;        <span class="hljs-keyword">int</span> op;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">int</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);            a[x]=y;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">int</span> x,y;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);            e[x]=y;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">cal</span>();        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">solve</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优劣解距离法</title>
    <link href="/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E6%B3%95/"/>
    <url>/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.28，其中一些理解可能已被笔者推翻或废弃。</p>          </div><h1 id="优劣解距离法topsis">优劣解距离法(TOPSIS)</h1><p>TOPSIS法(Technique for Order Preference by Similarity to IdealSolution)<br />可翻译为逼近理想解排序法，国内常简称为优劣解距离法。是根据有限个评价对象与理想化目标的接近程度进行排序的方法，是在现有的对象中进行相对优劣的评价。</p><p>TOPSIS 法是一种常用的综合评价方法，其能充分利用原始数据的信息，<br />其结果能精确地反映各评价方案之间的差距。</p><figure><img src="https://s2.loli.net/2022/02/28/jRuf16qiWHEZbGm.png"alt="不同压缩因子压缩熵权法的TOPSIS" /><figcaptionaria-hidden="true">不同压缩因子压缩熵权法的TOPSIS</figcaption></figure><h2 id="基本思想">基本思想</h2><p>构造计算评分公式：<spanclass="math inline">\(\frac{x-min}{max-min}\)</span></p><p>该公式能够良好的对一个指标下的数据进行评分，反应了单个数据在数据范围区间所处的位置。</p><p><strong>拓展</strong>：将其中 <spanclass="math inline">\(x-min\)</span> 理解为“x与最小点的距离”；<spanclass="math inline">\(max-x\)</span>理解为“x于最大值点的距离”即可得到多指标评价公式</p><h2 id="模型步骤">模型步骤</h2><h3 id="数据处理">数据处理</h3><p>对所有的指标构成进行说明</p><p>对于 <span class="math inline">\(m\)</span> 个评价指标横向排列，<spanclass="math inline">\(n\)</span> 个评价对象纵向排列的矩阵，记为 <spanclass="math display">\[X_{nm}=\left[\begin{array}{cccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n 1} &amp; x_{n 2} &amp; \cdots &amp; x_{n m}\end{array}\right]\]</span></p><h3 id="指标正向化">指标正向化</h3><p><strong>描述</strong>：统一指标类型，将为极小型、中间型、区间型等指标转换为极大值指标</p><p><strong>注</strong>：最好不要出现负数(无法求熵权)</p><ol type="1"><li>极小型指标转换为极大型指标的公式</li></ol><p><spanclass="math display">\[\bar{x}_{i}=max-x_i或\bar{x}_{i}=\frac{1}{x_i}\]</span><strong>其中</strong>：<spanclass="math inline">\(\bar{x}_{i}\)</span>代表转化后的结果</p><ol start="2" type="1"><li>中间型指标转化为极大型指标</li></ol><p><span class="math display">\[\bar{x}_{i}=1-\frac{\left|x_{i}-x_{\text{best }}\right|}{\max \left(\left|X-x_{\text {best}}\right|\right)}\]</span> <strong>其中</strong>：<spanclass="math inline">\(x_{best}\)</span> 指代的是最好的值</p><ol start="3" type="1"><li>区间型指标转化为极大型指标</li></ol><p><span class="math display">\[\overline{x_{i}}=\left\{\begin{array}{c}1-\frac{a-x_{i}}{M}, x_{i}&gt;a \\1, \quad a&lt;x_{i}&lt;b \\1-\frac{x_{i}-b}{M}, x_{i}&gt;b\end{array}\right.\]</span> <strong>其中</strong>：<span class="math inline">\(M=\max\{a-\min (X), \max (X)-b\}\)</span>即偏离最优区间最远的值; <spanclass="math inline">\(a\)</span>为下界，<spanclass="math inline">\(b\)</span>为上界</p><h3 id="标准化处理">标准化处理</h3><p><strong>描述</strong>：消去不同指标量纲的影响</p><p>记标准化矩阵为<span class="math inline">\(Z_{nm}\)</span>,有<spanclass="math inline">\(Z_{i j}=\frac{x_{i j}}{\sqrt{\sum_{i=1}^{n} x_{ij}^{2}}}\)</span></p><h3 id="计算得分">计算得分</h3><p>定义 <span class="math display">\[\begin{aligned}Z^{+} &amp;=\left(Z_{1}^{+}, Z_{2}^{+}, \cdots, Z_{m}^{+}\right) \\&amp;=\left(\max \left\{z_{11}, z_{21}, \cdots, z_{n 1}\right\}, \max\left\{z_{12}, z_{22}, \cdots, z_{n 2}\right\}, \cdots, \max \left\{z_{1m}, z_{2 m}, \cdots, z_{n m}\right\}\right) \\Z^{-} &amp;=\left(Z_{1}^{-}, Z_{2}^{-}, \cdots, Z_{m}^{-}\right) \\&amp;=\left(\min \left\{z_{11}, z_{21}, \cdots, z_{n 1}\right\}, \min\left\{z_{12}, z_{22}, \cdots, z_{n 2}\right\}, \cdots, \min \left\{z_{1m}, z_{2 m}, \cdots, z_{n m}\right\}\right)\end{aligned}\]</span></p><p>定义第 <span class="math inline">\(i(i=1,2, \cdots, n)\)</span>个评价对象与最大值的距离 <spanclass="math inline">\(D_{i}^{+}=\sqrt{\sum_{j=1}^{m}\widetilde{w}_{j}\left(Z_{j}^{+}-z_{ij}\right)^{2}}\)</span><br />定义第 <span class="math inline">\(i(i=1,2, \cdots, n)\)</span>个评价对象与最小值的距离 <spanclass="math inline">\(D_{i}^{-}=\sqrt{\sum_{j=1}^{m}\widetilde{w}_{j}\left(Z_{j}^{-}-z_{ij}\right)^{2}}\)</span><br />其中 <span class="math inline">\(\widetilde{w}_{j}\)</span>为加权的指标权重，权重默认为1(因为除法，权重单位量对结果无影响)，可以用层次分析法或熵权法确定权重。</p><p>第 <span class="math inline">\(i(i=1,2, \cdots, n)\)</span>个评价对象未归一化得分<spanclass="math inline">\(S_{i}=\frac{D_{i}^{-}}{D_{i}^{+}+D_{i}^{-}}\)</span></p><h3 id="结果处理">*结果处理</h3><p>为了比较不同评价模型得到的结果曲线，常常对结果处理。让结果更容易解释，或更好比较。(归一化、标准化)</p><p><spanclass="math display">\[\widetilde{S_{i}}=\frac{S_{i}}{\sum_{i=1}^{n}S_{i}}\]</span></p><h2 id="更多理解">更多理解</h2><p>对于形如上文 <span class="math inline">\(Z\)</span>的矩阵，可以将<span class="math inline">\(m\)</span>个评价指标看作<spanclass="math inline">\(m\)</span>个坐标轴。对于这<spanclass="math inline">\(m\)</span>个坐标轴的张成空间 <spanclass="math inline">\(V\)</span>，每一条横轴（即待评价单元）就可表示为该空间上的一点 <spanclass="math inline">\(P(x_{i1},x_{i2},...,x_{im})\)</span>。</p><p><span class="math inline">\(Z^{+}(Z_{1}^{+}, Z_{2}^{+}, \cdots,Z_{m}^{+})\)</span> , <span class="math inline">\(Z^{-}(Z_{1}^{-},Z_{2}^{-}, \cdots, Z_{m}^{-})\)</span> 为包含所有评价点集的最小“<spanclass="math inline">\(m\)</span>维体”的主对称轴上的两端点。</p><p>对于 <spanclass="math inline">\(S_{i}=\frac{D_{i}^{-}}{D_{i}^{+}+D_{i}^{-}}=\frac{1}{1+k}\)</span>, <span class="math inline">\(k\)</span> 的含义为点到 <spanclass="math inline">\(Z^+\)</span> 与 <spanclass="math inline">\(Z^-\)</span> 的距离比值。形如 <spanclass="math inline">\(k=\frac{D^+}{D^-}=\frac{dis(X,Z^+)}{dis(X,Z^-)}\)</span>的式子表示的曲线为<span class="math inline">\(m\)</span>纬的球体。</p><p>以下为2个评价指标时，以 <span class="math inline">\(Z^+(3,2)\)</span>, <span class="math inline">\(Z^-(0,0)\)</span> 为端点，<spanclass="math inline">\(k=\{2^{-4},2^{-3},...,2^4\}\)</span>时的函数图像。同一曲线上的点表示的评价结果相同。</p><figure><img src="https://s2.loli.net/2022/01/18/pqFAbi5Ek4SonVa.png"alt="二维评价张成空间" /><figcaption aria-hidden="true">二维评价张成空间</figcaption></figure><p>如图，可以看出TOPSIS评价对空间进行了扭曲（把<spanclass="math inline">\(m\)</span>空间非线性压缩为一维评价系）。保留了样本间间距，但损失了原始统计信息。</p><blockquote><p>通过下文解释，所以TOPSIS是高纬的归一化(Normalization)?但下文中说，归一化也是线性放缩。(22.1.18)</p></blockquote><h1 id="熵权法">熵权法</h1><p>熵权法构建系数利用了信息论的知识。简单的说，数据的变异程度（方差）越大，就说明这个指标蕴含的信息量越大，也就越重要。例如：一个指标都是相同的数值，那么这个指标的变异程度（方差）就超级小，也没对最终的判断做出贡献，所以这个指标的权重就可以赋为0。</p><h2 id="模型思想">模型思想</h2><p>记信息量为<span class="math inline">\(I(p)\)</span>，概率为<spanclass="math inline">\(p\)</span>，有<spanclass="math inline">\(I(1)=0\)</span>、<spanclass="math inline">\(I(0^+)=+\infty\)</span>，可以得到一个<spanclass="math inline">\(I\)</span>与<spanclass="math inline">\(p\)</span>呈反比的函数图像。</p><p>构造<span class="math inline">\(I(x)=- \ln{p(x)}\)</span>保证<spanclass="math inline">\(0 \leqslant p(x) \leqslant 1\)</span>。<spanclass="math inline">\(x\)</span>表示事情发送的情况，<spanclass="math inline">\(p(x)\)</span>表示事情发生的概率。</p><p>可定义事件<spanclass="math inline">\(X={x_1,x_2,...,x_n}\)</span>(<spanclass="math inline">\(x_i\)</span>为发生情况)的信息熵为： <spanclass="math display">\[H(X)=\sum_{i=1}^{n}\left[p\left(x_{i}\right)I\left(x_{i}\right)\right]=-\sum_{i=1}^{n}\left[p\left(x_{i}\right) \ln\left(p\left(x_{i}\right)\right)\right]\]</span>信息熵的本质是对信息量的期望值。</p><p><strong>注</strong>：可证当<spanclass="math inline">\(p(x_1)=p(x_2)=...=p(x_n)=\frac{1}{n}\)</span>时<spanclass="math inline">\(H(x)\)</span>取得最大值为<spanclass="math inline">\(\ln n\)</span>。</p><h2 id="基本步骤">基本步骤</h2><ol type="1"><li>矩阵正向化和标准化 <spanclass="math display">\[Z=\left[\begin{array}{cccc}z_{11} &amp; z_{12} &amp; \cdots &amp; z_{1 m} \\z_{21} &amp; z_{22} &amp; \cdots &amp; z_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n 1} &amp; z_{n 2} &amp; \cdots &amp; z_{n m}\end{array}\right]\]</span></li><li>对已经正向化和标准化的矩阵，若有负数需再次归一化(另一种标准化) <spanclass="math display">\[\tilde{z}_{i j}=\frac{x_{i j}-\min \left\{x_{1j}, x_{2 j}, \cdots, x_{n j}\right\}}{\max \left\{x_{1 j}, x_{2 j},\cdots, x_{n j}\right\}-\min \left\{x_{1 j}, x_{2 j}, \cdots, x_{nj}\right\}}\]</span></li><li>计算概率矩阵 <span class="math display">\[p_{i j}=\frac{\tilde{z}_{ij}}{\sum_{i=1}^{n} \tilde{z}_{i j}}\]</span></li><li>计算熵值。之所以除以了一个 <spanclass="math inline">\(ln(n)\)</span> 是为了归一化 <spanclass="math display">\[e=-\frac{1}{\ln (n)} \times \sum_{i=1}^{n} p_{i}\ln \left(p_{i}\right)\]</span></li><li>构建权重。首先用<spanclass="math inline">\(1-e_j\)</span>得到信息的效用值，之后因为权重只和为<spanclass="math inline">\(1\)</span>，在对权重进行归一化即可得到<spanclass="math inline">\(w_j\)</span>权重 <spanclass="math display">\[d_j=1-e_j\]</span> <spanclass="math display">\[w_j=\frac{d_j}{\sum_{j=1}^m d_j}\]</span></li></ol><blockquote><p>熵权法仅仅能反应指标信息量的大小，并不能反应指标的重要程度，所以使用熵权法加权的评价模型得到的结果往往比未加权的结果变化幅度更大，增减趋势更明显。但似乎并不能得到一个客观的评分？(22.1.21)</p></blockquote><figure><img src="https://pic.imgdb.cn/item/621c62d12ab3f51d911ebe63.png"alt="越往右越趋近正常的熵权法权重" /><figcaption aria-hidden="true">越往右越趋近正常的熵权法权重</figcaption></figure><h1 id="归一化与标准化">*归一化与标准化</h1><p>它们都是指特征工程中的特征线性缩放过程</p><p><strong>作用</strong>：</p><ol type="1"><li>使不同量纲的特征处于同一数值量级，减少方差大的特征的影响，使模型更准确。</li><li>加快学习算法的收敛速度。</li></ol><p><strong>缩放过程可以分为以下几种</strong>：</p><ol type="1"><li>缩放到均值为0，方差为1（Standardization——StandardScaler()）</li><li>缩放到0和1之间（Standardization——MinMaxScaler()）</li><li>缩放到-1和1之间（Standardization——MaxAbsScaler()）</li><li>缩放到0和1之间，保留原始数据的分布（Normalization——Normalizer()）</li></ol><p>1就是常说的z-score归一化，2是min-max归一化。</p><h2 id="归一化normalization">归一化（Normalization）</h2><h3 id="平均归一化mean-normalization">1.平均归一化（MeanNormalization）</h3><p>这种归一化需防止在线学习或在线推理中，新进样本突破原始min或max数据</p><p><span class="math display">\[\frac{X_{i}-\mu }{X_{\max }-X_{\min}}\]</span></p><p><strong>其中</strong>：<spanclass="math inline">\(X_{min}\)</span>表示对应矩阵中最小的数;<spanclass="math inline">\(X_{max}\)</span>表示对应矩阵中最大的数</p><h3 id="minmax归一化rescaling">2.minmax归一化（Rescaling）</h3><p>这种归一化需防止在线学习或在线推理中，新进样本突破原始min或max数据<span class="math display">\[\frac{X_{i}-X_{\min }}{X_{\max }-X_{\min}}\]</span></p><h3 id="非线性归一化non-linear-normlization">3.非线性归一化（Non-LinearNormlization）</h3><p><span class="math display">\[\begin{array}{c}\lg x \\\log _{2} x \\\frac{2}{\pi} \arctan x\end{array}\]</span> 这种归一化需考虑数据分布，进行适当的非线性函数选取。</p><h2 id="标准化standardization">标准化（Standardization）</h2><h3 id="z-score标准化">1.Z-Score标准化</h3><p><span class="math display">\[\frac{X_{i}-\mu}{\sigma}\]</span>这种标准化需要要求原数据近似高斯分布。</p><p><strong>其中</strong>：<spanclass="math inline">\(\mu\)</span>表示矩阵均值;<spanclass="math inline">\(\sigma\)</span>表示矩阵标准差</p><h2 id="中心化centralization">中心化（Centralization）</h2><p>对于中心化，有的地方成为Mean-Subtraction，表示均值-减去（有点日本话的感觉），有的地方称之为Zero-Mean即零均值化，还有的为Zero-Centered这个只可意会很难翻译。但总而言之，他们都是下面这个形式：<span class="math display">\[x_i-\mu\]</span></p><h2 id="区别和用途">区别和用途</h2><p>归一化和标准化的相同点都是对某个特征（column）进行缩放（scaling）而不是对某个样本的特征向量（row）进行缩放。对特征向量进行缩放是毫无意义的。</p><p>归一化和标准化都保持数据分布不变的情况下（两者本质上都只是对数据进行线性变化），对数据进行处理，但是从公式上面还是能够明显看出来，归一化的处理只是和最大值最小值相关，归一化后样本会失去原始的信息；标准化却是和数据的分布相关（均值，方差）。归一化更好保留了样本间间距；标准化的统计意义更强，是数据缩放的首选。</p><table><colgroup><col style="width: 57%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th style="text-align: center;">归一化</th><thstyle="text-align: left;"><font size=1>将一列数据“拍扁”到某个固定区间(常为[0,1]),和最大/小值有关</font></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>标准化</strong></td><tdstyle="text-align: left;"><font size=1><strong>将数据变换为均值0,标准差为1的分布(并非一定正态),缩放和每个点都有关(通过均值+方差体现)</strong></font></td></tr><tr class="even"><td style="text-align: center;"><strong>中心化</strong></td><tdstyle="text-align: left;"><font size=1><strong>变量减去均值，可避免异常值和极端值的影响，本质为口个平移过程，平移后数据中心是原点0</strong></font></td></tr></tbody></table><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.cnblogs.com/xiashiwendao/p/12130992.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://baike.baidu.com/item/TOPSIS%E6%B3%95/3094166?fr=aladdin<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://blog.csdn.net/limiyudianzi/article/details/103410150<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>bilibili:数学建模学习交流<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://www.zhihu.com/question/20467170<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/364338617<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOPSIS</tag>
      
      <tag>熵权法</tag>
      
      <tag>归一化与标准化</tag>
      
      <tag>综合评价</tag>
      
      <tag>客观赋权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>层次分析法</title>
    <link href="/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <url>/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.1，其中一些理解可能已被笔者推翻或废弃。</p>          </div><h1 id="层次分析法ahp">层次分析法(AHP)</h1><p>层次分析法(Analytic Hierarchy Process,AHP)<br />这是一种定性和定量相结合的、系统的、层次化的分析方法。这种方法是在对复杂决策问题的本质上，利用较少的定量信息使<strong>决策的思维过程数学化</strong>，从而为多目标、多准则或无结构特性的决策问题提供简便的决策方法。<strong>是对难以定量的复杂系统进行决策的模型</strong>。</p><p>层次分析法的根本是<strong>打分法</strong>：<u>确定指标</u>，<u>不同方案指标打分</u>，<u>为指标确定权重</u>。用于处理数据未知的评价。</p><p>层次分析法将问题分解为组成因素，并按照因素间关联、影响以及隶属关系将因素按不同的层次聚集组合，形成一个多层次的分析结构模型。从而最终使问题归结为最低层(供决策的方案、措施等)相对于最高层(总目标)的相对重要权值的确定或相对优劣次序的排定。</p><h2 id="基本步骤">基本步骤</h2><h3 id="建立层次模型">建立层次模型</h3><p>思考以下问题：</p><ol type="1"><li>我的的评价目标是什么？</li><li>达到目标有哪些方案？</li><li>★对方案的评价准则或指标是什么？（最好参考引用文献）</li></ol><p>将<u>决策的目标</u>、<u>决策准则</u>(考虑的因素)和<u>决策对象</u>绘制为层次结构图。</p><ol type="1"><li>最高层(目标层)：决策的目的、要解决的问题；</li><li>中间层(准则层或指标层)：考虑的因素、决策的准则；</li><li>最低层(方案层)：决策时的备选方案；</li></ol><p>或仅绘制评价体系(树状图或表格)如下(要包含<strong>多级指标</strong>)：</p><figure><img src="https://s2.loli.net/2022/01/18/oVnIQh5DpORcuqX.png"alt="评价模型" /><figcaption aria-hidden="true">评价模型</figcaption></figure><h3 id="构造判断矩阵">构造判断矩阵</h3><p>(成对比较矩阵)</p><p>在确定权重时，只给出定性的结果(就是我认为景色占80%，费用10%等等)，常常不被别人接受，因此采用一致矩阵法，即：</p><ul><li>不把所有因素放在一起比较，而是两两比较</li><li>对此时采用相对尺度，尽可能减少诸因素导致的相互比较的困难，提高准确性</li></ul><p>成对比较矩阵是表示本层所有因素针对上一层某一个因素(准侧或目标)的相对重要性的比较。成对比较矩阵的元素<span class="math inline">\(a_{ij}\)</span> 表示的是第 <spanclass="math inline">\(i\)</span> 个因素相对于第 <spanclass="math inline">\(j\)</span>个因素的比较结果，这个值使用的是Santy的1-9标度方法给出。</p><p>定义且满足</p><p><spanclass="math display">\[a_{ij}=i相对j的重要度=\frac{i的重要程度}{j的重要程度}=a_{ik}a_{kj}\]</span></p><p><img src="https://s2.loli.net/2022/01/18/f5gYz8SqUmTbahn.png" /></p><h3 id="一致性检验">一致性检验</h3><p><span class="math inline">\(\left[\begin{array}{cccc} a_{11} &amp;a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22} &amp; \cdots&amp; a_{2 n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{n1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}\end{array}\right]\)</span>为一致矩阵的充要条件<spanclass="math inline">\(\left\{\begin{array}{l} a_{i j}&gt;0 \\a_{11}=a_{22}=\cdots=a_{n n}=1 \\ {\left[a_{i 1},..., a_{in}\right]=k_{i}\left[a_{11},..., a_{1 n}\right]}\end{array}\right.\)</span></p><p>对于</p><p>一致阵：则我们自然会取对应于最大特征根 <spanclass="math inline">\(n\)</span> 的归一化特征向量 <spanclass="math inline">\(\{w_1,w_2,\cdots,w_n\}\)</span> ，且 <spanclass="math inline">\(\sum_{i=1}^{n}{w_i=1}\)</span> ， <spanclass="math inline">\(w_i\)</span> 表示下层第 <spanclass="math inline">\(i\)</span>个因素对上层某个因素影响程度的权值。</p><p>非一致阵：用其最大特征根对应的归一化特征向量作为权向量 <spanclass="math inline">\(W=\{w_1,w_2,\cdots,w_n\}\)</span> ，则 <spanclass="math inline">\(AW=\lambda W\)</span>，这样确定权向量的方法称为特征根法；</p><p>定理：</p><ol type="1"><li><span class="math inline">\(n\)</span> 阶一致阵的唯一非零特征根为<span class="math inline">\(n\)</span></li><li><span class="math inline">\(n\)</span> 阶互反阵 <spanclass="math inline">\(A\left(a_{i j}&gt;0, a_{i j}=\frac{1}{a_{j i}},a_{i i}=1\right)\)</span> 最大特征根 <span class="math inline">\(\lambda\geq n\)</span> ，当且仅当 <spanclass="math inline">\(\lambda=n\)</span> 时， <spanclass="math inline">\(A\)</span> 为一致矩阵。</li></ol><p><span class="math inline">\(\lambda\)</span> 连续的依赖于 <spanclass="math inline">\(a_{ij}\)</span> ，则 <spanclass="math inline">\(\lambda\)</span> 比 <spanclass="math inline">\(n\)</span> 大的越多， <spanclass="math inline">\(A\)</span>的不一致性越严重。用最大特征值对应的特征向量作为影响程度的权向量，其不一致程度越大，引起的判断误差越大。</p><p><strong>第一步：计算一致性指标CI</strong></p><p><span class="math display">\[CI=\frac{\lambda -n}{n-1}\]</span></p><ol type="1"><li><span class="math inline">\(CI=0\)</span> ,有完全的一致性；</li><li><span class="math inline">\(CI\)</span> 接近 <spanclass="math inline">\(0\)</span> ，有满意的一致性</li><li><span class="math inline">\(CI\)</span> 越大，不一致越严重；</li></ol><p><strong>第二步：查找对应的平均随机一致性指标RI</strong></p><table><colgroup><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /></colgroup><thead><tr class="header"><th style="text-align: center;">n</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">8</th><th style="text-align: center;">9</th><th style="text-align: center;">10</th><th style="text-align: center;">11</th><th style="text-align: center;">12</th><th style="text-align: center;">13</th><th style="text-align: center;">14</th><th style="text-align: center;">15</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">RI</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0.52</td><td style="text-align: center;">0.89</td><td style="text-align: center;">1.12</td><td style="text-align: center;">1.26</td><td style="text-align: center;">1.36</td><td style="text-align: center;">1.41</td><td style="text-align: center;">1.46</td><td style="text-align: center;">1.49</td><td style="text-align: center;">1.52</td><td style="text-align: center;">1.54</td><td style="text-align: center;">1.56</td><td style="text-align: center;">1.58</td><td style="text-align: center;">1.59</td></tr></tbody></table><p><span class="math inline">\(RI\)</span>为统计结果，详细计算方法参考<ahref="https://zhuanlan.zhihu.com/p/38207837">这里</a></p><p><strong>第三步：计算一致性比例CR</strong></p><p><span class="math display">\[CR=\frac{CI}{RI}\]</span></p><p>如果 <span class="math inline">\(CR &lt; 0.1\)</span>,则可认为判断矩阵的一致性可以接受；否则需要对判断矩阵进行修正。</p><h3 id="求得权重">求得权重</h3><ol type="1"><li>算术平均法求权重 <span class="math display">\[\omega_{i}=\frac{1}{n}\sum_{j=1}^{n} \frac{a_{i j}}{\sum_{k=1}^{n} a_{k j}}\]</span></li><li>几何平均法求权重 <spanclass="math display">\[\omega_{i}=\frac{\left(\prod_{j=1}^{n} a_{ij}\right)^{\frac{1}{n}}}{\sum_{k=1}^{n}\left(\prod_{j=1}^{n} a_{kj}\right)^{\frac{1}{n}}}\]</span></li><li>特征值法求权</li></ol><p>特别的：若特征值为n，对应特征向量为<spanclass="math inline">\(k\left[\frac{1}{a_{11}}, \frac{1}{a_{12}}, \cdots,\frac{1}{a_{1 n}}\right]^{T}\)</span>，且特征向量刚好为矩阵第一列。</p><p>假如我们的判断矩阵一致性可以接受，那么我们可以仿照一致矩阵权重的求法。</p><ol type="1"><li>求出矩阵A的最大特征值以及其对应的特征向量<br /></li><li>对求出的特征向量进行归一化即可得到我们的权重( <spanclass="math inline">\(\sum_{i=1}^{n}{w_i=1}\)</span> )</li></ol><h3 id="填表得结果">填表得结果</h3><figure><img src="https://s2.loli.net/2022/01/18/BgNZY8JkrPjMKtq.png"alt="表格" /><figcaption aria-hidden="true">表格</figcaption></figure><p>然后相应的加权计算得分即可得到结果。</p><h2 id="一点补充">一点补充</h2><h3 id="详细做法补充">详细做法补充</h3><ol type="1"><li>对于评价指标：<ol type="1"><li>单层评价指标：构造所有指标的两两判断矩阵，得到权值</li><li>多层评价指标：<ol type="1"><li>构造一级指标的两两判断矩阵，得到权值</li><li>构造每个一级指标下的二级指标的两两判断矩阵（每个一级指标一个矩阵），得到权值</li><li>构造每个二级指标下……<br />……</li></ol></li></ol></li><li>对于方案：<ol type="1"><li>对于每个最低级指标构造所有方案的两两判断矩阵，得到权值</li></ol></li></ol><p>示例：</p><p><span class="math display">\[\left\{\begin{array}{l}   一级指标1\left\{\begin{array}{l}      二级指标1 :a_{11},a_{12},a_{13}\\      二级指标2 :a_{21},a_{22},a_{23}\\   \end{array}\right.\\ \\   一级指标2\left\{\begin{array}{l}      二级指标3 :a_{31},a_{32},a_{33}\\      二级指标4 :a_{41},a_{42},a_{43}\\      二级指标5 :a_{51},a_{52},a_{53}\\   \end{array}\right.\\ \\   一级指标3 : a_{61},a_{62},a_{63}\end{array}\right.\\\]</span></p><h3 id="特征向量含义思考">特征向量含义思考</h3><p>对于矩阵 <span class="math inline">\(A=\left[\begin{array}{cccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22}&amp; \cdots &amp; a_{2 n} \\ \vdots &amp; \vdots &amp; \ddots &amp;\vdots \\ a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}\end{array}\right]\)</span> ， <spanclass="math inline">\(W=\left[\begin{array}{c} w_{1}\\ w_{2}\\ \vdots\\w_{n} \end{array}\right]\)</span> ，满足 <spanclass="math inline">\(AW=\lambda A\)</span> 。</p><p>矩阵的本质是变换，把 <span class="math inline">\(A\)</span> 看作对<span class="math inline">\(m\)</span> 纬空间单位球体进行 <spanclass="math inline">\(A\)</span> 变换,取 <spanclass="math inline">\(\lambda\)</span> 最大时的特征向量 <spanclass="math inline">\(W\)</span>,即表示为变换后的球体上与变换前方向相同的点中距离原点 <spanclass="math inline">\(O\)</span> 最远的点（距离原点距离为 <spanclass="math inline">\(\lambda\)</span> ）所表示的方向向量 。记 <spanclass="math inline">\(W\)</span> 为可以代表整个变换 <spanclass="math inline">\(A\)</span> 的线性变换。</p><blockquote><p>特别的对于对称矩阵 <span class="math inline">\(A\)</span> ，变换<span class="math inline">\(A\)</span>一定是将球变为椭球，这也是不同特征值对应特征向量一定正交的原因，相同特征值<span class="math inline">\(\lambda\)</span> 若有多个特征向量 <spanclass="math inline">\(e_1,e_2,...\)</span>，特征向量的张成空间都是该特征值<span class="math inline">\(\lambda\)</span> 的特征向量。<spanclass="math inline">\(\lambda\)</span> 的特征向量。<br />但是，对于非特殊矩阵，几何意义不明确，另外对于正互反矩阵、一致性矩阵的变换性质，笔者并不清楚，所以也仅仅能近似的类比理解到这里了。(22.1.18)</p></blockquote><h2 id="一些问题">一些问题</h2><ol type="1"><li>评价的决策层不能太多，太多的话n会很大,判断矩阵和一致矩阵差异可能会很大。</li><li>平均随机一致性指标RI的表格中n最多是15。</li></ol><p>所以<strong>当n过大可以分层归纳为多级指标</strong>再构造多个判断矩阵。</p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>bilibili:数学建模学习交流<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/38207837<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>综合评价</tag>
      
      <tag>层次分析法</tag>
      
      <tag>决策方法</tag>
      
      <tag>主观赋权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模糊综合评价</title>
    <link href="/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/"/>
    <url>/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.1，其中一些理解可能已被笔者推翻或废弃。</p>          </div><h1 id="模糊综合评价fuzzy-sets">模糊综合评价(fuzzy sets)</h1><p>模糊综合评价(Fuzzy Comprehension EvaluationMethod)又为模糊集合理论(fuzzy sets)对于难以明确分类，边界不明显的评价指标可才用模糊综合评价，模型关键在于构造的<strong>隶属函数</strong>的准确性和合理性。</p><h2 id="基本步骤">基本步骤</h2><h3 id="建立综合评价的因素集">建立综合评价的因素集</h3><p>模糊综合评价指标的构建。<br />因素集是以影响评价对象的各种因素为元素所组成的一个普通集合，通常用 <spanclass="math inline">\(U\)</span> 表示， <spanclass="math inline">\(U=(u_1,u_2,\cdots,u_m)\)</span>，其中元素 <spanclass="math inline">\(u_i\)</span> 代表影响评价对象的第 <spanclass="math inline">\(i\)</span>个因素。这些因素，通常都具有不同程度的模糊性。</p><h3 id="建立综合评价的评价集">建立综合评价的评价集</h3><p>评价集是评价者对评价对象可能做出的各种结果所组成的集合，通常用 <spanclass="math inline">\(V\)</span> 表示， <spanclass="math inline">\(V=(v_1,v _2,\cdots,v_m)\)</span> ，其中元素 <spanclass="math inline">\(v_i\)</span> 代表第 <spanclass="math inline">\(i\)</span> 种评价结果</p><h3 id="构造隶属函数获得评价矩阵">构造隶属函数，获得评价矩阵</h3><p>构造合理美观的隶属函数 <spanclass="math inline">\(Fuzz(x)\)</span>。</p><p>若因素集U中第i个元素对评价集V中第1个元素的隶属度为 <spanclass="math inline">\(r_{i1}\)</span> ，则对第 <spanclass="math inline">\(i\)</span>个元素单因素使用隶属函数评价的结果用模糊集合表示为：<spanclass="math inline">\(R_i=(r_{i1},r_{i2},\cdots,r_{in})\)</span>。以<span class="math inline">\(m\)</span> 个单因素评价集构成 <spanclass="math inline">\(R_{mn}=[R1,R2,\cdots,Rm]^T\)</span>，称为模糊综合评价矩阵。</p><h3 id="确定因素权向量">确定因素权向量</h3><p>评价工作中，各因素的重要程度有所不同，为此，给各因素 <spanclass="math inline">\(u_i\)</span>一个权重 <spanclass="math inline">\(w_i\)</span> ，各因素的权重集合的模糊集，用 <spanclass="math inline">\(W\)</span> 表示: <spanclass="math inline">\(W=(w_1,w_2,\cdots,w_m)\)</span>。</p><h3 id="建立综合评价模型">建立综合评价模型</h3><p>确定单因素评判矩阵 <span class="math inline">\(R\)</span>和因素权向量 <span class="math inline">\(W\)</span> 之后，通过模糊变化将<span class="math inline">\(U\)</span>上的模糊向量 <spanclass="math inline">\(A\)</span> 变为 <spanclass="math inline">\(V\)</span> 上的模糊向量 <spanclass="math inline">\(B\)</span>，即 <spanclass="math display">\[B=W_{1m}\cdotR_{mn}=(b_1,b_2,\cdots,b_n)\]</span></p><p>绘出结果 <span class="math inline">\(B\)</span> 图像，如 <imgsrc="https://pic3.zhimg.com/80/v2-368fd890e8f6524b341b070804782bd2_1440w.jpg" /></p><h2 id="一些思考">一些思考</h2><p>对于模糊评价，相较于作为一个“综合评价”，我更愿意把模糊综合评价看作为类似于层次分析法的<strong>带有主观意愿的评价</strong>（体现在隶属函数的构造上）；对于模糊集合理论（模糊数学），更愿意看作一种<strong>思想</strong>（隶属程度的思想）。</p><blockquote><p>在2021亚太杯C题的第三四题中我用模糊数学思想，对于“是否属于城市印象范围”构造了这样的“模糊隶属函数”。<spanclass="math inline">\(Fuz_1(x)=\frac{ℯ^{-(k(x-b))}}{ℯ^{-(k(x-b))}+1}\)</span>、<spanclass="math inline">\(Fuz_2(x)=ℯ^{\frac{(x-a)^2}{q}}\)</span>得到了以下的结果。 (22.2.1)</p></blockquote><figure><img src="https://s2.loli.net/2022/02/01/mO67ZcKR2L34Bau.png"alt="一些城市相关评价指标评分（隶属）图像" /><figcaptionaria-hidden="true">一些城市相关评价指标评分（隶属）图像</figcaption></figure><h1 id="参考">参考</h1><p>[^1]https://baike.baidu.com/item/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%B3%95/2162444[^2] https://zhuanlan.zhihu.com/p/32666445</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主观赋权</tag>
      
      <tag>模糊综合评价</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>灰色关联分析</title>
    <link href="/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
    <url>/2022/01/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-warning">            <p>请注意，本文最后更新于2022.2.28，其中一些理解可能已被笔者推翻或废弃。</p>          </div><h1 id="灰色关联分析gra">灰色关联分析(GRA)</h1><p>灰色关联度分析（Grey Relation Analysis）<br />可以在一个灰色系统中，衡量某个项目受其他的因素影响的相对强弱。</p><p>两个系统之间的因素，随时间或不同对象而变化的关联性大小的量度，称为关联度。两个因素变化即同步变化程度较高，即可谓二者关联程度较高；反之，则较低。因此，灰色关联分析方法，根据因素之间发展趋势的相似相异程度，为衡量因素间关联程度提供了量化的度量。</p><p>灰色关联分析的<strong>基本思想</strong>是根据<strong>序列曲线几何形状的相似程度</strong>来判断其联系是否紧密。曲线越接近，相应序列之间的关联度就越大，反之就越小。</p><h2 id="基本步骤">基本步骤</h2><h3 id="确定分析序列">确定分析序列</h3><ol type="1"><li><strong>母序列(又称参考序列、母指标)</strong></li></ol><p>能反映系统行为特征的数据序列，类似于因变量 <spanclass="math inline">\(Y\)</span> ，记为</p><p><span class="math display">\[Y=[y_1,y_2,...,y_m]^T\]</span></p><ol start="2" type="1"><li><strong>子序列(又称比较序列、子指标)</strong></li></ol><p>影响系统行为的因素组成的数据序列，类似于因变量 <spanclass="math inline">\(X\)</span> ，记为</p><p><span class="math display">\[X_{nm}=\left[\begin{array}{cccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n 1} &amp; x_{n 2} &amp; \cdots &amp; x_{n m}\end{array}\right]\]</span></p><p><strong>其中</strong>：<span class="math inline">\(n\)</span>为年份数量，<span class="math inline">\(m\)</span> 为要素的个数</p><h3 id="数据预处理">数据预处理</h3><p>由于不同要素具有不同量纲和数据范围范围，因此我们需要对它们进行归一化(常用均值化)去量纲，将它们统一到近似的范围内，然后重点关注其变化和趋势。</p><p><spanclass="math display">\[\widetilde{y}_{k}=\frac{y_{k}}{\bar{y_i}}, \quad\bar{y_i}=\frac{1}{n} \sum_{k=1}^{n} y_{k}\]</span></p><p><spanclass="math display">\[\widetilde{x}_{ki}=\frac{x_{ki}}{\bar{x_{\_i}}},\quad \bar{x_{\_i}}=\frac{1}{n} \sum_{k=1}^{n} x_{ki},(i=1,2,...m)\]</span></p><p>注：下文继续用 <span class="math inline">\(X\)</span> 代指预处理后的<span class="math inline">\(\widetilde{X}\)</span> ， <spanclass="math inline">\(Y\)</span> 代指 <spanclass="math inline">\(\widetilde{Y}\)</span>。</p><h3 id="计算灰色关联系数">计算灰色关联系数</h3><p>计算子序列中各个指标与母序列的关联系数</p><p>记 <span class="math display">\[a=\min _{i}\min_{k}\left|x_{0}(k)-x_{i}(k)\right|, \quad b=\max _{i}\max_{k}\left|x_{0}(k)-x_{i}(k)\right|\]</span>为两极最小差和最大差。</p><p>构造 <span class="math display">\[z_{k,j}=\xi_j(k)=\frac{a+\rhob}{|x_{kj}-y_j|+\rho b}\]</span> 构成 <spanclass="math inline">\(Z\)</span>。</p><p><strong>其中</strong>：<spanclass="math inline">\(\rho\)</span>为分辨系数，一般取0.5</p><h3 id="计算关联度">计算关联度</h3><p><span class="math display">\[r_j=\frac{1}{n} \sum_{k=1}^{n} \xi_j(k)= \frac{1}{n} \sum_{k=1}^{n} z_{kj}\]</span></p><h2 id="基于关联度计算权重的综合评价">基于关联度计算权重的综合评价</h2><p>本质是构造虚拟母指标，以各个指标与母指标的灰色关联度 <spanclass="math inline">\(r_j\)</span>代表指标权重，再<strong>以此权重对每个观测值做简单加权</strong>得到结果为评价。</p><p>权重 <span class="math inline">\(w_j\)</span>反应的是指标与样本最大值的关联度，指标下的观测值在同截面数据中最大的数目越多，与母序列相似程度愈高，<span class="math inline">\(w_j\)</span>愈大。所以得到的综合评价结果仅仅是未加权结果的更平缓曲线(?)</p><blockquote><p>本方法疑是来源清风的数学建模视频，在互联网上流传。与灰色关联分析的决策方法相异，正确性存疑。(2.28)</p></blockquote><h3 id="正向化预处理">1. 正向化预处理</h3><p>记正向化后的数据为： <spanclass="math display">\[X_{nm}=\left[\begin{array}{cccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n 1} &amp; x_{n 2} &amp; \cdots &amp; x_{n m}\end{array}\right]\]</span></p><p><strong>其中</strong>：<span class="math inline">\(n\)</span>为年份数，<span class="math inline">\(m\)</span> 为指标数</p><h3 id="去除量纲">2. 去除量纲</h3><p>每个数 <span class="math inline">\(x_{ij}\)</span> 除以每一列的平均值<span class="math inline">\(\bar{x_{\_i}}\)</span> ,记作 <spanclass="math inline">\(Z\)</span> ，有</p><p><span class="math display">\[z_{ki}=\frac{x_{ki}}{\bar{x_{\_i}}},\quad \bar{x_{\_i}}=\frac{1}{n} \sum_{k=1}^{n} x_{ki},(i=1,2,...m)\]</span></p><p><span class="math display">\[Z_{nm}=\left[\begin{array}{cccc}z_{11} &amp; z_{12} &amp; \cdots &amp; z_{1 m} \\z_{21} &amp; z_{22} &amp; \cdots &amp; z_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n 1} &amp; z_{n 2} &amp; \cdots &amp; z_{n m}\end{array}\right]\]</span></p><h3 id="构造母序列">3. 构造母序列</h3><p>构造<strong>虚拟指标</strong>表示每个观测值的最优值 <spanclass="math inline">\(Y=[y_1,y_2,...,y_n]^T\)</span> 其中</p><p><spanclass="math display">\[y_i=max(z_{i1},z_{i2},...,z_{im})\]</span></p><h3 id="计算关联系数">4. 计算关联系数</h3><p>记差值矩阵为 <span class="math inline">\(K\)</span>，有 <spanclass="math display">\[K=\left[\begin{array}{cccc}k_{11} &amp; k_{12} &amp; \cdots &amp; k_{1 m} \\k_{21} &amp; k_{22} &amp; \cdots &amp; k_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\k_{k 1} &amp; k_{n 2} &amp; \cdots &amp; k_{n m}\end{array}\right]=\left[\begin{array}{cccc}|z_{11}-y_1| &amp; |z_{12}-y_1| &amp; \cdots &amp; |z_{1 m}-y_1| \\|z_{21}-y_2| &amp; |z_{22}-y_2| &amp; \cdots &amp; |z_{2 m}-y_2| \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\|z_{n 1}-y_n| &amp; |z_{n 2}-y_n| &amp; \cdots &amp; |z_{n m}-y_n|\end{array}\right]\]</span></p><p>记 <span class="math display">\[a=\min _{i}\min_{j}\left|k_{ij}\right|, \quad b=\max_{i} \max_{j}\left|k_{ij}\right|\]</span> 为两极最小差和最大差。</p><h3 id="计算指标关联度">5. 计算指标关联度</h3><p>记 <span class="math display">\[\xi_{ij}=\frac{a+\rhob}{|k_{ij}|+\rho b}\]</span></p><p><strong>其中</strong>：<spanclass="math inline">\(\rho\)</span>为分辨系数，一般取0.5</p><p><span class="math display">\[r_j=\frac{1}{n} \sum_{i=1}^{n}\xi_{ij}\]</span></p><p><strong>其中</strong>：<span class="math inline">\(r_j\)</span> 为第<span class="math inline">\(j\)</span> 个指标的灰色关联度</p><h3 id="计算指标权重">6. 计算指标权重</h3><p><span class="math display">\[w_j=\frac{r_j}{\sum_{k=1}^{m} r_k}(j=1,2,...,m)\]</span></p><h3 id="计算得分">7. 计算得分</h3><p><span class="math display">\[S_i= \sum_{j=1}^{m} Z_{ij} \cdotr_j\]</span></p><h3 id="结果处理">8. 结果处理</h3><p><span class="math display">\[\tilde{S}_i=\frac{S_i}{\sum_{k=1}^{m}S_k} (i=1,2,\cdots,n)\]</span></p><h2 id="基于灰色关联分析的综合评价">基于灰色关联分析的综合评价</h2><h3 id="数据处理">1. 数据处理</h3><p>记横轴为指标，纵轴为样本编号的矩阵 <spanclass="math inline">\(X\)</span>经每个指标规范化（纵轴方向归一化/标准化）后为</p><p><span class="math display">\[Z_{nm}=\left[\begin{array}{cccc} z_{11}&amp; z_{12} &amp; \cdots &amp; z_{1 m} \\ z_{21} &amp; z_{22} &amp;\cdots &amp; z_{2 m} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n 1} &amp; z_{n 2} &amp; \cdots &amp; z_{n m}\end{array}\right]\\\]</span></p><h3 id="构造虚拟样本">2. 构造虚拟样本</h3><p>记虚拟母样本为 <span class="math inline">\(Y\)</span>，其每个元素取对应指标的最优值，</p><p><spanclass="math display">\[Y=\left[y_1,y_2,\dotsb,y_m\right]\]</span></p><p>其中</p><p><spanclass="math display">\[y_j=\max(z_{1j},z_{2j},\dotsb,z_{nj})\]</span></p><h3 id="计算关联系数-1">3. 计算关联系数</h3><p>记差值矩阵为 <span class="math inline">\(K\)</span> ，有</p><p><span class="math display">\[K=\left[\begin{array}{cccc}k_{11} &amp; k_{12} &amp; \cdots &amp; k_{1 m} \\k_{21} &amp; k_{22} &amp; \cdots &amp; k_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\k_{k 1} &amp; k_{n 2} &amp; \cdots &amp; k_{n m}\end{array}\right]=\left[\begin{array}{cccc}|z_{11}-y_1| &amp; |z_{12}-y_2| &amp; \cdots &amp; |z_{1 m}-y_m| \\|z_{21}-y_1| &amp; |z_{22}-y_2| &amp; \cdots &amp; |z_{2 m}-y_m| \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\|z_{n 1}-y_1| &amp; |z_{n 2}-y_2| &amp; \cdots &amp; |z_{n m}-y_m|\end{array}\right]\\\]</span></p><p>记</p><p><span class="math display">\[a=\min _{i} \min_{j}\left|k_{ij}\right|,\quad b=\max_{i} \max _{k}\left|k_{ij}\right|\\\]</span></p><h3 id="计算指标关联度-1">4.计算指标关联度</h3><p>取 <span class="math inline">\(\rho=0.5\)</span> ，记</p><p><span class="math display">\[\xi_{ij}=\frac{a+\rho b}{|k_{ij}|+\rhob}\\\]</span></p><p>得到第 <span class="math inline">\(i\)</span>个样本的灰色关联度，即评价结果为 <spanclass="math inline">\(r_i\)</span> 为</p><p><span class="math display">\[r_i=\frac{1}{m} \sum_{j=1}^{m} \xi_{ij}\ \ 或 \ \ r_i= \sum_{j=1}^{m} w_j\xi_{ij}\]</span></p><p>其中 <span class="math inline">\(w_j\)</span> 为指标的权重，</p><p>以此作为各个观测值的评价结果。</p><h1 id="去量纲化方法">*去量纲化方法</h1><h2 id="初值化">初值化</h2><p>顾名思义，就是把这一个序列的数据统一除以最开始的值，由于同一个因素的序列的量级差别不大，所以通过除以初值就能将这些值都整理到1这个量级附近。</p><p><span class="math display">\[f(x(k))=\frac{x(k)}{x(1)}=y(k), \quadx(1) \neq 0\]</span></p><h2 id="均值化">均值化</h2><p>顾名思义，就是把这个序列的数据除以均值，由于数量级大的序列均值比较大，所以除掉以后就能归一化到1的量级附近。</p><p><span class="math display">\[f(x(k))=\frac{x(k)}{\bar{x}}=y(k), \quad\bar{x}=\frac{1}{n} \sum_{k=1}^{n} x(k)\]</span></p><h2 id="百分比变换">百分比变换</h2><p><span class="math display">\[f(x(k))=\frac{x(k)}{\max _{k}x(k)}=y(k)\]</span></p><h2 id="倍数变换">倍数变换</h2><p><span class="math display">\[f(x(k))=\frac{x(k)}{\min _{k}x(k)}=y(k), \quad \min_{k} x(k) \neq 0\]</span></p><h2 id="归一化变换">归一化变换</h2><p><spanclass="math display">\[f(x(k))=\frac{x(k)}{x_{0}}=y(k)\]</span></p><h2 id="极差最大值变换">极差最大值变换</h2><p><span class="math display">\[f(x(k))=\frac{x(k)-\min _{k}x(k)}{\max_{k} x(k)}=y(k)\]</span></p><h2 id="区间值变换">区间值变换</h2><p><span class="math display">\[f(x(k))=\frac{x(k)-\min _{k}x(k)}{\max_{k} x(k)-\min _{k} x(k)}=y(k)\]</span></p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://baike.baidu.com/item/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E6%B3%95/8602076?fr=aladdin<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/149479206<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/266959639<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>综合评价</tag>
      
      <tag>客观赋权</tag>
      
      <tag>灰色关联分析</tag>
      
      <tag>去量纲方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022—SWJTU寒假选拔赛第一场复盘</title>
    <link href="/2022/01/14/12/"/>
    <url>/2022/01/14/12/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="比赛链接">比赛链接</h1><div class="note note-info">            <p><ahref="https://vjudge.net/contest/476119"><b>2022—SWJTU寒假选拔赛第一场</b></a></p>          </div><div class="note note-info">            <p><ahref="https://blog.csdn.net/m0_56007815/article/details/122506249?utm_source=app&amp;app_version=4.21.1&amp;utm_source=app"><b>题解</b></a></p>          </div><center><hr width=100px></center><h1 id="题目列表">题目列表</h1><p><font size=0.1 face="微软雅黑"><b> | | Stat | # | Title | | :-----|----: | :----: | :-------: | | <span class="label label-success">Solved</span> | 21/90| A | 惠老板观星 || <span class="label label-success">Solved</span> | 26/54 | B | Asuka大战兔子 | | <span class="label label-warning">Attempted</span> | 2/44 |C |我不会debug| | <span class="label label-success">Solved</span> | 39/51 | D| 我要吃饭| | |2/6 | E|删删删| | <span class="label label-success">Solved</span> |12/27| F |大水题| | |0/17 |G| 你一定会种树吧|| <span class="label label-warning">Attempted</span> |3 / 17| H |货车| | |9/28 |I|超级打字大师| | |1/3 |J|简单数学| | <span class="label label-warning">Attempted</span> |5/23 |K |小游戏| | <span class="label label-success">Solved</span> |36/72| L|cold玩真人cs| | | |M |杰哥打怪| </b></font></p><figure><img src="https://s2.loli.net/2022/01/20/tXAVbOE2zMBfK8g.png"alt="RANK" /><figcaption aria-hidden="true">RANK</figcaption></figure><h2 id="a-惠老板观星">A-惠老板观星</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>惠老板最近迷上了星空摄影，为了更好的出片，惠老板需要在山地中找到四个位置。从空中看，这四个位置必须是一个正方形的四个顶点。在惠老板的理论中这四个点必须有三个点的高度相同。而另外一个点的高度要高于这三个点。惠老板去了蒙德的龙脊雪山。对于惠老板来说龙脊雪山可以看成由n*n个小平台组成的地区。每个平台都有其独立的整数高度。现在他想找出高度相同的三个观测点中最高的观测位置的高度。</p><p><strong>输入格式</strong></p><p>第一行一个整数表示<span class="math inline">\(n*n\)</span>的矩阵,<span class="math inline">\(2&lt;=n&lt;=3002&lt;=n&lt;=300\)</span></p><p>接下来n行每行个数表示当前位置的高度。<spanclass="math inline">\(1&lt;=ht[i,j]&lt;=10^91&lt;=ht[i,j]&lt;=10^9\)</span></p><p><strong>输出格式</strong></p><p>一个整数表示能找的的最高的观测位置（注意你需要输出的是那三个高度相同的点的高度而不是第四个最高顶点的高度）。若没有符合条件的观测位置则输出-1.</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">2</code></pre></div></td></tr></table><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span></code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="b-asuka大战兔子">B-Asuka大战兔子</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>Asuka养了在他的农场养了许多兔子，他的农场由无数个方格构成的，农场行数为x,列数为y。现在Asuka的农场中有许多兔子还有许多萝卜。兔子能够不断向上下左右四个方向移动从而到达农场各个位置，若移动之后的放个有萝卜那么兔子可以将其吃掉。注意，兔子不能移动到已经有兔子的方格中。若兔子的上下左右四块田地中有萝卜，那么它也能够吃到。Asuka为了阻止他的兔子吃萝卜，他决定用围栏将将农场中的兔子和萝卜分开。他有足够多的围栏，但是围栏只能建造在空田地中。Auska想问你他能不能将所有的兔子和萝卜都分开。如果能请输出任意一种方案。否则输出No.</p><p>Asuka有非常的多的栅栏，你可以不输出使用最少栅栏的方案。</p><p><strong>输入格式</strong></p><p>第一行两个整数x和y表示农场的行数和列数，1&lt;=x,y&lt;=5001&lt;=x,y&lt;=500。接下来是一个x*y的字符串C表示萝卜R表示兔子。而空田地表示为"."。</p><p><strong>输出格式</strong></p><p>若可以将所有兔子和围栏分开则第一行输出“Yes”接下来输出任意一种方案。栅栏用"#"表示。空田地表示为"."。 否则输出No.</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-selector-class">.C</span><span class="hljs-selector-class">.RR</span>C.<span class="hljs-selector-class">.RR</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-class">.R</span>.....</code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">Yes<span class="hljs-string">.C</span><span class="hljs-comment">#RR</span>C.<span class="hljs-comment">#RR</span><span class="hljs-string">.C</span><span class="hljs-comment">#.R</span><span class="hljs-string">..</span><span class="hljs-comment">#..</span></code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="c-我不会debug">C-我不会debug</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>cold正在进行c语言考试，他提交程序之后，老师会告诉cold他对于每个测试点的结果是正确的（P）还是错误的（F），他将会得到一个只由P和F组成的字符串。他想让你帮他调试程序，你可以花一分钟删除首个或者最后一个字母，或者花两分钟删除字符串中间任何一个字母，删除之后将剩下的两端拼接起来。现在，他想问你将该字符串变成一个只存在P的字符串需要多少时间。</p><p><strong>输入格式</strong></p><p>第一行一个整数n，表示字符串长度<spanclass="math inline">\((1&lt;=n&lt;=10^6)(1&lt;=n&lt;=10^6)\)</span></p><p>第二行一个由P和F组成的字符串。</p><p><strong>输出格式</strong></p><p>一个整数，你调试程序所需要的最小时间。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs">6FPPFPP</code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">3</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="d-我要吃饭">D-我要吃饭</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>dki在考完cet—6之后非常愤怒，表示自己啥也不会，并且这次分数大概率比上次random的还低，他准备点一顿外卖来犒劳自己。</p><p>他打开某团，有七种菜品可以选择，价格分别是7,27,41,49,63,78,108元。</p><p>dki有三张满减券，分别是：</p><p>1、当总价达到69元可减15元。</p><p>2、当总价达到89元可减30元。</p><p>3、当总价达到120元可减50元。</p><p>但是dki只能使用一张优惠券。当他先但是系统自动为他选择了最优的优惠券。例如他总过点了400元的晚餐，他总共需要付350元。</p><p>dki总共点了n个菜，每个菜的单价分别为a1,a2,a3...an。他想知道他总共需要付多少钱。</p><p><strong>输入格式</strong></p><p>本题包含多组测试样例</p><p>第一行一个整数t, 表示有t组测试样例。<spanclass="math inline">\(1&lt;=t&lt;=10^61&lt;=t&lt;=10^6\)</span></p><p>对于每组测试样例</p><p>第一行一个整数n表示总共点了n个菜<spanclass="math inline">\(1&lt;=t&lt;=10^61&lt;=t&lt;=10^6\)</span>。</p><p><strong>输出格式</strong></p><p>对于每组测试样例输出一个数字，表示dki所需要支付的总价</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><span class="hljs-number">6</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">7</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">3487807139</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="e-删删删">E-删删删</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>给你一颗有n个结点的树，你可以删除这个树上任意数量的结点，如果在树的剩余每个结点部分仍然有至少一个结点与它相连，那么我们边成这种删除方式是漂亮的。Hertz想问你总共有多少种删除方式是美丽的。由于方案可能非常多，他希望你再计算的时候对998244353取模。</p><p>如果删除的结点集合相同，那么认为是相同的方式。</p><p><strong>输入格式</strong></p><p>本题含有多组测试样例，第一行输入一个整数t，表示总共有t组测试样例。</p><p>对于每组测试样例</p><p>第一行一个整数n，1&lt;=t&lt;=10^51&lt;=t&lt;=10 5</p><p>接下来n-1行，每行两个整数 x,y <spanclass="math inline">\((1≤x,y≤n,x≠y)(1≤x,y≤n,x≠y)\)</span>。表示x和y之间有一条边。</p><p>数据保证<span class="math inline">\(∑n≤10^6∑n≤10^6\)</span></p><p><strong>输出格式</strong></p><p>共有t行每行一个整数。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span><span class="hljs-number">7</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><span class="hljs-symbol">5 </span><span class="hljs-number">2</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">37</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="f-大水题">F-大水题</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>vc++最近在玩简单的数学题，他想给你分享一道简单的数学题.</p><p>一个数等于他所有真因子之和那么我们可以称指为完美数，例如<spanclass="math inline">\(1+2+4+7+14=28\)</span>，<spanclass="math inline">\(1+2+4+8+16+31+62+124+248=496\)</span>。</p><p>vc++觉得这不好玩，所以他自己创造一个半完美数的定义，令 S 为自然数 X的所有真因子的集合。如果存在 S的子集，使得子集中的数字之和等于数字本身，则称该数字是半完美的。</p><p>显然，所有完美数都是半完美数。此外，还有一些不完美的数字，它们也属于金成的半完美数字。例如，24的真实因子集是<spanclass="math inline">\({1,2,3,4,6,8,12}\)</span>，我们可以选择一个子集<spanclass="math inline">\({2,4,6,12}\)</span>，满足<spanclass="math inline">\(24=2+4+6+12\)</span>。所以24可以称为半完美数。</p><p>vc++想知道他是否能找到一个整数 k，它是正整数 x 的倍数，使得 k是一个半完美数。</p><p>由于 vc++不擅长数学，他希望 k 不能太大<spanclass="math inline">\(（k≤2×10^{18}）（k≤2×10^18）\)</span>，并且子集的大小不大于 1000。他希望你给你选择的子集。</p><p><strong>输入格式</strong></p><p>本题含有多组测试样例，第一行输入一个整数t，表示总共有t组测试样例。<spanclass="math inline">\(1&lt;=t&lt;=40001&lt;=t&lt;=4000\)</span>.</p><p>接下来t行每行一个正整数x，$1&lt;=x&lt;=10<sup>91&lt;=x&lt;=10</sup>9$</p><p><strong>输出格式</strong></p><p>总共2t行</p><p>每组第一行输出两个正整数k和l，k为你所找到的整数<spanclass="math inline">\((k&lt;=10^{18})(k&lt;=10^18)\)</span>，l为你所选择的子集的大小<spanclass="math inline">\((l&lt;=1000)(l&lt;=1000)\)</span>。</p><p>第二行输出你所选择的子集中的所有元素。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs">2102</code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">60 </span><span class="hljs-number">3</span><span class="hljs-symbol">10 </span><span class="hljs-number">20</span> <span class="hljs-number">30</span><span class="hljs-symbol">24 </span><span class="hljs-number">4</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">12</span></code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="g-你一定会种树吧">G-你一定会种树吧</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>cyh有一个长度为n的可操作序列a1,a2,a3,.......an。现在他可以对序列进行如下操作</p><p>1、 1 l r 对区间[l,r]的所有数加上<spanclass="math inline">\(lowbit(a[i])\)</span></p><p>2、2 l r 询问区间[l,r]中的和。</p><p>cyh需要你给出每次询问值对998244353取模的结果。</p><p><strong>输入格式</strong></p><p>第一行一个整数t, 1&lt;=t&lt;=201&lt;=t&lt;=20,表示有t组测试样例。</p><p>对于每组测试样例，第一行一个整数n,1&lt;=n&lt;=10^51&lt;=n&lt;=10 5,表示序列的长度。</p><p>接下来一行有有n个整数，表示该序列。</p><p>第三行一个整数m，表示需要进行操作的数量。$(1≤m≤10<sup>5)(1≤m≤10</sup>5)$</p><p>接下来m行，每行三个正整数x, l, r.x代表操作类型，l，r代表操作的区间。<spanclass="math inline">\(1&lt;=x&lt;=2,1&lt;=l,r&lt;=n1&lt;=x&lt;=2,1&lt;=l,r&lt;=n\)</span></p><p><strong>输出格式</strong></p><p>对于每次询问输出对998244353取模的结果</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span><span class="hljs-number">5</span><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">152012</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="h-货车">H-货车</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>有nn个城市被mm条路连接，每条路都有一个最大承重能力kk，如果货车总重量pp大于kk，则货车不能通过该条路。</p><p>如果一辆货车能从城市xx一直开到yy，则称城市x,yx,y对于该货车而言是“互通的”。</p><p>现在每次询问给定一个数pp表示货车总重量，请问有多少对城市对于这辆货车是“互通的”？</p><p><strong>输入格式</strong></p><p><span class="math inline">\(T(1≤T≤10)\)</span>组样例。</p><p>每组样例第一行包含三个整数<span class="math inline">\(n,m,q(2\le n\le1e5,1\le m\le 2e5,1\le q\le2e5)n,m,q(2≤n≤1e5,1≤m≤2e5,1≤q≤2e5)\)</span>分别表示城市的数量，路的数量，以及询问的数量。</p><p>然后是mm行，每行包含三个整数<span class="math inline">\(x,y,k(1\lex,y\le n,1\le k\le1e9)x,y,k(1≤x,y≤n,1≤k≤1e9)\)</span>表示城市x,yx,y之间有一条直接相连的路，最大承重能力为kk。</p><p>最后qq行，每行一个整数<span class="math inline">\(p(1\le p\le1e9)p(1≤p≤1e9)\)</span>表示货车总重量。</p><p><strong>输出格式</strong></p><p>每组样例输出qq行，每行包含一个整数，表示询问答案。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-number">3</span><span class="hljs-number">2</span><span class="hljs-number">1</span><span class="hljs-number">4</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">310101</code></pre></div></td></tr></table><p></font></p>    </div></div><p>最开始用了个dfs，然后超时？之后才明白是（最小生成树）建边并查集，离线。</p><p>改了好久还是没调出来。</p><h2 id="i-超级打字大师">I-超级打字大师</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p>众所周知，双拼是一种非常高效的打字手段,因为使用双拼，<strong>您只需按两次键即可输入任何中文单词</strong>。<center><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">表拼音双拼拼音双拼<span class="hljs-built_in">q,</span> iuqf, enf<span class="hljs-built_in">w,</span> eiwg, engg<span class="hljs-built_in">r,</span> uanrj, anjeeh, angh<span class="hljs-built_in">t,</span> uetk, uai, ingk<span class="hljs-built_in">y,</span> unyl, uang, iangl<span class="hljs-built_in">u,</span> shuz, ouz<span class="hljs-built_in">i,</span> chix, ia, uax<span class="hljs-built_in">o,</span> uooc, aoc<span class="hljs-built_in">p,</span> iepv, zh, uivaab, inb<span class="hljs-built_in">d,</span> aidm, ianm<span class="hljs-built_in">s,</span> ong, iongsn, iaon</code></pre></div></center><p><span class="math inline">\(ColdCold\)</span>最近在研究双拼打字,现在想请你帮忙将给定的句子以双拼的方式输出。比如说, "ni hao shijie"那么你需要输出的是,"ni hc ui jp"。</p><p>Tips:</p><ul><li>对于长度为 11的拼音,为了满足双拼的语法要求,你应该输出两个相同的该字符。</li><li>对于长度为 22 的拼音,不作改动,直接输出该拼音</li><li>对于像 angang这样的拼音如果独立出现,你应该先输出他的第一个字母,然后在表-格中查找整个拼音以获得第二个键ex.("ang" 会变成"ah")。而rang则会输出rh</li><li>为简化起见，任何输入中都没有字符 vv</li></ul><p><strong>输入格式</strong></p><p>有多个测试用例。每行包含一个。数据保证测试用例个数不超过10001000个，</p><p>每一行都是由空格分隔的拼音序列。</p><p>数据保证测试用例个数不超过10001000个， 一个测试用例的拼音个数不超过500500 个，所有测试用例的拼音个数不超过 50005000 个。</p><p><strong>输出格式</strong></p><p>由空格分隔的双拼序列。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ji</span><span class="hljs-keyword"></span>zhe ti mian <span class="hljs-keyword">shen </span>me wan yi<span class="hljs-keyword">beng </span><span class="hljs-keyword">bu </span>zhu leyuan lai ni ye wan yuan <span class="hljs-keyword">shen</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs vim">ji<span class="hljs-keyword">ve</span> ti mm uf <span class="hljs-keyword">me</span> wj yibg bu <span class="hljs-keyword">vu</span> <span class="hljs-keyword">le</span>yr ld ni ye wj yr uf</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="j-简单数学">J-简单数学</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>郑老板非常喜欢数学题，今天他给了你下面一个方程。 <spanclass="math display">\[f(n) = \begin{cases} 1, &amp; n \in \{1\} \bigcup \operatorname{质数} \\p\,f(p^{k-2}), &amp; n = p^k ~ (p \in \operatorname{质数}; ~ k &gt; 1)\\ f(p_1^{e_1})\prod_{i=2}^r {p_i}^{e_i}, &amp; n = \prod_{i=1}^r {p_i}^ {e_i} ~ (p_1 &lt; p_2 &lt; \cdots &lt; p_r; ~ p_i \in\operatorname{质数}; ~ r \ge 2) \end{cases}\]</span></p><p>现在郑老板想问你<span class="math inline">\(\sum_{i=1}^nf(i)\)</span>的结果，你能告诉他吗？</p><p><strong>输入格式</strong></p><p>一行一个正整数n <span class="math inline">\((1 \le n \le {10}^{7})n(1≤n≤10^7)\)</span>.</p><p><strong>输出格式</strong></p><p>一个正整数，代表结果。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs">50</code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">370</code></pre></div></td></tr></table><h2 id="node">Node</h2><p>对于第一个样例, <span class="math inline">\(f(1) = 1f(1)=1, f(2) =1f(2)=1, f(3) = 1f(3)=1, f(4) = 2f(4)=2, f(5) = 1f(5)=1, f(6) = 3f(6)=3,f(7) = 1f(7)=1, f(8) = 2f(8)=2, f(9) = 3f(9)=3, f(10) =5f(10)=5\)</span>.</p><p>题目保证答案小于 2^{64}-12 64 −1. </font></p>    </div></div><h2 id="k-小游戏">K-小游戏</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>dqhl76最近在玩一个游戏，他会给你一个长度为n的序列，序列中的元素为ai。他需要你对序列中的元素进行n-1次合并操作，每次合并操作你可以选择序列中的了两个相邻的元素，将a[x]和a[x+1]合并成一个元素值为<spanclass="math inline">\((a[x]*a[x+1])mod1000003\)</span>并且得到<spanclass="math inline">\((a[x]-a[x+1])^2\)</span>分。你将一直持续这个游戏，知道序列只剩下一个元素为止。</p><p>现在dqhl76想问你你能获得的最大积分是多少。</p><p><strong>输入格式</strong></p><p>第一行一个整数n表示序列的长度<spanclass="math inline">\(1&lt;=n&lt;=3001&lt;=n&lt;=300\)</span></p><p>T接下来一行n个整数，<spanclass="math inline">\(a[1],a[2],a[3]....a[n]1&lt;=ai&lt;=10^61&lt;=ai&lt;=10^6\)</span></p><p><strong>输出格式</strong></p><p>一个整数，表示你能达到的最大积分。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs">630</code></pre></div></td></tr></table><p></font></p>    </div></div><p>一道本应该AC的题目。</p><p>错误原因是 <code>w</code> 忘了开 LL。最重要的又看错了题，得分结果不用取 MOD ，只对 <code>a[i][j]</code>的合并结果取 MOD！！！</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    ll sum=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>()) sum=(sum&lt;&lt;<span class="hljs-number">3</span>)+(sum&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-keyword">return</span> flag*sum;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i,a,b) for(int i=(a);i&lt;=(b);i++)</span>ll a[<span class="hljs-number">330</span>][<span class="hljs-number">330</span>];ll dp[<span class="hljs-number">330</span>][<span class="hljs-number">330</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>();    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n)&#123;        a[i][i]=<span class="hljs-built_in">read</span>();    &#125;    <span class="hljs-built_in">FOR</span>(k,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;         <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n-k)&#123;<span class="hljs-comment">//i - i+k</span>            <span class="hljs-built_in">FOR</span>(j,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>)&#123;                ll w=(dp[i][i+j]+dp[i+j+<span class="hljs-number">1</span>][i+k]+(a[i][i+j]-a[i+j+<span class="hljs-number">1</span>][i+k])*(a[i][i+j]-a[i+j+<span class="hljs-number">1</span>][i+k])); <span class="hljs-comment">// 错误1</span>                <span class="hljs-keyword">if</span>(dp[i][i+k]&lt;=w)&#123;                    dp[i][i+k]=w; <span class="hljs-comment">//%MOD 错误2</span>                    a[i][i+k]=(a[i][i+j]*a[i+j+<span class="hljs-number">1</span>][i+k])%<span class="hljs-number">1000003</span>;                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;dp[<span class="hljs-number">1</span>][n]; <span class="hljs-comment">//%MOD 错误2</span>&#125;</code></pre></div><h2 id="l-cold玩真人cs">L-cold玩真人cs</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>cold最近迷上了射击游戏。在游戏中cold是一名狙击手。对于cold来说他有一个射击范围。在这个范围内的敌人它可以一发毙命。而在这个范围之外的敌人他需要两发。例如cold的射击范围是[30,90]，他每一次射击都能消灭一个在这个距离范围内的敌人。而不在这个距离之中的敌人,例如位置在95那么他则需要两发子弹。</p><p>现在cold倍困在山顶，有n个敌人围住了他，cold的枪里有m发子弹，并且cold知道每个敌人离他的距离。</p><p><strong>输入格式</strong></p><p>第一行四个整数n,m,s,f。分别表示n个敌人，m发子弹，cold能对[s,f]范围内的敌人一发毙命。<spanclass="math inline">\(1≤n≤1,000,000; 1≤m≤1,000,000,000;1≤s≤f≤1,000,000,0001≤n≤1,000,000;1≤m≤1,000,000,000;1≤s≤f≤1,000,000,000\)</span></p><p>第二行n个整数，表示每个敌人距cold的距离。</p><p><strong>输出格式</strong></p><p>若cold能杀死全部的敌人则输出lzdak!否则输出cold能杀死敌人的数量。</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">10</span><span class="hljs-symbol">2 </span><span class="hljs-number">9</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">lzdak!</code></pre></div></td></tr></table><p></font></p>    </div></div><h2 id="m-杰哥打怪">M-杰哥打怪</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        题目搬运    </div>    <div class='spoiler-content'>        <p><font size=0.1 face="微软雅黑"></p><p><strong>题目描述</strong></p><p>现在森林中有 nn 个村庄，住着猎人与怪兽，有 mm条路连接这些村庄且经过每条路都需要花费时间 11 。</p><p>第ii 个村庄的怪兽的防御力为<spanclass="math inline">\(w_i\)</span>，当猎人的攻击力大于等于怪兽的防御力时，猎人能够猎杀到这个村庄的怪兽。</p><p>现在有qq次询问，每次询问包含两个整数分别为<spanclass="math inline">\(a_i,p_ia\)</span>第<spanclass="math inline">\(a_i\)</span>个村庄攻击力<spanclass="math inline">\(p_i\)</span>的猎人要去打猎（可以打自家村庄的怪兽），请问猎人最少花费多少时间能打到怪兽？</p><p>每次询问时独立的，你只需要打到一个怪兽</p><p><strong>输入格式</strong></p><p>第一行给定三个整数 <span class="math inline">\(n,m,q(1\le n,m\le1e5,1\le q\le 5e5)n,m,q(1≤n,m≤1e5,1≤q≤5e5)\)</span>分别表示村庄，路以及询问的数量。</p><p>第二行nn个整数，期中第ii个整数表示第ii个村庄怪兽的防御力为<spanclass="math inline">\(w_i(1\le w_i\le 1e2)\)</span></p><p>接下来mm行，每行包含两个整数<span class="math inline">\(u_i,v_i(1\leu_i,v_i\le n,u_i\not=v_i)\)</span> 表示村庄<spanclass="math inline">\(u_i,v_i\)</span>之间有一条路。</p><p>最后qq行，每行包含两个整数<span class="math inline">\(p_i,a_i(1\lep_i\le n,1\le a_i\le 1e2)\)</span>表示第<spanclass="math inline">\(p_i\)</span>个村庄攻击力为<spanclass="math inline">\(a_i\)</span>的猎人要去打怪兽。</p><p><strong>输出格式</strong></p><p>每组样例输出qq行，每行包含一个整数，表示询问答案。如果无法打到怪兽则输出-1</p><p><strong>样例</strong></p><table><tr><th>Input</th><th>Output</th></tr><tr><td><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span></code></pre></div></td><td><div class="hljs code-wrapper"><pre><code class="hljs diff">0111<span class="hljs-deletion">-1</span></code></pre></div></td></tr></table><p></font></p>    </div></div><p>一道简单的 BFS ，但是没来得及了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年鉴 - 山河</title>
    <link href="/2021/12/31/11%E5%B9%B4%E6%8A%A5/"/>
    <url>/2021/12/31/11%E5%B9%B4%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class="note note-primary">update: 2021-12 28.22:00 29.15:18 29.2:08 30.20:17 31.13:19 31.20:46</p><blockquote><p>从往昔雪冬到来年腊月，黄梅落满枝头，却似换了人间。</p></blockquote><blockquote><p>山河已故，游子安在哉？</p></blockquote><p>这是一个新的尝试，第一次写这种文体，但一切的开拓都来源于尝试，所以我也愿意以这种形式，记录下这一春秋，与忘不掉的2021年。<br />无论是时代还是个人，这都是风云变幻的一年。</p><p><br>         <div id="aplayer-ftQYDFGI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"纸短情长","author":"空雨233","url":"http://music.163.com/song/media/outer/url?id=574381147.mp3","pic":"http://p2.music.126.net/dGhz5kbOZ8Uzeg1xFOeseg==/109951163364571995.jpg","lrc":""},{"title":"蚍蜉","author":"花粥","url":"http://music.163.com/song/media/outer/url?id=1465288939.mp3","pic":"http://p1.music.126.net/9zwep-NZlopJz0JL8IOkpg==/109951165165628584.jpg","lrc":""},{"title":"岁月神偷","author":"金玟岐","url":"http://music.163.com/song/media/outer/url?id=28285910.mp3","pic":"http://p2.music.126.net/gWNsPDBbQCQXVNvMdnAH8A==/18815942487303143.jpg","lrc":""},{"title":"伶仃谣","author":"河图","url":"http://music.163.com/song/media/outer/url?id=101120.mp3","pic":"http://p2.music.126.net/Jcv5rY1Pq6u9dPrPZYH0lQ==/58274116284443.jpg","lrc":""},{"title":"光亮","author":"周深","url":"http://music.163.com/song/media/outer/url?id=1892532629.mp3","pic":"http://p1.music.126.net/WxJ-SLlhxAxzoBNFI8t-lQ==/109951166589320177.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-ftQYDFGI");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script></p><hr /><h1 id="学习生活">1 学习/生活</h1><blockquote><p>这是人生的主曲，万事的根基</p></blockquote><h2 id="学业">1.1 学业</h2><p>在这一年里，我跨越了高中和大学的距离，也跨过了传统的义务教育阶段。告别一段记忆，一阶段的学习，迈入大学的大门，开始新的旅程。从公顷到千亩的土地，这是张度的变化；从百米到千米，这是距离的纵深；从五楼到数十层，这是高度；从百里到千里，这是漫天星火。大学，是新的场景，是新学业的起点，这是一个平台，他不指导你成功，但助推你前行。</p><h2 id="学习方式">1.2 学习方式</h2><p>在这一年，翻越人生中的重要山峰——高考，高考落幕，意味着告别传统授课形势的转型——从传统授课走向自主性学习。在这里，你不能要求老师教会你；在这里，没有固定陪伴你的友人；在这里，没有人来推动你前行；在这里，你才是自己的领路人，行走在深山巨谷里——大家结伴前行是看相相互能力，山顶者的教诲是看见过去的自己——当然，这里也有旅者之间的情谊，有指引者的温暖。</p><blockquote><p>高山仰止的背后，是无限的努力，天纵奇才，亦有成仲永之时。</p></blockquote><p>在初入大学时，我仅仅是完成作业、上课听讲、来不及预习也不会复习。我做着我曾经不怎么会做的事情，缺丢掉了我过去的优势。自诩接受新知识能力强，堆积到最后亦难以精通。在高中，我的学习主要是靠自己：上课做作业、看自己的书，晚自习做题和研究知识的本质，我用我从不自信的记忆能力，熟练的记忆理解了数学物理等公式，与此同时也带来了我对此的长期记忆——与大多数人在不学习后丢掉知识相反的：不容易忘记的记忆。我的知识是相通、成体系、可互推的，所以部分的遗忘可以重新推导出来，这也造就了我高中的弧形成绩曲线：开学即巅峰，然后下滑，最后几次考试排名再上升。所以我不理解那些说曾经学的，就忘了的人。也希望我不会成为这样的人。</p><p>大学的转机是半期考试前一个月：为了面临的数学建模比赛，从0开始，实现了两周过完清风数学建模视频的奇迹，这让我开始养成了长时间在外自习的习惯，在半期考试前一周，我在刷完当天的现代与高数题后再看数学建模论文——让看论文成为我刷完题的动力，(刷起来确实挺快的)。经历了“昏天黑地”的亚太杯（中间穿插了一个早上的半期考试），到“独自完成”新秀杯（整个期间还有ACM月赛和新秀杯）——自习的习惯从此养成，直到现在。从三教到图书馆，从第一次发清晨/夜晚的朋友圈到成为常态，用了半学期，一湾湖水见证了我学习方式的转变。</p><h2 id="生活状态环境">1.3 生活状态/环境</h2><p>熟悉了大学的食堂、宿舍、教学楼生活；学会了教学楼自习桌的使用；习惯了图书馆的进出预约。每周事件基本确定，吃饭地点时间基本固定，养成了记账和日记安排的习惯，淡化了ToDo计划清单习惯。手机使用量、重要性下滑，电脑成为了主要生产工具和学习工具。玩游戏行为全部抹除，把不怎么玩游戏变成了不玩游戏。</p><p>刚开始是和室友一起行动，熟悉了一切后，便尽量自己行动。身边没有友人，便仅能踽踽独行；若没有独立能力，又谈何友人。花了长时间的添置整理物件——我的寝室里面的桌子布置终于基本完备，所有相关生活用品也一一归位。同时，习惯了自己洗衣服，虽有洗衣间但基本没用过，保持了基本的生活整洁，冬天每天泡脚的习惯。</p><blockquote><p>熟知了一切，便无需他人伴行；孤独的灵魂，必将走向自己的远方。</p></blockquote><p>走出了自己的路，找到了生活方式和节奏，不为闲人所左右，寒假降临，亦希望来年能继续保持。</p><h2 id="学习进度规划">1.4 学习进度/规划</h2><h3 id="学科">1.4.1 学科</h3><p>今年学习的新知识有：(以重要/圆满/满意排序)</p><ol type="1"><li>高等数学I</li><li>线性代数B</li><li>数学建模(自学)</li><li>程序设计(大部分竞赛都学过)</li></ol><h3 id="软件语言">1.4.2 软件/语言</h3><p>今年学习的新技能有：(以满意度排序)</p><ol type="1"><li>学会了Latex的使用，能独立查阅解决问题，并写出完整（数学建模）论文</li><li>学会了部分Matlab</li><li>补充了C++部分遗漏知识</li></ol><h3 id="规划">1.4.3 规划</h3><p>计划学习的新知识和技能。</p><h4 id="编程语言">1.4.3.1 编程语言</h4><h5 id="必学">必学</h5><ol type="1"><li>Matlab，至少把大书学完，能独立完成大的程序</li><li>Python，打算学很久了，但一直没有成果</li></ol><h5 id="候学">候学</h5><ol type="1"><li>Java</li><li>Javascript</li><li>HTML/css</li></ol><h4 id="课内知识点">1.4.3.2 课内知识点</h4><p>(以优先级排序)</p><ol type="1"><li>高等数学II</li><li>大学物理</li><li>概率论与数理统计</li><li>离散数学/拓扑学</li><li>运筹学</li></ol><h4 id="竞赛知识点">1.4.3.3 竞赛知识点</h4><h5 id="编程比赛">编程比赛</h5><ul><li>对学过的算法/数据结构的复习和写代码，不能只会理解不会写</li><li>对没有学的算法/数据结构学习和补遗</li><li>因为很多考题不考模板，所以要做更多题型</li></ul><p>走上这条路，就放不了手，最初的梦，还是要流淌下去……</p><h5 id="数学建模">数学建模</h5><ul><li>Matlab的学习</li><li>清风基础数学模型的复习和重要模型的加深</li><li>学习更多的模型，尽量走出C题的模型</li></ul><p>接触的一个新的方向……能解决问题，得到结果的事情还是吸引我呀。</p><h2 id="与集体的关系">1.5 与集体的关系</h2><blockquote><p>万家灯火，却没盏灯留我。——《茫》</p></blockquote><h3 id="大学所在的各个集体">1.5.1 大学所在的各个集体</h3><p><del>因为能力，</del>大概就是说了我高中有策划节目制作背景/海报的经历和一些竞赛经历。于是，我的面试通过率是100%（办公室通过率可是很低的），因为申请的组织的较多，导致了加入的组织太多了，不过也没有哪个组织让我后悔吧……只不过我只能优先满足一些。<del>（另外我给很多部门的印象莫名很强）</del></p><h4 id="大学本班">1.5.1.1 大学本班</h4><p>大学的班级算是很小的班级了，一个班只有20余人。但，这并不是真正意义上的传统班集体，更像是学院的一个管理单元……在这个班，没有归属感也没有集体组织力，所以这也并不是我在意的群体。</p><h4 id="数学建模-办公室">1.5.1.2 数学建模-办公室</h4><p>这算是大家相互之间最熟悉的一个群体了，（比较有意思的一个这样的集体大家是否熟悉很有巧合性，有人员、组织性质、活动、QQ群氛围等因素），加入这个集体算是是本学期做的最正确的事情之一了。此外，这个集体背后是数学建模比赛和背靠数学建模协会，有幸能认识许多共事的友人，也能接触到各个专业首位之人，还有引路的学长……（让我了解“学霸”们在干什么，<del>然后卷起来</del>）。一个开学前就瞄准好了的组织。</p><h4 id="acm">1.5.1.3 ACM</h4><p>其实本是ACM协会外联部的一员，但是部门着实没有什么存在感。在这里，主要是参加举办的比赛——已经被内定<del>为校队成员</del>了，在这里可以找到编程的队友们，也有可爱的学长（听说我们已经被研究透了<del>可怕</del>）</p><h4 id="惟悦工作室">1.5.1.4 惟悦工作室</h4><p>我的另外一个重要社团，主要内容是每周开会和制作图书馆公众号推文。主要是它给了我与图书馆的一个链接——我是图书馆管理成员的一员，这也是我能养成到图书馆的习惯的动力，来自对图书馆的归属感？除此之外它提供了一个可以使用的自习室，只是有时候（特别是考试周）有学姐在就不好去。这也是我开学前就瞄准好了的组织。</p><h4 id="云运-视觉部">1.5.1.5 云运-视觉部</h4><p>因为事情多，逃了很多培训的组织（然后被…了），不过大多数活动还是参加了，有一群有意思的学姐~不过下学期开始有事情了。</p><h4 id="学院团委-青宣部">1.5.1.6 学院团委-青宣部</h4><p>最开始给我提供了Ps、（Pr、Ae）培训的组织，让我成功至少能使用这些软件了（虽然我有基础），也算是收获了有用的技能，这个组织女生较多……这个被我开学前瞄准好的组织，不好不坏吧。</p><hr /><h1 id="成长改变">2 成长/改变</h1><blockquote><p>什么是成长？或许只不过是推翻昨日…</p></blockquote><h2 id="责任压力">2.1 责任/压力</h2><p>在今年，我迈上了十八岁，成为了一位有完整权力的成年人；在这一年，我跨出了义务教育，开始走向高等教育；在这一年里，我走入社会，接触浮尘。我拥有了更多的选择权、决策权，与此相对我有了更多的压力——无论是生活的压力、社会的压力、还是学业的压力都如潮水涌来。我的成长，意味着父母的衰老，意味着年岁象限的后移，意味着我将要接过更多的家庭的担子。金钱成为不得不考虑的事情、就业方向与前进也成为关注的趋势，在混沌中浮沉，逝去的梦想与年少将成为永恒的回忆？真的要这样吗？</p><h2 id="性格">2.2 性格</h2><p>从古风的“翩翩公子”、好奇与兴趣驱使的、追求多元化与创造力的少年，到渐渐有条理、目光更加专一、眼神逐渐凉意的一袭黑衣，反复只在梨花开遍一夜间。从<code>INTP</code>慢慢靠近<code>INTJ</code>其间都经历了些什么？是因为碎玉后的心凉还是无边夜幕下的压力？当你步伐渐稳、表达愈清晰，是否仍记昔日，是否心怀少年？</p><blockquote><p>你说，我又是否该恭喜你，弥补了曾经的缺陷，送去了当年的圆月。</p></blockquote><p>你最终还是无法如旧。你背弃了过去？</p><h2 id="追求">2.3 追求</h2><blockquote><p>追求个人意义与自我实现的最大化。</p></blockquote><p>这是一个新的定义。并不是追求个人利益的最大化，一切的根本追求的都是意义。我追求将脑海中的构思付诸于现实；我寻求创新与创意；我追寻我的兴趣与研究事物的本质。这些都是自我实现的体现，同时也是对个人意义的体现，个人意义包含了自我的满足感，创造的价值感，同时也包含对社会的贡献。</p><h2 id="自信">2.4 自信</h2><p>请问，风倾失去自信了吗？</p><p>答案是，是的。是的，在进入大学以来的，我的学习能力收到了我自己的怀疑，两次高数的小测，我都有不会写的情况出现，我渐渐怀疑起了我的“快速理解接受使用新知识”的能力。此外曾经在学习上的优势感，也受到了挑战，同时“卷”字，进入了大家的常用话语。卷字，似乎有那么一点“勤能补拙”的感觉，我不认为自己“拙”，所以我认为“卷”也没有包含这个意思，它代表的是勤奋、是追寻自己梦想的行动、是实现自我价值的必需品。</p><h2 id="人际关系">2.5 人际关系</h2><p>如1.5所诉，大多数集体是没有集体感的。冷漠，是我在大学里，对待大部分熟人和陌生人的第一印象。我对友人以外的人不会打招呼，基本没有与班上的除寝室外的其他说过话。寝室的关系也很微妙，我并不喜欢这个寝室。对外，在非本专业倒是结实了不少友人。</p><p>路人们与我并没有瓜葛，走好自己的路，犬吠声也就随他去了~</p><hr /><h1 id="过客友人">3 过客/友人</h1><h2 id="熟人">3.1 熟人</h2><p>在这一年里，来来往往皆是路人，熙熙攘攘皆为过客，大千世界扑面而来，无数匆匆路过身边的，有一眼之缘的——皆为熟人。</p><p>这便是我我对于熟人的定义。没来得及走入生活的人，点头之交的人，又或是是偶然同处于一个环境下一个集体中而认识的人——一切未曾走进而又认识过的人，就是熟人。这个一个很大范围的划分，意味着我与他们并没有形成联系，这是友人的滤过器，或许这也是是我冷血与生性凉薄的证明——我并不在意，过客的评价于我，并不入眼。这也是我的界限，我交往的边界，宁缺毋滥，毕竟真正能同行的人，又有几何？所有的利益、勾心、应酬，都在这里面，而我的心——还是留给心中之人吧。</p><blockquote><p>身后灯火万千，均无归处。</p></blockquote><h2 id="同行者">3.2 同行者</h2><p>无论是集体中，还是比赛中，还是能遇到一群有着相似目标，有着相似经历，又或是有着相同话语的一群人。与这群人的相处，没有压力——这便是“同行者”。</p><h2 id="挚友">3.3 挚友</h2><p>挚友唯两人而已，比较有意思的是，最终的相知都在时间段的后半部分——初中的后半部分、高中的后半部分（小学亦是如此，但已迷途中路，故不做联系），关于对他们的描述我并不想写在这里，人物传记/岁月路会有一席之地。</p><h2 id="碎珩">3.4 碎珩</h2><blockquote><p>相逢一场，恍若昨昔。今朝玉散，哭不成泣。</p></blockquote><p>关于与她的一切，部分有日记/随笔记载，亦有书信支撑（部分文笔因为手机更换而吞没在了数据里，再也找不到了）。过去可能永远不会相信，一个人是如何填满你的心。</p><blockquote><p>有了她，就像忽然有了软肋，也有了铠甲。</p></blockquote><p>而，心空了又是什么样的感受？人们总是深刻的记着残缺的事情……</p><p>在此不愿落笔，将来必会重叙。</p><blockquote><p>而她，走入过你的生活，留下了无数的痕迹。在那个春夏之际呀，成为永恒的回忆；至于她，永远的停留在了那一瞬间……</p></blockquote><hr /><h1 id="部分app年报数据">4 部分app年报数据</h1><h2 id="知乎">4.1 知乎</h2><ul><li>我的看世界视角为45°，严谨、理性、沉稳</li><li>2021年在知乎浏览了18113个问题，26468个回答，超过99.99%的知友<br />即平均每天浏览49.6个问题，72.5个回答</li><li>今年常常在早晨来到知乎</li><li>最感兴趣的领域【社科】【工程学】【科技】</li></ul><p>真是夸张的浏览量，也证明了知乎是我今年第一大内容浏览平台。对于工程系，我倒是没有相关印象。</p><h2 id="网易云qq音乐">4.2 网易云/QQ音乐</h2><ul><li>我的音乐灵魂是83岁，“灵魂深藏东方神秘力量”</li><li>年度歌词中【少年】出现194次</li><li>有5天在24:00以后听歌，11月05号在3:06还在听《思君难见》</li><li>年度歌单：伶仃谣33次、白衣7次</li><li>日本流行35%、轻音乐29%、中国音乐18%</li><li>与【竹箫竹】共享160个小时的音乐</li></ul><p>因为听歌过少，和很大量的歌曲在电脑Listen1收听，所以数据样本很小，不太准确。</p><h2 id="qq">4.3 QQ</h2><ul><li>年度热聊好友：Hikari、长苏、树叶、元熹</li><li>好友数量：2019年145个、2020年108个、2021年176个</li></ul><p>看见了别人的qq好友都是200起步，300、400+的也很正常，不经感慨。<br />也许只有我的qq好友数才会下降吧。</p><hr /><p>因为时间关系，（主要因为没有灵感）未能详尽，完整的完成这篇年鉴，便在此寥寥的结束了。</p><p>“颠覆的2021”既指这个时代——中美对抗、疫情反复、大政策的出台（双减等）等国际国内的风云变幻，亦指我的18岁这一年，无论是这一年的成长，还是这一年的经历，都是今生为今的最高点，将深刻影响我的未来以及我的过去。</p><blockquote><p>年与岁去，日与时驰。愿君无望当日，愿君还记少年，愿君未来可期。</p></blockquote><p>祝读至此者，扶摇青云。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>年报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2021/12/18/test/"/>
    <url>/2021/12/18/test/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><code>阿哲</code></p><p class="note note-primary">标签</p><p><span class="label label-primary">Label</span></p><hr />        <div id="aplayer-eezdyIDz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"蚍蜉","author":"花粥","url":"http://music.163.com/song/media/outer/url?id=1465288939.mp3","pic":"http://p1.music.126.net/9zwep-NZlopJz0JL8IOkpg==/109951165165628584.jpg","lrc":""}]};  options.element = document.getElementById("aplayer-eezdyIDz");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><div id="aplayer-oPNwzWgb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><div class="hljs code-wrapper"><pre class="aplayer-lrc-content">[00:00.000] 风倾客栈</pre></div></div><script>var ap = new APlayer({element: document.getElementById("aplayer-oPNwzWgb"),narrow: false,autoplay: true,showlrc: 2,music: {title: "蚍蜉",author: "花粥",url: "http://music.163.com/song/media/outer/url?id=1465288939.mp3",pic: "http://p1.music.126.net/9zwep-NZlopJz0JL8IOkpg==/109951165165628584.jpg",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script>        <div id="aplayer-vwsiacii" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <div class="hljs code-wrapper"><pre class="aplayer-lrc-content"></pre></div>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-vwsiacii"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "With You",              author: "Cashew",              url: "https://music.163.com/song/media/outer/url?id=1836016368",              pic: "http://p2.music.126.net/5pjHUmGogDt3ODMtdRkpCA==/109951165875491071.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-oOArVYDg" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <div class="hljs code-wrapper"><pre class="aplayer-lrc-content"></pre></div>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-oOArVYDg"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "いつも何度でも",              author: "宗次郎 / 白鳥英美子",              url: "https://music.163.com/song/media/outer/url?id=4904688",              pic: "http://p1.music.126.net/OLR8pDUR87SV2mXR7YfZuQ==/683896232488507.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-CKUdSlhk" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <div class="hljs code-wrapper"><pre class="aplayer-lrc-content"></pre></div>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-CKUdSlhk"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "天使的翅膀",              author: "安琥",              url: "https://m801.music.126.net/20190807163909f479a88358835505df7bbe1357488869/jdyyaac/065d/555a/5359/1784a40f89b0c54e7b4ad3ed1592c313.m4a",              pic: "https://p1.music.126.net/TUGO1gz0hq_f00o4DN0ocg==/80264348833252.jpg?param=34y34",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>    <div id="aplayer-BpCbBHyx" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="7119348534" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#333030" data-order="random"    ></div><p>test<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="参考资料1">[1]</span></a></sup></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        带 空 格的标题    </div>    <div class='spoiler-content'>        <p>内容</p>    </div></div><p><span class="math display">\[ \LaTeX{} \]</span></p><p><span class="math display">\[\int_{}^{}secxdx=\int_{}^{}\frac{dx}{cosx}=ln\left|secx+tanx\right|+C\]</span> <span class="math display">\[\int_{}^{}secxdx=\int_{}^{}\frac{dx}{cosx}=ln\left|secx+tanx\right|+C\]</span></p><figure><img src="fig.png" alt="fig" /><figcaption aria-hidden="true">fig</figcaption></figure>            <input type="checkbox" disabled checked="checked">text          <div>            <input type="checkbox" disabled >text          </div><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a;    cin&gt;&gt;a;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料1<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花园</title>
    <link href="/2021/12/16/9%E8%8A%B1%E5%9B%AD/"/>
    <url>/2021/12/16/9%E8%8A%B1%E5%9B%AD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我的故事里，有一座金色的花园，它不太大，却也撑起了年少的天空。<span id="more"></span></p></blockquote><h2 id="小园记">小园记</h2><p>从小家人就告诉我，花坛很脏，我可不听——因为那可是我自己的家园。</p><p>从我记事开始，那座花坛就在那里，仿佛，也一直应该在那里。在我家楼下，是一个被三面楼房和一堵墙包围的大院子，而正中央椭圆形的绿化空间就是这座花坛，在这个花坛中，有种植的几颗树木，四座假山，几株花草和一些我不曾认识的灌木类植物。</p><p>大片大片的杂草总是随着季节的更替变换着不同的绿色，构成了花坛的主色调。与此同时新的杂草会挤占旧杂草的生存空间，杂草的演替伴随着我的年岁的长大不断更替着——直到我离开这片土地。</p><p>我依然记得，在假山与灌木形成的空间中与那时的玩伴搭建的基地——对纸条进行一点点修剪，再在潮湿的泥土上铺上报纸，这便是一切，噢，还有木棍和砖块做一点简单的“家具”。我们还在林间的空地设置捕鸟笼；在斜坡上挖掘坡道形成灌溉线路；在假山边挖坑添水移栽花草制作风景点；在大“路”中间做出完美不会被看穿的陷阱……这哪是是花坛，这分明就是一大片树林、一大片田野、还有远山下的烟雨小镇。这是我们的土地，这片土地上空是我们的蓝天。</p><p>我用儿时的脚掌丈量了整片土地，为土地，不厌其烦绘制了许多地图，地图上标识了各个地方出产的“矿物”，果实，物种。颇有执掌天下之感。但，随着绘制精度的增加，我与花园日渐生疏，我不在知道一些植物是什么时候长出来的，也不在清楚假山的矿物是否还充足。我仅记得，捕鸟笼下的米饭未有鸟儿光顾；完美的陷阱不小心被自己踩中。那些因为“爬山”被打，蚂蚁换了多少代的往事都已经褪去。</p><p>这片孕育了少年梦的花园，依然还是在那里，但似乎也早已不在了。这花园中的我已经逝去，失去了我的花园亦已破碎，岁月变迁，花园新的时代不属于我，花园的旧花草还认识多少个？</p><p>想必没有花草还认识我了吧。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>岁月录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>光点</tag>
      
      <tag>散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主题更换</title>
    <link href="/2021/12/14/8/"/>
    <url>/2021/12/14/8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为难以忍受的文章渲染问题，和难以修改的字号配文章宽度，终于还是换了个主题。还是纪念一下曾经的主页吧……</p><figure><img src="https://s3.bmp.ovh/imgs/2021/12/6b01bef3fe214858.png"alt="曾经的主页" /><figcaption aria-hidden="true">曾经的主页</figcaption></figure><p>新的主题配件很多，设置很全面，很多就不用去翻找修改底层代码了√</p><p>另外配上上次的插件，很多东西就可以正常显示了，（虽然一些标识符还是显示不了）</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近日小结</title>
    <link href="/2021/12/06/6/"/>
    <url>/2021/12/06/6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font face="宋体"><br />嘿，你好啊！:cat:<br />现在是7：16，或者你也可以当作半夜，很黑很黑的那种<br />毕竟现在是冬天，太阳出来还早呢，<br />嗯，没错，今天算是我人生中第一个不眠之夜了——应该说是通宵<br />通宵是为什么呢，想想最近发生了什么<br />没错！今天是新秀杯的最后一个早餐，<br />而我，终于在临近到早晨时<br />完成了论文——我已经下不了手了<br />对了，我今天终于吃了一次早餐， 那家包子店真好吃 </font></p><hr /><p><font face="宋体"><br />今天，是竞赛周的最后一天，或许应该叫“竞赛双周”<br />嗯，这两周全是竞赛：亚太杯、ACM新秀杯、数学建模新秀杯、CSP认证<br />或许这个月都可以算在内！<br />今天的开始，意味着，对于我来说——竞赛周的结束<br />但是，也意为这“考试周”的到来，因为比赛，我蹉跎了很多学习<br />我有好多好多的要再学一次<br />英语四级、期末考试都在路上<br />所以，从今天开始<br />应该有比半期考试前一周更应该投入的状态 </font></p><hr /><p><font face="宋体"><br />你知道的，我还是想说这次数学建模新秀杯<br />我再也不想遇到这样的队友了<br />我一个人承担了建模、编程、排版、和部分写作<br />这个写作是迫不得已的<br />他们完全不会写——而我也不是专业这方面的<br />悲剧的开始在第一天<br />第一天，我让他们先说想法就被说凭什么我给他们布置任务<br />之后，就是漫长的写代码——对于我，<br />而本来属于我们亚太杯的桌子，成了我的，然后就成了我们的<br />然后，就有了我写代码，有人在对面看线性代数<br />还有一个要来就只能很晚才能来<br />说实话，真的很生气<br />对于这两个没有认真对待这个事情的人<br />对于这两个不愿意去学习不懂的事物的人<br />气愤<br />在我愤愤不平的时候效率会大打折扣<br />但是我又能怎么办呢？<br />对于这些即将不再是队友的队友<br />我觉得我不会再和他们交流<br />倾，不是这样用的<br />因为没有风<br />只有一片死寂<br />哦对，我搬回去了<br />那个地方我很长时间应该不会去了 </font></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近日小结</title>
    <link href="/2021/11/30/5/"/>
    <url>/2021/11/30/5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font face="宋体"><br />昨天呐，结束了为期四天的亚太杯。真的很累啊，有两个晚上熬夜到了凌晨四点多。而且是在比赛后很长时间都没调整回来状态——那是什么样的？那是长时间高度维持紧张和尽量维持专注的感觉。嗯，是的，这样的感觉能够帮助我们获得紧迫感的压力带来的效率以及长时间的投入——那确实是长时间的投入。<br />四天来说，时间很紧张，任务量也挺大的。而且最画时间的是：找数据、建模、写和排版论文。找论文的坎坷是未曾设想的，而中国的互联网和数据管理……也是让人很难受。<br />不过好歹是大家都竭尽全力的完成了，算是得到了一个尽力的结果，这样的经历本身的价值就很能让我回味了，而且在比赛中我的各项能力也有明显提升。总的来说：很累，但很值得。</font></p><hr /><p><font face="宋体"><br />其实不止于此，在准备比赛和比赛期间还经历了半期考试、舞台剧拍摄的事情，时间很紧张也很充实。我愈发感到了时间的压力——我已经很久没有嫌下来了——大概是从原半期考试的前三周开始，我开始学习数学建模的基本模型；在原半期考试前后，搭建了这个blog和看论文，再到真的半期考试（也就是上周末）的前一周的每天刷、看历年半期考试题目；然后便是这次亚太杯和现在的新秀杯；眼看快来的还有编程新秀杯和CSP，时间重合度高、没有把握的英语四级、期末考试也即将来临——然后才是假期。<br />看到这里也可以看见未来很长一段时间也是充盈的，我还要找到更好的生活状态，千万不能像昨天那样了。昨天理发的一点点按摩好像是缓解了我高度集中的注意力的主要原因。<br /></font></p><hr /><p><font face="宋体"><br />新秀杯的队友相对于亚太杯队友差太多了，挺失望的，也挺后悔。这个比赛我可能要一个人做完了……而且题目题型区别很大，题量很小，但方法很重要，找不到方法就结果都没有。<br />另外，因为很多事情，我的正课落下了很多，还一直没有很好的时间去补和复习预习……<br />得找个出路…… </font></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>霜行</title>
    <link href="/2021/11/24/4/"/>
    <url>/2021/11/24/4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font face="宋体"><br />无数的心之所向<br />无论是忘没忘，还是忘不掉<br />潜意识的一直存在<br />在各种场合耦合的一瞬间的回忆<br />哦，不是回忆<br />是一种生自心尖的难言之感<br />它在告诉我，有的人曾经来过<br />它体会了温情的充盈<br />也感受了剥心抽骨之痛<br />也不对<br />那是慢慢的流逝<br />是留不住的寒霜<br />是留不下的泪行<br />留下的<br />满院清风<br />满盘萧瑟<br />勾起感想之时<br />是谁在瑟瑟中消逝<br />万般落幕之后<br />是谁往身体塞漫寒霜 </font></p><hr /><p>这里面省略很多字，但这些字都指向一个字<br />不知，"字"在何方<br />是否会一如过往</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>诗歌</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更新小记</title>
    <link href="/2021/11/20/3/"/>
    <url>/2021/11/20/3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对于<ahref="http://valine.js.org/"><font color = red >Valine</font></a>评论插件做出了以下调整：<font face = "宋体" size =3></p><ol type="1"><li>移除了被放弃的设置遗留代码</li><li>增加了大部分可用设置</li><li>改变了表情包（以后将继续调整）</li><li>拉取QQ头像（未证实）</li><li>强制拉取<ahref="http://cn.gravatar.com/"><font color = red >Gravatar</font></a>最新头像</li><li>更改默认头像为随机小机器人<br /><font size=1 color = #9f9f9f face = "宋体"> updata on 11.20</font></li></ol><p></font></p><p>更改了文章的标题背景略缩图: <font face = "宋体" size =3> -略缩图素材来源于网络，经<font color = red >PhotoShop</font>处理得到 -源文件已被不小心删除，只留下一个最高压缩版的<font color = red >jpg</font>，导致所有细节丢失和细小文字被抹除<br /><font size=1 color = #9f9f9f face = "宋体"> updata on 11.19</font></p><p></font></p><p><strong>此外：</strong><br />发现本博客内置的<font color = red >MarkDown</font>渲染有非常大的问题，博客端的文本显示是和本地编辑/在线网站预览不同的。代码渲染还没有实装，目前暂无解决办法。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>规划小记</title>
    <link href="/2021/11/19/2/"/>
    <url>/2021/11/19/2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>昨天和今天一直在反复看这个博客主题的底层代码以及注释了解各个属性变量的作用。因为是用的别人的主题模板，还是想着把这个主题个人化……</p><p>一直在装修这个小博客，很多地方还是不够满意，这个还得慢慢调整。昨天的主要调整是把评论功能加上了以及成功去除了<spanclass="math inline">\(bug\)</span>，想来以后面对的肯定是很多，只是不要把网站弄坏了就好……</p><p>毕竟一直在看<code>HTML</code>和<code>css</code>的代码，进步还是很大的，确实标记语言比编程语言好理解些……但是看<code>css</code>的很多东西还是一片茫然（白茫茫的一片）。</p><h5id="对于分类我想要分为如下几个categories">对于分类，我想要分为如下几个<spanclass="math inline">\(categories\)</span>：<font face = "宋体" size =3></h5><ul><li><font color = pansy ><kbd>动态</font>：包括随笔、日志在内</li><li><font color = pansy ><kbd>算法</font>：各种语言的算法都可以投放</li><li><font color = pansy ><kbd>数据结构</font>：同上，各语言写的数据结构</li><li><font color = pansy ><kbd>数学模型</font>：这个主要是面对数学建模的<br />……</font></li></ul><h5id="对于标签目前的有一下">对于标签,目前的有一下：<font face = "宋体" size =3></h5><ul><li><kbd> 随笔 </kbd>：所有包含日常/吐槽/情感等的文字都可以打上这个标签</li><li><kbd> 日志 </kbd> 所有关于对博客的规划/调整等等</li><li><kbd> 算法大类 </kbd>：如 <kbd> 二分答案 </kbd> <kbd>模拟退火 </kbd><kbd>快速排序 </kbd> <kbd>A*寻路</kbd>在内的非启发类或启发类（智能）算法</li><li><kbd> 语言大类 </kbd>：如<kbd>C++ </kbd> <kbd>Matlab </kbd><kbd>Python </kbd> <kbd>Latex </kbd>等等标记或非标记语言</li><li><kbd> 模型大类 </kbd>：如 <kbd>灰色预测 </kbd> <kbd>聚类模型 </kbd><kbd>多元回归分析 </kbd> <kbd>奇异值分解SVG </kbd>等模型</li><li><kbd> 结构大类 </kbd>：如<kbd>平衡树 </kbd> <kbd>支配树 </kbd><kbd>树链剖分 </kbd> <kbd>支配树 </kbd> <kbd>左偏树 </kbd>等结构<br />……</font></li></ul><p>但是这样的分类和标记其实有很多问题，很多属于两者之间的很难判断应该属于什么，比如很多数学模型倾向与算法、很多日志和随笔分不开等等…这种情况一直是让我头疼的问题——而且生活中在很多地方都有这样的问题。</p><p>与此同时，<code><spanclass="math inline">\(MarkDown\)</span></code>的标记语法我也忘了很多了，现在要慢慢的学习和回忆。比如以下对于关系:<code><spanclass="math inline">\(Markdown\)</span></code>中支持基本的<code><spanclass="math inline">\(HTMl\)</span></code>语法 <div class="hljs code-wrapper"><pre><code class="hljs md"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span></span> | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span></span> A <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span></span></code></pre></div> <code><kbd> A </kbd> | <b> A </b> | <i> A </i> | <em> A </em> | <sup> A </sup>| <sub> A </sub> | <code> A </code> </code> <br><br>另外，不能在花太多时间在这个上了，我还有很多其他的东西要准备……</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>故事的开始</title>
    <link href="/2021/11/17/1/"/>
    <url>/2021/11/17/1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="hello-world">Hello World</h1><p>这里是本站的第一篇网站<br />也是这个博客的开始</p><p>在这里想把岁月留住<br />埋下旧人之花，铭刻少年之梦</p><p>搭建这个博客遇到了不少困难，也绕过了不少弯路，磕磕绊绊走到这<br />还得感谢友人的帮助和陪伴<br />也算是完成了曾经的心愿——搭建个人网站</p><p>虽然这个小小的平台还是使用的别人的模板、别人的代码<br />但一路走来，我们都成长了，不是吗———<br />所谓，“井底之蛙不知大海宽广，却知晓天空之蓝”<br />毕竟，在故乡的明月下，谁的身影不是被渐渐拉长</p><p>哈哈，原谅我使用了这个动漫中的句子，放在这显得似乎也不是那么恰当<br />但是，你应该是明白我的意思的，<br />想必一百个哈姆雷特中也总会有我一个</p><p>还是说回来吧<br />这个博客的主要使命是「记录」——<br />由此发散<br />包括笔记、随笔在内的许多东西…<br />哦对，还想认识一些远方的人<br />不必相知，嗯，暂且就称为「过客」吧</p><p>所以，<br />来到这里的过客呀，<br />祝你幸福</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>动态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迎泽</title>
    <link href="/2020/11/25/10%E8%BF%8E%E6%B3%BD/"/>
    <url>/2020/11/25/10%E8%BF%8E%E6%B3%BD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>那秋夜中的湖水，永远的留在了那里，直到再也找不到它的影子…<span id="more"></span></p></blockquote><h2 id="迎泽影">迎泽影</h2><p>我梦见迎泽许多次，却仅到了一次。而那一次，便足以使我回味至今。</p><p>那是在国庆，我急于在北方这个略显萧瑟的城市寻找一个安心之所。萧瑟的不是这个城市，而是心；安心之所不是住处，而是寻找自己。毕竟，一个人同一群人，在陌生的城市里，在不习惯的空气中，显得格格不入。</p><p>那正是在被打击的日子里。同行的师友善意的提醒我们，不要太放在心上，好好去放松下吧。我不甘心，相信在繁华的都市中，我仍然能够找寻到一片净土，在那里，一定会告诉我许多我未曾知晓的秘密。</p><p>沿着小径，是夹岸的泛黄的叶柳，在夜色里略显幽僻，寂静的草深处，夏虫已然鸣出了丝丝秋意。沿着幽径行去，拨开纸条便是小亭，亭中有方石桌一，小石椅两，若有油灯一盏，月光一壶就更佳了。我并没有停留的念头，我只是脱离人群的一人，我只想看看园中的景色，更何况又没有能温酒的友人。</p><p>隔篁竹，水声熹微，在干燥的北地，有一公园相伴以是幸事，有流水助兴那就是惊喜了。溪流里波光粼粼，映着远处高楼的霓虹灯影，远处楼台上的灯火中，看不见月光，没有月光的晚上，本还是阴森森的，转过亭来，却恍然亮堂了起来。</p><p>这是一面湖水，在城市的中间，犹如一颗宝石。沿着堤行，路上三两个形单影只的身影，随着水流动到拱桥那边去了。背着手踱着，仿佛我独享了整个湖，湖面四周都是黑乎乎的，只有湖心处泛着光，上面的夜空里，有阴靉的薄云，一点星光也没有，地上，一人微熹，不知在想些什么。</p><p>像今天晚上，心思可以飞往各处，哪里都可以去，也可以哪里都不去。有湖停陪在身边，我不用害怕迷失，因为我也是其中的一部分了。</p><p>翻过小山拜访了楼台，在廊腰缦回中寻味，月色渐渐泻了出来，停在了阁楼的最高层。曲曲折折的小路，路旁萦绕着心心点点的花朵，就像是草木好奇的眼睛，她们仿佛就是与秋天过不去，故意在夏末才开放；她们又好像是天上的星星落在了草丛里，正如粒粒明珠。清风送香，向夜半的风把树阴吹斜，我便看见了同行的伙伴们，不在躲着他们的行去。“你们听见了吗？”他们莫名其妙还笑话我有文人气。我并没有听清楚他们在说什么，我只听见了花的香气。</p><p>花的香气是怎么样的呢，我已想不起来，不过梦回迎泽，那些影已经忘不掉了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>岁月录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>光点</tag>
      
      <tag>散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about me</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>转跳：<span class="label label-warning"><ahref="/update/"><font color=#0F0F3F size=3 face="微软雅黑"><b>「更新日志」</b></font></a></span> <span class="label label-success"><ahref="/links/"><font color=#0F0F3F size=3 face="微软雅黑"><b>「轻音/友链」</b></font></a></span> <span class="label label-info"><ahref="/shuoshuo/"><font color=#0F0F3F size=3 face="微软雅黑"><b>「说说/想法」</b></font></a></span> <span class="label label-danger"><ahref="/tags/"><font color=#0F0F3F size=3 face="微软雅黑"><b>「标签/频度」</b></font></a></span></p><hr /><p>Hi~ 啊哈，这里是<strong>风倾✧</strong>。</p><hr /><p>GitHub：<a href="https://github.com/Dramwig"><span class="citation"data-cites="Dramwig">@Dramwig</span></a><br />知乎：    <a href="https://www.zhihu.com/people/feng-qing-51-31"><spanclass="citation" data-cites="风倾">@风倾</span></a></p><p>邮箱：    <ahref="mailto:epochxi@outlook.com">zixi-wang@outlook.com</a></p><hr /><p>另：本小客栈评论的邮箱提醒有误（无法发送邮箱）</p><p><font size =1 >BLOG Power By <ahref="https://hexo.io/zh-cn/index.html">Hexo</a> &amp; <ahref="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> </font></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>Gallery</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="about">about</h1><h2 id="ժҫ">ժҪ</h2><h2 id="section">��</h2><h2 id="section-1">����</h2><h2 id="section-2">����</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>links</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="section">23123</h1><p>123</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>动态</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="section">2023.12.11</h4><ul><li>地上的黄叶仿佛是下了一场雪，在那个夜里，寒风瑟瑟，也许是一阵风，便有了叶落和满地金黄，在那个寒夜里，有人夜半灯火有人睡意阑珊。在已故的秋天里，心如落叶无声，事如春梦无痕。在来年的春里，要写一首歌。</li></ul><h4 id="section-1">2023.12.07</h4><ul><li>曾经有人羡慕我一群能陪我吃夜宵的，现在倒是没有人等我了</li><li>人来鸟雀寂，叶落晚霞升</li></ul><h4 id="section-2">2023.11.24</h4><ul><li>把以前送我的杯具拿走又给别人用，这是何意呢？虽然我确实用不上，但是不至于这样吧？</li></ul><h4 id="section-3">2023.11.22</h4><ul><li>关于玥的一些大致的事情已经被很多人知晓，想来想去应该还是这个博客透露的，我有想过隐藏掉那两篇文章，但是我还是决定展露他，而不是逃避隐瞒</li></ul><h4 id="section-4">2023.10.11</h4><ul><li>下了一夜的雨把我冲刷</li><li>是什么支撑我活下去？是生命之重、生命之轻？</li><li>我本来都准备好了信纸，想学习之余写点给你的文字放松心情……最终落得这个下场</li></ul><h4 id="section-5">2023.10.10</h4><ul><li>国一吗？本来应该很高兴的呀……</li></ul><h4 id="section-6">2023.10.09</h4><ul><li>有为学长很敏锐的捕捉了我的心悸，我很惊奇</li><li>书中学到的并不会让我习得深刻教训，如果我想和你尝试，你会答应吗？</li></ul><h4 id="section-7">2023.10.05</h4><ul><li>难忘大理之旅结束了，满足与镇痛激励着我成长和提高，哪些炸裂的思想已经记录在案</li><li>我要变得更好，一定要</li><li>卸载了永劫，删除了王者</li></ul><h4 id="section-8">2023.10.04</h4><ul><li>你静静的坐在身边，静静的合眼 静静的睡<br />静静的，离开大理，离开云南，离开牧笛<br />我也静静的，<br />因为我知道，静静的，是最后的时光<br />静静的，故事就暂停了<br />静静的，故事就远去了<br />留不住的，都在静静的消逝了<br />静静的，还能见吗</li></ul><h4 id="section-9">2023.09.27</h4><ul><li>数学建模协会又出现了奇怪的关系，xyj和fjx之间有事情，xyj和gc与她朋友之间有事，我无意于打听这些事情了……</li></ul><h4 id="section-10">2023.07.28</h4><ul><li>我梦到了坐在教室左侧的倒数第二排，har坐在我的左侧，身后是swy和wy，枕着她的手臂……不想醒来，黑板站着的史老师。</li><li>听闻互联网行业搞资产转移的太多了，要出重拳。现在生活越来越难了。</li></ul><h4 id="section-11">2023.07.20</h4><ul><li>昨夜里，我不再有逝去的魂灵，从此我的梦就透明了<br />晨光中，我扔掉了过往的记忆，从此我的脚步就轻盈了</li></ul><h4 id="section-12">2023.07.13</h4><ul><li>我梦到了她，梦到了她给我发消息，梦到了我们见面，梦到了不愉快，梦到了失望，梦到了无语，<!--梦到了我剪下她裙子(边沿)，-->愤愤的离开，梦到了还是后悔和看那很多她发的聊天记录。</li></ul><h4 id="section-13">2023.06.30</h4><ul><li>期末总算是考完了，但是似乎不慎理想……真羡慕他们临时的学习/记忆能力</li><li>焦虑</li></ul><h4 id="section-14">2023.05.28</h4><ul><li>这里的人来了又走，我好想留住故事啊……</li><li>熬夜了两三天做完了数据库实验又开始低效起来了吗？</li></ul><h4 id="section-15">2023.05.16</h4><ul><li>跳绳落地163，心里总算又少件事</li></ul><h4 id="section-16">2023.05.09</h4><ul><li>每一次集体投票都能让我感到深深的恶意…</li></ul><h4 id="section-17">2023.05.04</h4><ul><li>我伫立在冷风中，我在望着什么呢？<br />我送走了身边的人，一个人落在这河边桥下，我在想什么呢？<br />我应该是在的，可目光便随着思绪飘到了对岸，在目光的尽头，河水拐了个弯消失在了河滩草木中，再往下是灿烂的小黄鸭和橙红的浮漂，坐在金色小黄鸭中的点点人影往往复复，绕着相同的圆圈。再在桥墩前也没什么好描述的了。<br />包括我自己，消融在了这一成不变的图画中，像一个动图一样往往复复，做着相同的动作。<br />我为什么在这呢？因约来此。身在异乡却非异客，眼前的风景并不陌生。却也不同了。这个地方游过三个人，坐过两个人，如今却是一个人和两个和无数的游人。在这劳动假期的最后一天也理应如此。<br />是的，理应如此，理应一个人与两个人在无数人中穿梭，也理应一个人沉在奔流水间。世间一切如此，一切如常。</li></ul><h4 id="section-18">2023.04.08</h4><ul><li>在某些时候，自己比自己想象的更敏感</li><li>l，h，t，s一些琐碎的纷扰，和淡淡的忧伤。像压倒骆驼的最后一颗稻草？倒不至于，我还没有脆弱成这样，但是啊，真的感觉都走了。</li><li>我的能量很有限，能不能不要都让我输出呢？</li></ul><h4 id="section-19">2023.03.12</h4><ul><li>开学初期复习考试六级相关让人焦虑的项目全面结束，从今天起转向新学期科目的学习，开始行程新学期作息生活习惯与筹划竞赛科研安排。</li><li>和AFXR的交谈，发现我居然用ipad软件居然也算做成本了，”我真的老了“，”未来我只会指着chatgpt说，这是异端“。</li></ul><h4 id="section-20">2022.12.31</h4><ul><li>想写写文章或故事，但是没有状态，也下不了笔</li></ul><h4 id="section-21">2022.09.29</h4><ul><li>压力又上来了，就和大一下前段相同；以前的数学建模比赛都是为这个比赛做准备的；这个比赛的失利代表了我大学以来花费最多心思的比赛的失利</li></ul><h4 id="section-22">2022.09.28</h4><ul><li>数学建模国赛失利</li></ul><h4 id="section-23">2022.08.25</h4><ul><li>大石头终于落地了，总算是过了，虽然低，但压力小了太多了。</li><li>看着新生入学也算是感慨良多了，回想起来就像荒废了一年</li></ul><h4 id="section-24">2022.07.08</h4><ul><li>“我在部队什么都没学会，只学会了人情世故”-室友</li></ul><h4 id="section-25">2022.07.07</h4><ul><li>第一次有数学建模比赛未能获奖，真是难……</li></ul><h4 id="section-26">2022.06.25</h4><ul><li>第一次喝酒喝到微醺，听到了两人更多的细节的故事，很有意义……</li></ul><h4 id="section-27">2022.06.25</h4><ul><li>从昨天和高中同学的谈论中，我得知好像忘记了一个暗地喜欢我的人。</li></ul><h4 id="section-28">2022.06.07</h4><ul><li>和力院老师聊了一个半小时多，了解了更多，大学竟然有这样的好老师。</li><li>聊天，串串，喝酒，感情故事了解了许多，可是啤酒白酒下肚，并不能感受到醉意，亦无感情的激发……第一次喝酒，就这样吗？</li></ul><h4 id="section-29">2022.05.31</h4><ul><li>我认识了在大学第二个感兴趣的人，这里的感兴趣指对他的思想对他的经历感到好奇之类的。<br />是否会有更多的联系？不知……</li></ul><h4 id="section-30">2022.05.23</h4><ul><li>与协会出现了裂痕，哪里已经逝去了归属感。</li><li>另外，有一个小机灵鬼在昨天13点给我朋友圈点了赞又取消……被我发现了。</li></ul><h4 id="section-31">2022.05.17</h4><ul><li>扇子兜兜转转还是回到了我手中，我还是将它送给了她，也算是最后的纪念</li></ul><h4 id="section-32">2022.04.22</h4><ul><li>今天是她的生日，我发了说说，却收到了回复，一瞬间难以言喻的感情涌现……</li><li>她的世界很喧嚣，向上望去，迷蒙着孤月。</li><li>比起这个，我更担心你忘记<br />如果曾经的你只存在于自己的文字里，那和忘掉了没有区别<br />——小光君 15:38:41</li></ul><h4 id="section-33">2022.04.19</h4><ul><li>了却旧事，送别过往</li></ul><h4 id="section-34">2022.04.18</h4><ul><li>错付止否？<br />​有的人，终究是过客<br />​你要的，究竟是什么<br />​是雨夜的悲鸣<br />​还是鲜花烂漫的午后<br />​我不说</li></ul><h4 id="section-35">2022.04.04</h4><ul><li>生气，算是放鸽子？这样的数学建模队伍，不通知就取消会议？这是什么态度？这是什么观念？</li></ul><h4 id="section-36">2022.03.31</h4><ul><li>感觉惟悦的风格走向怪怪的，先用了“迎泽”避免一些东西吧。</li></ul><h4 id="section-37">2022.03.30</h4><ul><li>面试后在今天确定成功进入了只收了20人的学术部，邹佳兵刘宇韬没能进入，听说是有各自缺陷，黄雅蕾倒是也成功进入了，听说她被评价论文写的很好。</li></ul><h4 id="section-38">2022.03.23</h4><ul><li>拿到了新的手机，本以为会很兴奋的，实际上是打开的动力都没有。</li><li>夜宵和上一届学长聊了聊，反思这个词终究是落在了我的头上</li></ul><h4 id="section-39">2022.03.14</h4><ul><li>先打理好自己，再迎接来人</li></ul><h4 id="section-40">2022.03.13</h4><ul><li>今天发生了奇怪的事情，已经将照片保存入刻痕。我很害怕，也不能将手生回去询问情况，我终是个软弱的人……</li></ul><h4 id="section-41">2022.02.24</h4><ul><li>谢谢你啊， Atri ,在昨天晚上，难得又能感受的共情，与难过……</li><li>四级失败，但也……</li></ul><h4 id="section-42">2022.02.03</h4><ul><li>第一刀是伪装与谎言，是虚假的算法决策结果<br />第二刀是抓不住无法挽留必将逝去的她，以及伴随她慢慢失去记忆“死亡”的过程</li></ul><h4 id="section-43">2022.02.21</h4><ul><li>“这么多的日子里，你都是心事……”脑海里总是回想着这首歌，嗯，这首歌属于我的高中</li><li>如果心中有忘不掉的人，还怎么拥抱新的未来？</li></ul><h4 id="section-44">2022.02.17</h4><ul><li>花园一朝一毁而去，看来无归不远了</li></ul><h4 id="section-45">2022.02.04</h4><ul><li>生快……有三个人记得我生日（不包含亲人）</li></ul><h4 id="section-46">2022.02.03</h4><ul><li>概率论与数理统计宋浩视频看完了，书没有讲完，感觉也没有学到太多新东西(T~T)<br />第一次学完有这种感觉</li></ul><h4 id="section-47">2022.02.01</h4><ul><li>愿新的一年，仍有阳光满路，温暖如初。<br />May the new year still be sunny and warm as ever.<br />安喜乐，梦如许，长安宁。</li></ul><h4 id="section-48">2022.01.21</h4><ul><li>这个小镇是那么的小，那么的拥挤——一切都是灰蒙蒙的，似乎要将过往尘封<br />人们熙熙攘攘，喧嚣声<br />送来寥落。艳丽也染上灰色，蒙一层布，隔一层纱</li></ul><h4 id="section-49">2022.01.16</h4><ul><li>关于我提前计划15天干完了高数II，不知道为什么，我喜欢在一个时间段主要做一个事情，即使很长时间干一个事情很困以及效率不及混合做多个事情。</li></ul><h4 id="section-50">2022.01.13</h4><ul><li>整理了所有第一学期的成绩，重新整合了解了转专业细则和综测评价。一眼望去，是不可预知的未来，而我在悬崖边，摇摇欲坠……</li></ul><h4 id="section-51">2022.01.11</h4><ul><li>ACMCM得到了一等奖的好成绩，本来很开心的呀。但是得知了曾经队友另组它队，还是有一种压抑的难言之感，背叛后怕还是压力？虽然早就知道这样的事情必定会发生，也知道这很正常，人们都有自己的决定。所以我开始疑惑，到底应该认识了解更多的队伍，还是稳定在一个队伍中？<br />还是有一种压力，是无归无后路的压力。</li><li>恍然间，为他人做贤士之心已变</li><li>一切的压力和恐惧都来源于能力和学业的不足</li></ul><h4 id="section-52">2022.01.10</h4><ul><li>真正的自由是自律的自由，不是放纵的自由——罗翔<br />真正的快乐是自我实现的快乐，不是放纵自我的快乐</li></ul><h4 id="section-53">2022.01.06</h4><ul><li><p>三号，我终于在晚上回到了家。<br />在路途中，难得的没有出现劳累之感，要知道，以前出行都会很疲惫的（主要是心理）。不过在二号后，我的心情有明显的转变，不再是心事重重和不苟言笑了。<br />intp的感觉回来了，直到现在，也将会延长整个假期。但这并不代表我将会逝去习惯，相反这几天我都在继续刷高数的视频和早起。<br />今天就要回到故土了，祝一切安好。</p></li><li><p>相忘于江湖并不是妥协，而是更高的追求</p></li></ul><h4 id="section-54">2022.01.01</h4><ul><li><p>雨中的烧烤摊还是这样喧闹，<br />已到新年，愿君安好</p></li><li><p>你知道，我有多么舍不得过去的自己，与过去的你吗？谁？走入的我的心间，却换做每一晚的泪水。<br />也许，这就是我们分别的原因吧？<br />在一封封的书信后，一个不安的灵魂与另外一个无所适从的灵魂，也仅仅是相逢罢了吗？<br />我屏蔽了你的朋友圈，你的空间，我删去了那些能关联你我的中间人,<br />我拼了命的想要掩藏你在我生活中、生命中留下的痕迹<br />那一抹身影还是悄然入我梦来……梦里，一切多么安好……<br />我忘不掉你，所以我悄悄放开了你的朋友圈，窥探你的生活，<br />于是，我输了。<br />我不在记得起我们结识的日期，再也记不起你的电话号码，直至淡忘了书信的内容……<br />但我依然记得，案头上没来得及递出去的几封书信，记得知乎的那一篇回答，Gorkor还是在手机里，但打不开了。<br />好一个偷走我心的人，好一个未画完整的残月。<br />好一个你。</p></li><li><p>难得清闲的午后，慵懒倚靠在湖边<br />耳边是成双的黑天鹅相互答应的叫声，<br />眼前几米是梳理着羽毛的白色天鹅<br />还时不时的看看我</p></li><li><p>看完了《Little Misfortune》的视频，圆了高二一个事情吧。</p></li></ul><h4 id="section-55">2021.12.26</h4><ul><li><p>天气更冷了，玻璃开始模糊，呼出的白气散去，就已经到考试周了</p></li><li><p>每次回到宿舍，首先感到的是热气和二氧化碳，我会已经基本做到“空闲时间”不呆在宿舍了</p></li><li><p>图书馆的温度为20℃而回到宿舍，就看见了32℃的空调和闷热的空气</p></li></ul><h4 id="section-56">2021.12.23</h4><ul><li><p>从不怎么玩到不玩，只用了半月<br />从尝试到熟悉，只用了一个月<br />从梦想的勉励到习惯，不知道还有多久</p></li><li><p>今天就这样结束了吧，虽然有点不甘</p></li></ul><h4 id="section-57">2021.12.21</h4><ul><li><p>在未来，有人大概会告诉你，认为你是昔日上限最高的人，他只不过是感慨失意的曾经仰视者。而你，是个失败者。</p></li><li><p>在很长一段时间中，我将能否学到新的知识作为价值衡量点，而在几个月里我很少感受到这样的光点了，我将重拾它……</p></li><li><p>归雁与落辉</p></li></ul><h4 id="section-58">2021.12.19</h4><ul><li>小鸭子们从集群分布到独自行动<br />仅仅用了一个月的世界<br />漾起的清波，却有了天鹅的影子</li></ul><h4 id="section-59">2021.12.18</h4><ul><li>每天，都作一位旅人<br />逃也似的离开寝室，<br />像似，从温暖的地狱逃出，<br />却跌入了冰冷的世界<br />寒风，烟柳，归雀<br />半天的乌云<br />昏黄的圆月</li></ul><h4 id="section-60">2021.12.13</h4><ul><li>昨晚吃坏肚子后，吐了两次，身体发冷（上课），让我感觉到了身体的脆弱这也是梦到一些神奇东西的原因，挺难受的，现在也没好过来</li></ul><h4 id="section-61">2021.12.12</h4><ul><li>我其实挺希望有人能照入我的生活的，<br />在痛苦之后</li></ul><h4 id="section-62">2021.12.6</h4><ul><li>梦醒如初见，归来曾少年？</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>tag</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>更新日志</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="markdown-body"><h2 id="待解决问题">待解决问题</h2><div class="note note-danger">            <p>目录会显示“Hide”中的标题导致显示错误（在赛后总结中）</p>          </div><h2 id="待优化问题">待优化问题</h2><div class="note note-info">            <p>左侧过空，可以添加侧边栏或功能</p>          </div><hr /><h4 id="section">2023.10.06</h4><ul><li>移除了hexo-all-minifier</li></ul><h4 id="section-1">2023.08.08</h4><ul><li>使用<code>cnpm</code>安装了<ahref="https://github.com/chenzhutian/hexo-all-minifier">hexo-all-minifier</a>，用于压缩静态资源，提升加载速度。但是<code>hexo generate</code>和<code>hexo serve</code>速度变慢</li><li>出现了新问题，无法用HTML语法并排摆放图片了</li></ul><h4 id="section-2">2023.08.07</h4><ul><li>博客出现了无法渲染数学公式的问题，是渲染器的问题，卸载了<ahref="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a></li><li>安装了<ahref="https://github.com/hexojs/hexo-renderer-pandoc">hexo-renderer-pandoc</a>，采用mathjax引擎渲染数学公式</li><li>当前组件如下：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sh">+-- hexo-deployer-git@3.0.0 用于将博客部署到 Git 仓库的部署器。+-- hexo-generator-archive@1.0.0 生成文章归档页面的生成器。+-- hexo-generator-category@1.0.0 生成分类页面的生成器。+-- hexo-generator-index@2.0.0 生成首页的生成器。+-- hexo-generator-search@2.4.3 生成站内搜索功能的生成器。+-- hexo-generator-tag@1.0.0 生成标签页面的生成器。+-- hexo-renderer-ejs@1.0.0 使用 EJS 模板引擎渲染页面的渲染器。+-- hexo-renderer-pandoc@0.4.0 使用 Pandoc 渲染 Markdown 文件的渲染器。+-- hexo-renderer-stylus@2.0.1 使用 Stylus 渲染样式的渲染器。+-- hexo-server@2.0.0 用于本地调试和预览的服务器插件。+-- hexo-sliding-spoiler@1.2.1 添加滑动展示效果的插件。+-- hexo-tag-aplayer@3.0.4 在博客中嵌入音乐播放器的插件。+-- hexo-theme-landscape@0.0.3 Landscape 主题，一款简洁大气的 Hexo 主题。+-- hexo@5.4.0 Hexo 静态网站生成器的核心模块。`-- valine@1.4.16 一款快速、简洁且高效的无后端评论系统。</code></pre></div><h4 id="section-3">2023.08.06</h4><ul><li><del>安装并</del>卸载了<ahref="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a>，因为有多出一个前缀的bug导致图片无法显示</li><li>安装配置了<ahref="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>，解决了多年遗留的无法引用资源文件夹图片问题，可以不再使用图床了</li></ul><h4 id="section-4">2023.07.27</h4><ul><li>启用了新域名，<strong>域名更换为blog.wangzixi.top</strong>，网站访问量被重置</li></ul><h4 id="section-5">2022.12.31</h4><ul><li>修改了大部分文章的文件名格式，对应文章访问量被重置</li></ul><h4 id="section-6">2022.01.01</h4><ul><li>正式启用<ahref="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">aplayer</a></li></ul><h4 id="section-7">2021.12.26</h4><ul><li>增加了更多的背景，并整理分类了配置图片</li></ul><h4 id="section-8">2021.12.25</h4><ul><li><span class="math inline">\(\LaTeX{}\)</span>公式上线，卸载了原有渲染器<br /><del>安装并</del>删除了 mathjax &amp; <ahref="https://github.com/jgm/pandoc/blob/master/INSTALL.md">Pandoc</a><br />最终安装并使用了更轻量级的 katex</li><li>更换代码渲染样式为 <ahref="https://highlightjs.org/static/demo/">highlightjs &gt; TomorrowNight Bright</a></li><li>主题自带的 <spanclass="label label-primary">Tag</span>插件上线，包括单行和行内标签</li><li><ahref="https://github.com/fletchto99/hexo-sliding-spoiler">spoiler</a>插件上线，可以对部分文章内容折叠了，提升阅读体验</li></ul><h4 id="section-9">2021.12.23</h4><ul><li>再次取消菜单栏「主页」，<br />因为可以点击菜单栏左侧博客名回到主页</li><li>取消菜单栏「更新」，合并于「关于」界面，设置转跳链接</li><li>为提示点击博客名可回到主页，增加了home图标</li></ul><h4 id="section-10">2021.12.21</h4><ul><li>更改网站logo，更加符合名字了呢~</li></ul><h4 id="section-11">2021.12.14</h4><ul><li>全面翻新，<strong>主题更改为<ahref="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></strong></li><li>对背景、文字等做出调整</li><li>评论等配置重新添加</li><li>新增了歌单！并合并于「朋友」，<br />可以一边看友链一边听轻音乐了<del>bushi</del></li></ul><h4 id="section-12">2021.12.9</h4><ul><li><del>增加并</del>删除了<ahref="https://swiftype.com/">swiftype</a>搜索</li></ul><h4 id="section-13">2021.12.7</h4><ul><li>整合所有更新日志于update</li><li>调整菜单栏</li><li>部分页面不在有aboutMe卡片</li><li>部分页面圆角优化</li><li><del>增加并</del>放弃了<ahref="https://artitalk.js.org/">Artitalk</a></li><li>增加了导航栏qq图标</li><li>Markdown渲染器更改为<br /><ahref="https://www.npmjs.com/package/@upupming/hexo-renderer-markdown-it-plus"><spanclass="citation"data-cites="upupming/hexo-renderer-markdown-it-plus">@upupming/hexo-renderer-markdown-it-plus</span></a><br />插件++</li></ul><h4 id="section-14">2021.12.5</h4><ul><li>更改主题背景图片</li><li>精简菜单栏内容</li><li>更改主页文字</li></ul><h4 id="section-15">2021.11.20</h4><ul><li>网站logo和名称上线</li><li>移除了被放弃的底层代码</li><li>评论增加了大部分可用设置</li><li>改变了评论可用表情包</li><li>评论强制拉取QQ头像</li><li>评论头像强制拉取<ahref="https://en.gravatar.com">Gravatar</a>最新版</li><li>评论更改默认头像为随机小机器人</li><li>制作并部署第一个文章背景略缩图</li></ul><h4 id="section-16">2021.11.19</h4><ul><li>调整菜单栏，启用所有功能</li><li>对分类和标签进行了规划调整</li><li>更改主题底层代码</li><li><a href="https://valine.js.org/">Valine</a>评论上线</li></ul><h4 id="section-17">2021.11.17</h4><ul><li>基于<ahref="https://hexo.io/zh-cn/index.html">Hexo</a>驱动，Github部署打造了本网页</li><li>使用主题<ahref="https://github.com/miccall/hexo-theme-Mic_Theme">Miccal</a></li></ul></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
  </entry>
  
  
  
</search>
