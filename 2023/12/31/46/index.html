

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo/favicon.png">
  <link rel="icon" href="/img/logo/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="一个神秘的人">
  <meta name="author" content="epochxi">
  <meta name="keywords" content="dramwig">
  <meta name="description" content="计算机图形学理论课复习大纲 考试题型：简答题，计算题，绘图题，分析与设计题，程序实现题。 分数分别为：20分，30分，10分，30分，10分。 一、 图形学基本概念  什么是计算机图形学？ 计算机图形学的主要研究内容包括哪些？ 计算机图形学的主要应用领域。 图形和图像的主要区别是什么？ 计算机图形处理系统的主要构成。 显卡的工作流程。 什么是显示存储器？ GPU的基本概念。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机图形学 - 期末复习">
<meta property="og:url" content="http://example.com/2023/12/31/46/index.html">
<meta property="og:site_name" content="风倾客栈 ✧">
<meta property="og:description" content="计算机图形学理论课复习大纲 考试题型：简答题，计算题，绘图题，分析与设计题，程序实现题。 分数分别为：20分，30分，10分，30分，10分。 一、 图形学基本概念  什么是计算机图形学？ 计算机图形学的主要研究内容包括哪些？ 计算机图形学的主要应用领域。 图形和图像的主要区别是什么？ 计算机图形处理系统的主要构成。 显卡的工作流程。 什么是显示存储器？ GPU的基本概念。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/hKX8oDS7I3m4tEN.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/76vOlwcSKkImxGq.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/JmBR6XfWMtEOC1F.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/9oOc6aq1bNjHnhL.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/MqsiKHj7dQc6nWr.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/DIuh4QR5KZMarbU.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/15EK8hUg9einsdC.png">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/8cinNKfIslyD6ek.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/3FjEzHkNd2laMPO.png">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/I8RODVgrYcBblxZ.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/qrZhaFLtpNoWxRm.png">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/k1uw9eFMSd5OGv6.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/6DyukMBLPHzItlT.png">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/SE49AZKfWMmcTRj.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/09/gVWfeZhpoMTq4Ja.png">
<meta property="og:image" content="https://s2.loli.net/2023/12/31/NOakHouzQ9ECB8D.png">
<meta property="og:image" content="https://s2.loli.net/2023/12/31/sywN25MZjOcraDW.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/OTQDkLhuVjGW1Np.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/15EK8hUg9einsdC.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/ziYFIPXnT4CAN6U.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/6kh4qRsAJVboWuN.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/xPSw9HnlGL4toUJ.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/LAqHEJijUQ4oGzY.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/SHa59nx1TuBDwI7.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/uleTRDy7MwWmnGI.png">
<meta property="og:image" content="https://s2.loli.net/2023/12/30/SE49AZKfWMmcTRj.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/06/rwSGV3WHFTcxy1z.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/UXE7l39SjkPzV4y.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/jNULnzQf29BxgHP.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/lHerkjFw8hKLfJD.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/O9P2JCvAeByUmKj.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/b8odh1OEkGt3wZX.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/iLHvQzCr4nsbJDk.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/07/nPpvQtHSJVwU2Tk.png">
<meta property="article:published_time" content="2023-12-31T04:18:00.000Z">
<meta property="article:modified_time" content="2024-01-09T09:36:21.478Z">
<meta property="article:author" content="epochxi">
<meta property="article:tag" content="计算机图形学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2023/12/30/hKX8oDS7I3m4tEN.jpg">
  
  <title>计算机图形学 - 期末复习 &lt; 风倾客栈 ✧</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/tomorrow-night-bright.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hovor","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":false,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"fa7203cd147458a2bb6b7c7fc7bd03a3","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <!--菜单栏-->
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <i class="iconfont icon-home-fill"></i> <!-- homeͼ�� -->
      <strong>风倾客栈</strong> <!-- �������� -->
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content --> <!-- �˵��б� -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                朋友
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>
 
    <!--视差滚动-->
    <div class="banner" id="banner" parallax=true   
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <!--副标题 (打字机)-->
            <span class="h2" id="subtitle" title="计算机图形学 - 期末复习">
              <!--typing打字机-->
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-12-31 12:18" pubdate>
        2023年12月31日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      35k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机图形学 - 期末复习</h1>
            
            <div class="markdown-body">
              <h2 id="计算机图形学理论课复习大纲">计算机图形学理论课复习大纲</h2>
<p>考试题型：简答题，计算题，绘图题，分析与设计题，程序实现题。</p>
<p>分数分别为：20分，30分，10分，30分，10分。</p>
<h3 id="一-图形学基本概念">一、 图形学基本概念</h3>
<ol type="1">
<li>什么是计算机图形学？</li>
<li>计算机图形学的主要研究内容包括哪些？</li>
<li>计算机图形学的主要应用领域。</li>
<li>图形和图像的主要区别是什么？</li>
<li>计算机图形处理系统的主要构成。</li>
<li>显卡的工作流程。</li>
<li>什么是显示存储器？</li>
<li>GPU的基本概念。</li>
<li>显卡分辨率的含义。</li>
<li>GPU堆包含哪几种主要的类型，具有什么样的特点？</li>
<li>GPU渲染流水线包含哪几个阶段，分别完成什么任务？</li>
<li>光照的基本原理</li>
<li>光照模型的分类</li>
<li>光源的分类</li>
<li>纹理的表现形式。</li>
<li>纹理的过滤方式及寻址方式</li>
<li>多级纹理的基本原理</li>
<li>模型的表示方法</li>
<li>Direct3D 12图形绘制的基本原理</li>
<li>三维模型顶点的数据结构表示</li>
</ol>
<h3 id="二-图形学基本算法">二、 图形学基本算法</h3>
<p>要求：算法的基本原理，算法描述，算法执行过程分析，过程计算，编程实现等。</p>
<ol type="1">
<li>直线生成算法：DDA算法，中点画线法、Bresenham法。</li>
<li>圆和圆弧的生成算法：DDA算法，中点画线法，Bresenham法</li>
<li>线宽生成算法：刷子绘制法，实区域填充法</li>
<li>线型的处理</li>
<li>区域填充法：扫描线法，边填充法，种子填充法，扫描线种子填充法，</li>
<li>反走样技术：像素细分技术，Bresenham反走样技术</li>
<li>曲线生成：Bezier曲线和B样条曲线，包括二阶、三阶曲线等。</li>
<li>图形变化：平移、缩放、旋转</li>
<li>坐标系之间的变换：局部坐标、世界坐标、摄像机坐标、屏幕坐标</li>
<li>四边形裁剪算法：Cohen-Sutherland裁剪算法、中点分割裁剪算法、Liang-Barskey裁剪算法</li>
<li>多边形裁剪算法：Sutherland-Hodgman算法，Weiler-Atherton算法</li>
<li>三维线段裁剪算法：长方体裁剪算法，视椎体裁剪算法</li>
<li>图形消隐：背面剔除算法，画家算法，Weiler-Atherton算法，BSP树算法、深度缓冲区算法，Warnock算法</li>
<li>曲面的生成：Bezier曲面的生成，B样条曲面的生成，特别是二阶和三阶曲面</li>
<li>地形的生成算法</li>
<li>雨雪的模拟算法</li>
</ol>
<h2 id="第1章-绪论">第1章 绪论</h2>
<h3 id="什么是计算机图形学">什么是计算机图形学？</h3>
<p>计算机图形学是研究通过计算机将<strong>数据</strong>转化为<strong>图形</strong>，并在专门显示设备上显示的<strong>原理、方法和技术</strong>的学科。也就是如何<strong>用计算机生成、处理和显示图形</strong>的一门学科。</p>
<p>计算机图形学是研究怎样利用计算机来<strong>生成、处理和显示</strong>图形的<strong>原理、方法和技术</strong>的学科。</p>
<h3 id="计算机图形学的应用">计算机图形学的应用</h3>
<ol type="1">
<li>图形用户接口 (2) 工业应用 (3) 商业领域 (4) 艺术领域 (5)
科学计算可视化 (6) 虚拟现实 (7) 系统环境模拟</li>
</ol>
<h3 id="图形和图像的区别">图形和图像的区别</h3>
<ul>
<li><strong>表示方法</strong>不同：图形是由基本几何体（直线，点，圆、曲线、三角形等）构成的实体，同时具有几何属性和视觉属性。图像是由很多像素点构成的点阵信息。</li>
<li><strong>生成</strong>方法不同：图形是通过计算机算法生成的，而图像是通过照相机，摄像机等扫描设备或图像生成软件制作而成。</li>
<li><strong>研究侧重点</strong>不同：图形学主要研究如何使用计算机表示几何体，构建几何模型、如何通过建立数学模型或者算法把真实的或者想象的物体显示出来。图像处理主要研究如何将一种图像处理成另一种图像，包括图像增强、复原、解析和理解、编码、压缩、匹配，识别等。</li>
</ul>
<h2 id="第2章-计算机图像处理及显示的基本原理">第2章
计算机图像处理及显示的基本原理</h2>
<h3 id="显卡工作流程">显卡工作流程</h3>
<ol type="1">
<li>通过<strong>数据总线</strong>将要显示的图形或者图像数据送入GPU（图形处理器)。</li>
<li>GPU对送入的数据进行<strong>处理</strong>然后送入<strong>帧缓冲器</strong>（或称显存)
。</li>
<li>送入<strong>帧缓冲器</strong>中的数据将被送入<strong>视频控制器</strong>。视频控制器将根据接口的类型确定处理方式，完成<strong>数模转换</strong>；</li>
<li>视频控制器的输出将送到<strong>显示屏</strong>。</li>
</ol>
<h3 id="概念">概念</h3>
<ul>
<li><p><strong>帧缓存/显存：</strong>显存用来<strong>存储屏幕上像素的颜色值</strong>。帧缓冲器中的单元数目与显示器上的像素数目相同，单元与像素一一对应，各单元的数值决定了其对应的像素的颜色。（比如一个像素24位）</p></li>
<li><p><strong>显卡分辨率：</strong>显卡分辨率是指显卡输出给显示器并能在显示器上描绘的像素点的数量。</p></li>
<li><p><strong>显卡颜色深度：</strong>每个像素包含三种颜色：R，G，B。像素的精细度由组成像素的颜色的位数和照射到像素的颜色的强度决定。显示透明度，往往还增加8bits来表示透明度。</p></li>
<li><p>规定以左手定则根据顶点的排列顺序来确定三角面的朝向。</p></li>
</ul>
<h3
id="gpu处理输入的图形数据渲染流水线">GPU处理输入的图形数据（渲染流水线）</h3>
<ol type="1">
<li>输入装配阶段。从内存中读入相关的顶点和索引，从而生成几何图形的基本要素（点，线以及三角面）。</li>
<li>顶点着色阶段。完成顶点转换（从局部坐标系转换到齐次裁剪坐标系中），光照（纹理）等各种形式的运算。</li>
<li>曲面细分阶段。将一个大的三角形分解成若干个小的三角形。</li>
<li>几何着色阶段。对输入的点进行筛选，然后输出相应的构成几何图形的基本要素。同时几何着色可以输出一系列的点到内存空间中。</li>
<li>裁剪。将区域之外的物体去除掉，只显示区域之内的物体。</li>
<li>光栅化阶段。将几何图元变为二维图像。第一部分工作：<strong>决定窗口坐标中的哪些整型栅格区域被基本图元占用</strong>；第二部分工作：分配一个颜色值和一个深度值到各个区域以便进行消隐操作。<strong>目的，是找出一个几何单元（比如线段或三角形）所覆盖的像素</strong>。</li>
<li>像素着色阶段。通过这些点及相应的属性可以在GPU中计算除相应像素的颜色，光照的影响，阴影等处理效果。</li>
<li>输出融合阶段。一些像素无法通过深度测试而被排除，而另一些像素送入，与此前已经写入到后台缓冲区中的像素进行相应的融合处理。</li>
</ol>
<h2 id="第3章-基本图形生成">第3章 基本图形生成 ★</h2>
<h3 id="画线算法">画线算法</h3>
<h4 id="数值微分画线法dda">数值微分画线法（DDA）</h4>
<ul>
<li>输入<span class="math inline">\(P_0(x_0,y_0),
P_1(x_1,y_1)\)</span></li>
<li>计算增量 $ x=,y= \ ((y_1-y_0),(x_1-x_0))$</li>
<li>循环<span class="math inline">\(Length\)</span>次，<span
class="math inline">\(x_{i+1} = x_i+\Delta x, y_{i+1} = y_i+\Delta
y\)</span>，每步结果对不是整数那个四舍五入</li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/12/30/hKX8oDS7I3m4tEN.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="中点画线法">中点画线法</h4>
<p>原理：<span class="math inline">\(d = 2F(x_k+1,y_k+0.5) =
2a(x_k+1)+2b(y_k+0.5) + c, d_0 = 2a+b\)</span></p>
<ul>
<li><p>输入<span class="math inline">\(P_0(x_0,y_0),
P_1(x_1,y_1)\)</span></p></li>
<li><p><span class="math inline">\(a=y_0-y_1,
b=x_1-x_0\)</span></p></li>
<li><p><span class="math inline">\(d = 2a+b\)</span>， <span
class="math inline">\(delta1 = 2a , delta2 = 2(a+b)\)</span></p></li>
<li><p>当<span class="math inline">\(d\ge 0\)</span>，取下点 y不变 <span
class="math inline">\(y_{i+1} = y_i\)</span>, <span
class="math inline">\(d+=delta1\)</span>；(<code>x++</code>一直自增)</p>
<p>当<span class="math inline">\(d&lt;0\)</span>，取上点 y加一 <span
class="math inline">\(y_{i+1} = y_i+1\)</span>, <span
class="math inline">\(d+=delta2\)</span>.</p></li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/12/30/76vOlwcSKkImxGq.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="bresenham-画线算法">Bresenham 画线算法</h4>
<ul>
<li><p>输入<span class="math inline">\(P_0(x_0,y_0),
P_1(x_1,y_1)\)</span></p></li>
<li><p><span class="math inline">\(e=2\Delta y-\Delta
x\)</span></p></li>
<li><p>当<span class="math inline">\(e\ge 0\)</span>，取上点 <span
class="math inline">\(y_{i+1} = y_i+1\)</span>, <span
class="math inline">\(e&#39;=e+2\Delta y - 2\Delta x\)</span>；</p>
<p>当<span class="math inline">\(e&lt;0\)</span>，取下点 <span
class="math inline">\(y_{i+1} = y_i\)</span>, <span
class="math inline">\(e&#39;=e+2\Delta y\)</span>.</p></li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/12/30/JmBR6XfWMtEOC1F.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2023/12/30/9oOc6aq1bNjHnhL.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="圆形算法">圆形算法</h3>
<h4 id="中点画圆算法">中点画圆算法</h4>
<p>基本算法思想就是利用下一个点的绘制要么是右方的点，要么是右下侧的点。</p>
<ul>
<li><p>初始值 <span class="math inline">\(x=0,y=R\)</span>,<span
class="math inline">\(d=1-R\)</span></p></li>
<li><p><span class="math inline">\(d&lt;0\)</span>，y不变，<span
class="math inline">\(d=d+2x+3\)</span></p>
<p><span class="math inline">\(d\ge0\)</span>，y减一，<span
class="math inline">\(d= d+2x_n-2y_n+5\)</span></p></li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/12/30/MqsiKHj7dQc6nWr.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="bresenham画圆算法">Bresenham画圆算法</h4>
<p>利用下一个点的绘制要么是右方的点，要么是右下侧的点，要么是下方的点
不断判定三个距离哪个最短则选择哪个。</p>
<ul>
<li>初始化 x=0, y=R, d=2(1-R)</li>
<li>d&lt;0, 2(d+y)-1&lt;=0: x=x+1, d=d+2x+3</li>
<li>d&lt;0, 2(d+y)-1&gt;0: x=x+1, y=y-1, d=d+2(x-y+3)</li>
<li>d=0: x=x+1, y=y-1, d=d+2(x-y+3)</li>
<li>d&gt;0, 2(d-x)-1&lt;=0: x=x+1, y=y-1, d=d+2(x-y+3)</li>
<li>d&gt;0, 2(d-x)-1&gt;0: y=y-1, d=d-2y+3</li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/12/30/DIuh4QR5KZMarbU.jpg" srcset="/img/loading.gif" lazyload
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="线宽和线型的处理">线宽和线型的处理</h3>
<ul>
<li>线宽处理：刷子绘制法，方形刷子绘制法，实区域填充法产生线宽</li>
<li>线型处理：看成一个由布尔值对应的像素。每种线型对应一定的长度的像素，每个像素对应相应的布尔值。如果该像素对应的布尔值为1，则绘制该像素。如果对应的布尔值为0，则不绘制该像素。</li>
</ul>
<h3 id="区域填充">区域填充</h3>
<ul>
<li><p>检查某个像素是否在某个多边形区域内</p>
<ul>
<li>转角法：计算点与多边形各个顶点的连线所构成的夹角之和（带方向），为0标明是在区域外；如果为360°标明在区域内。</li>
<li>射线法：水平（右）或者垂直（下）方向做<strong>射线</strong>。判断该射线与多边形交点的个数。交点数为偶数在图形外；交点数奇数在图形内。</li>
</ul></li>
<li><p>扫描线法：</p>
<ul>
<li>求交、排序、两两配对、线段着色</li>
<li>注意<strong>顶点求交点</strong>规则：把所有极值顶点当成两个点</li>
<li>（活性边表法好像不考？）边表的结构为 <span
class="math inline">\([x,y_{max},\frac1k]\)</span>。 $x:
$当前扫描线与活性边的交点， $y_{max}: <span
class="math inline">\(活性边较高端点的\)</span>y$ 坐标值， $1k:
$活性边所在直线斜率的倒数。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2024/01/06/15EK8hUg9einsdC.png" srcset="/img/loading.gif" lazyload
alt="image-20240106225101692" />
<figcaption aria-hidden="true">image-20240106225101692</figcaption>
</figure></li>
<li><p>边填充法：该多边形每一条边右边区域像素的颜色全部取补</p></li>
<li><p>栅栏填充法：该多边形每一条边与栅栏之间像素的颜色全部取补</p></li>
<li><p>种子填充法：四连通/八联通，从某个像素点开始BFS/DFS整某个像素点开始个区域（缺点：堆栈大量使用）</p></li>
<li><p><strong>扫描线种子</strong>填充法：</p>
<ul>
<li>栈顶像素出栈。</li>
<li>沿扫描线对出栈像素的左右像素进行填充，直到遇到边界像素xl和xr为止</li>
<li>在区间[xl,xr]中检查与当前扫描线相邻的上下两条扫描线，则把<strong>每个</strong>
<em>非边界、未填充</em> 的
<strong>像素区间</strong>的<strong>最右</strong>像素取为种子像素入栈。</li>
</ul></li>
</ul>
<h3 id="图形反走样技术">图形反走样技术</h3>
<p>问题：阶梯状边界；图形细节失真；狭小图形遗失：动画序列中时隐时现，产生闪烁。本质是用<strong>离散</strong>的像素去表示<strong>连续图形</strong>，从而引起失真。</p>
<p>Bresenham区域反走样技术：将多边形每条边与具有一定面积的像素相交的面积大小分为8个等级。相交面积
0-1/8 1/8-2/8……</p>
<p><span class="math inline">\(S=(y_{i+1}+ y_i)/2=(y_i+ y_i+m)/2=
y_i+m/2=e+m/2\)</span></p>
<p>### 曲线生成</p>
<p>要求：</p>
<ul>
<li>唯一性</li>
<li>几何不变性：用<strong>相同的方法</strong>去拟合平面空间中<strong>不同坐标</strong>系下<strong>相同</strong>的几个点，得到的<strong>拟合曲线不变</strong>。直角坐标系不具备几何不变性。</li>
<li>易于定界：矢量坐标系中<span
class="math inline">\(p(t)=[x(t),y(t),z(t)]\)</span>，由于每一个变量都用统一的t标量来描述，非常容易确定其边界。</li>
<li>统一性:可以在不增加其他参数的情况下进行维数的扩充。P(t) = [x(t)
y(t)] =&gt; P(t) = [x(t) y(t) z(t)]</li>
</ul>
<h4 id="参数样条曲线">参数样条曲线</h4>
<ul>
<li>零阶几何连续性：<span
class="math inline">\(G^0\)</span>连续性，首尾相接</li>
<li>一阶几何连续性：<span
class="math inline">\(G^1\)</span>连续性，首尾相接，且切矢量方向连续（一阶导数成比例）</li>
<li>一阶几何连续性：<span
class="math inline">\(G^2\)</span>连续性，首尾相接，一二阶导数成比例，曲率连续。</li>
</ul>
<figure>
<img
src="/C:/Users/39366/AppData/Roaming/Typora/typora-user-images/image-20231230120756856.png" srcset="/img/loading.gif" lazyload
alt="image-20231230120756856" />
<figcaption aria-hidden="true">image-20231230120756856</figcaption>
</figure>
<p>参数样条曲线数学表示：</p>
<p><span class="math display">\[
P(t)=\begin{bmatrix}x(t)\\y(t)\\z(t)\end{bmatrix}=\begin{bmatrix}x_0&amp;x_1&amp;\cdots&amp;x_n\\y_0&amp;y_1&amp;\cdots&amp;y_n\\z_0&amp;z_1&amp;\cdots&amp;z_n\end{bmatrix}\begin{bmatrix}1
\\ \vdots\\t^n\end{bmatrix}=C\cdot T\quad t\in[0,1]
\]</span></p>
<p>Hermite插值样条：已知每个型值点的位置矢量及其切矢量，然后绘制出的样条曲线。</p>
<h4 id="bezier曲线的生成">Bezier曲线的生成</h4>
<p>Bezier曲线通过控制点来控制曲线的形状。把相邻的点连接起来形成一个特征多边形，并将其作为曲线的轮廓线，然后在每个特征多边形顶点配以伯恩斯坦（Bernstein)多项式作为权函数，对特征多边形的各顶点进行加权求和。
<span class="math display">\[
\begin{aligned}&amp;P(t)=\sum_{i=0}^nP_i\cdot BEZ_{i,n}(t)\quad
t\in[0,1]\\\\&amp;BEZ_{i,n}(t)=C_n^it^i(1-t)^{n-i},\quad
t\in[0,1]\end{aligned}
\]</span> <strong>De
Casteljau算法</strong>：<strong>递归</strong>法绘制点</p>
<ol type="1">
<li><p>用直线连接所有相邻的n个控制点，得到其特征多边形。</p></li>
<li><p>如果t∈[0,1]，则在特征多边形的每一条边上按照t:(1-t)的比例寻找一组新的点，构成新的多边形，该多边形的边比前面的多边形少一条边。</p></li>
<li><p>在新的多边形上，重复（2）的操作得到一组新的多边形。在n次这种操作之后，将得到一个点，该点即为曲线上的点。</p></li>
</ol>
<p><img src="https://s2.loli.net/2023/12/30/8cinNKfIslyD6ek.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:33%;" /></p>
<h4 id="b样条曲线的生成">B样条曲线的生成</h4>
<p>B样条曲线由n+m+1个控制点构成，其中<span class="math inline">\(P_0~
P_n\)</span>这个n+1个控制点控制其第一段曲线， <span
class="math inline">\(P_1~
P_{n+1}\)</span>这个n+1个控制点控制其第二段曲线,…,依次类推，总共m+1段曲线构成B样条曲线。
<span class="math display">\[
P(t)=\sum_{i=0}^nP_i\cdot B_{i,n}(t) t\in[0,1] \\
B_{i,n}(t){=}\color{red}\frac1{n!}\sum_{j=0}^{n-i}(-1)^jC_{n+1}^j(t+n-k-j)^n
\]</span></p>
<p>其第i段曲线可表示为：<span
class="math inline">\(\begin{aligned}\mathsf{P}_{i,n}(t)&amp;=\sum_{\mathrm{k=0}}^nP_{i+\mathrm{k}}\cdot
B_{k,n}(t)&amp;&amp;t\in[0,1]\end{aligned}\)</span></p>
<p><img src="https://s2.loli.net/2023/12/30/3FjEzHkNd2laMPO.png" srcset="/img/loading.gif" lazyload alt="image-20231230132401533" style="zoom:33%;" /></p>
<h2 id="第4章-图形变换与裁剪">第4章 图形变换与裁剪 ★</h2>
<h3 id="图形矩阵变换">图形矩阵变换</h3>
注：课程默认使用行向量表达，复合变换矩阵要写在行向量的右侧（从左向右结合）
$$ T_{3D}=
<span
class="math display">\[\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\b_x&amp;b_y&amp;b_z&amp;1\end{bmatrix}\]</span>
S_{3D}=
<span
class="math display">\[\begin{bmatrix}s_x&amp;0&amp;0&amp;0\\0&amp;s_y&amp;0&amp;0\\0&amp;0&amp;s_z&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\]</span>
<p>\</p>
<p><em>{}=</em>{}=_{}=$$
<img src="https://s2.loli.net/2023/12/30/I8RODVgrYcBblxZ.png" srcset="/img/loading.gif" lazyload alt="image-20231230135219739" style="zoom: 33%;" /></p>
<h4 id="平行投影">平行投影</h4>
<p><img src="https://s2.loli.net/2024/01/06/qrZhaFLtpNoWxRm.png" srcset="/img/loading.gif" lazyload alt="image-20240106213205808" style="zoom:15%;" /></p>
<p>投影平面为<strong>xOz面</strong></p>
<p><strong>主视图</strong>：y拍扁 <span class="math display">\[
T_\nu=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}
\]</span>
<strong>俯视图</strong>：z拍扁，绕X轴顺时针旋转90度，然后沿Z方向平移一段距离。
<span class="math display">\[
T_h=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;\cos(-90^\circ)&amp;\sin(-90^\circ)&amp;0\\0&amp;-\sin(-90^\circ)&amp;\cos(-90^\circ)&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;-z_p&amp;1\end{bmatrix}
\]</span>
<strong>侧视图</strong>：x拍扁，绕Z轴逆时针旋转90度到xOz面，然后在X轴方向上移动一定距离。<br />
<span class="math display">\[
T_W=\begin{bmatrix}0&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}\cos90^\circ&amp;\sin90^\circ&amp;0&amp;0\\-\sin90^\circ&amp;\cos90^\circ&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\-x_L&amp;0&amp;0&amp;1\end{bmatrix}
\]</span></p>
<p><strong>正轴测投影</strong>：将物体绕Z轴逆时针旋转某个角度（比如β角）,然后再绕X轴顺时针旋转α角，然后再向xOz面做正平行投影。
<span class="math display">\[
R_{zx}=R_zR_x=\begin{bmatrix}\cos \beta &amp; \sin \beta &amp; 0 &amp; 0
\\
-\sin \beta &amp; \cos \beta &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}
\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;\cos\alpha&amp;\sin\alpha&amp;0\\0&amp;-\sin\alpha&amp;\cos\alpha&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}
\]</span></p>
<h4 id="透视投影">透视投影</h4>
<ol type="1">
<li>一点透视：也称为平行透视。即投影平面与投影对象所在坐标系的一个坐标平面平行。</li>
<li>两点透视：也称为成角透视。即投影平面与投影对象所在坐标系的一个坐标轴平行，而与另两个坐标轴成一定角度。</li>
<li>三点透视：也称为斜透视。即投影平面与投影对象所在的坐标系的坐标轴均不平行。</li>
</ol>
<figure>
<img src="https://s2.loli.net/2023/12/30/k1uw9eFMSd5OGv6.png" srcset="/img/loading.gif" lazyload
alt="image-20231230135755972" />
<figcaption aria-hidden="true">image-20231230135755972</figcaption>
</figure>
<p>灭点：不平行于投影平面的平行线（如平行于 z
轴的平行线）的投影的汇聚点，这个点称为灭点。（一定落在同一个面上）</p>
<p>主灭点：平行于三维坐标系坐标轴的平行线在投影平面上形成的灭点。</p>
<p><span
class="math inline">\([x^{\prime},y^{\prime},z^{\prime},1]=[0,0,1/r,1]\)</span>
其对应的投景约矩阵为：</p>
<p><span class="math display">\[
\left[\begin{array}{llll}
x^{\prime} &amp; y^{\prime} &amp; z^{\prime} &amp; H
\end{array}\right]=\left[\begin{array}{llll}
x &amp; y &amp; z &amp; 1
\end{array}\right]\left[\begin{array}{llll}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; q \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]=\left[\begin{array}{llll}
x &amp; y &amp; z &amp; q y+1
\end{array}\right]
\]</span> 如果灭点在X轴<span
class="math inline">\([1/p,0,0,1]\)</span>和Y轴<span
class="math inline">\([0,1/q,0,1]\)</span>上，则对应的投影矩阵分别为:
<span class="math display">\[
P_{x}=\left[\begin{array}{llll}
1 &amp; 0 &amp; 0 &amp; p \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right], P_{y}=\left[\begin{array}{llll}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; q \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]
\]</span></p>
<h3 id="图形裁剪">图形裁剪</h3>
<h4
id="cohen-sutherland裁剪算法编码裁剪算法">Cohen-Sutherland裁剪算法（编码裁剪算法）</h4>
<ol type="1">
<li>对线段端点编码，定义为它所在区域的编码;</li>
<li>快速判断“完全可见”，若两端点编码均为0，则完全可见。<strong>RC0=0且RC1=0</strong></li>
<li>快速判断“完全不可见”，线段两端点编码的逻辑位“与”运算结果非零，则完全不可见。<strong>RC0&amp;RC1≠0</strong>说明直线段位于窗外的同一侧</li>
<li>若2)、3)不满足，逐个端点判断其编码 CtCbCrCl(C3C2C1C0)
中位是否为“1”，若是，则需求交，交点的x坐标进行排序，从而将原始线段分割成最多五段线段（四个交点）。然后根据（1）（2）步判断这些线段是否在区域内。</li>
</ol>
<p><img src="https://s2.loli.net/2024/01/06/6DyukMBLPHzItlT.png" srcset="/img/loading.gif" lazyload alt="image-20240106215840646" style="zoom:33%;" /></p>
<h4 id="中点分割裁剪算法">中点分割裁剪算法</h4>
<p>中点分割法的思想是通过不断求线段的中点，并<strong>采用Cohen-Sutherland算法可见性判断</strong>，然后确定可见区域内的线段。</p>
<ul>
<li>固定 P1，测试 P2是否在窗口内，若是，则 P2 是离 P1
点最远的可见点。否则，将线段 P1P2 对分，求出中点 Pm，编码判断线段 PmP2
是否全部在窗口外，若是，则舍弃PmP2，用 P1Pm代替
P1P2；若不是，则用PmP2代替P1P2。</li>
</ul>
<p>本质就是固定一个端点求，用二分法求这个端点的最远的可见点。</p>
<h4
id="liang梁友栋-barsky裁剪算法">Liang（<strong>梁友栋）</strong>-Barsky裁剪算法</h4>
<p>无论何种情况下，在裁剪区域之内的线段均为：AB ∩ RS ∩ TU</p>
<p><img src="https://s2.loli.net/2023/12/30/SE49AZKfWMmcTRj.png" srcset="/img/loading.gif" lazyload alt="image-20231230144247813" style="zoom:33%;" /></p>
<p>记<span class="math inline">\(L=\max \left[x_{\min }, \min
\left(x_{A}, x_{B}\right)\right], R=\min \left[x_{\max }, \max
\left(x_{A},
x_{B}\right)\right]\)</span>，不等式若有不成立，则不存在可见线段，不等式为：
<span class="math display">\[
\left\{\begin{array}{l}
L \leqslant R \\
L \leqslant \max \left(x_{T}, x_{U}\right) \\
\min \left(x_{T}, x_{U}\right) \leqslant R
\end{array}\right.;
\quad
\text{斜率&gt;0时}
\left\{\begin{array}{l}
L \leqslant R \\
L \leqslant x_{U} \\
x_{T} \leqslant R
\end{array}\right.;
\quad
\text{斜率&lt;0时}
\left\{\begin{array}{l}
L \leqslant R \\
L \leqslant x_{T} \\
x_{U} \leqslant R
\end{array}\right.
\]</span> A B 斜率大于 0 时，可见线段的端点坐标：<span
class="math inline">\(\begin{array}{l} x_{\alpha}=\max \left(L,
x_{T}\right) \\ x_{\beta}=\min \left(R, x_{U}\right)
\end{array}\)</span></p>
<p>A B 斜率小于 0 时，可见线段的端点坐标：<span
class="math inline">\(\begin{array}{l} x_{\alpha}=\max \left(L,
x_{U}\right) \\ x_{\beta}=\min \left(R, x_{T}\right)
\end{array}\)</span></p>
<h3 id="多边形裁剪">多边形裁剪</h3>
<h4 id="sutherland-hodgman算法">Sutherland-Hodgman算法</h4>
<p>基本思想：用裁剪窗口的每一条边去裁剪某个多边形</p>
<ol type="1">
<li>边 <span class="math inline">\(P_i P_{i+1}\)</span>
可见一侧，输出<span class="math inline">\(P_{i+1}\)</span>。<br />
</li>
<li>边<span class="math inline">\(P_i
P_{i+1}\)</span>不可见一侧，此时没有新的顶点输出。</li>
<li>边<span class="math inline">\(P_i
P_{i+1}\)</span>离开窗口，输出交点。</li>
<li>边<span class="math inline">\(P_i
P_{i+1}\)</span>进入窗口，该交点和顶点<span
class="math inline">\(P_{i+1}\)</span>都输出。</li>
</ol>
<p>问题：裁剪<strong>凹多边形</strong>可能会出现多余的边</p>
<h4 id="weiler-atherton算法">Weiler-Atherton算法</h4>
<p>可适用于任意类型的多边形，包括有空洞的。将裁剪多边形称为CP，被裁剪多边形称为SP。</p>
<ol type="1">
<li>算法首先将CP和SP的顶点按照<strong>外部边界取顺时针</strong>，内部边界取逆时针的的方式将其构成环形链表。</li>
<li>求出SP与CP边线的所有交点，并将这些交点插入到SP和CP的环形链表中，并<strong>标明</strong>交点是出点还是进点。</li>
<li>算法从任意一个<strong>进点开始</strong>沿着SP的边线按照边线所标示的方向搜集顶点序列，当遇到<strong>出点</strong>时，则<strong>沿着CP的边线</strong>所标示的方向搜集顶点序列，当遇到<strong>进点</strong>时，则<strong>沿着SP的边线</strong>所标示的方向搜集顶点序列。</li>
</ol>
<p>搜索所有点。</p>
<h3 id="图形消隐">图形消隐</h3>
<h4 id="背面剔除算法">背面剔除算法</h4>
<p>在取景变换（将物体从世界坐标系转换到摄像机坐标系）之前，将那些背离视点方向而不可见的景物表面剔除。</p>
<ol type="1">
<li>计算多边形的法向向量N和视线向量V。</li>
<li>计算法向向量N和视线向量V的夹角θ的余弦Cosθ=N.V。</li>
<li>cosθ＜0，即θ＞90°， 则该多边形表面为背面，是不可见的</li>
</ol>
<h4 id="画家算法">画家算法</h4>
<p>将多边形按照离视点的远近进行排序（P221
判断遮挡，分割），然后先画出被遮挡的多边形，再画出不被遮挡的多边形，用后画的多边形覆盖先画的多边形，从而达到自动消隐的目的。</p>
<h4 id="weiler-atherton算法-1">Weiler-Atherton算法</h4>
<p>算法思想：采用裁剪算法的思想对隐藏面进行消隐。</p>
<p>算法步骤如下：</p>
<ol type="1">
<li>先进行初步的深度预排序，即将变换到屏幕坐标系中的景物表面多边形按各顶点的
z 最小值进行排序，形成景物多边形表。</li>
<li>以当前具有最大 z 值（即离视点最近）的景物表面作为裁剪多边形 CP
。</li>
<li>用CP对景物多边形表中排在后面的景物表面进行裁剪，产生内部多边形 Pin
和外部多边形 Pout 。</li>
<li>由于多边形顶点离视点最近的多边形表面不一定是真正排在最前面的可见面，因此，需比较CP与内部多边形
Pin 的深度，检查 CP是否是真正离视点较近的多边形。
如果是，则CP为可见表面，而位于裁剪多边形 CP之内的多边形 Pin
为当前视点的隐藏面，可以消去该隐藏面；如果不是，则选择 Pin
为新的裁剪多边形，重复步骤 3。</li>
<li>将位于裁剪多边形之外的景物表面 Pout
组成外裁剪结果多边形表，取表中深度最大即排在最前面的表面为裁剪多边形，重复步骤
3，继续对表中其他景物表面进行裁剪。</li>
<li>上述过程递归进行，直到外裁剪结果多边形表为空时为止</li>
</ol>
<h4 id="bsp树算法">BSP树算法</h4>
<p>算法思想：平面分割二叉树</p>
<p>先在场景中选取一剖分平面
P1（与视点垂直的平面），将场景空间分割成两个半空间。它相应地把场景中的景物分成两组，相对于视点而言，一组景物多边形位于P1的前面，作为BSP树的左孩子（front)，另一组景物多边形位于P1的后面,作为BSP树的右孩子（Back)，如果有物体与
P1相交，就将它分割为两个物体分别标识为A和B，再用平面 P2
对所生成的两个子空间继续进行分割，并对每一子空间所含景物进行分类。上述空间剖分和景物分类过程递归进行，直至每一子空间中所含景物少于给定的阈值为止。</p>
<p>优先绘制标识为“back”的子空间中所含的景物，这样可使得前面的物体覆盖后面的物体，从而实现物体的消隐。</p>
<h4 id="深度缓冲区算法">深度缓冲区算法</h4>
<p>目前大多数的硬件实现方法</p>
<p>算法思想：对投影到显示屏上的每一个像素所对应的多边形表面的深度进行比较，然后取最近表面的属性值作为该像素的属性值。<strong>Z缓冲器（Z-buffer，深度缓冲区）</strong>，深度缓冲器只是帧缓冲器的扩充。</p>
<ol type="1">
<li>将场景中的所有多边形通过取景变换、透视变换变换到屏幕坐标系中，物体的深度比较可通过它们z值的比较来实现。</li>
<li>初始化深度缓冲存储器和帧缓冲器。深度缓冲器应初始化为离视点最远的最大z值，帧缓冲器应初始化为背景的属性值。</li>
<li>扫描待显示的每一个多边形，比较当前多边形所覆盖的每一个像素点的深度值，如果其深度值比深度缓冲区中当前像素的深度值小，则取代原来的深度值，并将对应像素的属性值保存到帧缓冲区对应的位置中。反之，则不做任何处理。循环该步骤，直到处理完所有的多边形。</li>
</ol>
<h4 id="warnock算法">Warnock算法</h4>
<p>该算法将整个观察范围细分成越来越小的矩形单元，直至每个单元仅包含单个可见面片的投影或不包含任何面片。</p>
<p>单纯窗口：景物已经足够简单，比如没有任何可见物体，或者窗口已被一个可见面片完全充满</p>
<p>算法思想：将非单纯的窗口四等分为4个子窗口（四叉树），对每个子窗口再进一步判别是否是单纯的，直到窗口单纯或窗口边长已缩减至一个像素点为止。</p>
<ol type="1">
<li>对每个窗口进行判断，若画面中所有多边形均与此窗口分离，即此窗口为空，则按背景光强或颜色直接显示而无需继续分割。</li>
<li>若窗口中仅包含一个多边形，则窗口内多边形外的区域按背景光强或颜色填充，多边形内按多边形相应的光强或颜色填充。</li>
<li>若窗口与一个多边形相交，则窗口内多边形外的区域按背景光强或颜色填充，相交多边形内位于窗口内的部分按多边形相应的光强或颜色填充。</li>
<li>若窗口被一个多边形包围且窗口内无其他的多边形，则窗口按此包围多边形相应的光强或颜色填充。</li>
<li>若窗口至少被一个多边形包围且此多边形距离视点最近，则窗口按此离视点最近的包围多边形的相应光强或颜色填充。</li>
<li>若以上条件都不满足，则继续细分窗口，并重复以上测试。</li>
</ol>
<p>四元素，看不懂…</p>
<h2 id="第5章-模型生成方法">第5章 模型生成方法</h2>
<h3 id="模型的表示方法">模型的表示方法</h3>
<p>三角面：顶点+索引</p>
<h3 id="参数多项式曲面">参数多项式曲面</h3>
<p><span class="math display">\[
\begin{cases}x=x(u,v)\\y=y(u,v)\\z=z(u,v)&amp;\end{cases}\quad(u,v)\in[0,1]\times[0,1]
\]</span></p>
<p><span class="math display">\[
P(u,v)=\sum_{i=0}^m\sum_{j=0}^na_{ij}u^i\nu^j=U^\mathrm{T}AV\quad(u,v)\in[0,1]\times[0,1]
\]</span></p>
<h4 id="bezier曲面">Bezier曲面</h4>
<p><span class="math display">\[
P(u,v)=\sum_{i=0}^m\sum_{j=0}^nP_{ij}BEZ_{i,m}(u)BEZ_{j,n}(v)\quad
u\in[0,1],v\in[0,1]\]</span> $$</p>
<h4 id="b-样条曲面">B 样条曲面</h4>
<p><span class="math display">\[
P(u,v)=\sum_{i=0}^m\sum_{j=0}^nP_{ij}B_{i,k}(u)B_{j,h}(\nu)\quad
u\in[0,1],\nu\in[0,1]
\]</span></p>
<figure>
<img src="https://s2.loli.net/2024/01/09/gVWfeZhpoMTq4Ja.png" srcset="/img/loading.gif" lazyload
alt="image-20240109100103615" />
<figcaption aria-hidden="true">image-20240109100103615</figcaption>
</figure>
<h3 id="d地形模拟">3D地形模拟</h3>
<h4 id="diamond-square算法">Diamond-Square算法</h4>
<ol type="1">
<li>给定一个四边形,四个顶点的坐标(包含高度)，定义一初始高度因子h和一缩放倍数b。</li>
<li>迭代，先求出四边形的中心点高度为顶点平均高度+h*r的随机数，再分别求出4个边的中点，高度为两端点高度的平均值+h*r</li>
<li>修正高度因子 h=h/b，用(2)的方法分别对这 4
个小正方形进行处理。直到达到所期望的山形细腻程度。</li>
</ol>
<h3 id="植物形态模拟">植物形态模拟</h3>
<h4 id="l系统的植物形态模拟">L系统的植物形态模拟</h4>
<ul>
<li>F：从当前位置向前走h的长度，同时画线</li>
<li>G：从当前位置向前走h的长度，但不画线</li>
<li>+：从当前方向向左转δ角度</li>
<li>−：从当前方向向右转δ角度</li>
<li>｜：原地转向180°</li>
</ul>
<p>定义一个产生式，通过产生式生成新的符号串。如果进行多次迭代，可生成更长的新的符号串，然后根据所产生的符号串来生成对应的树。</p>
<figure>
<img src="https://s2.loli.net/2023/12/31/NOakHouzQ9ECB8D.png" srcset="/img/loading.gif" lazyload
alt="image-20231231094949109" />
<figcaption aria-hidden="true">image-20231231094949109</figcaption>
</figure>
<h4 id="迭代函数算法iterated-function-systemifs">迭代函数算法（Iterated
Function System，IFS）</h4>
<p>IFS系统由一个压缩仿射变换集<span
class="math inline">\(X=\{w_1,w_2,…,w_N\}\)</span>和对应概率集<span
class="math inline">\(P=\{p_1,p_2,…,p_N\}\)</span>组成 <span
class="math display">\[
\begin{gathered}\sum_{j=1}^Np_j=1,p_j&gt;0,j=1,2,\cdots,N\\\boldsymbol{w}_j\begin{pmatrix}x\\y\end{pmatrix}=\begin{pmatrix}\boldsymbol{a}_j&amp;\boldsymbol{b}_j\\\boldsymbol{c}_j&amp;\boldsymbol{d}_j\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}+\begin{pmatrix}\boldsymbol{e}_j\\\boldsymbol{f}_j\end{pmatrix},\boldsymbol{j}=1,2,\cdots,N\end{gathered}
\]</span> 输入：初始点的坐标x,y; 输出：屏幕上显示的树</p>
<ol type="1">
<li>输入N或者设定N为某个固定值, 输入或设置迭代次数M。</li>
<li>随机生成N个W概率值，并保存到w[N]。</li>
<li>随机生成N个概率值，并保存到P[N]。</li>
<li>随机生成概率值p。</li>
<li>轮盘选择法。如果P&lt;P[0],则w= w[0]; 反之，如果P&lt;p[0]+P[1],则w=
w[0]+w[1];….</li>
<li>根据前面的公式更新x,y。</li>
<li>在屏幕上(x,y)的位置以一定的亮度或者颜色显示该像素。</li>
<li>循环执行步骤（4）~（7）M次。</li>
</ol>
<figure>
<img src="https://s2.loli.net/2023/12/31/sywN25MZjOcraDW.png" srcset="/img/loading.gif" lazyload
alt="image-20231231100959845" />
<figcaption aria-hidden="true">image-20231231100959845</figcaption>
</figure>
<h3
id="粒子系统雨雪现象模拟液态流体模拟">粒子系统：雨雪现象模拟、液态流体模拟</h3>
<ol type="1">
<li>生成一定数量的初始粒子，对其各个属性进行赋值。</li>
<li>更新粒子的运动参数，比如速度，加速度，位置，生命周期等。<br />
</li>
<li>针对每一个粒子，在粒子对应的位置上绘制位图，并进行位移的映射，背景融合等。</li>
<li>删除已经消亡的粒子，释放其占用的资源。</li>
</ol>
<p>在模拟时都是在每一帧对其属性进行更新。</p>
<ul>
<li>基于粒子系统的喷泉模拟</li>
<li>基于粒子系统的瀑布模拟</li>
</ul>
<h3 id="气态流体模拟">气态流体模拟</h3>
<p>细胞自动机：又称为元胞自动机（Cellular
Automata），是一种在空间和时间上都离散的演化动力系统。每个元胞之上都有若干种离散或者连续的状态，这些状态在每一个时间步都会按照相同的规则发生变化，于是形成了整个元胞自动机的演化过程。</p>
<p>例子：火焰的模拟，<span
class="math inline">\(s_{i,j}^t\)</span>局部温度<span
class="math inline">\(u_{i,j}^t\)</span>燃料供应……</p>
<h2 id="第6章-图形显示技术">第6章 图形显示技术</h2>
<h3 id="光照模型">光照模型</h3>
<ul>
<li>光照模型分类：几何光照模型（局部光照模型和整体光照模型）、物理光照模型</li>
<li>光源的分类：点光源、线光源、面光源、体光源</li>
</ul>
<h4 id="光照基本模型">光照基本模型</h4>
<p><strong>漫反射光</strong>(diffuse
Reflection)：当光线照射到物体表面，有一部分光线将进入物体内部，部分会被吸收，而另一部分会从内部向各个方向散射并返回表面，这就形成漫反射光。<span
class="math inline">\(\begin{aligned}c_d&amp;=\max(\texttt{L.n, 0})\cdot
B_L\otimes m_d\end{aligned}\)</span></p>
<p><strong>环境光照</strong>（Ambient
Light）：从其他物体发射过来的光线照射到物体所形成的间接光照。<span
class="math inline">\(c_a=A_L\otimes\boldsymbol{m}_d\mid\)</span></p>
<p><strong>镜面光照</strong>（Specular
reflection)：一部分光将被反射，另一部分光被折，被反射的部分称为镜面反射光，只有观察者在特定的角度才能看到。<span
class="math inline">\(\mathbf{c}_s=\max\left(\mathbf{L}\cdot\mathbf{n},0\right)\cdot\mathbf{B}_L\otimes\mathbf{R}_F(\alpha_h)\frac{m+8}8{\left(\mathbf{n}\cdot\mathbf{h}\right)}^m\)</span></p>
<p><strong>光照整体模型</strong>： <span class="math display">\[
\begin{aligned}
\text{LitColor}&amp; =\mathbf{c}_a+\mathbf{c}_d+\mathbf{c}_s  \\
&amp;=\mathbf{A}_L\otimes\mathbf{m}_d+\max\left(\mathbf{L}\cdot\mathbf{n},0\right)\cdot\mathbf{B}_L\otimes\left(\mathbf{m}_d+\mathbf{R}_F(\alpha_h)\frac{m+8}8{\left(\mathbf{n}\cdot\mathbf{h}\right)}^m\right)
\end{aligned}
\]</span></p>
<ul>
<li>L:光源的光向量 n: 表面法向 h: 光向量与观察向量之间的中间向量 $A_L:
$入射的环境光量。 <span
class="math inline">\(m_d:\)</span>根据表面漫反射率而反射的入射光量。
L.n: 光线与法向量之间夹角的余弦。 <span
class="math inline">\(a_h{:}\)</span> 中间向量h与光向量之间的夹角。
<span class="math inline">\(R_F(a_h):\)</span> 中间向量h
(由表面点指向观察点的单位向量) 所反射到观察者眼中的光量。 m:
控制表面的粗糙度。<span
class="math inline">\((\mathbf{n}\cdot\mathbf{h})^m\)</span>线h与宏观表面法向n之间夹角为<span
class="math inline">\(\Theta h\)</span>的所有为平面片段。 <span
class="math inline">\(\frac{m+8}{s}:\)</span>在镜面发射过程中，为模拟能量守恒所采用的归一化因子。</li>
</ul>
<p>环境光照</p>
<ul>
<li>环境光模型（物体表面对环境光反射的强度）</li>
<li>漫反射模型（观察者从不同角度观察到的反射光具有同样的亮度，这样的反射光成为漫反射光）</li>
<li>镜面反射（反射光 =&gt; 对入射光的直接反射）</li>
<li>Phong模型（环境光 + 漫反射光 + 镜面反射光）</li>
</ul>
<p><strong>整体光照模型：</strong>光线追踪</p>
<h3 id="明暗处理">明暗处理</h3>
<h4 id="gouraud明暗处理">Gouraud明暗处理</h4>
<p>基本思想：对离散的<strong>顶点颜色</strong>采样进行双线性插值得到内部点颜色。</p>
<ol type="1">
<li>计算每个多边形顶点的平均单位法矢量</li>
<li>对每个顶点根据简单光照模型计算光强</li>
<li>在多边形表面上对顶点颜色进行线性插值</li>
</ol>
<p>特点：（1）只适用于简单的漫反射模型（2）线性光强度插值会引起马赫带效应</p>
<h4 id="phong明暗处理">Phong明暗处理</h4>
<ol type="1">
<li>计算多边形顶点处曲面法向矢量的平均值。</li>
<li>对离散的多边形顶点<strong>法向量</strong>进行<strong>双线性插值</strong>，得到面上每个点的法向矢量。</li>
<li>按光照模型确定多边形内部各点的光强</li>
</ol>
<h3 id="纹理细节模拟">纹理细节模拟</h3>
<p><strong>颜色纹理</strong>：将图片映射到物体表面的方式来实现。将图片的四个角点的坐标分别定义为(0,0)
(0,1) (1,1) (1,0)。三角形每一个顶点均对应图片的一个(u,v)坐标。</p>
<p><strong>几何纹理</strong>：物体表面的微观几何形状（粗燥程度）。物体表面法向量矢量的修改可通过在各采样点的位置上增加一个扰动函数，对其做微小的扰动，从而改变表面的微观几何现状来实现。</p>
<p><strong>过程纹理</strong>：通过过程迭代函数生成纹理。目的是用简单的参数来逼真的描述复杂的自然纹理细节。例如：噪声函数，湍流函数等来动态的生成天空，水流等。</p>
<h2 id="复习大纲总结">复习大纲总结</h2>
<h3 id="图形学基本概念">图形学基本概念</h3>
<h4 id="什么是计算机图形学-1">1. 什么是计算机图形学？</h4>
<p>研究通过计算机，将<strong>数据</strong>转化为<strong>图形</strong>，并在专门显示设备上<strong>显示</strong>的<strong>原理、方法和技术</strong>的学科。也就是如何<strong>用计算机生成、处理和显示图形</strong>的一门学科。</p>
<h4 id="计算机图形学的主要研究内容包括哪些">2.
计算机图形学的主要研究内容包括哪些？</h4>
<p>硬件部分：包括各种<strong>输入/输出</strong>、<strong>图形处理设备</strong>或器件的研究</p>
<p>软件部分：</p>
<ul>
<li>图形<strong>生成</strong>算法的研究，包括基本图形的生成，比如直线，圆/圆弧，多边形，曲线/曲面，多面体，自然现象/自然景物等。</li>
<li>图形<strong>变换</strong>算法的研究，包括图形在平面或者空间中的变换，各种视窗之间的转换，平面和空间裁剪，消隐等。</li>
<li>图形<strong>显示技术</strong>研究，包括光照、材质、纹理、阴影、透明、光线追踪等技术的研究。</li>
</ul>
<h4 id="计算机图形学的主要应用领域">3. 计算机图形学的主要应用领域。</h4>
<ol type="1">
<li>图形用户接口 (2) 工业应用 (3) 商业领域 (4) 艺术领域 (5)
科学计算可视化 (6) 虚拟现实 (7) 系统环境模拟</li>
</ol>
<h4 id="图形和图像的主要区别是什么">4. 图形和图像的主要区别是什么？</h4>
<ul>
<li><strong>表示方法</strong>不同：图形是由基本几何体（直线，点，圆、曲线、三角形等）构成的实体，同时具有几何属性和视觉属性。图像是由很多像素点构成的点阵信息。</li>
<li><strong>生成方法</strong>不同：图形是通过计算机算法生成的，而图像是通过照相机，摄像机等扫描设备或图像生成软件制作而成。</li>
<li><strong>研究侧重点</strong>不同：图形学主要研究如何使用计算机<strong>表示几何体</strong>，构建几何模型、如何通过建立数学模型或者算法把真实的或者想象的物体显示出来。图像处理主要研究如何将一种图像<strong>处理成另一种图像</strong>，包括图像增强、复原、解析和理解、编码、压缩、匹配，识别等。</li>
</ul>
<h4 id="计算机图形处理系统的主要构成">5.
计算机图形处理系统的主要构成。</h4>
<p>典型的计算机图形系统包括
<strong>处理、存储、交互、输入、输出</strong> 5个基本功能</p>
<p><img src="https://s2.loli.net/2024/01/06/OTQDkLhuVjGW1Np.png" srcset="/img/loading.gif" lazyload alt="计算机图形学学习笔记（一）：图形学概论 - 知乎" style="zoom: 33%;" /></p>
<h4 id="显卡的工作流程">6. 显卡的工作流程。</h4>
<p>图像或者图形数据在CPU处理后，通过下面四个步骤到达显示器：</p>
<ol type="1">
<li>通过数据<strong>总线</strong>将要显示的图形或者图像数据送入<strong>GPU</strong>（图形处理器)。</li>
<li>GPU对送入的数据进行<strong>处理</strong>然后送入<strong>帧缓冲器</strong>（或称显存)
。</li>
<li>送入帧缓冲器中的数据将被送入<strong>视频控制器</strong>。视频控制器将根据接口的类型确定处理方式，完成数模转换；</li>
<li>视频控制器的输出将送到<strong>显示屏</strong>。</li>
</ol>
<h4 id="什么是显示存储器">7. 什么是显示存储器？</h4>
<p>显存用来<strong>存储屏幕上像素的颜色值</strong>，简称<strong>帧缓冲器</strong>，俗称显存。帧缓冲器中的单元数目与显示器上的像素数目相同，单元与像素一一对应，各单元的数值决定了其对应的像素的颜色。</p>
<h4 id="gpu的基本概念">8. GPU的基本概念。</h4>
<p>GPU是专为执行复杂的<strong>数学和几何计算</strong>而设计的<strong>微处理器</strong>，能够将复杂的图形<strong>转换</strong>成显示器能够显示的图像。GPU可通过编程完成所需要的图形变换和计算。</p>
<p>GPU可以完成大量的并行计算。由很多的流处理单元（SM，streaming
multiprocessor)构成，每一个流处理单元由多个核（计算单元），任务调度器，寄存器组，指令缓冲器，纹理缓冲区，纹理映射单元等构成。</p>
<h4 id="显卡分辨率的含义">9. 显卡分辨率的含义。</h4>
<p>显卡分辨率是指显卡输出给显示器并能在显示器上描绘的像素点的数量。分辨率越大，所能显示的图像的像素点就越多，并且能显示更多的细节，当然也就越清晰。</p>
<p>显卡分辨率跟显存的大小以及视频控制器上RAM
DAC的速率有关。如果显存足够大，则RAM DAC决定了分辨率的最大值。</p>
<h4 id="gpu堆包含哪几种主要的类型具有什么样的特点">10.
GPU堆包含哪几种主要的类型，具有什么样的特点？</h4>
<ul>
<li>上传堆：CPU只能将数据传送给上传堆，上传堆不能向CPU传数据。</li>
<li>默认堆：默认堆需要通过上传堆传送数据，CPU不能直接访问。</li>
<li>回读堆：GPU可通过回读堆将数据传送给CPU。</li>
</ul>
<h4 id="gpu渲染流水线包含哪几个阶段分别完成什么任务">11.
GPU渲染流水线包含哪几个阶段，分别完成什么任务？</h4>
<ol type="1">
<li><strong>输入装配</strong>阶段。从内存中读入相关的顶点和索引，从而生成几何图形的<strong>基本要素</strong>（点，线以及三角面）。</li>
<li><strong>顶点着色</strong>阶段。完成顶点转换（从局部坐标系转换到齐次裁剪坐标系中），光照（纹理）等各种形式的运算。</li>
<li><strong>曲面细分</strong>阶段。将一个大的三角形分解成若干个小的三角形。</li>
<li><strong>几何着色</strong>阶段。对输入的点进行筛选，然后输出相应的构成几何图形的基本要素。</li>
<li><strong>裁剪</strong>。将区域之外的物体去除掉，只显示区域之内的物体。</li>
<li><strong>光栅化</strong>阶段。将几何图元变为二维图像。</li>
<li><strong>像素着色</strong>阶段。通过这些点及相应的属性可以在GPU中计算除相应像素的颜色，光照的影响，阴影等处理效果。</li>
<li><strong>输出融合</strong>阶段。一些像素无法通过深度测试而被排除，而另一些像素送入，与此前已经写入到后台缓冲区中的像素进行相应的融合处理。</li>
</ol>
<h4 id="光照的基本原理">12. 光照的基本原理</h4>
<p>当光照射到物体表面时，物体将<strong>吸收</strong>一部分光，同时也会<strong>反射或透射</strong>一部分光。<strong>反射或透射</strong>出的光进入人的眼睛所显示出的颜色就是物体的颜色。</p>
<h4 id="光照模型的分类">13. 光照模型的分类</h4>
<ul>
<li>几何光照模型：以几何学原理为基础，形式简单，精度低，主要用于图像渲染。
<ul>
<li><strong>局部光照模型</strong>：局部光照模型假设物体表面不透明，反射均匀，光源直射物体表面，可模拟漫反射，镜面反射，阴影等。</li>
<li><strong>整体光照模型</strong>：在模拟局部光照模型的基础上，还须考虑周围环境对景物表面的影响。可以模拟镜面映像，透明，折射，相邻景物之间的色彩辉映等较为精致的光照效果。<br />
</li>
</ul></li>
<li>物理光照模型：以<strong>电池波反射理论</strong>为基础，精度高，形式比较复杂，用于光谱分析等物理领域。</li>
</ul>
<h4 id="光源的分类">14. 光源的分类</h4>
<ul>
<li><strong>点</strong>光源：光线由中心点均匀向四周散射。在光源比场景中的物体小得多或者距离物体足够远时，可将该光源视为点光源。</li>
<li><strong>线</strong>光源：发光的光源呈一条直线则称为线光源。线光源可看成由无数个点光源构成。比如日光灯，穿过单缝的光等。<br />
</li>
<li><strong>面</strong>光源：面光源是一种通过将光源均匀分布在一个平面上实现整体均匀照明效果的照明装置。</li>
<li><strong>体</strong>光源：体光源在所有方向上发射光线，产生全方位的光照效果。</li>
</ul>
<h4 id="纹理的表现形式">15. 纹理的表现形式。</h4>
<ul>
<li><strong>颜色纹理</strong>：将图片映射到物体表面的方式来实现。</li>
<li><strong>几何纹理</strong>：物体表面的微观几何形状（粗燥程度）。</li>
<li><strong>过程纹理</strong>：过程纹理用于表现各种规则或不规则的<strong>动态变化</strong>的自然景象。</li>
</ul>
<h4 id="纹理的过滤方式及寻址方式">16. 纹理的过滤方式及寻址方式</h4>
<ul>
<li><strong>纹理过滤</strong>：纹理图与实际待显示的图形大小不一致的情况，需要通过纹理过滤来解决。
<ul>
<li><strong>点</strong>过滤：在纹理贴图时，选择与待投影到屏幕上的几何体分辨率最为匹配的Mipmap层级，并根据具体需求选用常数插值或线性插值。</li>
<li><strong>线性</strong>过滤：在纹理贴图时，选区与待投影到屏幕上的几何体分辨率最为匹配的两个临近的Mipmap层级（一个稍大于屏幕上几何体的分辨率，一个稍小于屏幕上几何体的分辨率），然后对这两种MipMap层级的图分别进行常量过滤或线性过滤，生成他们各自相应的纹理颜色。最后再在这两种插值纹理之间进行颜色的插值计算。</li>
<li><strong>各向异性</strong>过滤：需要对映射点周围8个(正方体）或更多的像素进行取样，获得平均值后映射到像素点上。</li>
</ul></li>
<li><strong>寻址模式</strong>：当设定的纹理坐标值大于（1.0.1.0）时，则通过寻址模式来解决。
<ul>
<li><strong>重复寻址</strong>模式（Wrap）：通过在坐标的每个整数点处重复绘制图像来托充纹理函数。</li>
<li><strong>边框颜色寻址</strong>模式：通过将每个不在 [0,1]
范围内的坐标（u,v）都映射为<strong>指定的颜色</strong>（边框颜色）而拓充纹理函数</li>
<li><strong>钳位寻址</strong>模式：通过将范围[0,1]外的颜色使用<strong>边缘的纹理</strong>坐标内容进行延伸</li>
<li><strong>镜像寻址</strong>模式：通过在坐标的每个整数点处绘制图像的<strong>镜像来扩充</strong>纹理函数。</li>
</ul></li>
</ul>
<h4 id="多级纹理的基本原理">17. 多级纹理的基本原理</h4>
<p>多级纹理是指使用<strong>多个不同大小</strong>的纹理图片作为贴图来提高画面质量的方法。针对物体处于<strong>不同的距离</strong>，<strong>采用不同分辨率</strong>大小的纹理贴图，可以提高图像显示质量，降低图像渲染的复杂度。</p>
<h4 id="模型的表示方法-1">18. 模型的表示方法</h4>
<ul>
<li>通过<strong>三角形、四边形、曲面方程</strong>等来<strong>模拟</strong>物体的表面，最后形成三维模型；</li>
<li>是通过无数个细小的四面体、球体等<strong>基本几何体</strong>来构成整个物体。</li>
</ul>
<h4 id="direct3d-12图形绘制的基本原理">19. Direct3D
12图形绘制的基本原理</h4>
<p>CPU的数据传递给GPU之后，GPU将把它保存到到GPU的<strong>存储空间</strong>中。Direct12版本将其分成<strong>上传堆</strong>、<strong>默认堆</strong>和<strong>回读堆</strong>，并用于存储不同类型的图形数据，同时通过不同的API对其进行操作。Direct3D提供的<strong>图形接口</strong>，通过与GPU卡的<strong>通信</strong>及<strong>编程</strong>实现对图形的<strong>计算和显示</strong>。其原来由CPU进行的计算则转移到GPU中，由GPU计算出对应的像素位置，然后再进行显示。</p>
<h4 id="三维模型顶点的数据结构表示">20. 三维模型顶点的数据结构表示</h4>
<div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span>&#123;</span>
	XMFLOAT3 Pos;      <span class="hljs-comment">//顶点的坐标</span>
	XMFLOAT4 Color;    <span class="hljs-comment">//顶点的颜色，第四个位置表示alpha通道，用于控制颜色的透明度</span>
&#125;;
std::vector&lt;Vertex&gt; Vertices;   <span class="hljs-comment">//存储所有的顶点 </span>
std::vector&lt;<span class="hljs-keyword">int</span>&gt; Indices32;  <span class="hljs-comment">//存储所有三角面对应顶点的索引</span>

<span class="hljs-comment">// 一个正方体</span>
Vertices[<span class="hljs-number">0</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>);
Vertices[<span class="hljs-number">1</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-number">-1.0f</span>, +<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>);
Vertices[<span class="hljs-number">2</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(+<span class="hljs-number">1.0f</span>, +<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>);
Vertices[<span class="hljs-number">3</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(+<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>);
Vertices[<span class="hljs-number">4</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>, +<span class="hljs-number">1.0f</span>);
Vertices[<span class="hljs-number">5</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-number">-1.0f</span>, +<span class="hljs-number">1.0f</span>, +<span class="hljs-number">1.0f</span>);
Vertices[<span class="hljs-number">6</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(+<span class="hljs-number">1.0f</span>, +<span class="hljs-number">1.0f</span>, +<span class="hljs-number">1.0f</span>);
Vertices[<span class="hljs-number">7</span>].Pos=<span class="hljs-built_in">XMFLOAT3</span>(+<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>, +<span class="hljs-number">1.0f</span>);
Indices[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
Indices[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;
Indices[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>; <span class="hljs-comment">//左手定则来确定其法向</span>
Indices[<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;
Indices[<span class="hljs-number">4</span>]=<span class="hljs-number">2</span>;
Indices[<span class="hljs-number">5</span>]=<span class="hljs-number">3</span>; <span class="hljs-comment">// 左手定则来确定其法向</span>
……</code></pre></div>
<h3 id="图形学基本算法">图形学基本算法</h3>
<p>要求：算法的基本原理，算法描述，算法执行过程分析，过程计算，编程实现等。</p>
<h4 id="直线生成算法dda算法中点画线法bresenham法">1.
直线生成算法：DDA算法，中点画线法、Bresenham法。</h4>
<ul>
<li><p>DDA略</p></li>
<li><p>中点画线法</p>
<ul>
<li><p>检验 0 ≤ k ≤ 1</p></li>
<li><p>a = <strong>y0 - y1</strong>, b = x1 - x0</p></li>
<li><p>d0 = <strong>2a+b</strong></p></li>
<li><p>当<span class="math inline">\(d\ge 0\)</span>，取下点 y不变 <span
class="math inline">\(y_{i+1} = y_i\)</span>, <span
class="math inline">\(d&#39;=d+2a\)</span>；</p>
<p>当<span class="math inline">\(d&lt;0\)</span>，取上点 y加一 <span
class="math inline">\(y_{i+1} = y_i+1\)</span>, <span
class="math inline">\(d&#39;=d+2a+2b\)</span>.</p></li>
</ul></li>
<li><p>Bresenham法</p>
<ul>
<li><p>检验 0 ≤ k ≤ 1</p></li>
<li><p><span class="math inline">\(\Delta y\)</span> = y1 - y0, <span
class="math inline">\(\Delta x\)</span> = x1 - x0</p></li>
<li><p>e = <span class="math inline">\(2\Delta y-\Delta
x\)</span>,</p></li>
<li><p>当<span class="math inline">\(e\ge 0\)</span>，取上点 <span
class="math inline">\(y_{i+1} = y_i+1\)</span>, <span
class="math inline">\(e&#39;=e+2\Delta y - 2\Delta x\)</span>；</p>
<p>当<span class="math inline">\(e&lt;0\)</span>，取下点 <span
class="math inline">\(y_{i+1} = y_i\)</span>, <span
class="math inline">\(e&#39;=e+2\Delta y\)</span>.</p></li>
</ul></li>
</ul>
<h4 id="圆和圆弧的生成算法dda算法中点画线法bresenham法">2.
圆和圆弧的生成算法：DDA算法，中点画线法，Bresenham法</h4>
<ul>
<li><p>DDA算法</p>
<ul>
<li><p><span class="math inline">\(y_{n+1}= y_n-εx_n\)</span></p>
<p><span class="math inline">\(x_{n+1}= x_n+εy_n\)</span></p></li>
</ul></li>
<li><p>中点画线法</p>
<ul>
<li><p>初始值 <span class="math inline">\(x=0,y=R\)</span>, <span
class="math inline">\(d=1-R\)</span></p></li>
<li><p><span class="math inline">\(d&lt;0\)</span>，y不变，<span
class="math inline">\(d=d+2x+3\)</span></p>
<p><span class="math inline">\(d\ge0\)</span>，y减一，<span
class="math inline">\(d= d+2x-2y+5\)</span></p></li>
</ul></li>
<li><p>Bresenham法</p>
<ul>
<li>初始化 <span class="math inline">\(x=0, y=R, d=2(1-R)\)</span></li>
<li>d&lt;0, <strong>2(d+y)-1</strong>&lt;=0: <span
class="math inline">\(x=x+1, d=d+2x+3\)</span></li>
<li>d&lt;0, 2(d+y)-1&gt;0: <span class="math inline">\(x=x+1, y=y-1,
d=d+2x-2y+6\)</span></li>
<li>d=0: 同上</li>
<li>d&gt;0, 2(d-x)-1&lt;=0: 同上</li>
<li>d&gt;0, 2(d-x)-1&gt;0: <span class="math inline">\(y=y-1,
d=d-2y+3\)</span></li>
</ul></li>
</ul>
<h4 id="线宽生成算法刷子绘制法实区域填充法">3.
线宽生成算法：刷子绘制法，实区域填充法</h4>
<ul>
<li><p>刷子绘制法</p>
<ul>
<li><p>如果直线斜率小于等于1，则将刷子置成垂直方向。使垂直方向有w个像素。每次在中心点上下绘制w/2个像素。</p></li>
<li><p>如果直线斜率大于1，则将刷子支撑水平方向。使水平方向上有w个像素。如右图所示。</p></li>
<li><p>缺点： (1) 线宽较大时，不自然 (2)折线处有缺口 (3)宽度不符合要求
(4)对称问题：奇偶数像素，效果不同</p></li>
</ul></li>
<li><p>方形刷子绘制法：将正方形的中心对准单线条像素，然后沿单线条对应方向移动。</p></li>
</ul>
<h4 id="线型的处理">4. 线型的处理</h4>
<p>线型可以看成一个由布尔值对应的像素。每种线型对应一定的长度的像素，每个像素对应相应的布尔值。如果该像素对应的布尔值为1，则绘制该像素。如果对应的布尔值为0，则不绘制该像素。</p>
<h4 id="区域填充法扫描线法边填充法种子填充法扫描线种子填充法">5.
区域填充法：扫描线法，边填充法，种子填充法，扫描线种子填充法，</h4>
<ul>
<li><p>扫描线法：</p>
<ul>
<li>求交、排序、两两配对、线段着色，</li>
<li>注意<strong>顶点求交点</strong>规则：把所有极值顶点当成两个点</li>
<li>（活性边表法好像不考？）边表的结构为 <span
class="math inline">\([x,y_{max},\frac1k]\)</span>。 $x:
$当前扫描线与活性边的交点， $y_{max}: <span
class="math inline">\(活性边较高端点的\)</span>y$ 坐标值， $1k:
$活性边所在直线斜率的倒数。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2024/01/06/15EK8hUg9einsdC.png" srcset="/img/loading.gif" lazyload
alt="image-20240106225101692" />
<figcaption aria-hidden="true">image-20240106225101692</figcaption>
</figure></li>
<li><p>边填充法：该多边形每一条边右边区域像素的颜色全部取补</p></li>
<li><p>栅栏填充法：该多边形每一条边与栅栏之间像素的颜色全部取补</p></li>
<li><p>种子填充法：四连通/八联通，从某个像素点开始BFS/DFS整某个像素点开始个区域（缺点：堆栈大量使用）</p></li>
<li><p><strong>扫描线种子</strong>填充法：</p>
<ul>
<li>栈顶像素出栈。</li>
<li>沿扫描线对出栈像素的左右像素进行填充，直到遇到边界像素xl和xr为止</li>
<li>在区间[xl,xr]中检查与当前扫描线相邻的上下两条扫描线，则把<strong>每个</strong>
<em>非边界、未填充</em> 的
<strong>像素区间</strong>的<strong>最右</strong>像素取为种子像素入栈。</li>
</ul></li>
</ul>
<h4 id="反走样技术像素细分技术bresenham反走样技术">6.
反走样技术：像素细分技术，Bresenham反走样技术</h4>
<ul>
<li><p>像素细分技术</p>
<p>(1)将每个显示像素划分为若干个子像素。</p>
<p>(2)按照常规的计算方法计算出每个像素的颜色和亮度。</p>
<p>(3)采用算数平均或者加权平均等方法求解对应像素的亮度和颜色。</p>
<p>(4)显示出对应的像素。</p></li>
<li><p>Bresenham反走样技术：当待填充的多边形与具有一定面积的像素相交时，求出二者相交的面积，然后以此面积值来决定该像素应该显示的亮度和颜色。</p>
<p>Bresenham区域反走样算法首先将多边形每条边与具有一定面积的像素相交的面积大小分为8个等级，如果相交的面积小于1/8，则其灰度等级为0，介于1/8到2/8之间，则为1，依次类推。</p>
<p><span class="math inline">\(S=(y_{i+1}+ y_i)/2=(y_i+ y_i+m)/2=
y_i+m/2=e+m/2\)</span>，用e来确定像素的灰度值，注意将其映射到正的区间。</p></li>
</ul>
<h4 id="曲线生成bezier曲线和b样条曲线包括二阶三阶曲线等">7.
曲线生成：Bezier曲线和B样条曲线，包括二阶、三阶曲线等。</h4>
<p>二次Bezier曲线： 当控制点的个数为3时，可以得到Bezier曲线方程 <span
class="math inline">\(P(t)=(1-t)^2P_0+2t(1-t)P_1+t^2P_2\quad
t\in[0,1]\)</span></p>
<p><span class="math display">\[
\begin{aligned}&amp;\text{用矩阵形式表示为}:\\&amp;P(t)=[P_0,P_1,P_2]\begin{bmatrix}1&amp;-2&amp;1\\0&amp;2&amp;-2\\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1\\t\\t^2\end{bmatrix}\quad
t\in[0,1]\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}\text{性质}:\\&amp;\text{P}(0){=}P_0,\quad
P(1){=}P_2,\quad\text{P}^{\prime}(0){=}2(\text{P}_1-\text{P}_0),\quad\text{P}^{\prime}(1){=}2(\text{P}_2-\text{P}_1)\\&amp;\text{P}(0.5){=}\frac12(\text{P}_1+\frac12(P_0+\text{P}_2))=\frac12(\text{P}_1+\text{P}_m),\text{P}^{\prime}(0.5){=}\text{P}_2{-}\text{P}_0\end{aligned}
\]</span></p>
<p><img src="https://s2.loli.net/2024/01/06/ziYFIPXnT4CAN6U.png" srcset="/img/loading.gif" lazyload alt="image-20240106232012983" style="zoom:25%;" /></p>
<p>三次Bezier曲线： 当控制点的个数为4时，可以得到三次Bezier曲线方程：
<span
class="math inline">\(P(t)=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3=B_{0,3}(t)P_0+B_{1,3}(t)P_1+B_{2,3}(t)P_2+B_{3,3}(t)P_3\quad
t\in[0,1]\)</span> <span class="math display">\[
\begin{aligned}&amp;\text{用矩阵形式表示为}:\\&amp;P(t)=[P_0,P_1,P_2,P_3]\begin{bmatrix}1&amp;-3&amp;3&amp;-1\\0&amp;3&amp;-6&amp;3\\0&amp;0&amp;3&amp;3\\0&amp;0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1\\t\\t^2\\t^3\end{bmatrix}\quad
t\in[0,1]\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}\text{性质:}\\&amp;\mathsf P(0)=P_0,\quad
P(1)=P_3,\quad\mathsf P&#39;(0)=3(\mathsf P_1-\mathsf P_0),\quad\mathsf
P&#39;(1)=3(\mathsf P_3-\mathsf P_2)\\&amp;\mathsf
P&#39;&#39;(0)=6(\mathsf P_0-\mathsf2\mathsf P_1+\mathsf
P_2),\quad\mathsf P&#39;&#39;(1)=6(\mathsf P_1-\mathsf2\mathsf
P_2+\mathsf P_3)\end{aligned}
\]</span></p>
<p><img src="https://s2.loli.net/2024/01/07/6kh4qRsAJVboWuN.png" srcset="/img/loading.gif" lazyload alt="image-20240107103212717" style="zoom:25%;" /></p>
<p>二次B样条曲线：在n=2控制点为3个时，可得到二次B样条曲线的定义为：
<span class="math display">\[
P(t)=\sum_{i=0}^2P_i\cdot
B_{i,2}(t)=\frac12(t-1)^2P_0+\frac12(-2t^2+2t+1)P_1+\frac12t^2P_2
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\text{性质:} \\
&amp;\begin{aligned}\mathsf P(0)=\frac12(P_0+P_1)\quad\mathsf
P(1)=\frac12(P_1+P_2)\quad\mathsf P&#39;(0)=P_1-P_0\quad\mathsf
P&#39;(1)=P_2-P_1\end{aligned} \\
&amp;\mathsf{P}(0.5)=\frac12(\frac12\left(\mathsf{P}(0)+\mathsf{P}(1)\right)+P_1)=\frac12(P_m+P_1)\quad
P^{\prime}(0.5)=\mathsf{P}(1)-\mathsf{P}(0)
\end{aligned}
\]</span></p>
<p><img src="https://s2.loli.net/2024/01/06/xPSw9HnlGL4toUJ.png" srcset="/img/loading.gif" lazyload alt="image-20240106231929596" style="zoom:25%;" /></p>
<p>三次B样条曲线：在n=3控制点为4个时，可得到三次B样条曲线的定义为：
<span class="math display">\[
P(t)=\sum_{i=0}^3P_i\cdot
B_{i,3}(t)=\frac16(-t^3+3t^2-3t+1)P_0+\frac16(3t^3-6t^2+4)P_1+\frac16\left(-3t^3+3t^2+3t+1\right)P_2+\frac16t^3P_3
\]</span> 三次B样条曲线的起点在三角形<span class="math inline">\(\Delta
P_0P_1P_2\)</span>的中线<span
class="math inline">\(P_1P_m\)</span>上，且<strong>距离P1点的1/3</strong>处（<strong>不是中点！</strong>）。其切线方向与<span
class="math inline">\(P_0P_2\)</span>平行，且为底边长度的1/2。同样终点位于<span
class="math inline">\(\Delta P_1P_2P_3\)</span>的纵向<span
class="math inline">\(P_2P_n\)</span>上，且在距离P2点1/3处。其切线方向与<span
class="math inline">\(P_1P_3\)</span> ”平行，且为底边长度的1/2。 <span
class="math display">\[
\begin{aligned}\text{性质:}\\
&amp;P_{0,3}(0)=\frac{1}{6}(P_{0}+4P_{1}+P_{2})=\frac{1}{3}(\frac{P_{0}+P_{2}}{2})+\frac{2}{3}P_{1}
\\
&amp;P_{0,3}(1)=\frac{1}{6}\bigl(P_{1}+4P_{2}+P_{3}\bigr)=\frac{1}{3}\bigl(\frac{P_{1}+P_{3}}{2}\bigr)+\frac{2}{3}P_{2}
\\
&amp;P_{0,3}^{\prime}(0)=\frac{1}{2}(P_{2}-P_{0}),P_{0,3}^{\prime}(1)=\frac{1}{2}(P_{3}-P_{1})
\end{aligned}
\]</span>
<img src="https://s2.loli.net/2024/01/06/LAqHEJijUQ4oGzY.png" srcset="/img/loading.gif" lazyload alt="image-20240106231856996" style="zoom: 50%;" /></p>
<h4 id="图形变化平移缩放旋转">8. 图形变化：平移、缩放、旋转</h4>
<p><span class="math display">\[
T_{3D}=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\b_x&amp;b_y&amp;b_z&amp;1\end{bmatrix}S_{3D}=\begin{bmatrix}s_x&amp;0&amp;0&amp;0\\0&amp;s_y&amp;0&amp;0\\0&amp;0&amp;s_z&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}
\\\mathbf{R}_{\mathbf{x}}=\left[\begin{array}{cccc}1 &amp; 0 &amp; 0
&amp; 0 \\0 &amp; \cos \theta &amp; \sin \theta &amp; 0 \\0 &amp; -\sin
\theta &amp; \cos \theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp;
1\end{array}\right]\mathbf{R}_{\mathbf{y}}=\left[\begin{array}{cccc}\cos
\theta &amp; 0 &amp; -\sin \theta &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0
\\\sin \theta &amp; 0 &amp; \cos \theta &amp; 0 \\0 &amp; 0 &amp; 0
&amp;
1\end{array}\right]\mathbf{R}_{\mathbf{z}}=\left[\begin{array}{cccc}\cos
\theta &amp; \sin \theta &amp; 0 &amp; 0 \\-\sin \theta &amp; \cos
\theta &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0
&amp; 1\end{array}\right]
\]</span></p>
<p>坐标行向量表达，变换矩阵×在右侧，逆时针为正方向</p>
<h4 id="坐标系之间的变换局部坐标世界坐标摄像机坐标屏幕坐标">9.
坐标系之间的变换：局部坐标、世界坐标、摄像机坐标、屏幕坐标</h4>
<p><strong>摄像机坐标</strong>（PPT） <span class="math display">\[
\begin{align}
\left[x, y, z,
1\right]\begin{bmatrix}\dfrac{1}{r\tan\left(\alpha/2\right)}&amp;0&amp;0&amp;0\\0&amp;\dfrac{1}{\tan\left(\alpha/2\right)}&amp;0&amp;0\\
0&amp;0&amp;\dfrac{f}{f-n}&amp;1\\
0&amp;0&amp;\dfrac{-nf}{f-n}&amp;0\end{bmatrix}\quad&amp;=\left[\dfrac{x}{r\tan\left(\alpha/2\right)},\dfrac{y}{\tan\left(\alpha/2\right)},\dfrac{zf-nf}{f-n},z\right]\\\text{规格化}&amp;=
\left[\frac{x}{rz\tan\left(\alpha/2\right)},\frac{y}{z\tan\left(\alpha/2\right)},A+\frac{B}{z},1\right]
\end{align}
\]</span> <img
src="https://s2.loli.net/2024/01/07/9gKkVnEGQdm1iN2.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>世界坐标 - 摄像机坐标</strong></p>
<p>注意：坐标轴顺时针旋转，也就是场景逆时针选择。坐标轴变换对应的变换矩阵都是反向的。</p>
<ul>
<li>步骤1：场景坐标系的原点从场景坐标系平移到视点位置 E(Cx,Cy,Cz)</li>
<li>步骤2：经过平移后的坐标系绕<span
class="math inline">\(x_e\)</span>轴逆时针旋转90°，</li>
<li>步骤3：坐标系绕<span
class="math inline">\(y_e\)</span>轴顺时针旋转角<span
class="math inline">\(\varphi\)</span>，使新坐的z轴垂直指向原景物坐标系的Z轴，</li>
<li>步骤4：坐标系绕<span
class="math inline">\(x_e\)</span>轴顺时针旋转角<span
class="math inline">\(\theta\)</span>，使新坐的z轴垂直指向原景物坐标系的原点，</li>
<li>步骤5：右手坐标系调整为左手坐标系，x轴反向</li>
</ul>
<p><span class="math display">\[
\boldsymbol{T}_1=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\-C_x&amp;-C_y&amp;-C_z&amp;1\end{bmatrix}
\boldsymbol{T}_2=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;\cos(-90^\circ)&amp;\sin(-90^\circ)&amp;0\\0&amp;-\sin(-90^\circ)&amp;\cos(-90^\circ)&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}
\left.\boldsymbol{T}_{3}=\left[\begin{matrix}{\cos\varphi}&amp;{0}&amp;{-\sin\varphi}&amp;{0}\\{0}&amp;{1}&amp;{0}&amp;{0}\\{\sin\varphi}&amp;{0}&amp;{\cos\varphi}&amp;{0}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{matrix}\right.\right]
\boldsymbol{T}_{4}=\left[\begin{array}{cccc}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos \theta &amp; -\sin \theta &amp; 0 \\
0 &amp; \sin \theta &amp; \cos \theta &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]
\boldsymbol{T}_5=\begin{bmatrix}-1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{bmatrix}
\]</span></p>
<figure>
<img src="https://s2.loli.net/2024/01/07/SHa59nx1TuBDwI7.png" srcset="/img/loading.gif" lazyload
alt="image-20240107161501549" />
<figcaption aria-hidden="true">image-20240107161501549</figcaption>
</figure>
<h4
id="四边形裁剪算法cohen-sutherland裁剪算法中点分割裁剪算法liang-barskey裁剪算法">10.
四边形裁剪算法：Cohen-Sutherland裁剪算法、中点分割裁剪算法、Liang-Barskey裁剪算法</h4>
<ul>
<li>Cohen-Sutherland裁剪算法（编码裁剪算法）
<ol type="1">
<li>对线段端点编码，定义为它所在区域的编码;</li>
<li>快速判断“完全可见”，若两端点编码均为0，则完全可见。<strong>RC0=0且RC1=0</strong></li>
<li>快速判断“完全不可见”，线段两端点编码的逻辑位“与”运算结果非零，则完全不可见。<strong>RC0&amp;RC1≠0</strong>说明直线段位于窗外的同一侧</li>
<li>若2)、3)不满足，逐个端点判断其编码 CtCbCrCl(C3C2C1C0)
中位是否为“1”，若是，则需求交，交点的x坐标进行排序，从而将原始线段分割成最多五段线段（四个交点）。然后根据（1）（2）步判断这些线段是否在区域内。</li>
</ol></li>
</ul>
<p><img src="https://s2.loli.net/2024/01/06/uleTRDy7MwWmnGI.png" srcset="/img/loading.gif" lazyload alt="image-20240106215840646" style="zoom: 25%;" /></p>
<ul>
<li><p>中点分割裁剪算法</p>
<ul>
<li><p>采用Cohen-Sutherland算法判断可见性</p></li>
<li><p>固定 P1，测试 P2是否在窗口内，若是，则 P2 是离 P1
点最远的可见点。否则，将线段 P1P2 对分，求出中点 Pm，编码判断线段 PmP2
是否全部在窗口外，若是，则舍弃PmP2，用 P1Pm代替
P1P2；若不是，则用PmP2代替P1P2。求得离P1最远的可见点Pm。</p></li>
<li><p>固定P2，再测 P1，</p></li>
</ul></li>
<li><p>Liang（<strong>梁友栋）</strong>-Barsky裁剪算法</p>
<ul>
<li>无论何种情况下，在裁剪区域之内的线段均为：AB ∩ RS ∩ TU</li>
</ul></li>
</ul>
<p><img src="https://s2.loli.net/2023/12/30/SE49AZKfWMmcTRj.png" srcset="/img/loading.gif" lazyload alt="image-20231230144247813" style="zoom: 25%;" /></p>
<p>记<span class="math inline">\(L=\max \left[x_{\min }, \min
\left(x_{A}, x_{B}\right)\right], R=\min \left[x_{\max }, \max
\left(x_{A},
x_{B}\right)\right]\)</span>，不等式若有不成立，则不存在可见线段，不等式为：
<span class="math display">\[
\left\{\begin{array}{l}
L \leqslant R \\
L \leqslant \max \left(x_{T}, x_{U}\right) \\
\min \left(x_{T}, x_{U}\right) \leqslant R
\end{array}\right.;
\quad
\text{斜率&gt;0时}
\left\{\begin{array}{l}
L \leqslant R \\
L \leqslant x_{U} \\
x_{T} \leqslant R
\end{array}\right.;
\quad
\text{斜率&lt;0时}
\left\{\begin{array}{l}
L \leqslant R \\
L \leqslant x_{T} \\
x_{U} \leqslant R
\end{array}\right.
\]</span> A B 斜率大于 0 时，可见线段的端点坐标：<span
class="math inline">\(\begin{array}{l} x_{\alpha}=\max \left(L,
x_{T}\right) \\ x_{\beta}=\min \left(R, x_{U}\right)
\end{array}\)</span></p>
<p>A B 斜率小于 0 时，可见线段的端点坐标：<span
class="math inline">\(\begin{array}{l} x_{\alpha}=\max \left(L,
x_{U}\right) \\ x_{\beta}=\min \left(R, x_{T}\right)
\end{array}\)</span></p>
<h4 id="多边形裁剪算法sutherland-hodgman算法weiler-atherton算法">11.
多边形裁剪算法：Sutherland-Hodgman算法，Weiler-Atherton算法</h4>
<ul>
<li>Sutherland-Hodgman算法
<ul>
<li>裁剪<strong>凹多边形</strong>可能会出现多余的边</li>
</ul></li>
</ul>
<p><img src="https://s2.loli.net/2024/01/06/rwSGV3WHFTcxy1z.png" srcset="/img/loading.gif" lazyload alt="image-20240106233155378" style="zoom: 33%;" /></p>
<ul>
<li><p>Weiler-Atherton算法</p>
<ul>
<li>将裁剪多边形称为CP，被裁剪多边形称为SP。</li>
<li>算法首先将CP和SP的顶点按照<strong>外部边界取顺时针</strong>，内部边界取逆时针的的方式将其构成环形链表。</li>
<li>求SP与CP的所有交点，并将这些交点插入到SP和CP的环形链表中，并<strong>标明</strong>交点是出点还是进点（进入CP）。</li>
<li>算法从任意一个<strong>进点开始</strong>沿着SP的边线按照边线所标示的方向搜集顶点序列，当遇到<strong>出点</strong>时，则<strong>沿着CP的边线</strong>所标示的方向搜集顶点序列，当遇到<strong>进点</strong>时，则<strong>沿着SP的边线</strong>所标示的方向搜集顶点序列。</li>
<li>搜索所有点。</li>
</ul>
<p><img src="https://s2.loli.net/2024/01/07/UXE7l39SjkPzV4y.png" srcset="/img/loading.gif" lazyload alt="image-20240107175129445" style="zoom: 33%;" /></p></li>
</ul>
<h4 id="三维线段裁剪算法长方体裁剪算法视椎体裁剪算法">12.
三维线段裁剪算法：长方体裁剪算法，视椎体裁剪算法</h4>
<ul>
<li><p>长方体裁剪算法（编码裁剪算法）</p>
<ul>
<li>采用6位二进制对不同区域进行<strong>编码</strong>，[前，后，上，下，右，左]</li>
<li>如果线段的两个端点的编码全部为0，则完全在长方体内部</li>
<li>同时位于长方体的一侧，则两端点编码对应位相与的结果必不为0，因此该线段完全不可见。</li>
<li>穿越立方体，则需要求交，然后将线段分割成几个部分，分别判断每一段线段是否可见。</li>
</ul>
<p><img src="https://s2.loli.net/2024/01/07/jNULnzQf29BxgHP.png" srcset="/img/loading.gif" lazyload alt="image-20240107175302050" style="zoom: 50%;" /></p></li>
<li><p>视椎体裁剪</p>
<ul>
<li>计算每个平面方程。如果对应的方程的值&gt;0，表明在该平面之上……其他同长方体</li>
</ul></li>
</ul>
<h4
id="图形消隐背面剔除算法画家算法weiler-atherton算法bsp树算法深度缓冲区算法warnock算法">13.
图形消隐：背面剔除算法，画家算法，Weiler-Atherton算法，BSP树算法、深度缓冲区算法，Warnock算法</h4>
<ul>
<li><strong>背面剔除算法</strong>
<ol type="1">
<li><p>计算多边形的法向向量N和视线向量V。</p></li>
<li><p>计算法向向量N和视线向量V的夹角θ的余弦Cosθ=N.V。</p></li>
<li><p>cosθ＜0，即θ＞90°， 则该多边形表面为背面，是不可见的</p></li>
</ol></li>
<li><strong>画家算法</strong>
<ul>
<li>将多边形按照离视点的远近进行排序（P221
判断遮挡，分割），然后先画出被遮挡的多边形，再画出不被遮挡的多边形，用后画的多边形覆盖先画的多边形，从而达到自动消隐的目的。</li>
</ul></li>
<li><strong>Weiler-Atherton算法</strong>：采用裁剪算法的思想对隐藏面进行消隐。
<ol type="1">
<li>先进行初步的深度预排序，即将变换到屏幕坐标系中的景物表面多边形按各顶点的
z 最小值进行排序，形成景物多边形表。</li>
<li>以当前具有最大 z 值（即离视点最近）的景物表面作为裁剪多边形 CP
。</li>
<li>用CP对景物多边形表中排在后面的景物表面进行裁剪，产生内部多边形 Pin
和外部多边形 Pout 。</li>
<li>由于多边形顶点离视点最近的多边形表面不一定是真正排在最前面的可见面，因此，需比较CP与内部多边形
Pin 的深度，检查 CP是否是真正离视点较近的多边形。
如果是，则CP为可见表面，而位于裁剪多边形 CP之内的多边形 Pin
为当前视点的隐藏面，可以消去该隐藏面；如果不是，则选择 Pin
为新的裁剪多边形，重复步骤 3。</li>
<li>将位于裁剪多边形之外的景物表面 Pout
组成外裁剪结果多边形表，取表中深度最大即排在最前面的表面为裁剪多边形，重复步骤
3，继续对表中其他景物表面进行裁剪。</li>
<li>上述过程递归进行，直到外裁剪结果多边形表为空时为止</li>
</ol></li>
<li><strong>BSP树算法</strong>：平面分割二叉树
<ul>
<li>先在场景中选取一剖分平面
P1（与视点垂直的平面），将场景空间分割成两个半空间。它相应地把场景中的景物分成两组，相对于视点而言，一组景物多边形位于P1的前面，作为BSP树的左孩子（front)，另一组景物多边形位于P1的后面,作为BSP树的右孩子（Back)，如果有物体与
P1相交，就将它分割为两个物体分别标识为A和B，再用平面 P2
对所生成的两个子空间继续进行分割，并对每一子空间所含景物进行分类。上述空间剖分和景物分类过程递归进行，直至每一子空间中所含景物少于给定的阈值为止。</li>
<li>优先绘制标识为“back”的子空间中所含的景物，这样可使得前面的物体覆盖后面的物体，从而实现物体的消隐。</li>
</ul></li>
<li><strong>深度缓冲区算法</strong>：对投影到显示屏上的每一个像素所对应的多边形表面的深度进行比较，然后取最近表面的属性值作为该像素的属性值。深度缓冲器只是帧缓冲器的扩充。
<ol type="1">
<li>将场景中的所有多边形通过取景变换、透视变换变换到屏幕坐标系中，物体的深度比较可通过它们z值的比较来实现。</li>
<li>初始化深度缓冲存储器和帧缓冲器。深度缓冲器应初始化为离视点最远的最大z值，帧缓冲器应初始化为背景的属性值。</li>
<li>扫描待显示的每一个多边形，比较当前多边形所覆盖的每一个像素点的深度值，如果其深度值比深度缓冲区中当前像素的深度值小，则取代原来的深度值，并将对应像素的属性值保存到帧缓冲区对应的位置中。反之，则不做任何处理。循环该步骤，直到处理完所有的多边形。</li>
</ol></li>
<li><strong>Warnock算法</strong>：将非单纯的窗口四等分为4个子窗口（四叉树），对每个子窗口再进一步判别是否是单纯的，直到窗口单纯或窗口边长已缩减至一个像素点为止。
<ol type="1">
<li>对每个窗口进行判断，若画面中所有多边形均与此窗口分离，即此窗口为空，则按背景光强或颜色直接显示而无需继续分割。</li>
<li>若窗口中仅包含一个多边形，则窗口内多边形外的区域按背景光强或颜色填充，多边形内按多边形相应的光强或颜色填充。</li>
<li>若窗口与一个多边形相交，则窗口内多边形外的区域按背景光强或颜色填充，相交多边形内位于窗口内的部分按多边形相应的光强或颜色填充。</li>
<li>若窗口被一个多边形包围且窗口内无其他的多边形，则窗口按此包围多边形相应的光强或颜色填充。</li>
<li>若窗口至少被一个多边形包围且此多边形距离视点最近，则窗口按此离视点最近的包围多边形的相应光强或颜色填充。</li>
<li>若以上条件都不满足，则继续细分窗口，并重复以上测试。</li>
</ol></li>
</ul>
<h4
id="曲面的生成bezier曲面的生成b样条曲面的生成特别是二阶和三阶曲面">14.
曲面的生成：Bezier曲面的生成，B样条曲面的生成，特别是二阶和三阶曲面</h4>
<p>二阶Bezier曲面 <span class="math display">\[
P(u,v)=\sum_{i=0}^2\sum_{j=0}^2P_{ij}BEZ_{i,2}(u)BEZ_{j,2}(v)\quad
u\in[0,1],v\in[0,1]
\]</span> 三阶Bezier曲面 <span class="math display">\[
P(u,v)=\sum_{i=0}^3\sum_{j=0}^3P_{ij}BEZ_{i,3}(u)BEZ_{j,3}(v)\quad
u\in[0,1],v\in[0,1]\\
=\begin{bmatrix}BEZ_{0,3}(u)&amp;BEZ_{1,3}(u)&amp;BEZ_{2,3}(u)&amp;BEZ_{3,3}(u)\end{bmatrix}\begin{bmatrix}P_{00}&amp;P_{01}&amp;P_{02}&amp;P_{03}\\P_{10}&amp;P_{11}&amp;P_{12}&amp;P_{13}\\P_{20}&amp;P_{21}&amp;P_{22}&amp;P_{23}\\P_{30}&amp;P_{31}&amp;P_{32}&amp;P_{33}\end{bmatrix}\begin{bmatrix}BEZ_{0,3}(v)\\BEZ_{1,3}(v)\\BEZ_{2,3}(v)\\BEZ_{3,3}(v)\end{bmatrix}\\
=[(1-u)^3\quad3u(1-u)^2\quad3u^2(1-u)\quad
u^3]\begin{bmatrix}P_{00}&amp;P_{01}&amp;P_{02}&amp;P_{03}\\P_{10}&amp;P_{11}&amp;P_{12}&amp;P_{13}\\P_{20}&amp;P_{21}&amp;P_{22}&amp;P_{23}\\P_{30}&amp;P_{31}&amp;P_{32}&amp;P_{33}\end{bmatrix}\begin{bmatrix}(1-\nu)^3\\3\nu(1-\nu)^2\\3\nu^2(1-\nu)\\\nu^3\end{bmatrix}\\
\begin{aligned}=[1\quad u\quad u^2\quad
u^3]\boldsymbol{N}\begin{bmatrix}\boldsymbol{P}_{00}&amp;\boldsymbol{P}_{01}&amp;\boldsymbol{P}_{02}&amp;\boldsymbol{P}_{03}\\\boldsymbol{P}_{10}&amp;\boldsymbol{P}_{11}&amp;\boldsymbol{P}_{12}&amp;\boldsymbol{P}_{13}\\\boldsymbol{P}_{20}&amp;\boldsymbol{P}_{21}&amp;\boldsymbol{P}_{22}&amp;\boldsymbol{P}_{23}\\\boldsymbol{P}_{30}&amp;\boldsymbol{P}_{31}&amp;\boldsymbol{P}_{32}&amp;\boldsymbol{P}_{33}\end{bmatrix}\boldsymbol{N}^\intercal\begin{bmatrix}1\\v\\v^2\\v^3\end{bmatrix}\quad\text{其中:}\quad\boldsymbol{N}=\begin{bmatrix}1&amp;-3&amp;3&amp;-1\\0&amp;3&amp;-6&amp;3\\0&amp;0&amp;3&amp;-3\\0&amp;0&amp;0&amp;1\end{bmatrix},\end{aligned}
\]</span> 二阶B样条曲面 <span class="math display">\[
P(u,\nu)=\sum_{i=0}^m\sum_{j=0}^nP_{ij}B_{i,k}(u)B_{j,h}(\nu)\quad
u\in[0,1],\nu\in[0,1]
\]</span> 三阶B样条曲面 <span class="math display">\[
\begin{aligned}P(u,\nu)&amp;=\begin{bmatrix}B_{0,3}(u)&amp;B_{1,3}(u)&amp;B_{2,3}(u)&amp;B_{3,3}(u)\end{bmatrix}\begin{bmatrix}P_{00}&amp;P_{01}&amp;P_{02}&amp;P_{03}\\P_{10}&amp;P_{11}&amp;P_{12}&amp;P_{13}\\P_{20}&amp;P_{21}&amp;P_{22}&amp;P_{23}\\P_{30}&amp;P_{31}&amp;P_{32}&amp;P_{31}\end{bmatrix}\begin{bmatrix}B_{0,3}(v)\\B_{1,3}(v)\\B_{2,3}(v)\\B_{3,3}(v)\end{bmatrix}\\
&amp;=\begin{bmatrix}1&amp;u&amp;u^2&amp;u^3\end{bmatrix}N\begin{bmatrix}P_{00}&amp;P_{01}&amp;P_{02}&amp;P_{03}\\P_{10}&amp;P_{11}&amp;P_{12}&amp;P_{13}\\P_{20}&amp;P_{21}&amp;P_{22}&amp;P_{23}\\P_{30}&amp;P_{11}&amp;P_{32}&amp;P_{33}\end{bmatrix}N^{\intercal}\begin{bmatrix}1\\v\\v\\v^2\\v^3\end{bmatrix},N=\frac16\begin{bmatrix}1&amp;4&amp;1&amp;0\\-3&amp;0&amp;3&amp;0\\3&amp;-6&amp;3&amp;0\\-1&amp;3&amp;-3&amp;1\end{bmatrix}\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;B_{0,3}(u)=\frac16(-u^3+3u^2-3u+1), &amp;B_{0,3}(\nu) &amp;=
\frac16(-\nu^3+3\nu^2-3\nu+1)  \\
&amp;B_{1,3}(u)=\frac16(3u^3-6u^2+4)\text{
,}  &amp;B_{1,3}(\nu)&amp;=  \frac16(3\nu^3-6\nu^2+4)  \\
&amp;B_{2,3}(u)=\frac16(-3u^3+3u^2+3u+1),
&amp;B_{2,3}(\nu)&amp;=\frac16(-3\nu^3+3\nu^2+3\nu+1)  \\
&amp;B_{3,3}(u)= \frac16\boldsymbol{u}^3,  &amp;B_{3,3}(\nu)&amp;=
\begin{aligned}\frac{1}{6}\nu^3\end{aligned}
\end{aligned}
\]</span></p>
<h4 id="地形的生成算法">15. 地形的生成算法</h4>
<ul>
<li>Diamond-Square算法
<ol type="1">
<li>给定一个四边形,四个顶点的坐标(包含高度)，定义一初始高度因子h和一缩放倍数b。</li>
<li>迭代，先求出四边形的中心点高度为顶点平均高度+h*r的随机数，再分别求出4个边的中点，高度为两端点高度的平均值+h*r</li>
<li>修正高度因子 h=h/b，用(2)的方法分别对这 4
个小正方形进行处理。直到达到所期望的山形细腻程度。</li>
</ol></li>
</ul>
<h4 id="雨雪的模拟算法">16. 雨雪的模拟算法</h4>
<ul>
<li>生成一定数量的初始粒子，对其各个属性进行赋值。</li>
<li>更新粒子的运动参数，比如速度，加速度，位置，生命周期等。<br />
</li>
<li>针对每一个粒子，在粒子对应的位置上绘制位图，并进行位移的映射，背景融合等。</li>
<li>删除已经消亡的粒子，释放其占用的资源。</li>
</ul>
<p><span class="math display">\[
\begin{cases}\nu_x=\nu_x+\Delta t\cdot f/m\\\nu_y=\nu_y+\Delta
t\cdot\left(g+f/m\right)\\\nu_z=\nu_z+\Delta t\cdot f/m&amp;\end{cases},
\begin{cases}P_x=P_x+\nu_x\cdot\Delta t\\P_y=P_y+\nu_y\cdot\Delta
t\\P_z=P_z+\nu_z\cdot\Delta t&amp;\end{cases}
\]</span></p>
<h2 id="代码">代码</h2>
<h3 id="dda画直线">DDA画直线</h3>
<figure>
<img src="https://s2.loli.net/2024/01/07/lHerkjFw8hKLfJD.png" srcset="/img/loading.gif" lazyload
alt="CG--10-06_02-42-53" />
<figcaption aria-hidden="true">CG--10-06_02-42-53</figcaption>
</figure>
<div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Line_DDA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color color)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// 计算delta_x, delta_y, 确定steps，并计算dx, dy</span>
    <span class="hljs-keyword">int</span> delta_x = x1 - x0, delta_y = y1 - y0,
        steps = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(delta_x), <span class="hljs-built_in">abs</span>(delta_y));
    <span class="hljs-keyword">double</span> x = x0, y = y0,
           dx = (<span class="hljs-keyword">double</span>)delta_x / steps, dy = (<span class="hljs-keyword">double</span>)delta_y / steps;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= steps + <span class="hljs-number">1</span>; i++)
    &#123;
        <span class="hljs-built_in">putpixel</span>((<span class="hljs-keyword">int</span>)(x + <span class="hljs-number">0.5</span>), (<span class="hljs-keyword">int</span>)(y + <span class="hljs-number">0.5</span>), color); <span class="hljs-comment">// 四舍五入生成像素点</span>
        x += dx, y += dy;
    &#125;
&#125;</code></pre></div>
<h3 id="中点画线法-1">中点画线法</h3>
<figure>
<img src="https://s2.loli.net/2024/01/07/O9P2JCvAeByUmKj.png" srcset="/img/loading.gif" lazyload
alt="CG--10-06_02-43-03" />
<figcaption aria-hidden="true">CG--10-06_02-43-03</figcaption>
</figure>
<div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Line_Midpoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color color)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (x0 &gt; x1) <span class="hljs-comment">// 保证x0 &lt;= x1</span>
        <span class="hljs-built_in">swap</span>(x0, x1), <span class="hljs-built_in">swap</span>(y0, y1);
    <span class="hljs-keyword">int</span> a = y0 - y1, b = x1 - x0,   <span class="hljs-comment">// 直线L的参数（c因为没有用到不用计算）</span>
        d,                          <span class="hljs-comment">// 决策变量d</span>
        dd_L, dd_G,                 <span class="hljs-comment">// 决策变量d的增量(L代表小于0的情况，G代表大于0的情况)</span>
        x = x0, y = y0,             <span class="hljs-comment">// 初始P坐标</span>
        dPx_L, dPy_L, dPx_G, dPy_G; <span class="hljs-comment">// P坐标的增量(L代表小于0的情况，G代表大于0的情况)</span>
    <span class="hljs-comment">// 根据k值分情况生成决策变量和增量</span>
    <span class="hljs-keyword">if</span> (-b &lt;= a &amp;&amp; a &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// k ∈ [0, 1]</span>
    &#123;
        d = <span class="hljs-number">2</span> * a + b;                            <span class="hljs-comment">// d0 = 2a + b</span>
        dPx_L = <span class="hljs-number">1</span>, dPy_L = <span class="hljs-number">1</span>, dd_L = <span class="hljs-number">2</span> * (a + b); <span class="hljs-comment">// d &lt; 0情况</span>
        dPx_G = <span class="hljs-number">1</span>, dPy_G = <span class="hljs-number">0</span>, dd_G = <span class="hljs-number">2</span> * a;       <span class="hljs-comment">// d &gt;= 0 情况</span>
    &#125;
    <span class="hljs-comment">// 其他斜率情况略</span>
    <span class="hljs-comment">// 迭代生成直线</span>
    <span class="hljs-keyword">while</span> (x != x1 || y != y1)
    &#123;
        <span class="hljs-built_in">putpixel</span>(x, y, color);
        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>)
            x += dPx_L, y += dPy_L, d += dd_L;
        <span class="hljs-keyword">else</span>
            x += dPx_G, y += dPy_G, d += dd_G;
    &#125;
    <span class="hljs-built_in">putpixel</span>(x, y, color);
&#125;</code></pre></div>
<h3 id="bresenham-画线法">Bresenham 画线法</h3>
<figure>
<img src="https://s2.loli.net/2024/01/07/b8odh1OEkGt3wZX.png" srcset="/img/loading.gif" lazyload
alt="CG--10-06_02-43-08" />
<figcaption aria-hidden="true">CG--10-06_02-43-08</figcaption>
</figure>
<div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Line_Bresenham</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color color)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (x0 &gt; x1) <span class="hljs-comment">// 保证x0 &lt;= x1</span>
        <span class="hljs-built_in">swap</span>(x0, x1), <span class="hljs-built_in">swap</span>(y0, y1);
    <span class="hljs-keyword">int</span> Delta_x = x1 - x0, Delta_y = y1 - y0,
        d,                          <span class="hljs-comment">// 决策变量d</span>
        dd_L, dd_G,                 <span class="hljs-comment">// 决策变量d的增量(L代表小于0的情况，G代表大于0的情况)</span>
        x = x0, y = y0,             <span class="hljs-comment">// 初始P坐标</span>
        dPx_L, dPy_L, dPx_G, dPy_G; <span class="hljs-comment">// P坐标的增量(L代表小于0的情况，G代表大于0的情况)</span>
    <span class="hljs-comment">// 根据k值分情况生成决策变量和增量</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt;= Delta_y &amp;&amp; Delta_y &lt;= Delta_x) <span class="hljs-comment">// k ∈ [0, 1]</span>
    &#123;
        d = <span class="hljs-number">2</span> * Delta_y - Delta_x;                            <span class="hljs-comment">// d0 = 2Δy - Δx</span>
        dPx_L = <span class="hljs-number">1</span>, dPy_L = <span class="hljs-number">0</span>, dd_L = <span class="hljs-number">2</span> * Delta_y;             <span class="hljs-comment">// d &lt; 0情况</span>
        dPx_G = <span class="hljs-number">1</span>, dPy_G = <span class="hljs-number">1</span>, dd_G = <span class="hljs-number">2</span> * (Delta_y - Delta_x); <span class="hljs-comment">// d &gt;= 0 情况</span>
    &#125;
    <span class="hljs-comment">// 其他斜率情况略</span>
    <span class="hljs-comment">// 迭代生成直线</span>
    <span class="hljs-keyword">while</span> (x != x1 || y != y1)
    &#123;
        <span class="hljs-built_in">putpixel</span>(x, y, color);
        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>)
            x += dPx_L, y += dPy_L, d += dd_L;
        <span class="hljs-keyword">else</span>
            x += dPx_G, y += dPy_G, d += dd_G;
    &#125;
    <span class="hljs-built_in">putpixel</span>(x, y, color);
&#125;</code></pre></div>
<h3 id="中点画圆法">中点画圆法</h3>
<figure>
<img src="https://s2.loli.net/2024/01/07/iLHvQzCr4nsbJDk.png" srcset="/img/loading.gif" lazyload
alt="CG--10-06_02-43-19" />
<figcaption aria-hidden="true">CG--10-06_02-43-19</figcaption>
</figure>
<div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawCirclePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xc, <span class="hljs-keyword">int</span> yc, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, Color color)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">putpixel</span>(xc + x, yc + y, color);
    <span class="hljs-built_in">putpixel</span>(xc + y, yc + x, color);
    <span class="hljs-built_in">putpixel</span>(xc - x, yc + y, color);
    <span class="hljs-built_in">putpixel</span>(xc + y, yc - x, color);
    <span class="hljs-built_in">putpixel</span>(xc + x, yc - y, color);
    <span class="hljs-built_in">putpixel</span>(xc - y, yc + x, color);
    <span class="hljs-built_in">putpixel</span>(xc - x, yc - y, color);
    <span class="hljs-built_in">putpixel</span>(xc - y, yc - x, color);
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Circle_Midpoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xc, <span class="hljs-keyword">int</span> yc, <span class="hljs-keyword">int</span> R, Color color)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = R, <span class="hljs-comment">// 初始P坐标</span>
        d = <span class="hljs-number">1</span> - R;    <span class="hljs-comment">// 决策变量d</span>
    <span class="hljs-keyword">while</span> (x &lt; y)
    &#123;
        <span class="hljs-built_in">DrawCirclePoints</span>(xc, yc, x, y, color);
        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>)
            d += <span class="hljs-number">2</span> * x + <span class="hljs-number">3</span>, x++;
        <span class="hljs-keyword">else</span>
            d += <span class="hljs-number">2</span> * (x - y) + <span class="hljs-number">5</span>, x++, y--;
    &#125;
    <span class="hljs-built_in">DrawCirclePoints</span>(xc, yc, x, y, color);
&#125;</code></pre></div>
<h3 id="bresenham-画圆法">Bresenham 画圆法</h3>
<figure>
<img src="https://s2.loli.net/2024/01/07/nPpvQtHSJVwU2Tk.png" srcset="/img/loading.gif" lazyload
alt="CG--10-06_02-43-28" />
<figcaption aria-hidden="true">CG--10-06_02-43-28</figcaption>
</figure>
<div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// DrawCirclePoints()函数已在中点画圆法给出，这里不再给出</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Circle_Bresenham</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xc, <span class="hljs-keyword">int</span> yc, <span class="hljs-keyword">int</span> R, COLORREF color)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = R,  <span class="hljs-comment">// 初始P坐标</span>
        d = <span class="hljs-number">2</span> - <span class="hljs-number">2</span> * R; <span class="hljs-comment">// 决策变量d</span>
    <span class="hljs-keyword">while</span> (x &lt; y)
    &#123;
        <span class="hljs-built_in">DrawCirclePoints</span>(xc, yc, x, y, color);
        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">2</span> * (d + y) - <span class="hljs-number">1</span> &lt;= <span class="hljs-number">0</span>)
            d += <span class="hljs-number">2</span> * x + <span class="hljs-number">3</span>, x++;
        <span class="hljs-keyword">else</span>
            d += <span class="hljs-number">2</span> * (x - y + <span class="hljs-number">3</span>), x++, y--;
    &#125;
    <span class="hljs-built_in">DrawCirclePoints</span>(xc, yc, x, y, color);
&#125;</code></pre></div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%A4%A7%E5%AD%A6%E7%9B%B8%E5%85%B3/">大学相关</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/31/47/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络期末复习 - 期末复习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/28/49/">
                        <span class="hidden-mobile">Java开发技术 - 期末复习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <!-- begin 评论 -->
  <div id="valine"></div> 
  <!-- end 评论 -->
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
       
        var options = Object.assign(
          {"appId":"t9jCQpAs0bonvdH69rBoVs08-gzGzoHsz","appKey":"IVwl94UT4wnOPWUgwn4AfOCE","path":"window.location.pathname","placeholder":"世界的小小漂泊者呀，把你的足迹留在我的文字里吧…","avatar":"robohash","avatarForce":true,"meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","admin_email_hash":"393669798@qq.com","enableQQ":true,"emojiCDN":"//i0.hdslb.com/bfs/emote/","emojiMaps":{"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"}},
          {
            el: "#valine",
            path: window.location.pathname
          }
        ) 
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
 
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    <!--向顶部滚动的箭头-->
    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    <!--自定义底部 HTML 内容-->
    
  </main>
  
  <!--页脚-->
  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    <!---->
     &copy; <script type="text/javascript"> var myDate = new Date().getFullYear(); document.write(myDate) </script> <a target="_blank" rel="noopener" href="https://dramwig.github.io/" title="风倾 | 船动莲开" targe="_black" >风倾</a>  |  船动莲开 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;

      <!--通过API接口作为首页副标题的内容-->
      
        typing(title)  //tying打字机
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?fa7203cd147458a2bb6b7c7fc7bd03a3";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
